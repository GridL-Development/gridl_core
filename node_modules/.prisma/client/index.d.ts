
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model addressType
 * 
 */
export type addressType = $Result.DefaultSelection<Prisma.$addressTypePayload>
/**
 * Model ModelDataDimensionality
 * 
 */
export type ModelDataDimensionality = $Result.DefaultSelection<Prisma.$ModelDataDimensionalityPayload>
/**
 * Model TableColumnDefinition
 * 
 */
export type TableColumnDefinition = $Result.DefaultSelection<Prisma.$TableColumnDefinitionPayload>
/**
 * Model Config
 * 
 */
export type Config = $Result.DefaultSelection<Prisma.$ConfigPayload>
/**
 * Model Country
 * 
 */
export type Country = $Result.DefaultSelection<Prisma.$CountryPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Client
 * 
 */
export type Client = $Result.DefaultSelection<Prisma.$ClientPayload>
/**
 * Model Permission
 * 
 */
export type Permission = $Result.DefaultSelection<Prisma.$PermissionPayload>
/**
 * Model Instance
 * 
 */
export type Instance = $Result.DefaultSelection<Prisma.$InstancePayload>
/**
 * Model Version
 * 
 */
export type Version = $Result.DefaultSelection<Prisma.$VersionPayload>
/**
 * Model CurrencyIsoCode
 * 
 */
export type CurrencyIsoCode = $Result.DefaultSelection<Prisma.$CurrencyIsoCodePayload>
/**
 * Model Currency
 * 
 */
export type Currency = $Result.DefaultSelection<Prisma.$CurrencyPayload>
/**
 * Model Level
 * 
 */
export type Level = $Result.DefaultSelection<Prisma.$LevelPayload>
/**
 * Model LevelAttributeAndValue
 * 
 */
export type LevelAttributeAndValue = $Result.DefaultSelection<Prisma.$LevelAttributeAndValuePayload>
/**
 * Model LevelAttributeValue
 * 
 */
export type LevelAttributeValue = $Result.DefaultSelection<Prisma.$LevelAttributeValuePayload>
/**
 * Model LevelAttribute
 * 
 */
export type LevelAttribute = $Result.DefaultSelection<Prisma.$LevelAttributePayload>
/**
 * Model AccountAttribute
 * 
 */
export type AccountAttribute = $Result.DefaultSelection<Prisma.$AccountAttributePayload>
/**
 * Model AccountAttributeValue
 * 
 */
export type AccountAttributeValue = $Result.DefaultSelection<Prisma.$AccountAttributeValuePayload>
/**
 * Model AccountAttributeAndValue
 * 
 */
export type AccountAttributeAndValue = $Result.DefaultSelection<Prisma.$AccountAttributeAndValuePayload>
/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model Dimension
 * 
 */
export type Dimension = $Result.DefaultSelection<Prisma.$DimensionPayload>
/**
 * Model DimensionValue
 * 
 */
export type DimensionValue = $Result.DefaultSelection<Prisma.$DimensionValuePayload>
/**
 * Model DimensionValueAttribute
 * 
 */
export type DimensionValueAttribute = $Result.DefaultSelection<Prisma.$DimensionValueAttributePayload>
/**
 * Model DimensionValueAttributeValue
 * 
 */
export type DimensionValueAttributeValue = $Result.DefaultSelection<Prisma.$DimensionValueAttributeValuePayload>
/**
 * Model DimensionValueAttributeAndValue
 * 
 */
export type DimensionValueAttributeAndValue = $Result.DefaultSelection<Prisma.$DimensionValueAttributeAndValuePayload>
/**
 * Model Model
 * 
 */
export type Model = $Result.DefaultSelection<Prisma.$ModelPayload>
/**
 * Model ModelAccountStructure
 * 
 */
export type ModelAccountStructure = $Result.DefaultSelection<Prisma.$ModelAccountStructurePayload>
/**
 * Model ModelData
 * 
 */
export type ModelData = $Result.DefaultSelection<Prisma.$ModelDataPayload>
/**
 * Model ModelDataCalculations
 * 
 */
export type ModelDataCalculations = $Result.DefaultSelection<Prisma.$ModelDataCalculationsPayload>
/**
 * Model Table
 * 
 */
export type Table = $Result.DefaultSelection<Prisma.$TablePayload>
/**
 * Model TableData
 * 
 */
export type TableData = $Result.DefaultSelection<Prisma.$TableDataPayload>
/**
 * Model DataSource
 * 
 */
export type DataSource = $Result.DefaultSelection<Prisma.$DataSourcePayload>
/**
 * Model DataSourceTask
 * 
 */
export type DataSourceTask = $Result.DefaultSelection<Prisma.$DataSourceTaskPayload>
/**
 * Model DataSourceLoader
 * 
 */
export type DataSourceLoader = $Result.DefaultSelection<Prisma.$DataSourceLoaderPayload>
/**
 * Model DataSourceCredential
 * 
 */
export type DataSourceCredential = $Result.DefaultSelection<Prisma.$DataSourceCredentialPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const clientStatus: {
  Active: 'Active',
  Inactive: 'Inactive'
};

export type clientStatus = (typeof clientStatus)[keyof typeof clientStatus]


export const YesNo: {
  Yes: 'Yes',
  No: 'No'
};

export type YesNo = (typeof YesNo)[keyof typeof YesNo]


export const userRole: {
  Admin: 'Admin',
  Manager: 'Manager',
  User: 'User'
};

export type userRole = (typeof userRole)[keyof typeof userRole]


export const instanceStatus: {
  Active: 'Active',
  Inactive: 'Inactive'
};

export type instanceStatus = (typeof instanceStatus)[keyof typeof instanceStatus]


export const versionStatus: {
  Locked: 'Locked',
  Unlocked: 'Unlocked',
  Archived: 'Archived'
};

export type versionStatus = (typeof versionStatus)[keyof typeof versionStatus]


export const AccountType: {
  GL: 'GL',
  Custom: 'Custom'
};

export type AccountType = (typeof AccountType)[keyof typeof AccountType]


export const AccountTypeTag: {
  PnL: 'PnL',
  BalanceSheet: 'BalanceSheet',
  Custom: 'Custom',
  Model: 'Model'
};

export type AccountTypeTag = (typeof AccountTypeTag)[keyof typeof AccountTypeTag]


export const ActPlanBy: {
  Balance: 'Balance',
  Delta: 'Delta'
};

export type ActPlanBy = (typeof ActPlanBy)[keyof typeof ActPlanBy]


export const ActActualsBy: {
  Balance: 'Balance',
  Delta: 'Delta'
};

export type ActActualsBy = (typeof ActActualsBy)[keyof typeof ActActualsBy]


export const TimeStratum: {
  Week: 'Week',
  Month: 'Month'
};

export type TimeStratum = (typeof TimeStratum)[keyof typeof TimeStratum]


export const ActDisplayAs: {
  Currency: 'Currency',
  Decimal: 'Decimal',
  Percentage: 'Percentage'
};

export type ActDisplayAs = (typeof ActDisplayAs)[keyof typeof ActDisplayAs]


export const ModelStatus: {
  Active: 'Active',
  Inactive: 'Inactive'
};

export type ModelStatus = (typeof ModelStatus)[keyof typeof ModelStatus]


export const TableColumnType: {
  Text: 'Text',
  Number: 'Number',
  Date: 'Date',
  Checkbox: 'Checkbox',
  Dimension: 'Dimension'
};

export type TableColumnType = (typeof TableColumnType)[keyof typeof TableColumnType]


export const DataSourceType: {
  CSV: 'CSV',
  Excel: 'Excel',
  Quickbooks: 'Quickbooks',
  JSON: 'JSON',
  NetSuite: 'NetSuite',
  Adaptive: 'Adaptive'
};

export type DataSourceType = (typeof DataSourceType)[keyof typeof DataSourceType]


export const DatasourceCredentialAuthType: {
  Basic: 'Basic',
  PrivateKey: 'PrivateKey'
};

export type DatasourceCredentialAuthType = (typeof DatasourceCredentialAuthType)[keyof typeof DatasourceCredentialAuthType]


export const DataSourceLoaderType: {
  Level: 'Level',
  Account: 'Account',
  Dimension: 'Dimension',
  Attribute: 'Attribute',
  Planning: 'Planning'
};

export type DataSourceLoaderType = (typeof DataSourceLoaderType)[keyof typeof DataSourceLoaderType]

}

export type clientStatus = $Enums.clientStatus

export const clientStatus: typeof $Enums.clientStatus

export type YesNo = $Enums.YesNo

export const YesNo: typeof $Enums.YesNo

export type userRole = $Enums.userRole

export const userRole: typeof $Enums.userRole

export type instanceStatus = $Enums.instanceStatus

export const instanceStatus: typeof $Enums.instanceStatus

export type versionStatus = $Enums.versionStatus

export const versionStatus: typeof $Enums.versionStatus

export type AccountType = $Enums.AccountType

export const AccountType: typeof $Enums.AccountType

export type AccountTypeTag = $Enums.AccountTypeTag

export const AccountTypeTag: typeof $Enums.AccountTypeTag

export type ActPlanBy = $Enums.ActPlanBy

export const ActPlanBy: typeof $Enums.ActPlanBy

export type ActActualsBy = $Enums.ActActualsBy

export const ActActualsBy: typeof $Enums.ActActualsBy

export type TimeStratum = $Enums.TimeStratum

export const TimeStratum: typeof $Enums.TimeStratum

export type ActDisplayAs = $Enums.ActDisplayAs

export const ActDisplayAs: typeof $Enums.ActDisplayAs

export type ModelStatus = $Enums.ModelStatus

export const ModelStatus: typeof $Enums.ModelStatus

export type TableColumnType = $Enums.TableColumnType

export const TableColumnType: typeof $Enums.TableColumnType

export type DataSourceType = $Enums.DataSourceType

export const DataSourceType: typeof $Enums.DataSourceType

export type DatasourceCredentialAuthType = $Enums.DatasourceCredentialAuthType

export const DatasourceCredentialAuthType: typeof $Enums.DatasourceCredentialAuthType

export type DataSourceLoaderType = $Enums.DataSourceLoaderType

export const DataSourceLoaderType: typeof $Enums.DataSourceLoaderType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Configs
 * const configs = await prisma.config.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Configs
   * const configs = await prisma.config.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P]): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number }): $Utils.JsPromise<R>

  /**
   * Executes a raw MongoDB command and returns the result of it.
   * @example
   * ```
   * const user = await prisma.$runCommandRaw({
   *   aggregate: 'User',
   *   pipeline: [{ $match: { name: 'Bob' } }, { $project: { email: true, _id: false } }],
   *   explain: false,
   * })
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $runCommandRaw(command: Prisma.InputJsonObject): Prisma.PrismaPromise<Prisma.JsonObject>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs, $Utils.Call<Prisma.TypeMapCb, {
    extArgs: ExtArgs
  }>, ClientOptions>

      /**
   * `prisma.config`: Exposes CRUD operations for the **Config** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Configs
    * const configs = await prisma.config.findMany()
    * ```
    */
  get config(): Prisma.ConfigDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.country`: Exposes CRUD operations for the **Country** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Countries
    * const countries = await prisma.country.findMany()
    * ```
    */
  get country(): Prisma.CountryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.client`: Exposes CRUD operations for the **Client** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clients
    * const clients = await prisma.client.findMany()
    * ```
    */
  get client(): Prisma.ClientDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.permission`: Exposes CRUD operations for the **Permission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Permissions
    * const permissions = await prisma.permission.findMany()
    * ```
    */
  get permission(): Prisma.PermissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.instance`: Exposes CRUD operations for the **Instance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Instances
    * const instances = await prisma.instance.findMany()
    * ```
    */
  get instance(): Prisma.InstanceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.version`: Exposes CRUD operations for the **Version** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Versions
    * const versions = await prisma.version.findMany()
    * ```
    */
  get version(): Prisma.VersionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.currencyIsoCode`: Exposes CRUD operations for the **CurrencyIsoCode** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CurrencyIsoCodes
    * const currencyIsoCodes = await prisma.currencyIsoCode.findMany()
    * ```
    */
  get currencyIsoCode(): Prisma.CurrencyIsoCodeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.currency`: Exposes CRUD operations for the **Currency** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Currencies
    * const currencies = await prisma.currency.findMany()
    * ```
    */
  get currency(): Prisma.CurrencyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.level`: Exposes CRUD operations for the **Level** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Levels
    * const levels = await prisma.level.findMany()
    * ```
    */
  get level(): Prisma.LevelDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.levelAttributeAndValue`: Exposes CRUD operations for the **LevelAttributeAndValue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LevelAttributeAndValues
    * const levelAttributeAndValues = await prisma.levelAttributeAndValue.findMany()
    * ```
    */
  get levelAttributeAndValue(): Prisma.LevelAttributeAndValueDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.levelAttributeValue`: Exposes CRUD operations for the **LevelAttributeValue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LevelAttributeValues
    * const levelAttributeValues = await prisma.levelAttributeValue.findMany()
    * ```
    */
  get levelAttributeValue(): Prisma.LevelAttributeValueDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.levelAttribute`: Exposes CRUD operations for the **LevelAttribute** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LevelAttributes
    * const levelAttributes = await prisma.levelAttribute.findMany()
    * ```
    */
  get levelAttribute(): Prisma.LevelAttributeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.accountAttribute`: Exposes CRUD operations for the **AccountAttribute** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AccountAttributes
    * const accountAttributes = await prisma.accountAttribute.findMany()
    * ```
    */
  get accountAttribute(): Prisma.AccountAttributeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.accountAttributeValue`: Exposes CRUD operations for the **AccountAttributeValue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AccountAttributeValues
    * const accountAttributeValues = await prisma.accountAttributeValue.findMany()
    * ```
    */
  get accountAttributeValue(): Prisma.AccountAttributeValueDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.accountAttributeAndValue`: Exposes CRUD operations for the **AccountAttributeAndValue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AccountAttributeAndValues
    * const accountAttributeAndValues = await prisma.accountAttributeAndValue.findMany()
    * ```
    */
  get accountAttributeAndValue(): Prisma.AccountAttributeAndValueDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dimension`: Exposes CRUD operations for the **Dimension** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Dimensions
    * const dimensions = await prisma.dimension.findMany()
    * ```
    */
  get dimension(): Prisma.DimensionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dimensionValue`: Exposes CRUD operations for the **DimensionValue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DimensionValues
    * const dimensionValues = await prisma.dimensionValue.findMany()
    * ```
    */
  get dimensionValue(): Prisma.DimensionValueDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dimensionValueAttribute`: Exposes CRUD operations for the **DimensionValueAttribute** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DimensionValueAttributes
    * const dimensionValueAttributes = await prisma.dimensionValueAttribute.findMany()
    * ```
    */
  get dimensionValueAttribute(): Prisma.DimensionValueAttributeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dimensionValueAttributeValue`: Exposes CRUD operations for the **DimensionValueAttributeValue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DimensionValueAttributeValues
    * const dimensionValueAttributeValues = await prisma.dimensionValueAttributeValue.findMany()
    * ```
    */
  get dimensionValueAttributeValue(): Prisma.DimensionValueAttributeValueDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dimensionValueAttributeAndValue`: Exposes CRUD operations for the **DimensionValueAttributeAndValue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DimensionValueAttributeAndValues
    * const dimensionValueAttributeAndValues = await prisma.dimensionValueAttributeAndValue.findMany()
    * ```
    */
  get dimensionValueAttributeAndValue(): Prisma.DimensionValueAttributeAndValueDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.model`: Exposes CRUD operations for the **Model** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Models
    * const models = await prisma.model.findMany()
    * ```
    */
  get model(): Prisma.ModelDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.modelAccountStructure`: Exposes CRUD operations for the **ModelAccountStructure** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ModelAccountStructures
    * const modelAccountStructures = await prisma.modelAccountStructure.findMany()
    * ```
    */
  get modelAccountStructure(): Prisma.ModelAccountStructureDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.modelData`: Exposes CRUD operations for the **ModelData** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ModelData
    * const modelData = await prisma.modelData.findMany()
    * ```
    */
  get modelData(): Prisma.ModelDataDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.modelDataCalculations`: Exposes CRUD operations for the **ModelDataCalculations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ModelDataCalculations
    * const modelDataCalculations = await prisma.modelDataCalculations.findMany()
    * ```
    */
  get modelDataCalculations(): Prisma.ModelDataCalculationsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.table`: Exposes CRUD operations for the **Table** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tables
    * const tables = await prisma.table.findMany()
    * ```
    */
  get table(): Prisma.TableDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tableData`: Exposes CRUD operations for the **TableData** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TableData
    * const tableData = await prisma.tableData.findMany()
    * ```
    */
  get tableData(): Prisma.TableDataDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dataSource`: Exposes CRUD operations for the **DataSource** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DataSources
    * const dataSources = await prisma.dataSource.findMany()
    * ```
    */
  get dataSource(): Prisma.DataSourceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dataSourceTask`: Exposes CRUD operations for the **DataSourceTask** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DataSourceTasks
    * const dataSourceTasks = await prisma.dataSourceTask.findMany()
    * ```
    */
  get dataSourceTask(): Prisma.DataSourceTaskDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dataSourceLoader`: Exposes CRUD operations for the **DataSourceLoader** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DataSourceLoaders
    * const dataSourceLoaders = await prisma.dataSourceLoader.findMany()
    * ```
    */
  get dataSourceLoader(): Prisma.DataSourceLoaderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dataSourceCredential`: Exposes CRUD operations for the **DataSourceCredential** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DataSourceCredentials
    * const dataSourceCredentials = await prisma.dataSourceCredential.findMany()
    * ```
    */
  get dataSourceCredential(): Prisma.DataSourceCredentialDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.3.1
   * Query Engine version: acc0b9dd43eb689cbd20c9470515d719db10d0b0
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Config: 'Config',
    Country: 'Country',
    User: 'User',
    Client: 'Client',
    Permission: 'Permission',
    Instance: 'Instance',
    Version: 'Version',
    CurrencyIsoCode: 'CurrencyIsoCode',
    Currency: 'Currency',
    Level: 'Level',
    LevelAttributeAndValue: 'LevelAttributeAndValue',
    LevelAttributeValue: 'LevelAttributeValue',
    LevelAttribute: 'LevelAttribute',
    AccountAttribute: 'AccountAttribute',
    AccountAttributeValue: 'AccountAttributeValue',
    AccountAttributeAndValue: 'AccountAttributeAndValue',
    Account: 'Account',
    Dimension: 'Dimension',
    DimensionValue: 'DimensionValue',
    DimensionValueAttribute: 'DimensionValueAttribute',
    DimensionValueAttributeValue: 'DimensionValueAttributeValue',
    DimensionValueAttributeAndValue: 'DimensionValueAttributeAndValue',
    Model: 'Model',
    ModelAccountStructure: 'ModelAccountStructure',
    ModelData: 'ModelData',
    ModelDataCalculations: 'ModelDataCalculations',
    Table: 'Table',
    TableData: 'TableData',
    DataSource: 'DataSource',
    DataSourceTask: 'DataSourceTask',
    DataSourceLoader: 'DataSourceLoader',
    DataSourceCredential: 'DataSourceCredential'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "config" | "country" | "user" | "client" | "permission" | "instance" | "version" | "currencyIsoCode" | "currency" | "level" | "levelAttributeAndValue" | "levelAttributeValue" | "levelAttribute" | "accountAttribute" | "accountAttributeValue" | "accountAttributeAndValue" | "account" | "dimension" | "dimensionValue" | "dimensionValueAttribute" | "dimensionValueAttributeValue" | "dimensionValueAttributeAndValue" | "model" | "modelAccountStructure" | "modelData" | "modelDataCalculations" | "table" | "tableData" | "dataSource" | "dataSourceTask" | "dataSourceLoader" | "dataSourceCredential"
      txIsolationLevel: never
    }
    model: {
      Config: {
        payload: Prisma.$ConfigPayload<ExtArgs>
        fields: Prisma.ConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConfigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConfigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigPayload>
          }
          findFirst: {
            args: Prisma.ConfigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConfigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigPayload>
          }
          findMany: {
            args: Prisma.ConfigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigPayload>[]
          }
          create: {
            args: Prisma.ConfigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigPayload>
          }
          createMany: {
            args: Prisma.ConfigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ConfigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigPayload>
          }
          update: {
            args: Prisma.ConfigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigPayload>
          }
          deleteMany: {
            args: Prisma.ConfigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConfigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ConfigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigPayload>
          }
          aggregate: {
            args: Prisma.ConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConfig>
          }
          groupBy: {
            args: Prisma.ConfigGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConfigGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ConfigFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ConfigAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ConfigCountArgs<ExtArgs>
            result: $Utils.Optional<ConfigCountAggregateOutputType> | number
          }
        }
      }
      Country: {
        payload: Prisma.$CountryPayload<ExtArgs>
        fields: Prisma.CountryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CountryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CountryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          findFirst: {
            args: Prisma.CountryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CountryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          findMany: {
            args: Prisma.CountryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>[]
          }
          create: {
            args: Prisma.CountryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          createMany: {
            args: Prisma.CountryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CountryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          update: {
            args: Prisma.CountryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          deleteMany: {
            args: Prisma.CountryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CountryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CountryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          aggregate: {
            args: Prisma.CountryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCountry>
          }
          groupBy: {
            args: Prisma.CountryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CountryGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.CountryFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.CountryAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.CountryCountArgs<ExtArgs>
            result: $Utils.Optional<CountryCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.UserFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.UserAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Client: {
        payload: Prisma.$ClientPayload<ExtArgs>
        fields: Prisma.ClientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClientFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClientFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          findFirst: {
            args: Prisma.ClientFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClientFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          findMany: {
            args: Prisma.ClientFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>[]
          }
          create: {
            args: Prisma.ClientCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          createMany: {
            args: Prisma.ClientCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ClientDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          update: {
            args: Prisma.ClientUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          deleteMany: {
            args: Prisma.ClientDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClientUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ClientUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          aggregate: {
            args: Prisma.ClientAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClient>
          }
          groupBy: {
            args: Prisma.ClientGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClientGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ClientFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ClientAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ClientCountArgs<ExtArgs>
            result: $Utils.Optional<ClientCountAggregateOutputType> | number
          }
        }
      }
      Permission: {
        payload: Prisma.$PermissionPayload<ExtArgs>
        fields: Prisma.PermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PermissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PermissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          findFirst: {
            args: Prisma.PermissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PermissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          findMany: {
            args: Prisma.PermissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>[]
          }
          create: {
            args: Prisma.PermissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          createMany: {
            args: Prisma.PermissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PermissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          update: {
            args: Prisma.PermissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          deleteMany: {
            args: Prisma.PermissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PermissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PermissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          aggregate: {
            args: Prisma.PermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePermission>
          }
          groupBy: {
            args: Prisma.PermissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PermissionGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.PermissionFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.PermissionAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.PermissionCountArgs<ExtArgs>
            result: $Utils.Optional<PermissionCountAggregateOutputType> | number
          }
        }
      }
      Instance: {
        payload: Prisma.$InstancePayload<ExtArgs>
        fields: Prisma.InstanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InstanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InstanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstancePayload>
          }
          findFirst: {
            args: Prisma.InstanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InstanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstancePayload>
          }
          findMany: {
            args: Prisma.InstanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstancePayload>[]
          }
          create: {
            args: Prisma.InstanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstancePayload>
          }
          createMany: {
            args: Prisma.InstanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.InstanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstancePayload>
          }
          update: {
            args: Prisma.InstanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstancePayload>
          }
          deleteMany: {
            args: Prisma.InstanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InstanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InstanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstancePayload>
          }
          aggregate: {
            args: Prisma.InstanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInstance>
          }
          groupBy: {
            args: Prisma.InstanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<InstanceGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.InstanceFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.InstanceAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.InstanceCountArgs<ExtArgs>
            result: $Utils.Optional<InstanceCountAggregateOutputType> | number
          }
        }
      }
      Version: {
        payload: Prisma.$VersionPayload<ExtArgs>
        fields: Prisma.VersionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VersionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VersionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VersionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VersionPayload>
          }
          findFirst: {
            args: Prisma.VersionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VersionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VersionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VersionPayload>
          }
          findMany: {
            args: Prisma.VersionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VersionPayload>[]
          }
          create: {
            args: Prisma.VersionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VersionPayload>
          }
          createMany: {
            args: Prisma.VersionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.VersionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VersionPayload>
          }
          update: {
            args: Prisma.VersionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VersionPayload>
          }
          deleteMany: {
            args: Prisma.VersionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VersionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VersionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VersionPayload>
          }
          aggregate: {
            args: Prisma.VersionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVersion>
          }
          groupBy: {
            args: Prisma.VersionGroupByArgs<ExtArgs>
            result: $Utils.Optional<VersionGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.VersionFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.VersionAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.VersionCountArgs<ExtArgs>
            result: $Utils.Optional<VersionCountAggregateOutputType> | number
          }
        }
      }
      CurrencyIsoCode: {
        payload: Prisma.$CurrencyIsoCodePayload<ExtArgs>
        fields: Prisma.CurrencyIsoCodeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CurrencyIsoCodeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyIsoCodePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CurrencyIsoCodeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyIsoCodePayload>
          }
          findFirst: {
            args: Prisma.CurrencyIsoCodeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyIsoCodePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CurrencyIsoCodeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyIsoCodePayload>
          }
          findMany: {
            args: Prisma.CurrencyIsoCodeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyIsoCodePayload>[]
          }
          create: {
            args: Prisma.CurrencyIsoCodeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyIsoCodePayload>
          }
          createMany: {
            args: Prisma.CurrencyIsoCodeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CurrencyIsoCodeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyIsoCodePayload>
          }
          update: {
            args: Prisma.CurrencyIsoCodeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyIsoCodePayload>
          }
          deleteMany: {
            args: Prisma.CurrencyIsoCodeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CurrencyIsoCodeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CurrencyIsoCodeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyIsoCodePayload>
          }
          aggregate: {
            args: Prisma.CurrencyIsoCodeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCurrencyIsoCode>
          }
          groupBy: {
            args: Prisma.CurrencyIsoCodeGroupByArgs<ExtArgs>
            result: $Utils.Optional<CurrencyIsoCodeGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.CurrencyIsoCodeFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.CurrencyIsoCodeAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.CurrencyIsoCodeCountArgs<ExtArgs>
            result: $Utils.Optional<CurrencyIsoCodeCountAggregateOutputType> | number
          }
        }
      }
      Currency: {
        payload: Prisma.$CurrencyPayload<ExtArgs>
        fields: Prisma.CurrencyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CurrencyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CurrencyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload>
          }
          findFirst: {
            args: Prisma.CurrencyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CurrencyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload>
          }
          findMany: {
            args: Prisma.CurrencyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload>[]
          }
          create: {
            args: Prisma.CurrencyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload>
          }
          createMany: {
            args: Prisma.CurrencyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CurrencyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload>
          }
          update: {
            args: Prisma.CurrencyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload>
          }
          deleteMany: {
            args: Prisma.CurrencyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CurrencyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CurrencyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload>
          }
          aggregate: {
            args: Prisma.CurrencyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCurrency>
          }
          groupBy: {
            args: Prisma.CurrencyGroupByArgs<ExtArgs>
            result: $Utils.Optional<CurrencyGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.CurrencyFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.CurrencyAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.CurrencyCountArgs<ExtArgs>
            result: $Utils.Optional<CurrencyCountAggregateOutputType> | number
          }
        }
      }
      Level: {
        payload: Prisma.$LevelPayload<ExtArgs>
        fields: Prisma.LevelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LevelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LevelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevelPayload>
          }
          findFirst: {
            args: Prisma.LevelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LevelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevelPayload>
          }
          findMany: {
            args: Prisma.LevelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevelPayload>[]
          }
          create: {
            args: Prisma.LevelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevelPayload>
          }
          createMany: {
            args: Prisma.LevelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.LevelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevelPayload>
          }
          update: {
            args: Prisma.LevelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevelPayload>
          }
          deleteMany: {
            args: Prisma.LevelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LevelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LevelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevelPayload>
          }
          aggregate: {
            args: Prisma.LevelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLevel>
          }
          groupBy: {
            args: Prisma.LevelGroupByArgs<ExtArgs>
            result: $Utils.Optional<LevelGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.LevelFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.LevelAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.LevelCountArgs<ExtArgs>
            result: $Utils.Optional<LevelCountAggregateOutputType> | number
          }
        }
      }
      LevelAttributeAndValue: {
        payload: Prisma.$LevelAttributeAndValuePayload<ExtArgs>
        fields: Prisma.LevelAttributeAndValueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LevelAttributeAndValueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevelAttributeAndValuePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LevelAttributeAndValueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevelAttributeAndValuePayload>
          }
          findFirst: {
            args: Prisma.LevelAttributeAndValueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevelAttributeAndValuePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LevelAttributeAndValueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevelAttributeAndValuePayload>
          }
          findMany: {
            args: Prisma.LevelAttributeAndValueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevelAttributeAndValuePayload>[]
          }
          create: {
            args: Prisma.LevelAttributeAndValueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevelAttributeAndValuePayload>
          }
          createMany: {
            args: Prisma.LevelAttributeAndValueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.LevelAttributeAndValueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevelAttributeAndValuePayload>
          }
          update: {
            args: Prisma.LevelAttributeAndValueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevelAttributeAndValuePayload>
          }
          deleteMany: {
            args: Prisma.LevelAttributeAndValueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LevelAttributeAndValueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LevelAttributeAndValueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevelAttributeAndValuePayload>
          }
          aggregate: {
            args: Prisma.LevelAttributeAndValueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLevelAttributeAndValue>
          }
          groupBy: {
            args: Prisma.LevelAttributeAndValueGroupByArgs<ExtArgs>
            result: $Utils.Optional<LevelAttributeAndValueGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.LevelAttributeAndValueFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.LevelAttributeAndValueAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.LevelAttributeAndValueCountArgs<ExtArgs>
            result: $Utils.Optional<LevelAttributeAndValueCountAggregateOutputType> | number
          }
        }
      }
      LevelAttributeValue: {
        payload: Prisma.$LevelAttributeValuePayload<ExtArgs>
        fields: Prisma.LevelAttributeValueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LevelAttributeValueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevelAttributeValuePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LevelAttributeValueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevelAttributeValuePayload>
          }
          findFirst: {
            args: Prisma.LevelAttributeValueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevelAttributeValuePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LevelAttributeValueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevelAttributeValuePayload>
          }
          findMany: {
            args: Prisma.LevelAttributeValueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevelAttributeValuePayload>[]
          }
          create: {
            args: Prisma.LevelAttributeValueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevelAttributeValuePayload>
          }
          createMany: {
            args: Prisma.LevelAttributeValueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.LevelAttributeValueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevelAttributeValuePayload>
          }
          update: {
            args: Prisma.LevelAttributeValueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevelAttributeValuePayload>
          }
          deleteMany: {
            args: Prisma.LevelAttributeValueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LevelAttributeValueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LevelAttributeValueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevelAttributeValuePayload>
          }
          aggregate: {
            args: Prisma.LevelAttributeValueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLevelAttributeValue>
          }
          groupBy: {
            args: Prisma.LevelAttributeValueGroupByArgs<ExtArgs>
            result: $Utils.Optional<LevelAttributeValueGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.LevelAttributeValueFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.LevelAttributeValueAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.LevelAttributeValueCountArgs<ExtArgs>
            result: $Utils.Optional<LevelAttributeValueCountAggregateOutputType> | number
          }
        }
      }
      LevelAttribute: {
        payload: Prisma.$LevelAttributePayload<ExtArgs>
        fields: Prisma.LevelAttributeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LevelAttributeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevelAttributePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LevelAttributeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevelAttributePayload>
          }
          findFirst: {
            args: Prisma.LevelAttributeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevelAttributePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LevelAttributeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevelAttributePayload>
          }
          findMany: {
            args: Prisma.LevelAttributeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevelAttributePayload>[]
          }
          create: {
            args: Prisma.LevelAttributeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevelAttributePayload>
          }
          createMany: {
            args: Prisma.LevelAttributeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.LevelAttributeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevelAttributePayload>
          }
          update: {
            args: Prisma.LevelAttributeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevelAttributePayload>
          }
          deleteMany: {
            args: Prisma.LevelAttributeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LevelAttributeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LevelAttributeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevelAttributePayload>
          }
          aggregate: {
            args: Prisma.LevelAttributeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLevelAttribute>
          }
          groupBy: {
            args: Prisma.LevelAttributeGroupByArgs<ExtArgs>
            result: $Utils.Optional<LevelAttributeGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.LevelAttributeFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.LevelAttributeAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.LevelAttributeCountArgs<ExtArgs>
            result: $Utils.Optional<LevelAttributeCountAggregateOutputType> | number
          }
        }
      }
      AccountAttribute: {
        payload: Prisma.$AccountAttributePayload<ExtArgs>
        fields: Prisma.AccountAttributeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountAttributeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountAttributePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountAttributeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountAttributePayload>
          }
          findFirst: {
            args: Prisma.AccountAttributeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountAttributePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountAttributeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountAttributePayload>
          }
          findMany: {
            args: Prisma.AccountAttributeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountAttributePayload>[]
          }
          create: {
            args: Prisma.AccountAttributeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountAttributePayload>
          }
          createMany: {
            args: Prisma.AccountAttributeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AccountAttributeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountAttributePayload>
          }
          update: {
            args: Prisma.AccountAttributeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountAttributePayload>
          }
          deleteMany: {
            args: Prisma.AccountAttributeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountAttributeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AccountAttributeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountAttributePayload>
          }
          aggregate: {
            args: Prisma.AccountAttributeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccountAttribute>
          }
          groupBy: {
            args: Prisma.AccountAttributeGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountAttributeGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.AccountAttributeFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.AccountAttributeAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.AccountAttributeCountArgs<ExtArgs>
            result: $Utils.Optional<AccountAttributeCountAggregateOutputType> | number
          }
        }
      }
      AccountAttributeValue: {
        payload: Prisma.$AccountAttributeValuePayload<ExtArgs>
        fields: Prisma.AccountAttributeValueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountAttributeValueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountAttributeValuePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountAttributeValueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountAttributeValuePayload>
          }
          findFirst: {
            args: Prisma.AccountAttributeValueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountAttributeValuePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountAttributeValueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountAttributeValuePayload>
          }
          findMany: {
            args: Prisma.AccountAttributeValueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountAttributeValuePayload>[]
          }
          create: {
            args: Prisma.AccountAttributeValueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountAttributeValuePayload>
          }
          createMany: {
            args: Prisma.AccountAttributeValueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AccountAttributeValueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountAttributeValuePayload>
          }
          update: {
            args: Prisma.AccountAttributeValueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountAttributeValuePayload>
          }
          deleteMany: {
            args: Prisma.AccountAttributeValueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountAttributeValueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AccountAttributeValueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountAttributeValuePayload>
          }
          aggregate: {
            args: Prisma.AccountAttributeValueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccountAttributeValue>
          }
          groupBy: {
            args: Prisma.AccountAttributeValueGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountAttributeValueGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.AccountAttributeValueFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.AccountAttributeValueAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.AccountAttributeValueCountArgs<ExtArgs>
            result: $Utils.Optional<AccountAttributeValueCountAggregateOutputType> | number
          }
        }
      }
      AccountAttributeAndValue: {
        payload: Prisma.$AccountAttributeAndValuePayload<ExtArgs>
        fields: Prisma.AccountAttributeAndValueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountAttributeAndValueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountAttributeAndValuePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountAttributeAndValueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountAttributeAndValuePayload>
          }
          findFirst: {
            args: Prisma.AccountAttributeAndValueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountAttributeAndValuePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountAttributeAndValueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountAttributeAndValuePayload>
          }
          findMany: {
            args: Prisma.AccountAttributeAndValueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountAttributeAndValuePayload>[]
          }
          create: {
            args: Prisma.AccountAttributeAndValueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountAttributeAndValuePayload>
          }
          createMany: {
            args: Prisma.AccountAttributeAndValueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AccountAttributeAndValueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountAttributeAndValuePayload>
          }
          update: {
            args: Prisma.AccountAttributeAndValueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountAttributeAndValuePayload>
          }
          deleteMany: {
            args: Prisma.AccountAttributeAndValueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountAttributeAndValueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AccountAttributeAndValueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountAttributeAndValuePayload>
          }
          aggregate: {
            args: Prisma.AccountAttributeAndValueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccountAttributeAndValue>
          }
          groupBy: {
            args: Prisma.AccountAttributeAndValueGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountAttributeAndValueGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.AccountAttributeAndValueFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.AccountAttributeAndValueAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.AccountAttributeAndValueCountArgs<ExtArgs>
            result: $Utils.Optional<AccountAttributeAndValueCountAggregateOutputType> | number
          }
        }
      }
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.AccountFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.AccountAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      Dimension: {
        payload: Prisma.$DimensionPayload<ExtArgs>
        fields: Prisma.DimensionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DimensionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimensionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DimensionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimensionPayload>
          }
          findFirst: {
            args: Prisma.DimensionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimensionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DimensionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimensionPayload>
          }
          findMany: {
            args: Prisma.DimensionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimensionPayload>[]
          }
          create: {
            args: Prisma.DimensionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimensionPayload>
          }
          createMany: {
            args: Prisma.DimensionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DimensionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimensionPayload>
          }
          update: {
            args: Prisma.DimensionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimensionPayload>
          }
          deleteMany: {
            args: Prisma.DimensionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DimensionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DimensionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimensionPayload>
          }
          aggregate: {
            args: Prisma.DimensionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDimension>
          }
          groupBy: {
            args: Prisma.DimensionGroupByArgs<ExtArgs>
            result: $Utils.Optional<DimensionGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.DimensionFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.DimensionAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.DimensionCountArgs<ExtArgs>
            result: $Utils.Optional<DimensionCountAggregateOutputType> | number
          }
        }
      }
      DimensionValue: {
        payload: Prisma.$DimensionValuePayload<ExtArgs>
        fields: Prisma.DimensionValueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DimensionValueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimensionValuePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DimensionValueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimensionValuePayload>
          }
          findFirst: {
            args: Prisma.DimensionValueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimensionValuePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DimensionValueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimensionValuePayload>
          }
          findMany: {
            args: Prisma.DimensionValueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimensionValuePayload>[]
          }
          create: {
            args: Prisma.DimensionValueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimensionValuePayload>
          }
          createMany: {
            args: Prisma.DimensionValueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DimensionValueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimensionValuePayload>
          }
          update: {
            args: Prisma.DimensionValueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimensionValuePayload>
          }
          deleteMany: {
            args: Prisma.DimensionValueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DimensionValueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DimensionValueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimensionValuePayload>
          }
          aggregate: {
            args: Prisma.DimensionValueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDimensionValue>
          }
          groupBy: {
            args: Prisma.DimensionValueGroupByArgs<ExtArgs>
            result: $Utils.Optional<DimensionValueGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.DimensionValueFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.DimensionValueAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.DimensionValueCountArgs<ExtArgs>
            result: $Utils.Optional<DimensionValueCountAggregateOutputType> | number
          }
        }
      }
      DimensionValueAttribute: {
        payload: Prisma.$DimensionValueAttributePayload<ExtArgs>
        fields: Prisma.DimensionValueAttributeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DimensionValueAttributeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimensionValueAttributePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DimensionValueAttributeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimensionValueAttributePayload>
          }
          findFirst: {
            args: Prisma.DimensionValueAttributeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimensionValueAttributePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DimensionValueAttributeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimensionValueAttributePayload>
          }
          findMany: {
            args: Prisma.DimensionValueAttributeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimensionValueAttributePayload>[]
          }
          create: {
            args: Prisma.DimensionValueAttributeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimensionValueAttributePayload>
          }
          createMany: {
            args: Prisma.DimensionValueAttributeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DimensionValueAttributeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimensionValueAttributePayload>
          }
          update: {
            args: Prisma.DimensionValueAttributeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimensionValueAttributePayload>
          }
          deleteMany: {
            args: Prisma.DimensionValueAttributeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DimensionValueAttributeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DimensionValueAttributeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimensionValueAttributePayload>
          }
          aggregate: {
            args: Prisma.DimensionValueAttributeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDimensionValueAttribute>
          }
          groupBy: {
            args: Prisma.DimensionValueAttributeGroupByArgs<ExtArgs>
            result: $Utils.Optional<DimensionValueAttributeGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.DimensionValueAttributeFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.DimensionValueAttributeAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.DimensionValueAttributeCountArgs<ExtArgs>
            result: $Utils.Optional<DimensionValueAttributeCountAggregateOutputType> | number
          }
        }
      }
      DimensionValueAttributeValue: {
        payload: Prisma.$DimensionValueAttributeValuePayload<ExtArgs>
        fields: Prisma.DimensionValueAttributeValueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DimensionValueAttributeValueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimensionValueAttributeValuePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DimensionValueAttributeValueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimensionValueAttributeValuePayload>
          }
          findFirst: {
            args: Prisma.DimensionValueAttributeValueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimensionValueAttributeValuePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DimensionValueAttributeValueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimensionValueAttributeValuePayload>
          }
          findMany: {
            args: Prisma.DimensionValueAttributeValueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimensionValueAttributeValuePayload>[]
          }
          create: {
            args: Prisma.DimensionValueAttributeValueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimensionValueAttributeValuePayload>
          }
          createMany: {
            args: Prisma.DimensionValueAttributeValueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DimensionValueAttributeValueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimensionValueAttributeValuePayload>
          }
          update: {
            args: Prisma.DimensionValueAttributeValueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimensionValueAttributeValuePayload>
          }
          deleteMany: {
            args: Prisma.DimensionValueAttributeValueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DimensionValueAttributeValueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DimensionValueAttributeValueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimensionValueAttributeValuePayload>
          }
          aggregate: {
            args: Prisma.DimensionValueAttributeValueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDimensionValueAttributeValue>
          }
          groupBy: {
            args: Prisma.DimensionValueAttributeValueGroupByArgs<ExtArgs>
            result: $Utils.Optional<DimensionValueAttributeValueGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.DimensionValueAttributeValueFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.DimensionValueAttributeValueAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.DimensionValueAttributeValueCountArgs<ExtArgs>
            result: $Utils.Optional<DimensionValueAttributeValueCountAggregateOutputType> | number
          }
        }
      }
      DimensionValueAttributeAndValue: {
        payload: Prisma.$DimensionValueAttributeAndValuePayload<ExtArgs>
        fields: Prisma.DimensionValueAttributeAndValueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DimensionValueAttributeAndValueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimensionValueAttributeAndValuePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DimensionValueAttributeAndValueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimensionValueAttributeAndValuePayload>
          }
          findFirst: {
            args: Prisma.DimensionValueAttributeAndValueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimensionValueAttributeAndValuePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DimensionValueAttributeAndValueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimensionValueAttributeAndValuePayload>
          }
          findMany: {
            args: Prisma.DimensionValueAttributeAndValueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimensionValueAttributeAndValuePayload>[]
          }
          create: {
            args: Prisma.DimensionValueAttributeAndValueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimensionValueAttributeAndValuePayload>
          }
          createMany: {
            args: Prisma.DimensionValueAttributeAndValueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DimensionValueAttributeAndValueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimensionValueAttributeAndValuePayload>
          }
          update: {
            args: Prisma.DimensionValueAttributeAndValueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimensionValueAttributeAndValuePayload>
          }
          deleteMany: {
            args: Prisma.DimensionValueAttributeAndValueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DimensionValueAttributeAndValueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DimensionValueAttributeAndValueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimensionValueAttributeAndValuePayload>
          }
          aggregate: {
            args: Prisma.DimensionValueAttributeAndValueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDimensionValueAttributeAndValue>
          }
          groupBy: {
            args: Prisma.DimensionValueAttributeAndValueGroupByArgs<ExtArgs>
            result: $Utils.Optional<DimensionValueAttributeAndValueGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.DimensionValueAttributeAndValueFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.DimensionValueAttributeAndValueAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.DimensionValueAttributeAndValueCountArgs<ExtArgs>
            result: $Utils.Optional<DimensionValueAttributeAndValueCountAggregateOutputType> | number
          }
        }
      }
      Model: {
        payload: Prisma.$ModelPayload<ExtArgs>
        fields: Prisma.ModelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ModelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ModelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPayload>
          }
          findFirst: {
            args: Prisma.ModelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ModelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPayload>
          }
          findMany: {
            args: Prisma.ModelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPayload>[]
          }
          create: {
            args: Prisma.ModelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPayload>
          }
          createMany: {
            args: Prisma.ModelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ModelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPayload>
          }
          update: {
            args: Prisma.ModelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPayload>
          }
          deleteMany: {
            args: Prisma.ModelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ModelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ModelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPayload>
          }
          aggregate: {
            args: Prisma.ModelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateModel>
          }
          groupBy: {
            args: Prisma.ModelGroupByArgs<ExtArgs>
            result: $Utils.Optional<ModelGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ModelFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ModelAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ModelCountArgs<ExtArgs>
            result: $Utils.Optional<ModelCountAggregateOutputType> | number
          }
        }
      }
      ModelAccountStructure: {
        payload: Prisma.$ModelAccountStructurePayload<ExtArgs>
        fields: Prisma.ModelAccountStructureFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ModelAccountStructureFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelAccountStructurePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ModelAccountStructureFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelAccountStructurePayload>
          }
          findFirst: {
            args: Prisma.ModelAccountStructureFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelAccountStructurePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ModelAccountStructureFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelAccountStructurePayload>
          }
          findMany: {
            args: Prisma.ModelAccountStructureFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelAccountStructurePayload>[]
          }
          create: {
            args: Prisma.ModelAccountStructureCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelAccountStructurePayload>
          }
          createMany: {
            args: Prisma.ModelAccountStructureCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ModelAccountStructureDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelAccountStructurePayload>
          }
          update: {
            args: Prisma.ModelAccountStructureUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelAccountStructurePayload>
          }
          deleteMany: {
            args: Prisma.ModelAccountStructureDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ModelAccountStructureUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ModelAccountStructureUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelAccountStructurePayload>
          }
          aggregate: {
            args: Prisma.ModelAccountStructureAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateModelAccountStructure>
          }
          groupBy: {
            args: Prisma.ModelAccountStructureGroupByArgs<ExtArgs>
            result: $Utils.Optional<ModelAccountStructureGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ModelAccountStructureFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ModelAccountStructureAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ModelAccountStructureCountArgs<ExtArgs>
            result: $Utils.Optional<ModelAccountStructureCountAggregateOutputType> | number
          }
        }
      }
      ModelData: {
        payload: Prisma.$ModelDataPayload<ExtArgs>
        fields: Prisma.ModelDataFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ModelDataFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelDataPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ModelDataFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelDataPayload>
          }
          findFirst: {
            args: Prisma.ModelDataFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelDataPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ModelDataFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelDataPayload>
          }
          findMany: {
            args: Prisma.ModelDataFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelDataPayload>[]
          }
          create: {
            args: Prisma.ModelDataCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelDataPayload>
          }
          createMany: {
            args: Prisma.ModelDataCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ModelDataDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelDataPayload>
          }
          update: {
            args: Prisma.ModelDataUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelDataPayload>
          }
          deleteMany: {
            args: Prisma.ModelDataDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ModelDataUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ModelDataUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelDataPayload>
          }
          aggregate: {
            args: Prisma.ModelDataAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateModelData>
          }
          groupBy: {
            args: Prisma.ModelDataGroupByArgs<ExtArgs>
            result: $Utils.Optional<ModelDataGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ModelDataFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ModelDataAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ModelDataCountArgs<ExtArgs>
            result: $Utils.Optional<ModelDataCountAggregateOutputType> | number
          }
        }
      }
      ModelDataCalculations: {
        payload: Prisma.$ModelDataCalculationsPayload<ExtArgs>
        fields: Prisma.ModelDataCalculationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ModelDataCalculationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelDataCalculationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ModelDataCalculationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelDataCalculationsPayload>
          }
          findFirst: {
            args: Prisma.ModelDataCalculationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelDataCalculationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ModelDataCalculationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelDataCalculationsPayload>
          }
          findMany: {
            args: Prisma.ModelDataCalculationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelDataCalculationsPayload>[]
          }
          create: {
            args: Prisma.ModelDataCalculationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelDataCalculationsPayload>
          }
          createMany: {
            args: Prisma.ModelDataCalculationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ModelDataCalculationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelDataCalculationsPayload>
          }
          update: {
            args: Prisma.ModelDataCalculationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelDataCalculationsPayload>
          }
          deleteMany: {
            args: Prisma.ModelDataCalculationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ModelDataCalculationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ModelDataCalculationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelDataCalculationsPayload>
          }
          aggregate: {
            args: Prisma.ModelDataCalculationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateModelDataCalculations>
          }
          groupBy: {
            args: Prisma.ModelDataCalculationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ModelDataCalculationsGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ModelDataCalculationsFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ModelDataCalculationsAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ModelDataCalculationsCountArgs<ExtArgs>
            result: $Utils.Optional<ModelDataCalculationsCountAggregateOutputType> | number
          }
        }
      }
      Table: {
        payload: Prisma.$TablePayload<ExtArgs>
        fields: Prisma.TableFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TableFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TablePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TableFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TablePayload>
          }
          findFirst: {
            args: Prisma.TableFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TablePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TableFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TablePayload>
          }
          findMany: {
            args: Prisma.TableFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TablePayload>[]
          }
          create: {
            args: Prisma.TableCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TablePayload>
          }
          createMany: {
            args: Prisma.TableCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TableDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TablePayload>
          }
          update: {
            args: Prisma.TableUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TablePayload>
          }
          deleteMany: {
            args: Prisma.TableDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TableUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TableUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TablePayload>
          }
          aggregate: {
            args: Prisma.TableAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTable>
          }
          groupBy: {
            args: Prisma.TableGroupByArgs<ExtArgs>
            result: $Utils.Optional<TableGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.TableFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.TableAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.TableCountArgs<ExtArgs>
            result: $Utils.Optional<TableCountAggregateOutputType> | number
          }
        }
      }
      TableData: {
        payload: Prisma.$TableDataPayload<ExtArgs>
        fields: Prisma.TableDataFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TableDataFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TableDataPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TableDataFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TableDataPayload>
          }
          findFirst: {
            args: Prisma.TableDataFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TableDataPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TableDataFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TableDataPayload>
          }
          findMany: {
            args: Prisma.TableDataFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TableDataPayload>[]
          }
          create: {
            args: Prisma.TableDataCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TableDataPayload>
          }
          createMany: {
            args: Prisma.TableDataCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TableDataDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TableDataPayload>
          }
          update: {
            args: Prisma.TableDataUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TableDataPayload>
          }
          deleteMany: {
            args: Prisma.TableDataDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TableDataUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TableDataUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TableDataPayload>
          }
          aggregate: {
            args: Prisma.TableDataAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTableData>
          }
          groupBy: {
            args: Prisma.TableDataGroupByArgs<ExtArgs>
            result: $Utils.Optional<TableDataGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.TableDataFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.TableDataAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.TableDataCountArgs<ExtArgs>
            result: $Utils.Optional<TableDataCountAggregateOutputType> | number
          }
        }
      }
      DataSource: {
        payload: Prisma.$DataSourcePayload<ExtArgs>
        fields: Prisma.DataSourceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DataSourceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataSourcePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DataSourceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataSourcePayload>
          }
          findFirst: {
            args: Prisma.DataSourceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataSourcePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DataSourceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataSourcePayload>
          }
          findMany: {
            args: Prisma.DataSourceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataSourcePayload>[]
          }
          create: {
            args: Prisma.DataSourceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataSourcePayload>
          }
          createMany: {
            args: Prisma.DataSourceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DataSourceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataSourcePayload>
          }
          update: {
            args: Prisma.DataSourceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataSourcePayload>
          }
          deleteMany: {
            args: Prisma.DataSourceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DataSourceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DataSourceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataSourcePayload>
          }
          aggregate: {
            args: Prisma.DataSourceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDataSource>
          }
          groupBy: {
            args: Prisma.DataSourceGroupByArgs<ExtArgs>
            result: $Utils.Optional<DataSourceGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.DataSourceFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.DataSourceAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.DataSourceCountArgs<ExtArgs>
            result: $Utils.Optional<DataSourceCountAggregateOutputType> | number
          }
        }
      }
      DataSourceTask: {
        payload: Prisma.$DataSourceTaskPayload<ExtArgs>
        fields: Prisma.DataSourceTaskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DataSourceTaskFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataSourceTaskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DataSourceTaskFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataSourceTaskPayload>
          }
          findFirst: {
            args: Prisma.DataSourceTaskFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataSourceTaskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DataSourceTaskFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataSourceTaskPayload>
          }
          findMany: {
            args: Prisma.DataSourceTaskFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataSourceTaskPayload>[]
          }
          create: {
            args: Prisma.DataSourceTaskCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataSourceTaskPayload>
          }
          createMany: {
            args: Prisma.DataSourceTaskCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DataSourceTaskDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataSourceTaskPayload>
          }
          update: {
            args: Prisma.DataSourceTaskUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataSourceTaskPayload>
          }
          deleteMany: {
            args: Prisma.DataSourceTaskDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DataSourceTaskUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DataSourceTaskUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataSourceTaskPayload>
          }
          aggregate: {
            args: Prisma.DataSourceTaskAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDataSourceTask>
          }
          groupBy: {
            args: Prisma.DataSourceTaskGroupByArgs<ExtArgs>
            result: $Utils.Optional<DataSourceTaskGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.DataSourceTaskFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.DataSourceTaskAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.DataSourceTaskCountArgs<ExtArgs>
            result: $Utils.Optional<DataSourceTaskCountAggregateOutputType> | number
          }
        }
      }
      DataSourceLoader: {
        payload: Prisma.$DataSourceLoaderPayload<ExtArgs>
        fields: Prisma.DataSourceLoaderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DataSourceLoaderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataSourceLoaderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DataSourceLoaderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataSourceLoaderPayload>
          }
          findFirst: {
            args: Prisma.DataSourceLoaderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataSourceLoaderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DataSourceLoaderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataSourceLoaderPayload>
          }
          findMany: {
            args: Prisma.DataSourceLoaderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataSourceLoaderPayload>[]
          }
          create: {
            args: Prisma.DataSourceLoaderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataSourceLoaderPayload>
          }
          createMany: {
            args: Prisma.DataSourceLoaderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DataSourceLoaderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataSourceLoaderPayload>
          }
          update: {
            args: Prisma.DataSourceLoaderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataSourceLoaderPayload>
          }
          deleteMany: {
            args: Prisma.DataSourceLoaderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DataSourceLoaderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DataSourceLoaderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataSourceLoaderPayload>
          }
          aggregate: {
            args: Prisma.DataSourceLoaderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDataSourceLoader>
          }
          groupBy: {
            args: Prisma.DataSourceLoaderGroupByArgs<ExtArgs>
            result: $Utils.Optional<DataSourceLoaderGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.DataSourceLoaderFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.DataSourceLoaderAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.DataSourceLoaderCountArgs<ExtArgs>
            result: $Utils.Optional<DataSourceLoaderCountAggregateOutputType> | number
          }
        }
      }
      DataSourceCredential: {
        payload: Prisma.$DataSourceCredentialPayload<ExtArgs>
        fields: Prisma.DataSourceCredentialFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DataSourceCredentialFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataSourceCredentialPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DataSourceCredentialFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataSourceCredentialPayload>
          }
          findFirst: {
            args: Prisma.DataSourceCredentialFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataSourceCredentialPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DataSourceCredentialFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataSourceCredentialPayload>
          }
          findMany: {
            args: Prisma.DataSourceCredentialFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataSourceCredentialPayload>[]
          }
          create: {
            args: Prisma.DataSourceCredentialCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataSourceCredentialPayload>
          }
          createMany: {
            args: Prisma.DataSourceCredentialCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DataSourceCredentialDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataSourceCredentialPayload>
          }
          update: {
            args: Prisma.DataSourceCredentialUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataSourceCredentialPayload>
          }
          deleteMany: {
            args: Prisma.DataSourceCredentialDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DataSourceCredentialUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DataSourceCredentialUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataSourceCredentialPayload>
          }
          aggregate: {
            args: Prisma.DataSourceCredentialAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDataSourceCredential>
          }
          groupBy: {
            args: Prisma.DataSourceCredentialGroupByArgs<ExtArgs>
            result: $Utils.Optional<DataSourceCredentialGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.DataSourceCredentialFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.DataSourceCredentialAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.DataSourceCredentialCountArgs<ExtArgs>
            result: $Utils.Optional<DataSourceCredentialCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $runCommandRaw: {
          args: Prisma.InputJsonObject,
          result: Prisma.JsonObject
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    config?: ConfigOmit
    country?: CountryOmit
    user?: UserOmit
    client?: ClientOmit
    permission?: PermissionOmit
    instance?: InstanceOmit
    version?: VersionOmit
    currencyIsoCode?: CurrencyIsoCodeOmit
    currency?: CurrencyOmit
    level?: LevelOmit
    levelAttributeAndValue?: LevelAttributeAndValueOmit
    levelAttributeValue?: LevelAttributeValueOmit
    levelAttribute?: LevelAttributeOmit
    accountAttribute?: AccountAttributeOmit
    accountAttributeValue?: AccountAttributeValueOmit
    accountAttributeAndValue?: AccountAttributeAndValueOmit
    account?: AccountOmit
    dimension?: DimensionOmit
    dimensionValue?: DimensionValueOmit
    dimensionValueAttribute?: DimensionValueAttributeOmit
    dimensionValueAttributeValue?: DimensionValueAttributeValueOmit
    dimensionValueAttributeAndValue?: DimensionValueAttributeAndValueOmit
    model?: ModelOmit
    modelAccountStructure?: ModelAccountStructureOmit
    modelData?: ModelDataOmit
    modelDataCalculations?: ModelDataCalculationsOmit
    table?: TableOmit
    tableData?: TableDataOmit
    dataSource?: DataSourceOmit
    dataSourceTask?: DataSourceTaskOmit
    dataSourceLoader?: DataSourceLoaderOmit
    dataSourceCredential?: DataSourceCredentialOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CountryCountOutputType
   */

  export type CountryCountOutputType = {
    Client: number
    User: number
  }

  export type CountryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Client?: boolean | CountryCountOutputTypeCountClientArgs
    User?: boolean | CountryCountOutputTypeCountUserArgs
  }

  // Custom InputTypes
  /**
   * CountryCountOutputType without action
   */
  export type CountryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountryCountOutputType
     */
    select?: CountryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CountryCountOutputType without action
   */
  export type CountryCountOutputTypeCountClientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientWhereInput
  }

  /**
   * CountryCountOutputType without action
   */
  export type CountryCountOutputTypeCountUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * Count Type ClientCountOutputType
   */

  export type ClientCountOutputType = {
    users: number
    instances: number
    Permission: number
  }

  export type ClientCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | ClientCountOutputTypeCountUsersArgs
    instances?: boolean | ClientCountOutputTypeCountInstancesArgs
    Permission?: boolean | ClientCountOutputTypeCountPermissionArgs
  }

  // Custom InputTypes
  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientCountOutputType
     */
    select?: ClientCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountInstancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstanceWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountPermissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PermissionWhereInput
  }


  /**
   * Count Type InstanceCountOutputType
   */

  export type InstanceCountOutputType = {
    levels: number
    versions: number
    currencies: number
    accounts: number
    models: number
    dimensions: number
    dimensionValues: number
    levelAttributes: number
    dimensionValueAttributes: number
    accountAttributes: number
    levelAttValues: number
    accountAttValues: number
    dimensionValueAttributeValues: number
    modelData: number
    modelDataCalculations: number
    modelAccounts: number
    tables: number
    tableData: number
  }

  export type InstanceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    levels?: boolean | InstanceCountOutputTypeCountLevelsArgs
    versions?: boolean | InstanceCountOutputTypeCountVersionsArgs
    currencies?: boolean | InstanceCountOutputTypeCountCurrenciesArgs
    accounts?: boolean | InstanceCountOutputTypeCountAccountsArgs
    models?: boolean | InstanceCountOutputTypeCountModelsArgs
    dimensions?: boolean | InstanceCountOutputTypeCountDimensionsArgs
    dimensionValues?: boolean | InstanceCountOutputTypeCountDimensionValuesArgs
    levelAttributes?: boolean | InstanceCountOutputTypeCountLevelAttributesArgs
    dimensionValueAttributes?: boolean | InstanceCountOutputTypeCountDimensionValueAttributesArgs
    accountAttributes?: boolean | InstanceCountOutputTypeCountAccountAttributesArgs
    levelAttValues?: boolean | InstanceCountOutputTypeCountLevelAttValuesArgs
    accountAttValues?: boolean | InstanceCountOutputTypeCountAccountAttValuesArgs
    dimensionValueAttributeValues?: boolean | InstanceCountOutputTypeCountDimensionValueAttributeValuesArgs
    modelData?: boolean | InstanceCountOutputTypeCountModelDataArgs
    modelDataCalculations?: boolean | InstanceCountOutputTypeCountModelDataCalculationsArgs
    modelAccounts?: boolean | InstanceCountOutputTypeCountModelAccountsArgs
    tables?: boolean | InstanceCountOutputTypeCountTablesArgs
    tableData?: boolean | InstanceCountOutputTypeCountTableDataArgs
  }

  // Custom InputTypes
  /**
   * InstanceCountOutputType without action
   */
  export type InstanceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstanceCountOutputType
     */
    select?: InstanceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InstanceCountOutputType without action
   */
  export type InstanceCountOutputTypeCountLevelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LevelWhereInput
  }

  /**
   * InstanceCountOutputType without action
   */
  export type InstanceCountOutputTypeCountVersionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VersionWhereInput
  }

  /**
   * InstanceCountOutputType without action
   */
  export type InstanceCountOutputTypeCountCurrenciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CurrencyWhereInput
  }

  /**
   * InstanceCountOutputType without action
   */
  export type InstanceCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * InstanceCountOutputType without action
   */
  export type InstanceCountOutputTypeCountModelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModelWhereInput
  }

  /**
   * InstanceCountOutputType without action
   */
  export type InstanceCountOutputTypeCountDimensionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DimensionWhereInput
  }

  /**
   * InstanceCountOutputType without action
   */
  export type InstanceCountOutputTypeCountDimensionValuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DimensionValueWhereInput
  }

  /**
   * InstanceCountOutputType without action
   */
  export type InstanceCountOutputTypeCountLevelAttributesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LevelAttributeWhereInput
  }

  /**
   * InstanceCountOutputType without action
   */
  export type InstanceCountOutputTypeCountDimensionValueAttributesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DimensionValueAttributeWhereInput
  }

  /**
   * InstanceCountOutputType without action
   */
  export type InstanceCountOutputTypeCountAccountAttributesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountAttributeWhereInput
  }

  /**
   * InstanceCountOutputType without action
   */
  export type InstanceCountOutputTypeCountLevelAttValuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LevelAttributeValueWhereInput
  }

  /**
   * InstanceCountOutputType without action
   */
  export type InstanceCountOutputTypeCountAccountAttValuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountAttributeValueWhereInput
  }

  /**
   * InstanceCountOutputType without action
   */
  export type InstanceCountOutputTypeCountDimensionValueAttributeValuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DimensionValueAttributeValueWhereInput
  }

  /**
   * InstanceCountOutputType without action
   */
  export type InstanceCountOutputTypeCountModelDataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModelDataWhereInput
  }

  /**
   * InstanceCountOutputType without action
   */
  export type InstanceCountOutputTypeCountModelDataCalculationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModelDataCalculationsWhereInput
  }

  /**
   * InstanceCountOutputType without action
   */
  export type InstanceCountOutputTypeCountModelAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModelAccountStructureWhereInput
  }

  /**
   * InstanceCountOutputType without action
   */
  export type InstanceCountOutputTypeCountTablesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TableWhereInput
  }

  /**
   * InstanceCountOutputType without action
   */
  export type InstanceCountOutputTypeCountTableDataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TableDataWhereInput
  }


  /**
   * Count Type VersionCountOutputType
   */

  export type VersionCountOutputType = {
    modelData: number
    modelDataCalculations: number
  }

  export type VersionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    modelData?: boolean | VersionCountOutputTypeCountModelDataArgs
    modelDataCalculations?: boolean | VersionCountOutputTypeCountModelDataCalculationsArgs
  }

  // Custom InputTypes
  /**
   * VersionCountOutputType without action
   */
  export type VersionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VersionCountOutputType
     */
    select?: VersionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VersionCountOutputType without action
   */
  export type VersionCountOutputTypeCountModelDataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModelDataWhereInput
  }

  /**
   * VersionCountOutputType without action
   */
  export type VersionCountOutputTypeCountModelDataCalculationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModelDataCalculationsWhereInput
  }


  /**
   * Count Type CurrencyIsoCodeCountOutputType
   */

  export type CurrencyIsoCodeCountOutputType = {
    currencies: number
    config: number
  }

  export type CurrencyIsoCodeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    currencies?: boolean | CurrencyIsoCodeCountOutputTypeCountCurrenciesArgs
    config?: boolean | CurrencyIsoCodeCountOutputTypeCountConfigArgs
  }

  // Custom InputTypes
  /**
   * CurrencyIsoCodeCountOutputType without action
   */
  export type CurrencyIsoCodeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurrencyIsoCodeCountOutputType
     */
    select?: CurrencyIsoCodeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CurrencyIsoCodeCountOutputType without action
   */
  export type CurrencyIsoCodeCountOutputTypeCountCurrenciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CurrencyWhereInput
  }

  /**
   * CurrencyIsoCodeCountOutputType without action
   */
  export type CurrencyIsoCodeCountOutputTypeCountConfigArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConfigWhereInput
  }


  /**
   * Count Type CurrencyCountOutputType
   */

  export type CurrencyCountOutputType = {
    levels: number
    defaults: number
  }

  export type CurrencyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    levels?: boolean | CurrencyCountOutputTypeCountLevelsArgs
    defaults?: boolean | CurrencyCountOutputTypeCountDefaultsArgs
  }

  // Custom InputTypes
  /**
   * CurrencyCountOutputType without action
   */
  export type CurrencyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurrencyCountOutputType
     */
    select?: CurrencyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CurrencyCountOutputType without action
   */
  export type CurrencyCountOutputTypeCountLevelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LevelWhereInput
  }

  /**
   * CurrencyCountOutputType without action
   */
  export type CurrencyCountOutputTypeCountDefaultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConfigWhereInput
  }


  /**
   * Count Type LevelCountOutputType
   */

  export type LevelCountOutputType = {
    AttributeAndValues: number
    childLevels: number
    modelData: number
    modeldataCalculations: number
  }

  export type LevelCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AttributeAndValues?: boolean | LevelCountOutputTypeCountAttributeAndValuesArgs
    childLevels?: boolean | LevelCountOutputTypeCountChildLevelsArgs
    modelData?: boolean | LevelCountOutputTypeCountModelDataArgs
    modeldataCalculations?: boolean | LevelCountOutputTypeCountModeldataCalculationsArgs
  }

  // Custom InputTypes
  /**
   * LevelCountOutputType without action
   */
  export type LevelCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LevelCountOutputType
     */
    select?: LevelCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LevelCountOutputType without action
   */
  export type LevelCountOutputTypeCountAttributeAndValuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LevelAttributeAndValueWhereInput
  }

  /**
   * LevelCountOutputType without action
   */
  export type LevelCountOutputTypeCountChildLevelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LevelWhereInput
  }

  /**
   * LevelCountOutputType without action
   */
  export type LevelCountOutputTypeCountModelDataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModelDataWhereInput
  }

  /**
   * LevelCountOutputType without action
   */
  export type LevelCountOutputTypeCountModeldataCalculationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModelDataCalculationsWhereInput
  }


  /**
   * Count Type LevelAttributeValueCountOutputType
   */

  export type LevelAttributeValueCountOutputType = {
    childAttributeValues: number
    levelAttributeAndValues: number
  }

  export type LevelAttributeValueCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    childAttributeValues?: boolean | LevelAttributeValueCountOutputTypeCountChildAttributeValuesArgs
    levelAttributeAndValues?: boolean | LevelAttributeValueCountOutputTypeCountLevelAttributeAndValuesArgs
  }

  // Custom InputTypes
  /**
   * LevelAttributeValueCountOutputType without action
   */
  export type LevelAttributeValueCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LevelAttributeValueCountOutputType
     */
    select?: LevelAttributeValueCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LevelAttributeValueCountOutputType without action
   */
  export type LevelAttributeValueCountOutputTypeCountChildAttributeValuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LevelAttributeValueWhereInput
  }

  /**
   * LevelAttributeValueCountOutputType without action
   */
  export type LevelAttributeValueCountOutputTypeCountLevelAttributeAndValuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LevelAttributeAndValueWhereInput
  }


  /**
   * Count Type LevelAttributeCountOutputType
   */

  export type LevelAttributeCountOutputType = {
    levelAttributeValues: number
    levelAttributeAndValues: number
  }

  export type LevelAttributeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    levelAttributeValues?: boolean | LevelAttributeCountOutputTypeCountLevelAttributeValuesArgs
    levelAttributeAndValues?: boolean | LevelAttributeCountOutputTypeCountLevelAttributeAndValuesArgs
  }

  // Custom InputTypes
  /**
   * LevelAttributeCountOutputType without action
   */
  export type LevelAttributeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LevelAttributeCountOutputType
     */
    select?: LevelAttributeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LevelAttributeCountOutputType without action
   */
  export type LevelAttributeCountOutputTypeCountLevelAttributeValuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LevelAttributeValueWhereInput
  }

  /**
   * LevelAttributeCountOutputType without action
   */
  export type LevelAttributeCountOutputTypeCountLevelAttributeAndValuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LevelAttributeAndValueWhereInput
  }


  /**
   * Count Type AccountAttributeCountOutputType
   */

  export type AccountAttributeCountOutputType = {
    accountAttributeValues: number
    AttributeAndValues: number
  }

  export type AccountAttributeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accountAttributeValues?: boolean | AccountAttributeCountOutputTypeCountAccountAttributeValuesArgs
    AttributeAndValues?: boolean | AccountAttributeCountOutputTypeCountAttributeAndValuesArgs
  }

  // Custom InputTypes
  /**
   * AccountAttributeCountOutputType without action
   */
  export type AccountAttributeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountAttributeCountOutputType
     */
    select?: AccountAttributeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AccountAttributeCountOutputType without action
   */
  export type AccountAttributeCountOutputTypeCountAccountAttributeValuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountAttributeValueWhereInput
  }

  /**
   * AccountAttributeCountOutputType without action
   */
  export type AccountAttributeCountOutputTypeCountAttributeAndValuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountAttributeAndValueWhereInput
  }


  /**
   * Count Type AccountAttributeValueCountOutputType
   */

  export type AccountAttributeValueCountOutputType = {
    childAttributeValues: number
    AttributeAndValues: number
  }

  export type AccountAttributeValueCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    childAttributeValues?: boolean | AccountAttributeValueCountOutputTypeCountChildAttributeValuesArgs
    AttributeAndValues?: boolean | AccountAttributeValueCountOutputTypeCountAttributeAndValuesArgs
  }

  // Custom InputTypes
  /**
   * AccountAttributeValueCountOutputType without action
   */
  export type AccountAttributeValueCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountAttributeValueCountOutputType
     */
    select?: AccountAttributeValueCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AccountAttributeValueCountOutputType without action
   */
  export type AccountAttributeValueCountOutputTypeCountChildAttributeValuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountAttributeValueWhereInput
  }

  /**
   * AccountAttributeValueCountOutputType without action
   */
  export type AccountAttributeValueCountOutputTypeCountAttributeAndValuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountAttributeAndValueWhereInput
  }


  /**
   * Count Type AccountCountOutputType
   */

  export type AccountCountOutputType = {
    childAccounts: number
    AttributeAndValues: number
    modelAccounts: number
    modelData: number
    modeldataCalculations: number
  }

  export type AccountCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    childAccounts?: boolean | AccountCountOutputTypeCountChildAccountsArgs
    AttributeAndValues?: boolean | AccountCountOutputTypeCountAttributeAndValuesArgs
    modelAccounts?: boolean | AccountCountOutputTypeCountModelAccountsArgs
    modelData?: boolean | AccountCountOutputTypeCountModelDataArgs
    modeldataCalculations?: boolean | AccountCountOutputTypeCountModeldataCalculationsArgs
  }

  // Custom InputTypes
  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountCountOutputType
     */
    select?: AccountCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountChildAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountAttributeAndValuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountAttributeAndValueWhereInput
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountModelAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModelAccountStructureWhereInput
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountModelDataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModelDataWhereInput
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountModeldataCalculationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModelDataCalculationsWhereInput
  }


  /**
   * Count Type DimensionCountOutputType
   */

  export type DimensionCountOutputType = {
    dimensionValues: number
  }

  export type DimensionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dimensionValues?: boolean | DimensionCountOutputTypeCountDimensionValuesArgs
  }

  // Custom InputTypes
  /**
   * DimensionCountOutputType without action
   */
  export type DimensionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimensionCountOutputType
     */
    select?: DimensionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DimensionCountOutputType without action
   */
  export type DimensionCountOutputTypeCountDimensionValuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DimensionValueWhereInput
  }


  /**
   * Count Type DimensionValueCountOutputType
   */

  export type DimensionValueCountOutputType = {
    childDimensionValues: number
    AttributeAndValues: number
  }

  export type DimensionValueCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    childDimensionValues?: boolean | DimensionValueCountOutputTypeCountChildDimensionValuesArgs
    AttributeAndValues?: boolean | DimensionValueCountOutputTypeCountAttributeAndValuesArgs
  }

  // Custom InputTypes
  /**
   * DimensionValueCountOutputType without action
   */
  export type DimensionValueCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimensionValueCountOutputType
     */
    select?: DimensionValueCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DimensionValueCountOutputType without action
   */
  export type DimensionValueCountOutputTypeCountChildDimensionValuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DimensionValueWhereInput
  }

  /**
   * DimensionValueCountOutputType without action
   */
  export type DimensionValueCountOutputTypeCountAttributeAndValuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DimensionValueAttributeAndValueWhereInput
  }


  /**
   * Count Type DimensionValueAttributeCountOutputType
   */

  export type DimensionValueAttributeCountOutputType = {
    AttributeValues: number
    AttributeAndValues: number
  }

  export type DimensionValueAttributeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AttributeValues?: boolean | DimensionValueAttributeCountOutputTypeCountAttributeValuesArgs
    AttributeAndValues?: boolean | DimensionValueAttributeCountOutputTypeCountAttributeAndValuesArgs
  }

  // Custom InputTypes
  /**
   * DimensionValueAttributeCountOutputType without action
   */
  export type DimensionValueAttributeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimensionValueAttributeCountOutputType
     */
    select?: DimensionValueAttributeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DimensionValueAttributeCountOutputType without action
   */
  export type DimensionValueAttributeCountOutputTypeCountAttributeValuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DimensionValueAttributeValueWhereInput
  }

  /**
   * DimensionValueAttributeCountOutputType without action
   */
  export type DimensionValueAttributeCountOutputTypeCountAttributeAndValuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DimensionValueAttributeAndValueWhereInput
  }


  /**
   * Count Type DimensionValueAttributeValueCountOutputType
   */

  export type DimensionValueAttributeValueCountOutputType = {
    childAttributeValues: number
    dimensionAttributeAndValues: number
  }

  export type DimensionValueAttributeValueCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    childAttributeValues?: boolean | DimensionValueAttributeValueCountOutputTypeCountChildAttributeValuesArgs
    dimensionAttributeAndValues?: boolean | DimensionValueAttributeValueCountOutputTypeCountDimensionAttributeAndValuesArgs
  }

  // Custom InputTypes
  /**
   * DimensionValueAttributeValueCountOutputType without action
   */
  export type DimensionValueAttributeValueCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimensionValueAttributeValueCountOutputType
     */
    select?: DimensionValueAttributeValueCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DimensionValueAttributeValueCountOutputType without action
   */
  export type DimensionValueAttributeValueCountOutputTypeCountChildAttributeValuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DimensionValueAttributeValueWhereInput
  }

  /**
   * DimensionValueAttributeValueCountOutputType without action
   */
  export type DimensionValueAttributeValueCountOutputTypeCountDimensionAttributeAndValuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DimensionValueAttributeAndValueWhereInput
  }


  /**
   * Count Type ModelCountOutputType
   */

  export type ModelCountOutputType = {
    modelData: number
    modelAccounts: number
    modelDataCalculations: number
  }

  export type ModelCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    modelData?: boolean | ModelCountOutputTypeCountModelDataArgs
    modelAccounts?: boolean | ModelCountOutputTypeCountModelAccountsArgs
    modelDataCalculations?: boolean | ModelCountOutputTypeCountModelDataCalculationsArgs
  }

  // Custom InputTypes
  /**
   * ModelCountOutputType without action
   */
  export type ModelCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelCountOutputType
     */
    select?: ModelCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ModelCountOutputType without action
   */
  export type ModelCountOutputTypeCountModelDataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModelDataWhereInput
  }

  /**
   * ModelCountOutputType without action
   */
  export type ModelCountOutputTypeCountModelAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModelAccountStructureWhereInput
  }

  /**
   * ModelCountOutputType without action
   */
  export type ModelCountOutputTypeCountModelDataCalculationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModelDataCalculationsWhereInput
  }


  /**
   * Count Type ModelAccountStructureCountOutputType
   */

  export type ModelAccountStructureCountOutputType = {
    modeldataCalculations: number
    childAccounts: number
  }

  export type ModelAccountStructureCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    modeldataCalculations?: boolean | ModelAccountStructureCountOutputTypeCountModeldataCalculationsArgs
    childAccounts?: boolean | ModelAccountStructureCountOutputTypeCountChildAccountsArgs
  }

  // Custom InputTypes
  /**
   * ModelAccountStructureCountOutputType without action
   */
  export type ModelAccountStructureCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelAccountStructureCountOutputType
     */
    select?: ModelAccountStructureCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ModelAccountStructureCountOutputType without action
   */
  export type ModelAccountStructureCountOutputTypeCountModeldataCalculationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModelDataCalculationsWhereInput
  }

  /**
   * ModelAccountStructureCountOutputType without action
   */
  export type ModelAccountStructureCountOutputTypeCountChildAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModelAccountStructureWhereInput
  }


  /**
   * Count Type TableCountOutputType
   */

  export type TableCountOutputType = {
    tableData: number
  }

  export type TableCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tableData?: boolean | TableCountOutputTypeCountTableDataArgs
  }

  // Custom InputTypes
  /**
   * TableCountOutputType without action
   */
  export type TableCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TableCountOutputType
     */
    select?: TableCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TableCountOutputType without action
   */
  export type TableCountOutputTypeCountTableDataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TableDataWhereInput
  }


  /**
   * Count Type DataSourceCredentialCountOutputType
   */

  export type DataSourceCredentialCountOutputType = {
    datasources: number
  }

  export type DataSourceCredentialCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    datasources?: boolean | DataSourceCredentialCountOutputTypeCountDatasourcesArgs
  }

  // Custom InputTypes
  /**
   * DataSourceCredentialCountOutputType without action
   */
  export type DataSourceCredentialCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataSourceCredentialCountOutputType
     */
    select?: DataSourceCredentialCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DataSourceCredentialCountOutputType without action
   */
  export type DataSourceCredentialCountOutputTypeCountDatasourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DataSourceWhereInput
  }


  /**
   * Models
   */

  /**
   * Model addressType
   */





  export type addressTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    address1?: boolean
    address2?: boolean
    city?: boolean
    state?: boolean
  }, ExtArgs["result"]["addressType"]>



  export type addressTypeSelectScalar = {
    address1?: boolean
    address2?: boolean
    city?: boolean
    state?: boolean
  }

  export type addressTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"address1" | "address2" | "city" | "state", ExtArgs["result"]["addressType"]>

  export type $addressTypePayload = {
    name: "addressType"
    objects: {}
    scalars: {
      address1: string | null
      address2: string | null
      city: string | null
      state: string | null
    }
    composites: {}
  }

  type addressTypeGetPayload<S extends boolean | null | undefined | addressTypeDefaultArgs> = $Result.GetResult<Prisma.$addressTypePayload, S>





  /**
   * Fields of the addressType model
   */ 
  interface addressTypeFieldRefs {
    readonly address1: FieldRef<"addressType", 'String'>
    readonly address2: FieldRef<"addressType", 'String'>
    readonly city: FieldRef<"addressType", 'String'>
    readonly state: FieldRef<"addressType", 'String'>
  }
    

  // Custom InputTypes
  /**
   * addressType without action
   */
  export type addressTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the addressType
     */
    select?: addressTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the addressType
     */
    omit?: addressTypeOmit<ExtArgs> | null
  }


  /**
   * Model ModelDataDimensionality
   */





  export type ModelDataDimensionalitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    dimensionId?: boolean
    dimensionValueId?: boolean
  }, ExtArgs["result"]["modelDataDimensionality"]>



  export type ModelDataDimensionalitySelectScalar = {
    dimensionId?: boolean
    dimensionValueId?: boolean
  }

  export type ModelDataDimensionalityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"dimensionId" | "dimensionValueId", ExtArgs["result"]["modelDataDimensionality"]>

  export type $ModelDataDimensionalityPayload = {
    name: "ModelDataDimensionality"
    objects: {}
    scalars: {
      dimensionId: string
      dimensionValueId: string
    }
    composites: {}
  }

  type ModelDataDimensionalityGetPayload<S extends boolean | null | undefined | ModelDataDimensionalityDefaultArgs> = $Result.GetResult<Prisma.$ModelDataDimensionalityPayload, S>





  /**
   * Fields of the ModelDataDimensionality model
   */ 
  interface ModelDataDimensionalityFieldRefs {
    readonly dimensionId: FieldRef<"ModelDataDimensionality", 'String'>
    readonly dimensionValueId: FieldRef<"ModelDataDimensionality", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ModelDataDimensionality without action
   */
  export type ModelDataDimensionalityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelDataDimensionality
     */
    select?: ModelDataDimensionalitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelDataDimensionality
     */
    omit?: ModelDataDimensionalityOmit<ExtArgs> | null
  }


  /**
   * Model TableColumnDefinition
   */





  export type TableColumnDefinitionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    tableId?: boolean
    name?: boolean
    code?: boolean
    type?: boolean
    dimensionId?: boolean
  }, ExtArgs["result"]["tableColumnDefinition"]>



  export type TableColumnDefinitionSelectScalar = {
    tableId?: boolean
    name?: boolean
    code?: boolean
    type?: boolean
    dimensionId?: boolean
  }

  export type TableColumnDefinitionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"tableId" | "name" | "code" | "type" | "dimensionId", ExtArgs["result"]["tableColumnDefinition"]>

  export type $TableColumnDefinitionPayload = {
    name: "TableColumnDefinition"
    objects: {}
    scalars: {
      tableId: string
      name: string
      code: string
      type: $Enums.TableColumnType
      dimensionId: string | null
    }
    composites: {}
  }

  type TableColumnDefinitionGetPayload<S extends boolean | null | undefined | TableColumnDefinitionDefaultArgs> = $Result.GetResult<Prisma.$TableColumnDefinitionPayload, S>





  /**
   * Fields of the TableColumnDefinition model
   */ 
  interface TableColumnDefinitionFieldRefs {
    readonly tableId: FieldRef<"TableColumnDefinition", 'String'>
    readonly name: FieldRef<"TableColumnDefinition", 'String'>
    readonly code: FieldRef<"TableColumnDefinition", 'String'>
    readonly type: FieldRef<"TableColumnDefinition", 'TableColumnType'>
    readonly dimensionId: FieldRef<"TableColumnDefinition", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TableColumnDefinition without action
   */
  export type TableColumnDefinitionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TableColumnDefinition
     */
    select?: TableColumnDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TableColumnDefinition
     */
    omit?: TableColumnDefinitionOmit<ExtArgs> | null
  }


  /**
   * Model Config
   */

  export type AggregateConfig = {
    _count: ConfigCountAggregateOutputType | null
    _min: ConfigMinAggregateOutputType | null
    _max: ConfigMaxAggregateOutputType | null
  }

  export type ConfigMinAggregateOutputType = {
    id: string | null
    defaultIsoCurrencyId: string | null
    defaultCurrencyId: string | null
    defaultTopLevelName: string | null
    defaultTopLevelDescription: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConfigMaxAggregateOutputType = {
    id: string | null
    defaultIsoCurrencyId: string | null
    defaultCurrencyId: string | null
    defaultTopLevelName: string | null
    defaultTopLevelDescription: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConfigCountAggregateOutputType = {
    id: number
    defaultIsoCurrencyId: number
    defaultCurrencyId: number
    defaultTopLevelName: number
    defaultTopLevelDescription: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ConfigMinAggregateInputType = {
    id?: true
    defaultIsoCurrencyId?: true
    defaultCurrencyId?: true
    defaultTopLevelName?: true
    defaultTopLevelDescription?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConfigMaxAggregateInputType = {
    id?: true
    defaultIsoCurrencyId?: true
    defaultCurrencyId?: true
    defaultTopLevelName?: true
    defaultTopLevelDescription?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConfigCountAggregateInputType = {
    id?: true
    defaultIsoCurrencyId?: true
    defaultCurrencyId?: true
    defaultTopLevelName?: true
    defaultTopLevelDescription?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Config to aggregate.
     */
    where?: ConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Configs to fetch.
     */
    orderBy?: ConfigOrderByWithRelationInput | ConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Configs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Configs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Configs
    **/
    _count?: true | ConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConfigMaxAggregateInputType
  }

  export type GetConfigAggregateType<T extends ConfigAggregateArgs> = {
        [P in keyof T & keyof AggregateConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConfig[P]>
      : GetScalarType<T[P], AggregateConfig[P]>
  }




  export type ConfigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConfigWhereInput
    orderBy?: ConfigOrderByWithAggregationInput | ConfigOrderByWithAggregationInput[]
    by: ConfigScalarFieldEnum[] | ConfigScalarFieldEnum
    having?: ConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConfigCountAggregateInputType | true
    _min?: ConfigMinAggregateInputType
    _max?: ConfigMaxAggregateInputType
  }

  export type ConfigGroupByOutputType = {
    id: string
    defaultIsoCurrencyId: string
    defaultCurrencyId: string
    defaultTopLevelName: string
    defaultTopLevelDescription: string
    createdAt: Date | null
    updatedAt: Date | null
    _count: ConfigCountAggregateOutputType | null
    _min: ConfigMinAggregateOutputType | null
    _max: ConfigMaxAggregateOutputType | null
  }

  type GetConfigGroupByPayload<T extends ConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConfigGroupByOutputType[P]>
            : GetScalarType<T[P], ConfigGroupByOutputType[P]>
        }
      >
    >


  export type ConfigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    defaultIsoCurrencyId?: boolean
    defaultCurrencyId?: boolean
    defaultTopLevelName?: boolean
    defaultTopLevelDescription?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    defaultIsoCurrency?: boolean | CurrencyIsoCodeDefaultArgs<ExtArgs>
    defaultCurrency?: boolean | CurrencyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["config"]>



  export type ConfigSelectScalar = {
    id?: boolean
    defaultIsoCurrencyId?: boolean
    defaultCurrencyId?: boolean
    defaultTopLevelName?: boolean
    defaultTopLevelDescription?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ConfigOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "defaultIsoCurrencyId" | "defaultCurrencyId" | "defaultTopLevelName" | "defaultTopLevelDescription" | "createdAt" | "updatedAt", ExtArgs["result"]["config"]>
  export type ConfigInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    defaultIsoCurrency?: boolean | CurrencyIsoCodeDefaultArgs<ExtArgs>
    defaultCurrency?: boolean | CurrencyDefaultArgs<ExtArgs>
  }

  export type $ConfigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Config"
    objects: {
      defaultIsoCurrency: Prisma.$CurrencyIsoCodePayload<ExtArgs>
      defaultCurrency: Prisma.$CurrencyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      defaultIsoCurrencyId: string
      defaultCurrencyId: string
      defaultTopLevelName: string
      defaultTopLevelDescription: string
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["config"]>
    composites: {}
  }

  type ConfigGetPayload<S extends boolean | null | undefined | ConfigDefaultArgs> = $Result.GetResult<Prisma.$ConfigPayload, S>

  type ConfigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConfigFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConfigCountAggregateInputType | true
    }

  export interface ConfigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Config'], meta: { name: 'Config' } }
    /**
     * Find zero or one Config that matches the filter.
     * @param {ConfigFindUniqueArgs} args - Arguments to find a Config
     * @example
     * // Get one Config
     * const config = await prisma.config.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConfigFindUniqueArgs>(args: SelectSubset<T, ConfigFindUniqueArgs<ExtArgs>>): Prisma__ConfigClient<$Result.GetResult<Prisma.$ConfigPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Config that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConfigFindUniqueOrThrowArgs} args - Arguments to find a Config
     * @example
     * // Get one Config
     * const config = await prisma.config.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConfigFindUniqueOrThrowArgs>(args: SelectSubset<T, ConfigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConfigClient<$Result.GetResult<Prisma.$ConfigPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Config that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigFindFirstArgs} args - Arguments to find a Config
     * @example
     * // Get one Config
     * const config = await prisma.config.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConfigFindFirstArgs>(args?: SelectSubset<T, ConfigFindFirstArgs<ExtArgs>>): Prisma__ConfigClient<$Result.GetResult<Prisma.$ConfigPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Config that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigFindFirstOrThrowArgs} args - Arguments to find a Config
     * @example
     * // Get one Config
     * const config = await prisma.config.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConfigFindFirstOrThrowArgs>(args?: SelectSubset<T, ConfigFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConfigClient<$Result.GetResult<Prisma.$ConfigPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Configs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Configs
     * const configs = await prisma.config.findMany()
     * 
     * // Get first 10 Configs
     * const configs = await prisma.config.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const configWithIdOnly = await prisma.config.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConfigFindManyArgs>(args?: SelectSubset<T, ConfigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConfigPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Config.
     * @param {ConfigCreateArgs} args - Arguments to create a Config.
     * @example
     * // Create one Config
     * const Config = await prisma.config.create({
     *   data: {
     *     // ... data to create a Config
     *   }
     * })
     * 
     */
    create<T extends ConfigCreateArgs>(args: SelectSubset<T, ConfigCreateArgs<ExtArgs>>): Prisma__ConfigClient<$Result.GetResult<Prisma.$ConfigPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Configs.
     * @param {ConfigCreateManyArgs} args - Arguments to create many Configs.
     * @example
     * // Create many Configs
     * const config = await prisma.config.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConfigCreateManyArgs>(args?: SelectSubset<T, ConfigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Config.
     * @param {ConfigDeleteArgs} args - Arguments to delete one Config.
     * @example
     * // Delete one Config
     * const Config = await prisma.config.delete({
     *   where: {
     *     // ... filter to delete one Config
     *   }
     * })
     * 
     */
    delete<T extends ConfigDeleteArgs>(args: SelectSubset<T, ConfigDeleteArgs<ExtArgs>>): Prisma__ConfigClient<$Result.GetResult<Prisma.$ConfigPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Config.
     * @param {ConfigUpdateArgs} args - Arguments to update one Config.
     * @example
     * // Update one Config
     * const config = await prisma.config.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConfigUpdateArgs>(args: SelectSubset<T, ConfigUpdateArgs<ExtArgs>>): Prisma__ConfigClient<$Result.GetResult<Prisma.$ConfigPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Configs.
     * @param {ConfigDeleteManyArgs} args - Arguments to filter Configs to delete.
     * @example
     * // Delete a few Configs
     * const { count } = await prisma.config.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConfigDeleteManyArgs>(args?: SelectSubset<T, ConfigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Configs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Configs
     * const config = await prisma.config.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConfigUpdateManyArgs>(args: SelectSubset<T, ConfigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Config.
     * @param {ConfigUpsertArgs} args - Arguments to update or create a Config.
     * @example
     * // Update or create a Config
     * const config = await prisma.config.upsert({
     *   create: {
     *     // ... data to create a Config
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Config we want to update
     *   }
     * })
     */
    upsert<T extends ConfigUpsertArgs>(args: SelectSubset<T, ConfigUpsertArgs<ExtArgs>>): Prisma__ConfigClient<$Result.GetResult<Prisma.$ConfigPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Configs that matches the filter.
     * @param {ConfigFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const config = await prisma.config.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: ConfigFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Config.
     * @param {ConfigAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const config = await prisma.config.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ConfigAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Configs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigCountArgs} args - Arguments to filter Configs to count.
     * @example
     * // Count the number of Configs
     * const count = await prisma.config.count({
     *   where: {
     *     // ... the filter for the Configs we want to count
     *   }
     * })
    **/
    count<T extends ConfigCountArgs>(
      args?: Subset<T, ConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Config.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConfigAggregateArgs>(args: Subset<T, ConfigAggregateArgs>): Prisma.PrismaPromise<GetConfigAggregateType<T>>

    /**
     * Group by Config.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConfigGroupByArgs['orderBy'] }
        : { orderBy?: ConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Config model
   */
  readonly fields: ConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Config.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConfigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    defaultIsoCurrency<T extends CurrencyIsoCodeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CurrencyIsoCodeDefaultArgs<ExtArgs>>): Prisma__CurrencyIsoCodeClient<$Result.GetResult<Prisma.$CurrencyIsoCodePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    defaultCurrency<T extends CurrencyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CurrencyDefaultArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Config model
   */ 
  interface ConfigFieldRefs {
    readonly id: FieldRef<"Config", 'String'>
    readonly defaultIsoCurrencyId: FieldRef<"Config", 'String'>
    readonly defaultCurrencyId: FieldRef<"Config", 'String'>
    readonly defaultTopLevelName: FieldRef<"Config", 'String'>
    readonly defaultTopLevelDescription: FieldRef<"Config", 'String'>
    readonly createdAt: FieldRef<"Config", 'DateTime'>
    readonly updatedAt: FieldRef<"Config", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Config findUnique
   */
  export type ConfigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Config
     */
    select?: ConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Config
     */
    omit?: ConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigInclude<ExtArgs> | null
    /**
     * Filter, which Config to fetch.
     */
    where: ConfigWhereUniqueInput
  }

  /**
   * Config findUniqueOrThrow
   */
  export type ConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Config
     */
    select?: ConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Config
     */
    omit?: ConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigInclude<ExtArgs> | null
    /**
     * Filter, which Config to fetch.
     */
    where: ConfigWhereUniqueInput
  }

  /**
   * Config findFirst
   */
  export type ConfigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Config
     */
    select?: ConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Config
     */
    omit?: ConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigInclude<ExtArgs> | null
    /**
     * Filter, which Config to fetch.
     */
    where?: ConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Configs to fetch.
     */
    orderBy?: ConfigOrderByWithRelationInput | ConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Configs.
     */
    cursor?: ConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Configs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Configs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Configs.
     */
    distinct?: ConfigScalarFieldEnum | ConfigScalarFieldEnum[]
  }

  /**
   * Config findFirstOrThrow
   */
  export type ConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Config
     */
    select?: ConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Config
     */
    omit?: ConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigInclude<ExtArgs> | null
    /**
     * Filter, which Config to fetch.
     */
    where?: ConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Configs to fetch.
     */
    orderBy?: ConfigOrderByWithRelationInput | ConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Configs.
     */
    cursor?: ConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Configs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Configs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Configs.
     */
    distinct?: ConfigScalarFieldEnum | ConfigScalarFieldEnum[]
  }

  /**
   * Config findMany
   */
  export type ConfigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Config
     */
    select?: ConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Config
     */
    omit?: ConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigInclude<ExtArgs> | null
    /**
     * Filter, which Configs to fetch.
     */
    where?: ConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Configs to fetch.
     */
    orderBy?: ConfigOrderByWithRelationInput | ConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Configs.
     */
    cursor?: ConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Configs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Configs.
     */
    skip?: number
    distinct?: ConfigScalarFieldEnum | ConfigScalarFieldEnum[]
  }

  /**
   * Config create
   */
  export type ConfigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Config
     */
    select?: ConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Config
     */
    omit?: ConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigInclude<ExtArgs> | null
    /**
     * The data needed to create a Config.
     */
    data: XOR<ConfigCreateInput, ConfigUncheckedCreateInput>
  }

  /**
   * Config createMany
   */
  export type ConfigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Configs.
     */
    data: ConfigCreateManyInput | ConfigCreateManyInput[]
  }

  /**
   * Config update
   */
  export type ConfigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Config
     */
    select?: ConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Config
     */
    omit?: ConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigInclude<ExtArgs> | null
    /**
     * The data needed to update a Config.
     */
    data: XOR<ConfigUpdateInput, ConfigUncheckedUpdateInput>
    /**
     * Choose, which Config to update.
     */
    where: ConfigWhereUniqueInput
  }

  /**
   * Config updateMany
   */
  export type ConfigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Configs.
     */
    data: XOR<ConfigUpdateManyMutationInput, ConfigUncheckedUpdateManyInput>
    /**
     * Filter which Configs to update
     */
    where?: ConfigWhereInput
    /**
     * Limit how many Configs to update.
     */
    limit?: number
  }

  /**
   * Config upsert
   */
  export type ConfigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Config
     */
    select?: ConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Config
     */
    omit?: ConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigInclude<ExtArgs> | null
    /**
     * The filter to search for the Config to update in case it exists.
     */
    where: ConfigWhereUniqueInput
    /**
     * In case the Config found by the `where` argument doesn't exist, create a new Config with this data.
     */
    create: XOR<ConfigCreateInput, ConfigUncheckedCreateInput>
    /**
     * In case the Config was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConfigUpdateInput, ConfigUncheckedUpdateInput>
  }

  /**
   * Config delete
   */
  export type ConfigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Config
     */
    select?: ConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Config
     */
    omit?: ConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigInclude<ExtArgs> | null
    /**
     * Filter which Config to delete.
     */
    where: ConfigWhereUniqueInput
  }

  /**
   * Config deleteMany
   */
  export type ConfigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Configs to delete
     */
    where?: ConfigWhereInput
    /**
     * Limit how many Configs to delete.
     */
    limit?: number
  }

  /**
   * Config findRaw
   */
  export type ConfigFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Config aggregateRaw
   */
  export type ConfigAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Config without action
   */
  export type ConfigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Config
     */
    select?: ConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Config
     */
    omit?: ConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigInclude<ExtArgs> | null
  }


  /**
   * Model Country
   */

  export type AggregateCountry = {
    _count: CountryCountAggregateOutputType | null
    _min: CountryMinAggregateOutputType | null
    _max: CountryMaxAggregateOutputType | null
  }

  export type CountryMinAggregateOutputType = {
    id: string | null
    name: string | null
    iso_3166_2_code: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CountryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    iso_3166_2_code: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CountryCountAggregateOutputType = {
    id: number
    name: number
    iso_3166_2_code: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CountryMinAggregateInputType = {
    id?: true
    name?: true
    iso_3166_2_code?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CountryMaxAggregateInputType = {
    id?: true
    name?: true
    iso_3166_2_code?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CountryCountAggregateInputType = {
    id?: true
    name?: true
    iso_3166_2_code?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CountryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Country to aggregate.
     */
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     */
    orderBy?: CountryOrderByWithRelationInput | CountryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Countries
    **/
    _count?: true | CountryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CountryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CountryMaxAggregateInputType
  }

  export type GetCountryAggregateType<T extends CountryAggregateArgs> = {
        [P in keyof T & keyof AggregateCountry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCountry[P]>
      : GetScalarType<T[P], AggregateCountry[P]>
  }




  export type CountryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CountryWhereInput
    orderBy?: CountryOrderByWithAggregationInput | CountryOrderByWithAggregationInput[]
    by: CountryScalarFieldEnum[] | CountryScalarFieldEnum
    having?: CountryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CountryCountAggregateInputType | true
    _min?: CountryMinAggregateInputType
    _max?: CountryMaxAggregateInputType
  }

  export type CountryGroupByOutputType = {
    id: string
    name: string
    iso_3166_2_code: string
    createdAt: Date | null
    updatedAt: Date | null
    _count: CountryCountAggregateOutputType | null
    _min: CountryMinAggregateOutputType | null
    _max: CountryMaxAggregateOutputType | null
  }

  type GetCountryGroupByPayload<T extends CountryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CountryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CountryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CountryGroupByOutputType[P]>
            : GetScalarType<T[P], CountryGroupByOutputType[P]>
        }
      >
    >


  export type CountrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    iso_3166_2_code?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Client?: boolean | Country$ClientArgs<ExtArgs>
    User?: boolean | Country$UserArgs<ExtArgs>
    _count?: boolean | CountryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["country"]>



  export type CountrySelectScalar = {
    id?: boolean
    name?: boolean
    iso_3166_2_code?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CountryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "iso_3166_2_code" | "createdAt" | "updatedAt", ExtArgs["result"]["country"]>
  export type CountryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Client?: boolean | Country$ClientArgs<ExtArgs>
    User?: boolean | Country$UserArgs<ExtArgs>
    _count?: boolean | CountryCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CountryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Country"
    objects: {
      Client: Prisma.$ClientPayload<ExtArgs>[]
      User: Prisma.$UserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      iso_3166_2_code: string
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["country"]>
    composites: {}
  }

  type CountryGetPayload<S extends boolean | null | undefined | CountryDefaultArgs> = $Result.GetResult<Prisma.$CountryPayload, S>

  type CountryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CountryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CountryCountAggregateInputType | true
    }

  export interface CountryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Country'], meta: { name: 'Country' } }
    /**
     * Find zero or one Country that matches the filter.
     * @param {CountryFindUniqueArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CountryFindUniqueArgs>(args: SelectSubset<T, CountryFindUniqueArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Country that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CountryFindUniqueOrThrowArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CountryFindUniqueOrThrowArgs>(args: SelectSubset<T, CountryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Country that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryFindFirstArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CountryFindFirstArgs>(args?: SelectSubset<T, CountryFindFirstArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Country that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryFindFirstOrThrowArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CountryFindFirstOrThrowArgs>(args?: SelectSubset<T, CountryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Countries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Countries
     * const countries = await prisma.country.findMany()
     * 
     * // Get first 10 Countries
     * const countries = await prisma.country.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const countryWithIdOnly = await prisma.country.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CountryFindManyArgs>(args?: SelectSubset<T, CountryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Country.
     * @param {CountryCreateArgs} args - Arguments to create a Country.
     * @example
     * // Create one Country
     * const Country = await prisma.country.create({
     *   data: {
     *     // ... data to create a Country
     *   }
     * })
     * 
     */
    create<T extends CountryCreateArgs>(args: SelectSubset<T, CountryCreateArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Countries.
     * @param {CountryCreateManyArgs} args - Arguments to create many Countries.
     * @example
     * // Create many Countries
     * const country = await prisma.country.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CountryCreateManyArgs>(args?: SelectSubset<T, CountryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Country.
     * @param {CountryDeleteArgs} args - Arguments to delete one Country.
     * @example
     * // Delete one Country
     * const Country = await prisma.country.delete({
     *   where: {
     *     // ... filter to delete one Country
     *   }
     * })
     * 
     */
    delete<T extends CountryDeleteArgs>(args: SelectSubset<T, CountryDeleteArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Country.
     * @param {CountryUpdateArgs} args - Arguments to update one Country.
     * @example
     * // Update one Country
     * const country = await prisma.country.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CountryUpdateArgs>(args: SelectSubset<T, CountryUpdateArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Countries.
     * @param {CountryDeleteManyArgs} args - Arguments to filter Countries to delete.
     * @example
     * // Delete a few Countries
     * const { count } = await prisma.country.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CountryDeleteManyArgs>(args?: SelectSubset<T, CountryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Countries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Countries
     * const country = await prisma.country.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CountryUpdateManyArgs>(args: SelectSubset<T, CountryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Country.
     * @param {CountryUpsertArgs} args - Arguments to update or create a Country.
     * @example
     * // Update or create a Country
     * const country = await prisma.country.upsert({
     *   create: {
     *     // ... data to create a Country
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Country we want to update
     *   }
     * })
     */
    upsert<T extends CountryUpsertArgs>(args: SelectSubset<T, CountryUpsertArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Countries that matches the filter.
     * @param {CountryFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const country = await prisma.country.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: CountryFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Country.
     * @param {CountryAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const country = await prisma.country.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: CountryAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Countries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryCountArgs} args - Arguments to filter Countries to count.
     * @example
     * // Count the number of Countries
     * const count = await prisma.country.count({
     *   where: {
     *     // ... the filter for the Countries we want to count
     *   }
     * })
    **/
    count<T extends CountryCountArgs>(
      args?: Subset<T, CountryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CountryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Country.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CountryAggregateArgs>(args: Subset<T, CountryAggregateArgs>): Prisma.PrismaPromise<GetCountryAggregateType<T>>

    /**
     * Group by Country.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CountryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CountryGroupByArgs['orderBy'] }
        : { orderBy?: CountryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CountryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCountryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Country model
   */
  readonly fields: CountryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Country.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CountryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Client<T extends Country$ClientArgs<ExtArgs> = {}>(args?: Subset<T, Country$ClientArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    User<T extends Country$UserArgs<ExtArgs> = {}>(args?: Subset<T, Country$UserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Country model
   */ 
  interface CountryFieldRefs {
    readonly id: FieldRef<"Country", 'String'>
    readonly name: FieldRef<"Country", 'String'>
    readonly iso_3166_2_code: FieldRef<"Country", 'String'>
    readonly createdAt: FieldRef<"Country", 'DateTime'>
    readonly updatedAt: FieldRef<"Country", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Country findUnique
   */
  export type CountryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter, which Country to fetch.
     */
    where: CountryWhereUniqueInput
  }

  /**
   * Country findUniqueOrThrow
   */
  export type CountryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter, which Country to fetch.
     */
    where: CountryWhereUniqueInput
  }

  /**
   * Country findFirst
   */
  export type CountryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter, which Country to fetch.
     */
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     */
    orderBy?: CountryOrderByWithRelationInput | CountryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Countries.
     */
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Countries.
     */
    distinct?: CountryScalarFieldEnum | CountryScalarFieldEnum[]
  }

  /**
   * Country findFirstOrThrow
   */
  export type CountryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter, which Country to fetch.
     */
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     */
    orderBy?: CountryOrderByWithRelationInput | CountryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Countries.
     */
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Countries.
     */
    distinct?: CountryScalarFieldEnum | CountryScalarFieldEnum[]
  }

  /**
   * Country findMany
   */
  export type CountryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter, which Countries to fetch.
     */
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     */
    orderBy?: CountryOrderByWithRelationInput | CountryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Countries.
     */
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     */
    skip?: number
    distinct?: CountryScalarFieldEnum | CountryScalarFieldEnum[]
  }

  /**
   * Country create
   */
  export type CountryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * The data needed to create a Country.
     */
    data: XOR<CountryCreateInput, CountryUncheckedCreateInput>
  }

  /**
   * Country createMany
   */
  export type CountryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Countries.
     */
    data: CountryCreateManyInput | CountryCreateManyInput[]
  }

  /**
   * Country update
   */
  export type CountryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * The data needed to update a Country.
     */
    data: XOR<CountryUpdateInput, CountryUncheckedUpdateInput>
    /**
     * Choose, which Country to update.
     */
    where: CountryWhereUniqueInput
  }

  /**
   * Country updateMany
   */
  export type CountryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Countries.
     */
    data: XOR<CountryUpdateManyMutationInput, CountryUncheckedUpdateManyInput>
    /**
     * Filter which Countries to update
     */
    where?: CountryWhereInput
    /**
     * Limit how many Countries to update.
     */
    limit?: number
  }

  /**
   * Country upsert
   */
  export type CountryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * The filter to search for the Country to update in case it exists.
     */
    where: CountryWhereUniqueInput
    /**
     * In case the Country found by the `where` argument doesn't exist, create a new Country with this data.
     */
    create: XOR<CountryCreateInput, CountryUncheckedCreateInput>
    /**
     * In case the Country was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CountryUpdateInput, CountryUncheckedUpdateInput>
  }

  /**
   * Country delete
   */
  export type CountryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter which Country to delete.
     */
    where: CountryWhereUniqueInput
  }

  /**
   * Country deleteMany
   */
  export type CountryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Countries to delete
     */
    where?: CountryWhereInput
    /**
     * Limit how many Countries to delete.
     */
    limit?: number
  }

  /**
   * Country findRaw
   */
  export type CountryFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Country aggregateRaw
   */
  export type CountryAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Country.Client
   */
  export type Country$ClientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    where?: ClientWhereInput
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    cursor?: ClientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Country.User
   */
  export type Country$UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Country without action
   */
  export type CountryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    authProviderId: string | null
    role: $Enums.userRole | null
    countryId: string | null
    clientId: string | null
    defaultInstance: string | null
    selectedInstance: string | null
    lastLogin: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    authProviderId: string | null
    role: $Enums.userRole | null
    countryId: string | null
    clientId: string | null
    defaultInstance: string | null
    selectedInstance: string | null
    lastLogin: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    firstName: number
    lastName: number
    email: number
    authProviderId: number
    role: number
    countryId: number
    permissions: number
    clientId: number
    defaultInstance: number
    selectedInstance: number
    lastLogin: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    authProviderId?: true
    role?: true
    countryId?: true
    clientId?: true
    defaultInstance?: true
    selectedInstance?: true
    lastLogin?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    authProviderId?: true
    role?: true
    countryId?: true
    clientId?: true
    defaultInstance?: true
    selectedInstance?: true
    lastLogin?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    authProviderId?: true
    role?: true
    countryId?: true
    permissions?: true
    clientId?: true
    defaultInstance?: true
    selectedInstance?: true
    lastLogin?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    firstName: string
    lastName: string
    email: string
    authProviderId: string
    role: $Enums.userRole
    countryId: string | null
    permissions: string[]
    clientId: string
    defaultInstance: string
    selectedInstance: string | null
    lastLogin: Date
    createdAt: Date | null
    updatedAt: Date | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    authProviderId?: boolean
    role?: boolean
    countryId?: boolean
    permissions?: boolean
    clientId?: boolean
    defaultInstance?: boolean
    selectedInstance?: boolean
    lastLogin?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    country?: boolean | User$countryArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>



  export type UserSelectScalar = {
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    authProviderId?: boolean
    role?: boolean
    countryId?: boolean
    permissions?: boolean
    clientId?: boolean
    defaultInstance?: boolean
    selectedInstance?: boolean
    lastLogin?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "firstName" | "lastName" | "email" | "authProviderId" | "role" | "countryId" | "permissions" | "clientId" | "defaultInstance" | "selectedInstance" | "lastLogin" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    country?: boolean | User$countryArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      country: Prisma.$CountryPayload<ExtArgs> | null
      client: Prisma.$ClientPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      firstName: string
      lastName: string
      email: string
      authProviderId: string
      role: $Enums.userRole
      countryId: string | null
      permissions: string[]
      clientId: string
      defaultInstance: string
      selectedInstance: string | null
      lastLogin: Date
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Users that matches the filter.
     * @param {UserFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const user = await prisma.user.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: UserFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a User.
     * @param {UserAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const user = await prisma.user.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: UserAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    country<T extends User$countryArgs<ExtArgs> = {}>(args?: Subset<T, User$countryArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    client<T extends ClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientDefaultArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly authProviderId: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'userRole'>
    readonly countryId: FieldRef<"User", 'String'>
    readonly permissions: FieldRef<"User", 'String[]'>
    readonly clientId: FieldRef<"User", 'String'>
    readonly defaultInstance: FieldRef<"User", 'String'>
    readonly selectedInstance: FieldRef<"User", 'String'>
    readonly lastLogin: FieldRef<"User", 'DateTime'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User findRaw
   */
  export type UserFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * User aggregateRaw
   */
  export type UserAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * User.country
   */
  export type User$countryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    where?: CountryWhereInput
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Client
   */

  export type AggregateClient = {
    _count: ClientCountAggregateOutputType | null
    _min: ClientMinAggregateOutputType | null
    _max: ClientMaxAggregateOutputType | null
  }

  export type ClientMinAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    status: $Enums.clientStatus | null
    countryId: string | null
    contactId: string | null
    lastLogin: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClientMaxAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    status: $Enums.clientStatus | null
    countryId: string | null
    contactId: string | null
    lastLogin: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClientCountAggregateOutputType = {
    id: number
    name: number
    code: number
    status: number
    countryId: number
    contactId: number
    lastLogin: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ClientMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
    status?: true
    countryId?: true
    contactId?: true
    lastLogin?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClientMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
    status?: true
    countryId?: true
    contactId?: true
    lastLogin?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClientCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    status?: true
    countryId?: true
    contactId?: true
    lastLogin?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ClientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Client to aggregate.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Clients
    **/
    _count?: true | ClientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientMaxAggregateInputType
  }

  export type GetClientAggregateType<T extends ClientAggregateArgs> = {
        [P in keyof T & keyof AggregateClient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClient[P]>
      : GetScalarType<T[P], AggregateClient[P]>
  }




  export type ClientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientWhereInput
    orderBy?: ClientOrderByWithAggregationInput | ClientOrderByWithAggregationInput[]
    by: ClientScalarFieldEnum[] | ClientScalarFieldEnum
    having?: ClientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientCountAggregateInputType | true
    _min?: ClientMinAggregateInputType
    _max?: ClientMaxAggregateInputType
  }

  export type ClientGroupByOutputType = {
    id: string
    name: string
    code: string
    status: $Enums.clientStatus
    countryId: string | null
    contactId: string | null
    lastLogin: Date
    createdAt: Date | null
    updatedAt: Date | null
    _count: ClientCountAggregateOutputType | null
    _min: ClientMinAggregateOutputType | null
    _max: ClientMaxAggregateOutputType | null
  }

  type GetClientGroupByPayload<T extends ClientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientGroupByOutputType[P]>
            : GetScalarType<T[P], ClientGroupByOutputType[P]>
        }
      >
    >


  export type ClientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    status?: boolean
    address?: boolean | addressTypeDefaultArgs<ExtArgs>
    countryId?: boolean
    contactId?: boolean
    lastLogin?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    country?: boolean | Client$countryArgs<ExtArgs>
    users?: boolean | Client$usersArgs<ExtArgs>
    instances?: boolean | Client$instancesArgs<ExtArgs>
    Permission?: boolean | Client$PermissionArgs<ExtArgs>
    _count?: boolean | ClientCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["client"]>



  export type ClientSelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
    status?: boolean
    countryId?: boolean
    contactId?: boolean
    lastLogin?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ClientOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "code" | "status" | "address" | "countryId" | "contactId" | "lastLogin" | "createdAt" | "updatedAt", ExtArgs["result"]["client"]>
  export type ClientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    country?: boolean | Client$countryArgs<ExtArgs>
    users?: boolean | Client$usersArgs<ExtArgs>
    instances?: boolean | Client$instancesArgs<ExtArgs>
    Permission?: boolean | Client$PermissionArgs<ExtArgs>
    _count?: boolean | ClientCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ClientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Client"
    objects: {
      country: Prisma.$CountryPayload<ExtArgs> | null
      users: Prisma.$UserPayload<ExtArgs>[]
      instances: Prisma.$InstancePayload<ExtArgs>[]
      Permission: Prisma.$PermissionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      code: string
      status: $Enums.clientStatus
      countryId: string | null
      contactId: string | null
      lastLogin: Date
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["client"]>
    composites: {
      address: Prisma.$addressTypePayload | null
    }
  }

  type ClientGetPayload<S extends boolean | null | undefined | ClientDefaultArgs> = $Result.GetResult<Prisma.$ClientPayload, S>

  type ClientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClientFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClientCountAggregateInputType | true
    }

  export interface ClientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Client'], meta: { name: 'Client' } }
    /**
     * Find zero or one Client that matches the filter.
     * @param {ClientFindUniqueArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClientFindUniqueArgs>(args: SelectSubset<T, ClientFindUniqueArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Client that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClientFindUniqueOrThrowArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClientFindUniqueOrThrowArgs>(args: SelectSubset<T, ClientFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Client that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindFirstArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClientFindFirstArgs>(args?: SelectSubset<T, ClientFindFirstArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Client that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindFirstOrThrowArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClientFindFirstOrThrowArgs>(args?: SelectSubset<T, ClientFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Clients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clients
     * const clients = await prisma.client.findMany()
     * 
     * // Get first 10 Clients
     * const clients = await prisma.client.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientWithIdOnly = await prisma.client.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClientFindManyArgs>(args?: SelectSubset<T, ClientFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Client.
     * @param {ClientCreateArgs} args - Arguments to create a Client.
     * @example
     * // Create one Client
     * const Client = await prisma.client.create({
     *   data: {
     *     // ... data to create a Client
     *   }
     * })
     * 
     */
    create<T extends ClientCreateArgs>(args: SelectSubset<T, ClientCreateArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Clients.
     * @param {ClientCreateManyArgs} args - Arguments to create many Clients.
     * @example
     * // Create many Clients
     * const client = await prisma.client.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClientCreateManyArgs>(args?: SelectSubset<T, ClientCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Client.
     * @param {ClientDeleteArgs} args - Arguments to delete one Client.
     * @example
     * // Delete one Client
     * const Client = await prisma.client.delete({
     *   where: {
     *     // ... filter to delete one Client
     *   }
     * })
     * 
     */
    delete<T extends ClientDeleteArgs>(args: SelectSubset<T, ClientDeleteArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Client.
     * @param {ClientUpdateArgs} args - Arguments to update one Client.
     * @example
     * // Update one Client
     * const client = await prisma.client.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClientUpdateArgs>(args: SelectSubset<T, ClientUpdateArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Clients.
     * @param {ClientDeleteManyArgs} args - Arguments to filter Clients to delete.
     * @example
     * // Delete a few Clients
     * const { count } = await prisma.client.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClientDeleteManyArgs>(args?: SelectSubset<T, ClientDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clients
     * const client = await prisma.client.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClientUpdateManyArgs>(args: SelectSubset<T, ClientUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Client.
     * @param {ClientUpsertArgs} args - Arguments to update or create a Client.
     * @example
     * // Update or create a Client
     * const client = await prisma.client.upsert({
     *   create: {
     *     // ... data to create a Client
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Client we want to update
     *   }
     * })
     */
    upsert<T extends ClientUpsertArgs>(args: SelectSubset<T, ClientUpsertArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Clients that matches the filter.
     * @param {ClientFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const client = await prisma.client.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: ClientFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Client.
     * @param {ClientAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const client = await prisma.client.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ClientAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientCountArgs} args - Arguments to filter Clients to count.
     * @example
     * // Count the number of Clients
     * const count = await prisma.client.count({
     *   where: {
     *     // ... the filter for the Clients we want to count
     *   }
     * })
    **/
    count<T extends ClientCountArgs>(
      args?: Subset<T, ClientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientAggregateArgs>(args: Subset<T, ClientAggregateArgs>): Prisma.PrismaPromise<GetClientAggregateType<T>>

    /**
     * Group by Client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientGroupByArgs['orderBy'] }
        : { orderBy?: ClientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Client model
   */
  readonly fields: ClientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Client.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    country<T extends Client$countryArgs<ExtArgs> = {}>(args?: Subset<T, Client$countryArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    users<T extends Client$usersArgs<ExtArgs> = {}>(args?: Subset<T, Client$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    instances<T extends Client$instancesArgs<ExtArgs> = {}>(args?: Subset<T, Client$instancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstancePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Permission<T extends Client$PermissionArgs<ExtArgs> = {}>(args?: Subset<T, Client$PermissionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Client model
   */ 
  interface ClientFieldRefs {
    readonly id: FieldRef<"Client", 'String'>
    readonly name: FieldRef<"Client", 'String'>
    readonly code: FieldRef<"Client", 'String'>
    readonly status: FieldRef<"Client", 'clientStatus'>
    readonly countryId: FieldRef<"Client", 'String'>
    readonly contactId: FieldRef<"Client", 'String'>
    readonly lastLogin: FieldRef<"Client", 'DateTime'>
    readonly createdAt: FieldRef<"Client", 'DateTime'>
    readonly updatedAt: FieldRef<"Client", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Client findUnique
   */
  export type ClientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client findUniqueOrThrow
   */
  export type ClientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client findFirst
   */
  export type ClientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clients.
     */
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client findFirstOrThrow
   */
  export type ClientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clients.
     */
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client findMany
   */
  export type ClientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Clients to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client create
   */
  export type ClientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The data needed to create a Client.
     */
    data: XOR<ClientCreateInput, ClientUncheckedCreateInput>
  }

  /**
   * Client createMany
   */
  export type ClientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Clients.
     */
    data: ClientCreateManyInput | ClientCreateManyInput[]
  }

  /**
   * Client update
   */
  export type ClientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The data needed to update a Client.
     */
    data: XOR<ClientUpdateInput, ClientUncheckedUpdateInput>
    /**
     * Choose, which Client to update.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client updateMany
   */
  export type ClientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Clients.
     */
    data: XOR<ClientUpdateManyMutationInput, ClientUncheckedUpdateManyInput>
    /**
     * Filter which Clients to update
     */
    where?: ClientWhereInput
    /**
     * Limit how many Clients to update.
     */
    limit?: number
  }

  /**
   * Client upsert
   */
  export type ClientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The filter to search for the Client to update in case it exists.
     */
    where: ClientWhereUniqueInput
    /**
     * In case the Client found by the `where` argument doesn't exist, create a new Client with this data.
     */
    create: XOR<ClientCreateInput, ClientUncheckedCreateInput>
    /**
     * In case the Client was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientUpdateInput, ClientUncheckedUpdateInput>
  }

  /**
   * Client delete
   */
  export type ClientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter which Client to delete.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client deleteMany
   */
  export type ClientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Clients to delete
     */
    where?: ClientWhereInput
    /**
     * Limit how many Clients to delete.
     */
    limit?: number
  }

  /**
   * Client findRaw
   */
  export type ClientFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Client aggregateRaw
   */
  export type ClientAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Client.country
   */
  export type Client$countryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    where?: CountryWhereInput
  }

  /**
   * Client.users
   */
  export type Client$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Client.instances
   */
  export type Client$instancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instance
     */
    select?: InstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Instance
     */
    omit?: InstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstanceInclude<ExtArgs> | null
    where?: InstanceWhereInput
    orderBy?: InstanceOrderByWithRelationInput | InstanceOrderByWithRelationInput[]
    cursor?: InstanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InstanceScalarFieldEnum | InstanceScalarFieldEnum[]
  }

  /**
   * Client.Permission
   */
  export type Client$PermissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    where?: PermissionWhereInput
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    cursor?: PermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Client without action
   */
  export type ClientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
  }


  /**
   * Model Permission
   */

  export type AggregatePermission = {
    _count: PermissionCountAggregateOutputType | null
    _min: PermissionMinAggregateOutputType | null
    _max: PermissionMaxAggregateOutputType | null
  }

  export type PermissionMinAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    clientId: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PermissionMaxAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    clientId: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PermissionCountAggregateOutputType = {
    id: number
    name: number
    code: number
    clientId: number
    actions: number
    subjects: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PermissionMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
    clientId?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PermissionMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
    clientId?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PermissionCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    clientId?: true
    actions?: true
    subjects?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Permission to aggregate.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Permissions
    **/
    _count?: true | PermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PermissionMaxAggregateInputType
  }

  export type GetPermissionAggregateType<T extends PermissionAggregateArgs> = {
        [P in keyof T & keyof AggregatePermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePermission[P]>
      : GetScalarType<T[P], AggregatePermission[P]>
  }




  export type PermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PermissionWhereInput
    orderBy?: PermissionOrderByWithAggregationInput | PermissionOrderByWithAggregationInput[]
    by: PermissionScalarFieldEnum[] | PermissionScalarFieldEnum
    having?: PermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PermissionCountAggregateInputType | true
    _min?: PermissionMinAggregateInputType
    _max?: PermissionMaxAggregateInputType
  }

  export type PermissionGroupByOutputType = {
    id: string
    name: string
    code: string
    clientId: string
    actions: string[]
    subjects: string[]
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    _count: PermissionCountAggregateOutputType | null
    _min: PermissionMinAggregateOutputType | null
    _max: PermissionMaxAggregateOutputType | null
  }

  type GetPermissionGroupByPayload<T extends PermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PermissionGroupByOutputType[P]>
            : GetScalarType<T[P], PermissionGroupByOutputType[P]>
        }
      >
    >


  export type PermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    clientId?: boolean
    actions?: boolean
    subjects?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["permission"]>



  export type PermissionSelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
    clientId?: boolean
    actions?: boolean
    subjects?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PermissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "code" | "clientId" | "actions" | "subjects" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["permission"]>
  export type PermissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }

  export type $PermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Permission"
    objects: {
      client: Prisma.$ClientPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      code: string
      clientId: string
      actions: string[]
      subjects: string[]
      description: string | null
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["permission"]>
    composites: {}
  }

  type PermissionGetPayload<S extends boolean | null | undefined | PermissionDefaultArgs> = $Result.GetResult<Prisma.$PermissionPayload, S>

  type PermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PermissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PermissionCountAggregateInputType | true
    }

  export interface PermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Permission'], meta: { name: 'Permission' } }
    /**
     * Find zero or one Permission that matches the filter.
     * @param {PermissionFindUniqueArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PermissionFindUniqueArgs>(args: SelectSubset<T, PermissionFindUniqueArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Permission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PermissionFindUniqueOrThrowArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PermissionFindUniqueOrThrowArgs>(args: SelectSubset<T, PermissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Permission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindFirstArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PermissionFindFirstArgs>(args?: SelectSubset<T, PermissionFindFirstArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Permission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindFirstOrThrowArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PermissionFindFirstOrThrowArgs>(args?: SelectSubset<T, PermissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Permissions
     * const permissions = await prisma.permission.findMany()
     * 
     * // Get first 10 Permissions
     * const permissions = await prisma.permission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const permissionWithIdOnly = await prisma.permission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PermissionFindManyArgs>(args?: SelectSubset<T, PermissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Permission.
     * @param {PermissionCreateArgs} args - Arguments to create a Permission.
     * @example
     * // Create one Permission
     * const Permission = await prisma.permission.create({
     *   data: {
     *     // ... data to create a Permission
     *   }
     * })
     * 
     */
    create<T extends PermissionCreateArgs>(args: SelectSubset<T, PermissionCreateArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Permissions.
     * @param {PermissionCreateManyArgs} args - Arguments to create many Permissions.
     * @example
     * // Create many Permissions
     * const permission = await prisma.permission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PermissionCreateManyArgs>(args?: SelectSubset<T, PermissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Permission.
     * @param {PermissionDeleteArgs} args - Arguments to delete one Permission.
     * @example
     * // Delete one Permission
     * const Permission = await prisma.permission.delete({
     *   where: {
     *     // ... filter to delete one Permission
     *   }
     * })
     * 
     */
    delete<T extends PermissionDeleteArgs>(args: SelectSubset<T, PermissionDeleteArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Permission.
     * @param {PermissionUpdateArgs} args - Arguments to update one Permission.
     * @example
     * // Update one Permission
     * const permission = await prisma.permission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PermissionUpdateArgs>(args: SelectSubset<T, PermissionUpdateArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Permissions.
     * @param {PermissionDeleteManyArgs} args - Arguments to filter Permissions to delete.
     * @example
     * // Delete a few Permissions
     * const { count } = await prisma.permission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PermissionDeleteManyArgs>(args?: SelectSubset<T, PermissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Permissions
     * const permission = await prisma.permission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PermissionUpdateManyArgs>(args: SelectSubset<T, PermissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Permission.
     * @param {PermissionUpsertArgs} args - Arguments to update or create a Permission.
     * @example
     * // Update or create a Permission
     * const permission = await prisma.permission.upsert({
     *   create: {
     *     // ... data to create a Permission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Permission we want to update
     *   }
     * })
     */
    upsert<T extends PermissionUpsertArgs>(args: SelectSubset<T, PermissionUpsertArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Permissions that matches the filter.
     * @param {PermissionFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const permission = await prisma.permission.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: PermissionFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Permission.
     * @param {PermissionAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const permission = await prisma.permission.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: PermissionAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionCountArgs} args - Arguments to filter Permissions to count.
     * @example
     * // Count the number of Permissions
     * const count = await prisma.permission.count({
     *   where: {
     *     // ... the filter for the Permissions we want to count
     *   }
     * })
    **/
    count<T extends PermissionCountArgs>(
      args?: Subset<T, PermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PermissionAggregateArgs>(args: Subset<T, PermissionAggregateArgs>): Prisma.PrismaPromise<GetPermissionAggregateType<T>>

    /**
     * Group by Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PermissionGroupByArgs['orderBy'] }
        : { orderBy?: PermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Permission model
   */
  readonly fields: PermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Permission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends ClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientDefaultArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Permission model
   */ 
  interface PermissionFieldRefs {
    readonly id: FieldRef<"Permission", 'String'>
    readonly name: FieldRef<"Permission", 'String'>
    readonly code: FieldRef<"Permission", 'String'>
    readonly clientId: FieldRef<"Permission", 'String'>
    readonly actions: FieldRef<"Permission", 'String[]'>
    readonly subjects: FieldRef<"Permission", 'String[]'>
    readonly description: FieldRef<"Permission", 'String'>
    readonly createdAt: FieldRef<"Permission", 'DateTime'>
    readonly updatedAt: FieldRef<"Permission", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Permission findUnique
   */
  export type PermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission findUniqueOrThrow
   */
  export type PermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission findFirst
   */
  export type PermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permissions.
     */
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission findFirstOrThrow
   */
  export type PermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permissions.
     */
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission findMany
   */
  export type PermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permissions to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission create
   */
  export type PermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a Permission.
     */
    data: XOR<PermissionCreateInput, PermissionUncheckedCreateInput>
  }

  /**
   * Permission createMany
   */
  export type PermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Permissions.
     */
    data: PermissionCreateManyInput | PermissionCreateManyInput[]
  }

  /**
   * Permission update
   */
  export type PermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a Permission.
     */
    data: XOR<PermissionUpdateInput, PermissionUncheckedUpdateInput>
    /**
     * Choose, which Permission to update.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission updateMany
   */
  export type PermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Permissions.
     */
    data: XOR<PermissionUpdateManyMutationInput, PermissionUncheckedUpdateManyInput>
    /**
     * Filter which Permissions to update
     */
    where?: PermissionWhereInput
    /**
     * Limit how many Permissions to update.
     */
    limit?: number
  }

  /**
   * Permission upsert
   */
  export type PermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the Permission to update in case it exists.
     */
    where: PermissionWhereUniqueInput
    /**
     * In case the Permission found by the `where` argument doesn't exist, create a new Permission with this data.
     */
    create: XOR<PermissionCreateInput, PermissionUncheckedCreateInput>
    /**
     * In case the Permission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PermissionUpdateInput, PermissionUncheckedUpdateInput>
  }

  /**
   * Permission delete
   */
  export type PermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter which Permission to delete.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission deleteMany
   */
  export type PermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Permissions to delete
     */
    where?: PermissionWhereInput
    /**
     * Limit how many Permissions to delete.
     */
    limit?: number
  }

  /**
   * Permission findRaw
   */
  export type PermissionFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Permission aggregateRaw
   */
  export type PermissionAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Permission without action
   */
  export type PermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
  }


  /**
   * Model Instance
   */

  export type AggregateInstance = {
    _count: InstanceCountAggregateOutputType | null
    _min: InstanceMinAggregateOutputType | null
    _max: InstanceMaxAggregateOutputType | null
  }

  export type InstanceMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    clientId: string | null
    description: string | null
    status: $Enums.instanceStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InstanceMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    clientId: string | null
    description: string | null
    status: $Enums.instanceStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InstanceCountAggregateOutputType = {
    id: number
    code: number
    name: number
    clientId: number
    description: number
    status: number
    userIds: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InstanceMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    clientId?: true
    description?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InstanceMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    clientId?: true
    description?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InstanceCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    clientId?: true
    description?: true
    status?: true
    userIds?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InstanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Instance to aggregate.
     */
    where?: InstanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Instances to fetch.
     */
    orderBy?: InstanceOrderByWithRelationInput | InstanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InstanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Instances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Instances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Instances
    **/
    _count?: true | InstanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InstanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InstanceMaxAggregateInputType
  }

  export type GetInstanceAggregateType<T extends InstanceAggregateArgs> = {
        [P in keyof T & keyof AggregateInstance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInstance[P]>
      : GetScalarType<T[P], AggregateInstance[P]>
  }




  export type InstanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstanceWhereInput
    orderBy?: InstanceOrderByWithAggregationInput | InstanceOrderByWithAggregationInput[]
    by: InstanceScalarFieldEnum[] | InstanceScalarFieldEnum
    having?: InstanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InstanceCountAggregateInputType | true
    _min?: InstanceMinAggregateInputType
    _max?: InstanceMaxAggregateInputType
  }

  export type InstanceGroupByOutputType = {
    id: string
    code: string
    name: string
    clientId: string
    description: string | null
    status: $Enums.instanceStatus
    userIds: string[]
    createdAt: Date | null
    updatedAt: Date | null
    _count: InstanceCountAggregateOutputType | null
    _min: InstanceMinAggregateOutputType | null
    _max: InstanceMaxAggregateOutputType | null
  }

  type GetInstanceGroupByPayload<T extends InstanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InstanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InstanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InstanceGroupByOutputType[P]>
            : GetScalarType<T[P], InstanceGroupByOutputType[P]>
        }
      >
    >


  export type InstanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    clientId?: boolean
    description?: boolean
    status?: boolean
    userIds?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
    levels?: boolean | Instance$levelsArgs<ExtArgs>
    versions?: boolean | Instance$versionsArgs<ExtArgs>
    currencies?: boolean | Instance$currenciesArgs<ExtArgs>
    accounts?: boolean | Instance$accountsArgs<ExtArgs>
    models?: boolean | Instance$modelsArgs<ExtArgs>
    dimensions?: boolean | Instance$dimensionsArgs<ExtArgs>
    dimensionValues?: boolean | Instance$dimensionValuesArgs<ExtArgs>
    levelAttributes?: boolean | Instance$levelAttributesArgs<ExtArgs>
    dimensionValueAttributes?: boolean | Instance$dimensionValueAttributesArgs<ExtArgs>
    accountAttributes?: boolean | Instance$accountAttributesArgs<ExtArgs>
    levelAttValues?: boolean | Instance$levelAttValuesArgs<ExtArgs>
    accountAttValues?: boolean | Instance$accountAttValuesArgs<ExtArgs>
    dimensionValueAttributeValues?: boolean | Instance$dimensionValueAttributeValuesArgs<ExtArgs>
    modelData?: boolean | Instance$modelDataArgs<ExtArgs>
    modelDataCalculations?: boolean | Instance$modelDataCalculationsArgs<ExtArgs>
    modelAccounts?: boolean | Instance$modelAccountsArgs<ExtArgs>
    tables?: boolean | Instance$tablesArgs<ExtArgs>
    tableData?: boolean | Instance$tableDataArgs<ExtArgs>
    _count?: boolean | InstanceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["instance"]>



  export type InstanceSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    clientId?: boolean
    description?: boolean
    status?: boolean
    userIds?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InstanceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "name" | "clientId" | "description" | "status" | "userIds" | "createdAt" | "updatedAt", ExtArgs["result"]["instance"]>
  export type InstanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
    levels?: boolean | Instance$levelsArgs<ExtArgs>
    versions?: boolean | Instance$versionsArgs<ExtArgs>
    currencies?: boolean | Instance$currenciesArgs<ExtArgs>
    accounts?: boolean | Instance$accountsArgs<ExtArgs>
    models?: boolean | Instance$modelsArgs<ExtArgs>
    dimensions?: boolean | Instance$dimensionsArgs<ExtArgs>
    dimensionValues?: boolean | Instance$dimensionValuesArgs<ExtArgs>
    levelAttributes?: boolean | Instance$levelAttributesArgs<ExtArgs>
    dimensionValueAttributes?: boolean | Instance$dimensionValueAttributesArgs<ExtArgs>
    accountAttributes?: boolean | Instance$accountAttributesArgs<ExtArgs>
    levelAttValues?: boolean | Instance$levelAttValuesArgs<ExtArgs>
    accountAttValues?: boolean | Instance$accountAttValuesArgs<ExtArgs>
    dimensionValueAttributeValues?: boolean | Instance$dimensionValueAttributeValuesArgs<ExtArgs>
    modelData?: boolean | Instance$modelDataArgs<ExtArgs>
    modelDataCalculations?: boolean | Instance$modelDataCalculationsArgs<ExtArgs>
    modelAccounts?: boolean | Instance$modelAccountsArgs<ExtArgs>
    tables?: boolean | Instance$tablesArgs<ExtArgs>
    tableData?: boolean | Instance$tableDataArgs<ExtArgs>
    _count?: boolean | InstanceCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $InstancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Instance"
    objects: {
      client: Prisma.$ClientPayload<ExtArgs>
      levels: Prisma.$LevelPayload<ExtArgs>[]
      versions: Prisma.$VersionPayload<ExtArgs>[]
      currencies: Prisma.$CurrencyPayload<ExtArgs>[]
      accounts: Prisma.$AccountPayload<ExtArgs>[]
      models: Prisma.$ModelPayload<ExtArgs>[]
      dimensions: Prisma.$DimensionPayload<ExtArgs>[]
      dimensionValues: Prisma.$DimensionValuePayload<ExtArgs>[]
      levelAttributes: Prisma.$LevelAttributePayload<ExtArgs>[]
      dimensionValueAttributes: Prisma.$DimensionValueAttributePayload<ExtArgs>[]
      accountAttributes: Prisma.$AccountAttributePayload<ExtArgs>[]
      levelAttValues: Prisma.$LevelAttributeValuePayload<ExtArgs>[]
      accountAttValues: Prisma.$AccountAttributeValuePayload<ExtArgs>[]
      dimensionValueAttributeValues: Prisma.$DimensionValueAttributeValuePayload<ExtArgs>[]
      modelData: Prisma.$ModelDataPayload<ExtArgs>[]
      modelDataCalculations: Prisma.$ModelDataCalculationsPayload<ExtArgs>[]
      modelAccounts: Prisma.$ModelAccountStructurePayload<ExtArgs>[]
      tables: Prisma.$TablePayload<ExtArgs>[]
      tableData: Prisma.$TableDataPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      name: string
      clientId: string
      description: string | null
      status: $Enums.instanceStatus
      userIds: string[]
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["instance"]>
    composites: {}
  }

  type InstanceGetPayload<S extends boolean | null | undefined | InstanceDefaultArgs> = $Result.GetResult<Prisma.$InstancePayload, S>

  type InstanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InstanceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InstanceCountAggregateInputType | true
    }

  export interface InstanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Instance'], meta: { name: 'Instance' } }
    /**
     * Find zero or one Instance that matches the filter.
     * @param {InstanceFindUniqueArgs} args - Arguments to find a Instance
     * @example
     * // Get one Instance
     * const instance = await prisma.instance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InstanceFindUniqueArgs>(args: SelectSubset<T, InstanceFindUniqueArgs<ExtArgs>>): Prisma__InstanceClient<$Result.GetResult<Prisma.$InstancePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Instance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InstanceFindUniqueOrThrowArgs} args - Arguments to find a Instance
     * @example
     * // Get one Instance
     * const instance = await prisma.instance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InstanceFindUniqueOrThrowArgs>(args: SelectSubset<T, InstanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InstanceClient<$Result.GetResult<Prisma.$InstancePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Instance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstanceFindFirstArgs} args - Arguments to find a Instance
     * @example
     * // Get one Instance
     * const instance = await prisma.instance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InstanceFindFirstArgs>(args?: SelectSubset<T, InstanceFindFirstArgs<ExtArgs>>): Prisma__InstanceClient<$Result.GetResult<Prisma.$InstancePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Instance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstanceFindFirstOrThrowArgs} args - Arguments to find a Instance
     * @example
     * // Get one Instance
     * const instance = await prisma.instance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InstanceFindFirstOrThrowArgs>(args?: SelectSubset<T, InstanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__InstanceClient<$Result.GetResult<Prisma.$InstancePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Instances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Instances
     * const instances = await prisma.instance.findMany()
     * 
     * // Get first 10 Instances
     * const instances = await prisma.instance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const instanceWithIdOnly = await prisma.instance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InstanceFindManyArgs>(args?: SelectSubset<T, InstanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstancePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Instance.
     * @param {InstanceCreateArgs} args - Arguments to create a Instance.
     * @example
     * // Create one Instance
     * const Instance = await prisma.instance.create({
     *   data: {
     *     // ... data to create a Instance
     *   }
     * })
     * 
     */
    create<T extends InstanceCreateArgs>(args: SelectSubset<T, InstanceCreateArgs<ExtArgs>>): Prisma__InstanceClient<$Result.GetResult<Prisma.$InstancePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Instances.
     * @param {InstanceCreateManyArgs} args - Arguments to create many Instances.
     * @example
     * // Create many Instances
     * const instance = await prisma.instance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InstanceCreateManyArgs>(args?: SelectSubset<T, InstanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Instance.
     * @param {InstanceDeleteArgs} args - Arguments to delete one Instance.
     * @example
     * // Delete one Instance
     * const Instance = await prisma.instance.delete({
     *   where: {
     *     // ... filter to delete one Instance
     *   }
     * })
     * 
     */
    delete<T extends InstanceDeleteArgs>(args: SelectSubset<T, InstanceDeleteArgs<ExtArgs>>): Prisma__InstanceClient<$Result.GetResult<Prisma.$InstancePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Instance.
     * @param {InstanceUpdateArgs} args - Arguments to update one Instance.
     * @example
     * // Update one Instance
     * const instance = await prisma.instance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InstanceUpdateArgs>(args: SelectSubset<T, InstanceUpdateArgs<ExtArgs>>): Prisma__InstanceClient<$Result.GetResult<Prisma.$InstancePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Instances.
     * @param {InstanceDeleteManyArgs} args - Arguments to filter Instances to delete.
     * @example
     * // Delete a few Instances
     * const { count } = await prisma.instance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InstanceDeleteManyArgs>(args?: SelectSubset<T, InstanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Instances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Instances
     * const instance = await prisma.instance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InstanceUpdateManyArgs>(args: SelectSubset<T, InstanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Instance.
     * @param {InstanceUpsertArgs} args - Arguments to update or create a Instance.
     * @example
     * // Update or create a Instance
     * const instance = await prisma.instance.upsert({
     *   create: {
     *     // ... data to create a Instance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Instance we want to update
     *   }
     * })
     */
    upsert<T extends InstanceUpsertArgs>(args: SelectSubset<T, InstanceUpsertArgs<ExtArgs>>): Prisma__InstanceClient<$Result.GetResult<Prisma.$InstancePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Instances that matches the filter.
     * @param {InstanceFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const instance = await prisma.instance.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: InstanceFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Instance.
     * @param {InstanceAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const instance = await prisma.instance.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: InstanceAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Instances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstanceCountArgs} args - Arguments to filter Instances to count.
     * @example
     * // Count the number of Instances
     * const count = await prisma.instance.count({
     *   where: {
     *     // ... the filter for the Instances we want to count
     *   }
     * })
    **/
    count<T extends InstanceCountArgs>(
      args?: Subset<T, InstanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InstanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Instance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InstanceAggregateArgs>(args: Subset<T, InstanceAggregateArgs>): Prisma.PrismaPromise<GetInstanceAggregateType<T>>

    /**
     * Group by Instance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InstanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InstanceGroupByArgs['orderBy'] }
        : { orderBy?: InstanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InstanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInstanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Instance model
   */
  readonly fields: InstanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Instance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InstanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends ClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientDefaultArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    levels<T extends Instance$levelsArgs<ExtArgs> = {}>(args?: Subset<T, Instance$levelsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LevelPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    versions<T extends Instance$versionsArgs<ExtArgs> = {}>(args?: Subset<T, Instance$versionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VersionPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    currencies<T extends Instance$currenciesArgs<ExtArgs> = {}>(args?: Subset<T, Instance$currenciesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    accounts<T extends Instance$accountsArgs<ExtArgs> = {}>(args?: Subset<T, Instance$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    models<T extends Instance$modelsArgs<ExtArgs> = {}>(args?: Subset<T, Instance$modelsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModelPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    dimensions<T extends Instance$dimensionsArgs<ExtArgs> = {}>(args?: Subset<T, Instance$dimensionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DimensionPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    dimensionValues<T extends Instance$dimensionValuesArgs<ExtArgs> = {}>(args?: Subset<T, Instance$dimensionValuesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DimensionValuePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    levelAttributes<T extends Instance$levelAttributesArgs<ExtArgs> = {}>(args?: Subset<T, Instance$levelAttributesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LevelAttributePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    dimensionValueAttributes<T extends Instance$dimensionValueAttributesArgs<ExtArgs> = {}>(args?: Subset<T, Instance$dimensionValueAttributesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DimensionValueAttributePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    accountAttributes<T extends Instance$accountAttributesArgs<ExtArgs> = {}>(args?: Subset<T, Instance$accountAttributesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountAttributePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    levelAttValues<T extends Instance$levelAttValuesArgs<ExtArgs> = {}>(args?: Subset<T, Instance$levelAttValuesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LevelAttributeValuePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    accountAttValues<T extends Instance$accountAttValuesArgs<ExtArgs> = {}>(args?: Subset<T, Instance$accountAttValuesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountAttributeValuePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    dimensionValueAttributeValues<T extends Instance$dimensionValueAttributeValuesArgs<ExtArgs> = {}>(args?: Subset<T, Instance$dimensionValueAttributeValuesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DimensionValueAttributeValuePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    modelData<T extends Instance$modelDataArgs<ExtArgs> = {}>(args?: Subset<T, Instance$modelDataArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModelDataPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    modelDataCalculations<T extends Instance$modelDataCalculationsArgs<ExtArgs> = {}>(args?: Subset<T, Instance$modelDataCalculationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModelDataCalculationsPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    modelAccounts<T extends Instance$modelAccountsArgs<ExtArgs> = {}>(args?: Subset<T, Instance$modelAccountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModelAccountStructurePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    tables<T extends Instance$tablesArgs<ExtArgs> = {}>(args?: Subset<T, Instance$tablesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TablePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    tableData<T extends Instance$tableDataArgs<ExtArgs> = {}>(args?: Subset<T, Instance$tableDataArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TableDataPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Instance model
   */ 
  interface InstanceFieldRefs {
    readonly id: FieldRef<"Instance", 'String'>
    readonly code: FieldRef<"Instance", 'String'>
    readonly name: FieldRef<"Instance", 'String'>
    readonly clientId: FieldRef<"Instance", 'String'>
    readonly description: FieldRef<"Instance", 'String'>
    readonly status: FieldRef<"Instance", 'instanceStatus'>
    readonly userIds: FieldRef<"Instance", 'String[]'>
    readonly createdAt: FieldRef<"Instance", 'DateTime'>
    readonly updatedAt: FieldRef<"Instance", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Instance findUnique
   */
  export type InstanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instance
     */
    select?: InstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Instance
     */
    omit?: InstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstanceInclude<ExtArgs> | null
    /**
     * Filter, which Instance to fetch.
     */
    where: InstanceWhereUniqueInput
  }

  /**
   * Instance findUniqueOrThrow
   */
  export type InstanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instance
     */
    select?: InstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Instance
     */
    omit?: InstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstanceInclude<ExtArgs> | null
    /**
     * Filter, which Instance to fetch.
     */
    where: InstanceWhereUniqueInput
  }

  /**
   * Instance findFirst
   */
  export type InstanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instance
     */
    select?: InstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Instance
     */
    omit?: InstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstanceInclude<ExtArgs> | null
    /**
     * Filter, which Instance to fetch.
     */
    where?: InstanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Instances to fetch.
     */
    orderBy?: InstanceOrderByWithRelationInput | InstanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Instances.
     */
    cursor?: InstanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Instances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Instances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Instances.
     */
    distinct?: InstanceScalarFieldEnum | InstanceScalarFieldEnum[]
  }

  /**
   * Instance findFirstOrThrow
   */
  export type InstanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instance
     */
    select?: InstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Instance
     */
    omit?: InstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstanceInclude<ExtArgs> | null
    /**
     * Filter, which Instance to fetch.
     */
    where?: InstanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Instances to fetch.
     */
    orderBy?: InstanceOrderByWithRelationInput | InstanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Instances.
     */
    cursor?: InstanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Instances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Instances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Instances.
     */
    distinct?: InstanceScalarFieldEnum | InstanceScalarFieldEnum[]
  }

  /**
   * Instance findMany
   */
  export type InstanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instance
     */
    select?: InstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Instance
     */
    omit?: InstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstanceInclude<ExtArgs> | null
    /**
     * Filter, which Instances to fetch.
     */
    where?: InstanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Instances to fetch.
     */
    orderBy?: InstanceOrderByWithRelationInput | InstanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Instances.
     */
    cursor?: InstanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Instances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Instances.
     */
    skip?: number
    distinct?: InstanceScalarFieldEnum | InstanceScalarFieldEnum[]
  }

  /**
   * Instance create
   */
  export type InstanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instance
     */
    select?: InstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Instance
     */
    omit?: InstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstanceInclude<ExtArgs> | null
    /**
     * The data needed to create a Instance.
     */
    data: XOR<InstanceCreateInput, InstanceUncheckedCreateInput>
  }

  /**
   * Instance createMany
   */
  export type InstanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Instances.
     */
    data: InstanceCreateManyInput | InstanceCreateManyInput[]
  }

  /**
   * Instance update
   */
  export type InstanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instance
     */
    select?: InstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Instance
     */
    omit?: InstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstanceInclude<ExtArgs> | null
    /**
     * The data needed to update a Instance.
     */
    data: XOR<InstanceUpdateInput, InstanceUncheckedUpdateInput>
    /**
     * Choose, which Instance to update.
     */
    where: InstanceWhereUniqueInput
  }

  /**
   * Instance updateMany
   */
  export type InstanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Instances.
     */
    data: XOR<InstanceUpdateManyMutationInput, InstanceUncheckedUpdateManyInput>
    /**
     * Filter which Instances to update
     */
    where?: InstanceWhereInput
    /**
     * Limit how many Instances to update.
     */
    limit?: number
  }

  /**
   * Instance upsert
   */
  export type InstanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instance
     */
    select?: InstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Instance
     */
    omit?: InstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstanceInclude<ExtArgs> | null
    /**
     * The filter to search for the Instance to update in case it exists.
     */
    where: InstanceWhereUniqueInput
    /**
     * In case the Instance found by the `where` argument doesn't exist, create a new Instance with this data.
     */
    create: XOR<InstanceCreateInput, InstanceUncheckedCreateInput>
    /**
     * In case the Instance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InstanceUpdateInput, InstanceUncheckedUpdateInput>
  }

  /**
   * Instance delete
   */
  export type InstanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instance
     */
    select?: InstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Instance
     */
    omit?: InstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstanceInclude<ExtArgs> | null
    /**
     * Filter which Instance to delete.
     */
    where: InstanceWhereUniqueInput
  }

  /**
   * Instance deleteMany
   */
  export type InstanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Instances to delete
     */
    where?: InstanceWhereInput
    /**
     * Limit how many Instances to delete.
     */
    limit?: number
  }

  /**
   * Instance findRaw
   */
  export type InstanceFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Instance aggregateRaw
   */
  export type InstanceAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Instance.levels
   */
  export type Instance$levelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Level
     */
    omit?: LevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelInclude<ExtArgs> | null
    where?: LevelWhereInput
    orderBy?: LevelOrderByWithRelationInput | LevelOrderByWithRelationInput[]
    cursor?: LevelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LevelScalarFieldEnum | LevelScalarFieldEnum[]
  }

  /**
   * Instance.versions
   */
  export type Instance$versionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Version
     */
    select?: VersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Version
     */
    omit?: VersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VersionInclude<ExtArgs> | null
    where?: VersionWhereInput
    orderBy?: VersionOrderByWithRelationInput | VersionOrderByWithRelationInput[]
    cursor?: VersionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VersionScalarFieldEnum | VersionScalarFieldEnum[]
  }

  /**
   * Instance.currencies
   */
  export type Instance$currenciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyInclude<ExtArgs> | null
    where?: CurrencyWhereInput
    orderBy?: CurrencyOrderByWithRelationInput | CurrencyOrderByWithRelationInput[]
    cursor?: CurrencyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CurrencyScalarFieldEnum | CurrencyScalarFieldEnum[]
  }

  /**
   * Instance.accounts
   */
  export type Instance$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Instance.models
   */
  export type Instance$modelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Model
     */
    select?: ModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Model
     */
    omit?: ModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelInclude<ExtArgs> | null
    where?: ModelWhereInput
    orderBy?: ModelOrderByWithRelationInput | ModelOrderByWithRelationInput[]
    cursor?: ModelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ModelScalarFieldEnum | ModelScalarFieldEnum[]
  }

  /**
   * Instance.dimensions
   */
  export type Instance$dimensionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dimension
     */
    select?: DimensionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dimension
     */
    omit?: DimensionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimensionInclude<ExtArgs> | null
    where?: DimensionWhereInput
    orderBy?: DimensionOrderByWithRelationInput | DimensionOrderByWithRelationInput[]
    cursor?: DimensionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DimensionScalarFieldEnum | DimensionScalarFieldEnum[]
  }

  /**
   * Instance.dimensionValues
   */
  export type Instance$dimensionValuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimensionValue
     */
    select?: DimensionValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DimensionValue
     */
    omit?: DimensionValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimensionValueInclude<ExtArgs> | null
    where?: DimensionValueWhereInput
    orderBy?: DimensionValueOrderByWithRelationInput | DimensionValueOrderByWithRelationInput[]
    cursor?: DimensionValueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DimensionValueScalarFieldEnum | DimensionValueScalarFieldEnum[]
  }

  /**
   * Instance.levelAttributes
   */
  export type Instance$levelAttributesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LevelAttribute
     */
    select?: LevelAttributeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LevelAttribute
     */
    omit?: LevelAttributeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelAttributeInclude<ExtArgs> | null
    where?: LevelAttributeWhereInput
    orderBy?: LevelAttributeOrderByWithRelationInput | LevelAttributeOrderByWithRelationInput[]
    cursor?: LevelAttributeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LevelAttributeScalarFieldEnum | LevelAttributeScalarFieldEnum[]
  }

  /**
   * Instance.dimensionValueAttributes
   */
  export type Instance$dimensionValueAttributesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimensionValueAttribute
     */
    select?: DimensionValueAttributeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DimensionValueAttribute
     */
    omit?: DimensionValueAttributeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimensionValueAttributeInclude<ExtArgs> | null
    where?: DimensionValueAttributeWhereInput
    orderBy?: DimensionValueAttributeOrderByWithRelationInput | DimensionValueAttributeOrderByWithRelationInput[]
    cursor?: DimensionValueAttributeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DimensionValueAttributeScalarFieldEnum | DimensionValueAttributeScalarFieldEnum[]
  }

  /**
   * Instance.accountAttributes
   */
  export type Instance$accountAttributesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountAttribute
     */
    select?: AccountAttributeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountAttribute
     */
    omit?: AccountAttributeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountAttributeInclude<ExtArgs> | null
    where?: AccountAttributeWhereInput
    orderBy?: AccountAttributeOrderByWithRelationInput | AccountAttributeOrderByWithRelationInput[]
    cursor?: AccountAttributeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountAttributeScalarFieldEnum | AccountAttributeScalarFieldEnum[]
  }

  /**
   * Instance.levelAttValues
   */
  export type Instance$levelAttValuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LevelAttributeValue
     */
    select?: LevelAttributeValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LevelAttributeValue
     */
    omit?: LevelAttributeValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelAttributeValueInclude<ExtArgs> | null
    where?: LevelAttributeValueWhereInput
    orderBy?: LevelAttributeValueOrderByWithRelationInput | LevelAttributeValueOrderByWithRelationInput[]
    cursor?: LevelAttributeValueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LevelAttributeValueScalarFieldEnum | LevelAttributeValueScalarFieldEnum[]
  }

  /**
   * Instance.accountAttValues
   */
  export type Instance$accountAttValuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountAttributeValue
     */
    select?: AccountAttributeValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountAttributeValue
     */
    omit?: AccountAttributeValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountAttributeValueInclude<ExtArgs> | null
    where?: AccountAttributeValueWhereInput
    orderBy?: AccountAttributeValueOrderByWithRelationInput | AccountAttributeValueOrderByWithRelationInput[]
    cursor?: AccountAttributeValueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountAttributeValueScalarFieldEnum | AccountAttributeValueScalarFieldEnum[]
  }

  /**
   * Instance.dimensionValueAttributeValues
   */
  export type Instance$dimensionValueAttributeValuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimensionValueAttributeValue
     */
    select?: DimensionValueAttributeValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DimensionValueAttributeValue
     */
    omit?: DimensionValueAttributeValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimensionValueAttributeValueInclude<ExtArgs> | null
    where?: DimensionValueAttributeValueWhereInput
    orderBy?: DimensionValueAttributeValueOrderByWithRelationInput | DimensionValueAttributeValueOrderByWithRelationInput[]
    cursor?: DimensionValueAttributeValueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DimensionValueAttributeValueScalarFieldEnum | DimensionValueAttributeValueScalarFieldEnum[]
  }

  /**
   * Instance.modelData
   */
  export type Instance$modelDataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelData
     */
    select?: ModelDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelData
     */
    omit?: ModelDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelDataInclude<ExtArgs> | null
    where?: ModelDataWhereInput
    orderBy?: ModelDataOrderByWithRelationInput | ModelDataOrderByWithRelationInput[]
    cursor?: ModelDataWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ModelDataScalarFieldEnum | ModelDataScalarFieldEnum[]
  }

  /**
   * Instance.modelDataCalculations
   */
  export type Instance$modelDataCalculationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelDataCalculations
     */
    select?: ModelDataCalculationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelDataCalculations
     */
    omit?: ModelDataCalculationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelDataCalculationsInclude<ExtArgs> | null
    where?: ModelDataCalculationsWhereInput
    orderBy?: ModelDataCalculationsOrderByWithRelationInput | ModelDataCalculationsOrderByWithRelationInput[]
    cursor?: ModelDataCalculationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ModelDataCalculationsScalarFieldEnum | ModelDataCalculationsScalarFieldEnum[]
  }

  /**
   * Instance.modelAccounts
   */
  export type Instance$modelAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelAccountStructure
     */
    select?: ModelAccountStructureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelAccountStructure
     */
    omit?: ModelAccountStructureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelAccountStructureInclude<ExtArgs> | null
    where?: ModelAccountStructureWhereInput
    orderBy?: ModelAccountStructureOrderByWithRelationInput | ModelAccountStructureOrderByWithRelationInput[]
    cursor?: ModelAccountStructureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ModelAccountStructureScalarFieldEnum | ModelAccountStructureScalarFieldEnum[]
  }

  /**
   * Instance.tables
   */
  export type Instance$tablesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Table
     */
    select?: TableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Table
     */
    omit?: TableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableInclude<ExtArgs> | null
    where?: TableWhereInput
    orderBy?: TableOrderByWithRelationInput | TableOrderByWithRelationInput[]
    cursor?: TableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TableScalarFieldEnum | TableScalarFieldEnum[]
  }

  /**
   * Instance.tableData
   */
  export type Instance$tableDataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TableData
     */
    select?: TableDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TableData
     */
    omit?: TableDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableDataInclude<ExtArgs> | null
    where?: TableDataWhereInput
    orderBy?: TableDataOrderByWithRelationInput | TableDataOrderByWithRelationInput[]
    cursor?: TableDataWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TableDataScalarFieldEnum | TableDataScalarFieldEnum[]
  }

  /**
   * Instance without action
   */
  export type InstanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instance
     */
    select?: InstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Instance
     */
    omit?: InstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstanceInclude<ExtArgs> | null
  }


  /**
   * Model Version
   */

  export type AggregateVersion = {
    _count: VersionCountAggregateOutputType | null
    _min: VersionMinAggregateOutputType | null
    _max: VersionMaxAggregateOutputType | null
  }

  export type VersionMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    begin: Date | null
    end: Date | null
    startOfPlan: Date | null
    description: string | null
    isDefault: boolean | null
    isActuals: boolean | null
    status: $Enums.versionStatus | null
    clientId: string | null
    instanceId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VersionMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    begin: Date | null
    end: Date | null
    startOfPlan: Date | null
    description: string | null
    isDefault: boolean | null
    isActuals: boolean | null
    status: $Enums.versionStatus | null
    clientId: string | null
    instanceId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VersionCountAggregateOutputType = {
    id: number
    code: number
    name: number
    begin: number
    end: number
    startOfPlan: number
    description: number
    isDefault: number
    isActuals: number
    status: number
    clientId: number
    instanceId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VersionMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    begin?: true
    end?: true
    startOfPlan?: true
    description?: true
    isDefault?: true
    isActuals?: true
    status?: true
    clientId?: true
    instanceId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VersionMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    begin?: true
    end?: true
    startOfPlan?: true
    description?: true
    isDefault?: true
    isActuals?: true
    status?: true
    clientId?: true
    instanceId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VersionCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    begin?: true
    end?: true
    startOfPlan?: true
    description?: true
    isDefault?: true
    isActuals?: true
    status?: true
    clientId?: true
    instanceId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VersionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Version to aggregate.
     */
    where?: VersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Versions to fetch.
     */
    orderBy?: VersionOrderByWithRelationInput | VersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Versions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Versions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Versions
    **/
    _count?: true | VersionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VersionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VersionMaxAggregateInputType
  }

  export type GetVersionAggregateType<T extends VersionAggregateArgs> = {
        [P in keyof T & keyof AggregateVersion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVersion[P]>
      : GetScalarType<T[P], AggregateVersion[P]>
  }




  export type VersionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VersionWhereInput
    orderBy?: VersionOrderByWithAggregationInput | VersionOrderByWithAggregationInput[]
    by: VersionScalarFieldEnum[] | VersionScalarFieldEnum
    having?: VersionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VersionCountAggregateInputType | true
    _min?: VersionMinAggregateInputType
    _max?: VersionMaxAggregateInputType
  }

  export type VersionGroupByOutputType = {
    id: string
    code: string
    name: string
    begin: Date
    end: Date
    startOfPlan: Date
    description: string | null
    isDefault: boolean
    isActuals: boolean
    status: $Enums.versionStatus
    clientId: string
    instanceId: string
    createdAt: Date | null
    updatedAt: Date | null
    _count: VersionCountAggregateOutputType | null
    _min: VersionMinAggregateOutputType | null
    _max: VersionMaxAggregateOutputType | null
  }

  type GetVersionGroupByPayload<T extends VersionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VersionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VersionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VersionGroupByOutputType[P]>
            : GetScalarType<T[P], VersionGroupByOutputType[P]>
        }
      >
    >


  export type VersionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    begin?: boolean
    end?: boolean
    startOfPlan?: boolean
    description?: boolean
    isDefault?: boolean
    isActuals?: boolean
    status?: boolean
    clientId?: boolean
    instanceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    instance?: boolean | InstanceDefaultArgs<ExtArgs>
    modelData?: boolean | Version$modelDataArgs<ExtArgs>
    modelDataCalculations?: boolean | Version$modelDataCalculationsArgs<ExtArgs>
    _count?: boolean | VersionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["version"]>



  export type VersionSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    begin?: boolean
    end?: boolean
    startOfPlan?: boolean
    description?: boolean
    isDefault?: boolean
    isActuals?: boolean
    status?: boolean
    clientId?: boolean
    instanceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VersionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "name" | "begin" | "end" | "startOfPlan" | "description" | "isDefault" | "isActuals" | "status" | "clientId" | "instanceId" | "createdAt" | "updatedAt", ExtArgs["result"]["version"]>
  export type VersionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    instance?: boolean | InstanceDefaultArgs<ExtArgs>
    modelData?: boolean | Version$modelDataArgs<ExtArgs>
    modelDataCalculations?: boolean | Version$modelDataCalculationsArgs<ExtArgs>
    _count?: boolean | VersionCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $VersionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Version"
    objects: {
      instance: Prisma.$InstancePayload<ExtArgs>
      modelData: Prisma.$ModelDataPayload<ExtArgs>[]
      modelDataCalculations: Prisma.$ModelDataCalculationsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      name: string
      begin: Date
      end: Date
      startOfPlan: Date
      description: string | null
      isDefault: boolean
      isActuals: boolean
      status: $Enums.versionStatus
      clientId: string
      instanceId: string
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["version"]>
    composites: {}
  }

  type VersionGetPayload<S extends boolean | null | undefined | VersionDefaultArgs> = $Result.GetResult<Prisma.$VersionPayload, S>

  type VersionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VersionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VersionCountAggregateInputType | true
    }

  export interface VersionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Version'], meta: { name: 'Version' } }
    /**
     * Find zero or one Version that matches the filter.
     * @param {VersionFindUniqueArgs} args - Arguments to find a Version
     * @example
     * // Get one Version
     * const version = await prisma.version.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VersionFindUniqueArgs>(args: SelectSubset<T, VersionFindUniqueArgs<ExtArgs>>): Prisma__VersionClient<$Result.GetResult<Prisma.$VersionPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Version that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VersionFindUniqueOrThrowArgs} args - Arguments to find a Version
     * @example
     * // Get one Version
     * const version = await prisma.version.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VersionFindUniqueOrThrowArgs>(args: SelectSubset<T, VersionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VersionClient<$Result.GetResult<Prisma.$VersionPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Version that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VersionFindFirstArgs} args - Arguments to find a Version
     * @example
     * // Get one Version
     * const version = await prisma.version.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VersionFindFirstArgs>(args?: SelectSubset<T, VersionFindFirstArgs<ExtArgs>>): Prisma__VersionClient<$Result.GetResult<Prisma.$VersionPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Version that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VersionFindFirstOrThrowArgs} args - Arguments to find a Version
     * @example
     * // Get one Version
     * const version = await prisma.version.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VersionFindFirstOrThrowArgs>(args?: SelectSubset<T, VersionFindFirstOrThrowArgs<ExtArgs>>): Prisma__VersionClient<$Result.GetResult<Prisma.$VersionPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Versions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VersionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Versions
     * const versions = await prisma.version.findMany()
     * 
     * // Get first 10 Versions
     * const versions = await prisma.version.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const versionWithIdOnly = await prisma.version.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VersionFindManyArgs>(args?: SelectSubset<T, VersionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VersionPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Version.
     * @param {VersionCreateArgs} args - Arguments to create a Version.
     * @example
     * // Create one Version
     * const Version = await prisma.version.create({
     *   data: {
     *     // ... data to create a Version
     *   }
     * })
     * 
     */
    create<T extends VersionCreateArgs>(args: SelectSubset<T, VersionCreateArgs<ExtArgs>>): Prisma__VersionClient<$Result.GetResult<Prisma.$VersionPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Versions.
     * @param {VersionCreateManyArgs} args - Arguments to create many Versions.
     * @example
     * // Create many Versions
     * const version = await prisma.version.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VersionCreateManyArgs>(args?: SelectSubset<T, VersionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Version.
     * @param {VersionDeleteArgs} args - Arguments to delete one Version.
     * @example
     * // Delete one Version
     * const Version = await prisma.version.delete({
     *   where: {
     *     // ... filter to delete one Version
     *   }
     * })
     * 
     */
    delete<T extends VersionDeleteArgs>(args: SelectSubset<T, VersionDeleteArgs<ExtArgs>>): Prisma__VersionClient<$Result.GetResult<Prisma.$VersionPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Version.
     * @param {VersionUpdateArgs} args - Arguments to update one Version.
     * @example
     * // Update one Version
     * const version = await prisma.version.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VersionUpdateArgs>(args: SelectSubset<T, VersionUpdateArgs<ExtArgs>>): Prisma__VersionClient<$Result.GetResult<Prisma.$VersionPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Versions.
     * @param {VersionDeleteManyArgs} args - Arguments to filter Versions to delete.
     * @example
     * // Delete a few Versions
     * const { count } = await prisma.version.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VersionDeleteManyArgs>(args?: SelectSubset<T, VersionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Versions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VersionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Versions
     * const version = await prisma.version.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VersionUpdateManyArgs>(args: SelectSubset<T, VersionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Version.
     * @param {VersionUpsertArgs} args - Arguments to update or create a Version.
     * @example
     * // Update or create a Version
     * const version = await prisma.version.upsert({
     *   create: {
     *     // ... data to create a Version
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Version we want to update
     *   }
     * })
     */
    upsert<T extends VersionUpsertArgs>(args: SelectSubset<T, VersionUpsertArgs<ExtArgs>>): Prisma__VersionClient<$Result.GetResult<Prisma.$VersionPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Versions that matches the filter.
     * @param {VersionFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const version = await prisma.version.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: VersionFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Version.
     * @param {VersionAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const version = await prisma.version.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: VersionAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Versions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VersionCountArgs} args - Arguments to filter Versions to count.
     * @example
     * // Count the number of Versions
     * const count = await prisma.version.count({
     *   where: {
     *     // ... the filter for the Versions we want to count
     *   }
     * })
    **/
    count<T extends VersionCountArgs>(
      args?: Subset<T, VersionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VersionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Version.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VersionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VersionAggregateArgs>(args: Subset<T, VersionAggregateArgs>): Prisma.PrismaPromise<GetVersionAggregateType<T>>

    /**
     * Group by Version.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VersionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VersionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VersionGroupByArgs['orderBy'] }
        : { orderBy?: VersionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VersionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVersionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Version model
   */
  readonly fields: VersionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Version.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VersionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    instance<T extends InstanceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InstanceDefaultArgs<ExtArgs>>): Prisma__InstanceClient<$Result.GetResult<Prisma.$InstancePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    modelData<T extends Version$modelDataArgs<ExtArgs> = {}>(args?: Subset<T, Version$modelDataArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModelDataPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    modelDataCalculations<T extends Version$modelDataCalculationsArgs<ExtArgs> = {}>(args?: Subset<T, Version$modelDataCalculationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModelDataCalculationsPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Version model
   */ 
  interface VersionFieldRefs {
    readonly id: FieldRef<"Version", 'String'>
    readonly code: FieldRef<"Version", 'String'>
    readonly name: FieldRef<"Version", 'String'>
    readonly begin: FieldRef<"Version", 'DateTime'>
    readonly end: FieldRef<"Version", 'DateTime'>
    readonly startOfPlan: FieldRef<"Version", 'DateTime'>
    readonly description: FieldRef<"Version", 'String'>
    readonly isDefault: FieldRef<"Version", 'Boolean'>
    readonly isActuals: FieldRef<"Version", 'Boolean'>
    readonly status: FieldRef<"Version", 'versionStatus'>
    readonly clientId: FieldRef<"Version", 'String'>
    readonly instanceId: FieldRef<"Version", 'String'>
    readonly createdAt: FieldRef<"Version", 'DateTime'>
    readonly updatedAt: FieldRef<"Version", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Version findUnique
   */
  export type VersionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Version
     */
    select?: VersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Version
     */
    omit?: VersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VersionInclude<ExtArgs> | null
    /**
     * Filter, which Version to fetch.
     */
    where: VersionWhereUniqueInput
  }

  /**
   * Version findUniqueOrThrow
   */
  export type VersionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Version
     */
    select?: VersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Version
     */
    omit?: VersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VersionInclude<ExtArgs> | null
    /**
     * Filter, which Version to fetch.
     */
    where: VersionWhereUniqueInput
  }

  /**
   * Version findFirst
   */
  export type VersionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Version
     */
    select?: VersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Version
     */
    omit?: VersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VersionInclude<ExtArgs> | null
    /**
     * Filter, which Version to fetch.
     */
    where?: VersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Versions to fetch.
     */
    orderBy?: VersionOrderByWithRelationInput | VersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Versions.
     */
    cursor?: VersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Versions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Versions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Versions.
     */
    distinct?: VersionScalarFieldEnum | VersionScalarFieldEnum[]
  }

  /**
   * Version findFirstOrThrow
   */
  export type VersionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Version
     */
    select?: VersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Version
     */
    omit?: VersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VersionInclude<ExtArgs> | null
    /**
     * Filter, which Version to fetch.
     */
    where?: VersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Versions to fetch.
     */
    orderBy?: VersionOrderByWithRelationInput | VersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Versions.
     */
    cursor?: VersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Versions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Versions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Versions.
     */
    distinct?: VersionScalarFieldEnum | VersionScalarFieldEnum[]
  }

  /**
   * Version findMany
   */
  export type VersionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Version
     */
    select?: VersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Version
     */
    omit?: VersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VersionInclude<ExtArgs> | null
    /**
     * Filter, which Versions to fetch.
     */
    where?: VersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Versions to fetch.
     */
    orderBy?: VersionOrderByWithRelationInput | VersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Versions.
     */
    cursor?: VersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Versions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Versions.
     */
    skip?: number
    distinct?: VersionScalarFieldEnum | VersionScalarFieldEnum[]
  }

  /**
   * Version create
   */
  export type VersionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Version
     */
    select?: VersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Version
     */
    omit?: VersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VersionInclude<ExtArgs> | null
    /**
     * The data needed to create a Version.
     */
    data: XOR<VersionCreateInput, VersionUncheckedCreateInput>
  }

  /**
   * Version createMany
   */
  export type VersionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Versions.
     */
    data: VersionCreateManyInput | VersionCreateManyInput[]
  }

  /**
   * Version update
   */
  export type VersionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Version
     */
    select?: VersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Version
     */
    omit?: VersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VersionInclude<ExtArgs> | null
    /**
     * The data needed to update a Version.
     */
    data: XOR<VersionUpdateInput, VersionUncheckedUpdateInput>
    /**
     * Choose, which Version to update.
     */
    where: VersionWhereUniqueInput
  }

  /**
   * Version updateMany
   */
  export type VersionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Versions.
     */
    data: XOR<VersionUpdateManyMutationInput, VersionUncheckedUpdateManyInput>
    /**
     * Filter which Versions to update
     */
    where?: VersionWhereInput
    /**
     * Limit how many Versions to update.
     */
    limit?: number
  }

  /**
   * Version upsert
   */
  export type VersionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Version
     */
    select?: VersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Version
     */
    omit?: VersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VersionInclude<ExtArgs> | null
    /**
     * The filter to search for the Version to update in case it exists.
     */
    where: VersionWhereUniqueInput
    /**
     * In case the Version found by the `where` argument doesn't exist, create a new Version with this data.
     */
    create: XOR<VersionCreateInput, VersionUncheckedCreateInput>
    /**
     * In case the Version was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VersionUpdateInput, VersionUncheckedUpdateInput>
  }

  /**
   * Version delete
   */
  export type VersionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Version
     */
    select?: VersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Version
     */
    omit?: VersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VersionInclude<ExtArgs> | null
    /**
     * Filter which Version to delete.
     */
    where: VersionWhereUniqueInput
  }

  /**
   * Version deleteMany
   */
  export type VersionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Versions to delete
     */
    where?: VersionWhereInput
    /**
     * Limit how many Versions to delete.
     */
    limit?: number
  }

  /**
   * Version findRaw
   */
  export type VersionFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Version aggregateRaw
   */
  export type VersionAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Version.modelData
   */
  export type Version$modelDataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelData
     */
    select?: ModelDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelData
     */
    omit?: ModelDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelDataInclude<ExtArgs> | null
    where?: ModelDataWhereInput
    orderBy?: ModelDataOrderByWithRelationInput | ModelDataOrderByWithRelationInput[]
    cursor?: ModelDataWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ModelDataScalarFieldEnum | ModelDataScalarFieldEnum[]
  }

  /**
   * Version.modelDataCalculations
   */
  export type Version$modelDataCalculationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelDataCalculations
     */
    select?: ModelDataCalculationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelDataCalculations
     */
    omit?: ModelDataCalculationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelDataCalculationsInclude<ExtArgs> | null
    where?: ModelDataCalculationsWhereInput
    orderBy?: ModelDataCalculationsOrderByWithRelationInput | ModelDataCalculationsOrderByWithRelationInput[]
    cursor?: ModelDataCalculationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ModelDataCalculationsScalarFieldEnum | ModelDataCalculationsScalarFieldEnum[]
  }

  /**
   * Version without action
   */
  export type VersionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Version
     */
    select?: VersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Version
     */
    omit?: VersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VersionInclude<ExtArgs> | null
  }


  /**
   * Model CurrencyIsoCode
   */

  export type AggregateCurrencyIsoCode = {
    _count: CurrencyIsoCodeCountAggregateOutputType | null
    _min: CurrencyIsoCodeMinAggregateOutputType | null
    _max: CurrencyIsoCodeMaxAggregateOutputType | null
  }

  export type CurrencyIsoCodeMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CurrencyIsoCodeMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CurrencyIsoCodeCountAggregateOutputType = {
    id: number
    code: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CurrencyIsoCodeMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CurrencyIsoCodeMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CurrencyIsoCodeCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CurrencyIsoCodeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CurrencyIsoCode to aggregate.
     */
    where?: CurrencyIsoCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CurrencyIsoCodes to fetch.
     */
    orderBy?: CurrencyIsoCodeOrderByWithRelationInput | CurrencyIsoCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CurrencyIsoCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CurrencyIsoCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CurrencyIsoCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CurrencyIsoCodes
    **/
    _count?: true | CurrencyIsoCodeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CurrencyIsoCodeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CurrencyIsoCodeMaxAggregateInputType
  }

  export type GetCurrencyIsoCodeAggregateType<T extends CurrencyIsoCodeAggregateArgs> = {
        [P in keyof T & keyof AggregateCurrencyIsoCode]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCurrencyIsoCode[P]>
      : GetScalarType<T[P], AggregateCurrencyIsoCode[P]>
  }




  export type CurrencyIsoCodeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CurrencyIsoCodeWhereInput
    orderBy?: CurrencyIsoCodeOrderByWithAggregationInput | CurrencyIsoCodeOrderByWithAggregationInput[]
    by: CurrencyIsoCodeScalarFieldEnum[] | CurrencyIsoCodeScalarFieldEnum
    having?: CurrencyIsoCodeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CurrencyIsoCodeCountAggregateInputType | true
    _min?: CurrencyIsoCodeMinAggregateInputType
    _max?: CurrencyIsoCodeMaxAggregateInputType
  }

  export type CurrencyIsoCodeGroupByOutputType = {
    id: string
    code: string
    name: string
    createdAt: Date | null
    updatedAt: Date | null
    _count: CurrencyIsoCodeCountAggregateOutputType | null
    _min: CurrencyIsoCodeMinAggregateOutputType | null
    _max: CurrencyIsoCodeMaxAggregateOutputType | null
  }

  type GetCurrencyIsoCodeGroupByPayload<T extends CurrencyIsoCodeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CurrencyIsoCodeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CurrencyIsoCodeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CurrencyIsoCodeGroupByOutputType[P]>
            : GetScalarType<T[P], CurrencyIsoCodeGroupByOutputType[P]>
        }
      >
    >


  export type CurrencyIsoCodeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    currencies?: boolean | CurrencyIsoCode$currenciesArgs<ExtArgs>
    config?: boolean | CurrencyIsoCode$configArgs<ExtArgs>
    _count?: boolean | CurrencyIsoCodeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["currencyIsoCode"]>



  export type CurrencyIsoCodeSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CurrencyIsoCodeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "name" | "createdAt" | "updatedAt", ExtArgs["result"]["currencyIsoCode"]>
  export type CurrencyIsoCodeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    currencies?: boolean | CurrencyIsoCode$currenciesArgs<ExtArgs>
    config?: boolean | CurrencyIsoCode$configArgs<ExtArgs>
    _count?: boolean | CurrencyIsoCodeCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CurrencyIsoCodePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CurrencyIsoCode"
    objects: {
      currencies: Prisma.$CurrencyPayload<ExtArgs>[]
      config: Prisma.$ConfigPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      name: string
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["currencyIsoCode"]>
    composites: {}
  }

  type CurrencyIsoCodeGetPayload<S extends boolean | null | undefined | CurrencyIsoCodeDefaultArgs> = $Result.GetResult<Prisma.$CurrencyIsoCodePayload, S>

  type CurrencyIsoCodeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CurrencyIsoCodeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CurrencyIsoCodeCountAggregateInputType | true
    }

  export interface CurrencyIsoCodeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CurrencyIsoCode'], meta: { name: 'CurrencyIsoCode' } }
    /**
     * Find zero or one CurrencyIsoCode that matches the filter.
     * @param {CurrencyIsoCodeFindUniqueArgs} args - Arguments to find a CurrencyIsoCode
     * @example
     * // Get one CurrencyIsoCode
     * const currencyIsoCode = await prisma.currencyIsoCode.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CurrencyIsoCodeFindUniqueArgs>(args: SelectSubset<T, CurrencyIsoCodeFindUniqueArgs<ExtArgs>>): Prisma__CurrencyIsoCodeClient<$Result.GetResult<Prisma.$CurrencyIsoCodePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one CurrencyIsoCode that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CurrencyIsoCodeFindUniqueOrThrowArgs} args - Arguments to find a CurrencyIsoCode
     * @example
     * // Get one CurrencyIsoCode
     * const currencyIsoCode = await prisma.currencyIsoCode.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CurrencyIsoCodeFindUniqueOrThrowArgs>(args: SelectSubset<T, CurrencyIsoCodeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CurrencyIsoCodeClient<$Result.GetResult<Prisma.$CurrencyIsoCodePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first CurrencyIsoCode that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyIsoCodeFindFirstArgs} args - Arguments to find a CurrencyIsoCode
     * @example
     * // Get one CurrencyIsoCode
     * const currencyIsoCode = await prisma.currencyIsoCode.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CurrencyIsoCodeFindFirstArgs>(args?: SelectSubset<T, CurrencyIsoCodeFindFirstArgs<ExtArgs>>): Prisma__CurrencyIsoCodeClient<$Result.GetResult<Prisma.$CurrencyIsoCodePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first CurrencyIsoCode that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyIsoCodeFindFirstOrThrowArgs} args - Arguments to find a CurrencyIsoCode
     * @example
     * // Get one CurrencyIsoCode
     * const currencyIsoCode = await prisma.currencyIsoCode.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CurrencyIsoCodeFindFirstOrThrowArgs>(args?: SelectSubset<T, CurrencyIsoCodeFindFirstOrThrowArgs<ExtArgs>>): Prisma__CurrencyIsoCodeClient<$Result.GetResult<Prisma.$CurrencyIsoCodePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more CurrencyIsoCodes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyIsoCodeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CurrencyIsoCodes
     * const currencyIsoCodes = await prisma.currencyIsoCode.findMany()
     * 
     * // Get first 10 CurrencyIsoCodes
     * const currencyIsoCodes = await prisma.currencyIsoCode.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const currencyIsoCodeWithIdOnly = await prisma.currencyIsoCode.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CurrencyIsoCodeFindManyArgs>(args?: SelectSubset<T, CurrencyIsoCodeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CurrencyIsoCodePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a CurrencyIsoCode.
     * @param {CurrencyIsoCodeCreateArgs} args - Arguments to create a CurrencyIsoCode.
     * @example
     * // Create one CurrencyIsoCode
     * const CurrencyIsoCode = await prisma.currencyIsoCode.create({
     *   data: {
     *     // ... data to create a CurrencyIsoCode
     *   }
     * })
     * 
     */
    create<T extends CurrencyIsoCodeCreateArgs>(args: SelectSubset<T, CurrencyIsoCodeCreateArgs<ExtArgs>>): Prisma__CurrencyIsoCodeClient<$Result.GetResult<Prisma.$CurrencyIsoCodePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many CurrencyIsoCodes.
     * @param {CurrencyIsoCodeCreateManyArgs} args - Arguments to create many CurrencyIsoCodes.
     * @example
     * // Create many CurrencyIsoCodes
     * const currencyIsoCode = await prisma.currencyIsoCode.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CurrencyIsoCodeCreateManyArgs>(args?: SelectSubset<T, CurrencyIsoCodeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CurrencyIsoCode.
     * @param {CurrencyIsoCodeDeleteArgs} args - Arguments to delete one CurrencyIsoCode.
     * @example
     * // Delete one CurrencyIsoCode
     * const CurrencyIsoCode = await prisma.currencyIsoCode.delete({
     *   where: {
     *     // ... filter to delete one CurrencyIsoCode
     *   }
     * })
     * 
     */
    delete<T extends CurrencyIsoCodeDeleteArgs>(args: SelectSubset<T, CurrencyIsoCodeDeleteArgs<ExtArgs>>): Prisma__CurrencyIsoCodeClient<$Result.GetResult<Prisma.$CurrencyIsoCodePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one CurrencyIsoCode.
     * @param {CurrencyIsoCodeUpdateArgs} args - Arguments to update one CurrencyIsoCode.
     * @example
     * // Update one CurrencyIsoCode
     * const currencyIsoCode = await prisma.currencyIsoCode.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CurrencyIsoCodeUpdateArgs>(args: SelectSubset<T, CurrencyIsoCodeUpdateArgs<ExtArgs>>): Prisma__CurrencyIsoCodeClient<$Result.GetResult<Prisma.$CurrencyIsoCodePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more CurrencyIsoCodes.
     * @param {CurrencyIsoCodeDeleteManyArgs} args - Arguments to filter CurrencyIsoCodes to delete.
     * @example
     * // Delete a few CurrencyIsoCodes
     * const { count } = await prisma.currencyIsoCode.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CurrencyIsoCodeDeleteManyArgs>(args?: SelectSubset<T, CurrencyIsoCodeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CurrencyIsoCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyIsoCodeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CurrencyIsoCodes
     * const currencyIsoCode = await prisma.currencyIsoCode.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CurrencyIsoCodeUpdateManyArgs>(args: SelectSubset<T, CurrencyIsoCodeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CurrencyIsoCode.
     * @param {CurrencyIsoCodeUpsertArgs} args - Arguments to update or create a CurrencyIsoCode.
     * @example
     * // Update or create a CurrencyIsoCode
     * const currencyIsoCode = await prisma.currencyIsoCode.upsert({
     *   create: {
     *     // ... data to create a CurrencyIsoCode
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CurrencyIsoCode we want to update
     *   }
     * })
     */
    upsert<T extends CurrencyIsoCodeUpsertArgs>(args: SelectSubset<T, CurrencyIsoCodeUpsertArgs<ExtArgs>>): Prisma__CurrencyIsoCodeClient<$Result.GetResult<Prisma.$CurrencyIsoCodePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more CurrencyIsoCodes that matches the filter.
     * @param {CurrencyIsoCodeFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const currencyIsoCode = await prisma.currencyIsoCode.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: CurrencyIsoCodeFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a CurrencyIsoCode.
     * @param {CurrencyIsoCodeAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const currencyIsoCode = await prisma.currencyIsoCode.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: CurrencyIsoCodeAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of CurrencyIsoCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyIsoCodeCountArgs} args - Arguments to filter CurrencyIsoCodes to count.
     * @example
     * // Count the number of CurrencyIsoCodes
     * const count = await prisma.currencyIsoCode.count({
     *   where: {
     *     // ... the filter for the CurrencyIsoCodes we want to count
     *   }
     * })
    **/
    count<T extends CurrencyIsoCodeCountArgs>(
      args?: Subset<T, CurrencyIsoCodeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CurrencyIsoCodeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CurrencyIsoCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyIsoCodeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CurrencyIsoCodeAggregateArgs>(args: Subset<T, CurrencyIsoCodeAggregateArgs>): Prisma.PrismaPromise<GetCurrencyIsoCodeAggregateType<T>>

    /**
     * Group by CurrencyIsoCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyIsoCodeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CurrencyIsoCodeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CurrencyIsoCodeGroupByArgs['orderBy'] }
        : { orderBy?: CurrencyIsoCodeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CurrencyIsoCodeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCurrencyIsoCodeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CurrencyIsoCode model
   */
  readonly fields: CurrencyIsoCodeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CurrencyIsoCode.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CurrencyIsoCodeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    currencies<T extends CurrencyIsoCode$currenciesArgs<ExtArgs> = {}>(args?: Subset<T, CurrencyIsoCode$currenciesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    config<T extends CurrencyIsoCode$configArgs<ExtArgs> = {}>(args?: Subset<T, CurrencyIsoCode$configArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConfigPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CurrencyIsoCode model
   */ 
  interface CurrencyIsoCodeFieldRefs {
    readonly id: FieldRef<"CurrencyIsoCode", 'String'>
    readonly code: FieldRef<"CurrencyIsoCode", 'String'>
    readonly name: FieldRef<"CurrencyIsoCode", 'String'>
    readonly createdAt: FieldRef<"CurrencyIsoCode", 'DateTime'>
    readonly updatedAt: FieldRef<"CurrencyIsoCode", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CurrencyIsoCode findUnique
   */
  export type CurrencyIsoCodeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurrencyIsoCode
     */
    select?: CurrencyIsoCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CurrencyIsoCode
     */
    omit?: CurrencyIsoCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyIsoCodeInclude<ExtArgs> | null
    /**
     * Filter, which CurrencyIsoCode to fetch.
     */
    where: CurrencyIsoCodeWhereUniqueInput
  }

  /**
   * CurrencyIsoCode findUniqueOrThrow
   */
  export type CurrencyIsoCodeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurrencyIsoCode
     */
    select?: CurrencyIsoCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CurrencyIsoCode
     */
    omit?: CurrencyIsoCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyIsoCodeInclude<ExtArgs> | null
    /**
     * Filter, which CurrencyIsoCode to fetch.
     */
    where: CurrencyIsoCodeWhereUniqueInput
  }

  /**
   * CurrencyIsoCode findFirst
   */
  export type CurrencyIsoCodeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurrencyIsoCode
     */
    select?: CurrencyIsoCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CurrencyIsoCode
     */
    omit?: CurrencyIsoCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyIsoCodeInclude<ExtArgs> | null
    /**
     * Filter, which CurrencyIsoCode to fetch.
     */
    where?: CurrencyIsoCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CurrencyIsoCodes to fetch.
     */
    orderBy?: CurrencyIsoCodeOrderByWithRelationInput | CurrencyIsoCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CurrencyIsoCodes.
     */
    cursor?: CurrencyIsoCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CurrencyIsoCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CurrencyIsoCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CurrencyIsoCodes.
     */
    distinct?: CurrencyIsoCodeScalarFieldEnum | CurrencyIsoCodeScalarFieldEnum[]
  }

  /**
   * CurrencyIsoCode findFirstOrThrow
   */
  export type CurrencyIsoCodeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurrencyIsoCode
     */
    select?: CurrencyIsoCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CurrencyIsoCode
     */
    omit?: CurrencyIsoCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyIsoCodeInclude<ExtArgs> | null
    /**
     * Filter, which CurrencyIsoCode to fetch.
     */
    where?: CurrencyIsoCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CurrencyIsoCodes to fetch.
     */
    orderBy?: CurrencyIsoCodeOrderByWithRelationInput | CurrencyIsoCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CurrencyIsoCodes.
     */
    cursor?: CurrencyIsoCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CurrencyIsoCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CurrencyIsoCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CurrencyIsoCodes.
     */
    distinct?: CurrencyIsoCodeScalarFieldEnum | CurrencyIsoCodeScalarFieldEnum[]
  }

  /**
   * CurrencyIsoCode findMany
   */
  export type CurrencyIsoCodeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurrencyIsoCode
     */
    select?: CurrencyIsoCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CurrencyIsoCode
     */
    omit?: CurrencyIsoCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyIsoCodeInclude<ExtArgs> | null
    /**
     * Filter, which CurrencyIsoCodes to fetch.
     */
    where?: CurrencyIsoCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CurrencyIsoCodes to fetch.
     */
    orderBy?: CurrencyIsoCodeOrderByWithRelationInput | CurrencyIsoCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CurrencyIsoCodes.
     */
    cursor?: CurrencyIsoCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CurrencyIsoCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CurrencyIsoCodes.
     */
    skip?: number
    distinct?: CurrencyIsoCodeScalarFieldEnum | CurrencyIsoCodeScalarFieldEnum[]
  }

  /**
   * CurrencyIsoCode create
   */
  export type CurrencyIsoCodeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurrencyIsoCode
     */
    select?: CurrencyIsoCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CurrencyIsoCode
     */
    omit?: CurrencyIsoCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyIsoCodeInclude<ExtArgs> | null
    /**
     * The data needed to create a CurrencyIsoCode.
     */
    data: XOR<CurrencyIsoCodeCreateInput, CurrencyIsoCodeUncheckedCreateInput>
  }

  /**
   * CurrencyIsoCode createMany
   */
  export type CurrencyIsoCodeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CurrencyIsoCodes.
     */
    data: CurrencyIsoCodeCreateManyInput | CurrencyIsoCodeCreateManyInput[]
  }

  /**
   * CurrencyIsoCode update
   */
  export type CurrencyIsoCodeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurrencyIsoCode
     */
    select?: CurrencyIsoCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CurrencyIsoCode
     */
    omit?: CurrencyIsoCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyIsoCodeInclude<ExtArgs> | null
    /**
     * The data needed to update a CurrencyIsoCode.
     */
    data: XOR<CurrencyIsoCodeUpdateInput, CurrencyIsoCodeUncheckedUpdateInput>
    /**
     * Choose, which CurrencyIsoCode to update.
     */
    where: CurrencyIsoCodeWhereUniqueInput
  }

  /**
   * CurrencyIsoCode updateMany
   */
  export type CurrencyIsoCodeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CurrencyIsoCodes.
     */
    data: XOR<CurrencyIsoCodeUpdateManyMutationInput, CurrencyIsoCodeUncheckedUpdateManyInput>
    /**
     * Filter which CurrencyIsoCodes to update
     */
    where?: CurrencyIsoCodeWhereInput
    /**
     * Limit how many CurrencyIsoCodes to update.
     */
    limit?: number
  }

  /**
   * CurrencyIsoCode upsert
   */
  export type CurrencyIsoCodeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurrencyIsoCode
     */
    select?: CurrencyIsoCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CurrencyIsoCode
     */
    omit?: CurrencyIsoCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyIsoCodeInclude<ExtArgs> | null
    /**
     * The filter to search for the CurrencyIsoCode to update in case it exists.
     */
    where: CurrencyIsoCodeWhereUniqueInput
    /**
     * In case the CurrencyIsoCode found by the `where` argument doesn't exist, create a new CurrencyIsoCode with this data.
     */
    create: XOR<CurrencyIsoCodeCreateInput, CurrencyIsoCodeUncheckedCreateInput>
    /**
     * In case the CurrencyIsoCode was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CurrencyIsoCodeUpdateInput, CurrencyIsoCodeUncheckedUpdateInput>
  }

  /**
   * CurrencyIsoCode delete
   */
  export type CurrencyIsoCodeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurrencyIsoCode
     */
    select?: CurrencyIsoCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CurrencyIsoCode
     */
    omit?: CurrencyIsoCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyIsoCodeInclude<ExtArgs> | null
    /**
     * Filter which CurrencyIsoCode to delete.
     */
    where: CurrencyIsoCodeWhereUniqueInput
  }

  /**
   * CurrencyIsoCode deleteMany
   */
  export type CurrencyIsoCodeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CurrencyIsoCodes to delete
     */
    where?: CurrencyIsoCodeWhereInput
    /**
     * Limit how many CurrencyIsoCodes to delete.
     */
    limit?: number
  }

  /**
   * CurrencyIsoCode findRaw
   */
  export type CurrencyIsoCodeFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * CurrencyIsoCode aggregateRaw
   */
  export type CurrencyIsoCodeAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * CurrencyIsoCode.currencies
   */
  export type CurrencyIsoCode$currenciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyInclude<ExtArgs> | null
    where?: CurrencyWhereInput
    orderBy?: CurrencyOrderByWithRelationInput | CurrencyOrderByWithRelationInput[]
    cursor?: CurrencyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CurrencyScalarFieldEnum | CurrencyScalarFieldEnum[]
  }

  /**
   * CurrencyIsoCode.config
   */
  export type CurrencyIsoCode$configArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Config
     */
    select?: ConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Config
     */
    omit?: ConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigInclude<ExtArgs> | null
    where?: ConfigWhereInput
    orderBy?: ConfigOrderByWithRelationInput | ConfigOrderByWithRelationInput[]
    cursor?: ConfigWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConfigScalarFieldEnum | ConfigScalarFieldEnum[]
  }

  /**
   * CurrencyIsoCode without action
   */
  export type CurrencyIsoCodeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurrencyIsoCode
     */
    select?: CurrencyIsoCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CurrencyIsoCode
     */
    omit?: CurrencyIsoCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyIsoCodeInclude<ExtArgs> | null
  }


  /**
   * Model Currency
   */

  export type AggregateCurrency = {
    _count: CurrencyCountAggregateOutputType | null
    _avg: CurrencyAvgAggregateOutputType | null
    _sum: CurrencySumAggregateOutputType | null
    _min: CurrencyMinAggregateOutputType | null
    _max: CurrencyMaxAggregateOutputType | null
  }

  export type CurrencyAvgAggregateOutputType = {
    assignedLevels: number | null
  }

  export type CurrencySumAggregateOutputType = {
    assignedLevels: number | null
  }

  export type CurrencyMinAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    currencyIsoCodeId: string | null
    assignedLevels: number | null
    isDefault: $Enums.YesNo | null
    clientId: string | null
    instanceId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CurrencyMaxAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    currencyIsoCodeId: string | null
    assignedLevels: number | null
    isDefault: $Enums.YesNo | null
    clientId: string | null
    instanceId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CurrencyCountAggregateOutputType = {
    id: number
    name: number
    code: number
    currencyIsoCodeId: number
    assignedLevels: number
    isDefault: number
    clientId: number
    instanceId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CurrencyAvgAggregateInputType = {
    assignedLevels?: true
  }

  export type CurrencySumAggregateInputType = {
    assignedLevels?: true
  }

  export type CurrencyMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
    currencyIsoCodeId?: true
    assignedLevels?: true
    isDefault?: true
    clientId?: true
    instanceId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CurrencyMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
    currencyIsoCodeId?: true
    assignedLevels?: true
    isDefault?: true
    clientId?: true
    instanceId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CurrencyCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    currencyIsoCodeId?: true
    assignedLevels?: true
    isDefault?: true
    clientId?: true
    instanceId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CurrencyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Currency to aggregate.
     */
    where?: CurrencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Currencies to fetch.
     */
    orderBy?: CurrencyOrderByWithRelationInput | CurrencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CurrencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Currencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Currencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Currencies
    **/
    _count?: true | CurrencyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CurrencyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CurrencySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CurrencyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CurrencyMaxAggregateInputType
  }

  export type GetCurrencyAggregateType<T extends CurrencyAggregateArgs> = {
        [P in keyof T & keyof AggregateCurrency]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCurrency[P]>
      : GetScalarType<T[P], AggregateCurrency[P]>
  }




  export type CurrencyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CurrencyWhereInput
    orderBy?: CurrencyOrderByWithAggregationInput | CurrencyOrderByWithAggregationInput[]
    by: CurrencyScalarFieldEnum[] | CurrencyScalarFieldEnum
    having?: CurrencyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CurrencyCountAggregateInputType | true
    _avg?: CurrencyAvgAggregateInputType
    _sum?: CurrencySumAggregateInputType
    _min?: CurrencyMinAggregateInputType
    _max?: CurrencyMaxAggregateInputType
  }

  export type CurrencyGroupByOutputType = {
    id: string
    name: string
    code: string
    currencyIsoCodeId: string
    assignedLevels: number
    isDefault: $Enums.YesNo
    clientId: string
    instanceId: string
    createdAt: Date | null
    updatedAt: Date | null
    _count: CurrencyCountAggregateOutputType | null
    _avg: CurrencyAvgAggregateOutputType | null
    _sum: CurrencySumAggregateOutputType | null
    _min: CurrencyMinAggregateOutputType | null
    _max: CurrencyMaxAggregateOutputType | null
  }

  type GetCurrencyGroupByPayload<T extends CurrencyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CurrencyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CurrencyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CurrencyGroupByOutputType[P]>
            : GetScalarType<T[P], CurrencyGroupByOutputType[P]>
        }
      >
    >


  export type CurrencySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    currencyIsoCodeId?: boolean
    assignedLevels?: boolean
    isDefault?: boolean
    clientId?: boolean
    instanceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    currencyIsoCode?: boolean | CurrencyIsoCodeDefaultArgs<ExtArgs>
    instance?: boolean | InstanceDefaultArgs<ExtArgs>
    levels?: boolean | Currency$levelsArgs<ExtArgs>
    defaults?: boolean | Currency$defaultsArgs<ExtArgs>
    _count?: boolean | CurrencyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["currency"]>



  export type CurrencySelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
    currencyIsoCodeId?: boolean
    assignedLevels?: boolean
    isDefault?: boolean
    clientId?: boolean
    instanceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CurrencyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "code" | "currencyIsoCodeId" | "assignedLevels" | "isDefault" | "clientId" | "instanceId" | "createdAt" | "updatedAt", ExtArgs["result"]["currency"]>
  export type CurrencyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    currencyIsoCode?: boolean | CurrencyIsoCodeDefaultArgs<ExtArgs>
    instance?: boolean | InstanceDefaultArgs<ExtArgs>
    levels?: boolean | Currency$levelsArgs<ExtArgs>
    defaults?: boolean | Currency$defaultsArgs<ExtArgs>
    _count?: boolean | CurrencyCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CurrencyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Currency"
    objects: {
      currencyIsoCode: Prisma.$CurrencyIsoCodePayload<ExtArgs>
      instance: Prisma.$InstancePayload<ExtArgs>
      levels: Prisma.$LevelPayload<ExtArgs>[]
      defaults: Prisma.$ConfigPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      code: string
      currencyIsoCodeId: string
      assignedLevels: number
      isDefault: $Enums.YesNo
      clientId: string
      instanceId: string
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["currency"]>
    composites: {}
  }

  type CurrencyGetPayload<S extends boolean | null | undefined | CurrencyDefaultArgs> = $Result.GetResult<Prisma.$CurrencyPayload, S>

  type CurrencyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CurrencyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CurrencyCountAggregateInputType | true
    }

  export interface CurrencyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Currency'], meta: { name: 'Currency' } }
    /**
     * Find zero or one Currency that matches the filter.
     * @param {CurrencyFindUniqueArgs} args - Arguments to find a Currency
     * @example
     * // Get one Currency
     * const currency = await prisma.currency.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CurrencyFindUniqueArgs>(args: SelectSubset<T, CurrencyFindUniqueArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Currency that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CurrencyFindUniqueOrThrowArgs} args - Arguments to find a Currency
     * @example
     * // Get one Currency
     * const currency = await prisma.currency.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CurrencyFindUniqueOrThrowArgs>(args: SelectSubset<T, CurrencyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Currency that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyFindFirstArgs} args - Arguments to find a Currency
     * @example
     * // Get one Currency
     * const currency = await prisma.currency.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CurrencyFindFirstArgs>(args?: SelectSubset<T, CurrencyFindFirstArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Currency that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyFindFirstOrThrowArgs} args - Arguments to find a Currency
     * @example
     * // Get one Currency
     * const currency = await prisma.currency.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CurrencyFindFirstOrThrowArgs>(args?: SelectSubset<T, CurrencyFindFirstOrThrowArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Currencies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Currencies
     * const currencies = await prisma.currency.findMany()
     * 
     * // Get first 10 Currencies
     * const currencies = await prisma.currency.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const currencyWithIdOnly = await prisma.currency.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CurrencyFindManyArgs>(args?: SelectSubset<T, CurrencyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Currency.
     * @param {CurrencyCreateArgs} args - Arguments to create a Currency.
     * @example
     * // Create one Currency
     * const Currency = await prisma.currency.create({
     *   data: {
     *     // ... data to create a Currency
     *   }
     * })
     * 
     */
    create<T extends CurrencyCreateArgs>(args: SelectSubset<T, CurrencyCreateArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Currencies.
     * @param {CurrencyCreateManyArgs} args - Arguments to create many Currencies.
     * @example
     * // Create many Currencies
     * const currency = await prisma.currency.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CurrencyCreateManyArgs>(args?: SelectSubset<T, CurrencyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Currency.
     * @param {CurrencyDeleteArgs} args - Arguments to delete one Currency.
     * @example
     * // Delete one Currency
     * const Currency = await prisma.currency.delete({
     *   where: {
     *     // ... filter to delete one Currency
     *   }
     * })
     * 
     */
    delete<T extends CurrencyDeleteArgs>(args: SelectSubset<T, CurrencyDeleteArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Currency.
     * @param {CurrencyUpdateArgs} args - Arguments to update one Currency.
     * @example
     * // Update one Currency
     * const currency = await prisma.currency.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CurrencyUpdateArgs>(args: SelectSubset<T, CurrencyUpdateArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Currencies.
     * @param {CurrencyDeleteManyArgs} args - Arguments to filter Currencies to delete.
     * @example
     * // Delete a few Currencies
     * const { count } = await prisma.currency.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CurrencyDeleteManyArgs>(args?: SelectSubset<T, CurrencyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Currencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Currencies
     * const currency = await prisma.currency.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CurrencyUpdateManyArgs>(args: SelectSubset<T, CurrencyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Currency.
     * @param {CurrencyUpsertArgs} args - Arguments to update or create a Currency.
     * @example
     * // Update or create a Currency
     * const currency = await prisma.currency.upsert({
     *   create: {
     *     // ... data to create a Currency
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Currency we want to update
     *   }
     * })
     */
    upsert<T extends CurrencyUpsertArgs>(args: SelectSubset<T, CurrencyUpsertArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Currencies that matches the filter.
     * @param {CurrencyFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const currency = await prisma.currency.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: CurrencyFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Currency.
     * @param {CurrencyAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const currency = await prisma.currency.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: CurrencyAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Currencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyCountArgs} args - Arguments to filter Currencies to count.
     * @example
     * // Count the number of Currencies
     * const count = await prisma.currency.count({
     *   where: {
     *     // ... the filter for the Currencies we want to count
     *   }
     * })
    **/
    count<T extends CurrencyCountArgs>(
      args?: Subset<T, CurrencyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CurrencyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Currency.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CurrencyAggregateArgs>(args: Subset<T, CurrencyAggregateArgs>): Prisma.PrismaPromise<GetCurrencyAggregateType<T>>

    /**
     * Group by Currency.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CurrencyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CurrencyGroupByArgs['orderBy'] }
        : { orderBy?: CurrencyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CurrencyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCurrencyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Currency model
   */
  readonly fields: CurrencyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Currency.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CurrencyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    currencyIsoCode<T extends CurrencyIsoCodeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CurrencyIsoCodeDefaultArgs<ExtArgs>>): Prisma__CurrencyIsoCodeClient<$Result.GetResult<Prisma.$CurrencyIsoCodePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    instance<T extends InstanceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InstanceDefaultArgs<ExtArgs>>): Prisma__InstanceClient<$Result.GetResult<Prisma.$InstancePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    levels<T extends Currency$levelsArgs<ExtArgs> = {}>(args?: Subset<T, Currency$levelsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LevelPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    defaults<T extends Currency$defaultsArgs<ExtArgs> = {}>(args?: Subset<T, Currency$defaultsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConfigPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Currency model
   */ 
  interface CurrencyFieldRefs {
    readonly id: FieldRef<"Currency", 'String'>
    readonly name: FieldRef<"Currency", 'String'>
    readonly code: FieldRef<"Currency", 'String'>
    readonly currencyIsoCodeId: FieldRef<"Currency", 'String'>
    readonly assignedLevels: FieldRef<"Currency", 'Int'>
    readonly isDefault: FieldRef<"Currency", 'YesNo'>
    readonly clientId: FieldRef<"Currency", 'String'>
    readonly instanceId: FieldRef<"Currency", 'String'>
    readonly createdAt: FieldRef<"Currency", 'DateTime'>
    readonly updatedAt: FieldRef<"Currency", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Currency findUnique
   */
  export type CurrencyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyInclude<ExtArgs> | null
    /**
     * Filter, which Currency to fetch.
     */
    where: CurrencyWhereUniqueInput
  }

  /**
   * Currency findUniqueOrThrow
   */
  export type CurrencyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyInclude<ExtArgs> | null
    /**
     * Filter, which Currency to fetch.
     */
    where: CurrencyWhereUniqueInput
  }

  /**
   * Currency findFirst
   */
  export type CurrencyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyInclude<ExtArgs> | null
    /**
     * Filter, which Currency to fetch.
     */
    where?: CurrencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Currencies to fetch.
     */
    orderBy?: CurrencyOrderByWithRelationInput | CurrencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Currencies.
     */
    cursor?: CurrencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Currencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Currencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Currencies.
     */
    distinct?: CurrencyScalarFieldEnum | CurrencyScalarFieldEnum[]
  }

  /**
   * Currency findFirstOrThrow
   */
  export type CurrencyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyInclude<ExtArgs> | null
    /**
     * Filter, which Currency to fetch.
     */
    where?: CurrencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Currencies to fetch.
     */
    orderBy?: CurrencyOrderByWithRelationInput | CurrencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Currencies.
     */
    cursor?: CurrencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Currencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Currencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Currencies.
     */
    distinct?: CurrencyScalarFieldEnum | CurrencyScalarFieldEnum[]
  }

  /**
   * Currency findMany
   */
  export type CurrencyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyInclude<ExtArgs> | null
    /**
     * Filter, which Currencies to fetch.
     */
    where?: CurrencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Currencies to fetch.
     */
    orderBy?: CurrencyOrderByWithRelationInput | CurrencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Currencies.
     */
    cursor?: CurrencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Currencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Currencies.
     */
    skip?: number
    distinct?: CurrencyScalarFieldEnum | CurrencyScalarFieldEnum[]
  }

  /**
   * Currency create
   */
  export type CurrencyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyInclude<ExtArgs> | null
    /**
     * The data needed to create a Currency.
     */
    data: XOR<CurrencyCreateInput, CurrencyUncheckedCreateInput>
  }

  /**
   * Currency createMany
   */
  export type CurrencyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Currencies.
     */
    data: CurrencyCreateManyInput | CurrencyCreateManyInput[]
  }

  /**
   * Currency update
   */
  export type CurrencyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyInclude<ExtArgs> | null
    /**
     * The data needed to update a Currency.
     */
    data: XOR<CurrencyUpdateInput, CurrencyUncheckedUpdateInput>
    /**
     * Choose, which Currency to update.
     */
    where: CurrencyWhereUniqueInput
  }

  /**
   * Currency updateMany
   */
  export type CurrencyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Currencies.
     */
    data: XOR<CurrencyUpdateManyMutationInput, CurrencyUncheckedUpdateManyInput>
    /**
     * Filter which Currencies to update
     */
    where?: CurrencyWhereInput
    /**
     * Limit how many Currencies to update.
     */
    limit?: number
  }

  /**
   * Currency upsert
   */
  export type CurrencyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyInclude<ExtArgs> | null
    /**
     * The filter to search for the Currency to update in case it exists.
     */
    where: CurrencyWhereUniqueInput
    /**
     * In case the Currency found by the `where` argument doesn't exist, create a new Currency with this data.
     */
    create: XOR<CurrencyCreateInput, CurrencyUncheckedCreateInput>
    /**
     * In case the Currency was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CurrencyUpdateInput, CurrencyUncheckedUpdateInput>
  }

  /**
   * Currency delete
   */
  export type CurrencyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyInclude<ExtArgs> | null
    /**
     * Filter which Currency to delete.
     */
    where: CurrencyWhereUniqueInput
  }

  /**
   * Currency deleteMany
   */
  export type CurrencyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Currencies to delete
     */
    where?: CurrencyWhereInput
    /**
     * Limit how many Currencies to delete.
     */
    limit?: number
  }

  /**
   * Currency findRaw
   */
  export type CurrencyFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Currency aggregateRaw
   */
  export type CurrencyAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Currency.levels
   */
  export type Currency$levelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Level
     */
    omit?: LevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelInclude<ExtArgs> | null
    where?: LevelWhereInput
    orderBy?: LevelOrderByWithRelationInput | LevelOrderByWithRelationInput[]
    cursor?: LevelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LevelScalarFieldEnum | LevelScalarFieldEnum[]
  }

  /**
   * Currency.defaults
   */
  export type Currency$defaultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Config
     */
    select?: ConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Config
     */
    omit?: ConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigInclude<ExtArgs> | null
    where?: ConfigWhereInput
    orderBy?: ConfigOrderByWithRelationInput | ConfigOrderByWithRelationInput[]
    cursor?: ConfigWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConfigScalarFieldEnum | ConfigScalarFieldEnum[]
  }

  /**
   * Currency without action
   */
  export type CurrencyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyInclude<ExtArgs> | null
  }


  /**
   * Model Level
   */

  export type AggregateLevel = {
    _count: LevelCountAggregateOutputType | null
    _min: LevelMinAggregateOutputType | null
    _max: LevelMaxAggregateOutputType | null
  }

  export type LevelMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    isRoot: boolean | null
    description: string | null
    parentId: string | null
    clientId: string | null
    instanceId: string | null
    currencyId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LevelMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    isRoot: boolean | null
    description: string | null
    parentId: string | null
    clientId: string | null
    instanceId: string | null
    currencyId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LevelCountAggregateOutputType = {
    id: number
    code: number
    name: number
    isRoot: number
    description: number
    parentId: number
    clientId: number
    instanceId: number
    currencyId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LevelMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    isRoot?: true
    description?: true
    parentId?: true
    clientId?: true
    instanceId?: true
    currencyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LevelMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    isRoot?: true
    description?: true
    parentId?: true
    clientId?: true
    instanceId?: true
    currencyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LevelCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    isRoot?: true
    description?: true
    parentId?: true
    clientId?: true
    instanceId?: true
    currencyId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LevelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Level to aggregate.
     */
    where?: LevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Levels to fetch.
     */
    orderBy?: LevelOrderByWithRelationInput | LevelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Levels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Levels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Levels
    **/
    _count?: true | LevelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LevelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LevelMaxAggregateInputType
  }

  export type GetLevelAggregateType<T extends LevelAggregateArgs> = {
        [P in keyof T & keyof AggregateLevel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLevel[P]>
      : GetScalarType<T[P], AggregateLevel[P]>
  }




  export type LevelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LevelWhereInput
    orderBy?: LevelOrderByWithAggregationInput | LevelOrderByWithAggregationInput[]
    by: LevelScalarFieldEnum[] | LevelScalarFieldEnum
    having?: LevelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LevelCountAggregateInputType | true
    _min?: LevelMinAggregateInputType
    _max?: LevelMaxAggregateInputType
  }

  export type LevelGroupByOutputType = {
    id: string
    code: string
    name: string
    isRoot: boolean
    description: string | null
    parentId: string | null
    clientId: string
    instanceId: string
    currencyId: string
    createdAt: Date | null
    updatedAt: Date | null
    _count: LevelCountAggregateOutputType | null
    _min: LevelMinAggregateOutputType | null
    _max: LevelMaxAggregateOutputType | null
  }

  type GetLevelGroupByPayload<T extends LevelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LevelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LevelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LevelGroupByOutputType[P]>
            : GetScalarType<T[P], LevelGroupByOutputType[P]>
        }
      >
    >


  export type LevelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    isRoot?: boolean
    description?: boolean
    parentId?: boolean
    clientId?: boolean
    instanceId?: boolean
    currencyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    AttributeAndValues?: boolean | Level$AttributeAndValuesArgs<ExtArgs>
    parent?: boolean | Level$parentArgs<ExtArgs>
    instance?: boolean | InstanceDefaultArgs<ExtArgs>
    currency?: boolean | CurrencyDefaultArgs<ExtArgs>
    childLevels?: boolean | Level$childLevelsArgs<ExtArgs>
    modelData?: boolean | Level$modelDataArgs<ExtArgs>
    modeldataCalculations?: boolean | Level$modeldataCalculationsArgs<ExtArgs>
    _count?: boolean | LevelCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["level"]>



  export type LevelSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    isRoot?: boolean
    description?: boolean
    parentId?: boolean
    clientId?: boolean
    instanceId?: boolean
    currencyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LevelOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "name" | "isRoot" | "description" | "parentId" | "clientId" | "instanceId" | "currencyId" | "createdAt" | "updatedAt", ExtArgs["result"]["level"]>
  export type LevelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AttributeAndValues?: boolean | Level$AttributeAndValuesArgs<ExtArgs>
    parent?: boolean | Level$parentArgs<ExtArgs>
    instance?: boolean | InstanceDefaultArgs<ExtArgs>
    currency?: boolean | CurrencyDefaultArgs<ExtArgs>
    childLevels?: boolean | Level$childLevelsArgs<ExtArgs>
    modelData?: boolean | Level$modelDataArgs<ExtArgs>
    modeldataCalculations?: boolean | Level$modeldataCalculationsArgs<ExtArgs>
    _count?: boolean | LevelCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $LevelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Level"
    objects: {
      AttributeAndValues: Prisma.$LevelAttributeAndValuePayload<ExtArgs>[]
      parent: Prisma.$LevelPayload<ExtArgs> | null
      instance: Prisma.$InstancePayload<ExtArgs>
      currency: Prisma.$CurrencyPayload<ExtArgs>
      childLevels: Prisma.$LevelPayload<ExtArgs>[]
      modelData: Prisma.$ModelDataPayload<ExtArgs>[]
      modeldataCalculations: Prisma.$ModelDataCalculationsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      name: string
      isRoot: boolean
      description: string | null
      parentId: string | null
      clientId: string
      instanceId: string
      currencyId: string
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["level"]>
    composites: {}
  }

  type LevelGetPayload<S extends boolean | null | undefined | LevelDefaultArgs> = $Result.GetResult<Prisma.$LevelPayload, S>

  type LevelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LevelFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LevelCountAggregateInputType | true
    }

  export interface LevelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Level'], meta: { name: 'Level' } }
    /**
     * Find zero or one Level that matches the filter.
     * @param {LevelFindUniqueArgs} args - Arguments to find a Level
     * @example
     * // Get one Level
     * const level = await prisma.level.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LevelFindUniqueArgs>(args: SelectSubset<T, LevelFindUniqueArgs<ExtArgs>>): Prisma__LevelClient<$Result.GetResult<Prisma.$LevelPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Level that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LevelFindUniqueOrThrowArgs} args - Arguments to find a Level
     * @example
     * // Get one Level
     * const level = await prisma.level.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LevelFindUniqueOrThrowArgs>(args: SelectSubset<T, LevelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LevelClient<$Result.GetResult<Prisma.$LevelPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Level that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevelFindFirstArgs} args - Arguments to find a Level
     * @example
     * // Get one Level
     * const level = await prisma.level.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LevelFindFirstArgs>(args?: SelectSubset<T, LevelFindFirstArgs<ExtArgs>>): Prisma__LevelClient<$Result.GetResult<Prisma.$LevelPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Level that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevelFindFirstOrThrowArgs} args - Arguments to find a Level
     * @example
     * // Get one Level
     * const level = await prisma.level.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LevelFindFirstOrThrowArgs>(args?: SelectSubset<T, LevelFindFirstOrThrowArgs<ExtArgs>>): Prisma__LevelClient<$Result.GetResult<Prisma.$LevelPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Levels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Levels
     * const levels = await prisma.level.findMany()
     * 
     * // Get first 10 Levels
     * const levels = await prisma.level.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const levelWithIdOnly = await prisma.level.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LevelFindManyArgs>(args?: SelectSubset<T, LevelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LevelPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Level.
     * @param {LevelCreateArgs} args - Arguments to create a Level.
     * @example
     * // Create one Level
     * const Level = await prisma.level.create({
     *   data: {
     *     // ... data to create a Level
     *   }
     * })
     * 
     */
    create<T extends LevelCreateArgs>(args: SelectSubset<T, LevelCreateArgs<ExtArgs>>): Prisma__LevelClient<$Result.GetResult<Prisma.$LevelPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Levels.
     * @param {LevelCreateManyArgs} args - Arguments to create many Levels.
     * @example
     * // Create many Levels
     * const level = await prisma.level.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LevelCreateManyArgs>(args?: SelectSubset<T, LevelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Level.
     * @param {LevelDeleteArgs} args - Arguments to delete one Level.
     * @example
     * // Delete one Level
     * const Level = await prisma.level.delete({
     *   where: {
     *     // ... filter to delete one Level
     *   }
     * })
     * 
     */
    delete<T extends LevelDeleteArgs>(args: SelectSubset<T, LevelDeleteArgs<ExtArgs>>): Prisma__LevelClient<$Result.GetResult<Prisma.$LevelPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Level.
     * @param {LevelUpdateArgs} args - Arguments to update one Level.
     * @example
     * // Update one Level
     * const level = await prisma.level.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LevelUpdateArgs>(args: SelectSubset<T, LevelUpdateArgs<ExtArgs>>): Prisma__LevelClient<$Result.GetResult<Prisma.$LevelPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Levels.
     * @param {LevelDeleteManyArgs} args - Arguments to filter Levels to delete.
     * @example
     * // Delete a few Levels
     * const { count } = await prisma.level.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LevelDeleteManyArgs>(args?: SelectSubset<T, LevelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Levels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Levels
     * const level = await prisma.level.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LevelUpdateManyArgs>(args: SelectSubset<T, LevelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Level.
     * @param {LevelUpsertArgs} args - Arguments to update or create a Level.
     * @example
     * // Update or create a Level
     * const level = await prisma.level.upsert({
     *   create: {
     *     // ... data to create a Level
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Level we want to update
     *   }
     * })
     */
    upsert<T extends LevelUpsertArgs>(args: SelectSubset<T, LevelUpsertArgs<ExtArgs>>): Prisma__LevelClient<$Result.GetResult<Prisma.$LevelPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Levels that matches the filter.
     * @param {LevelFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const level = await prisma.level.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: LevelFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Level.
     * @param {LevelAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const level = await prisma.level.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: LevelAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Levels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevelCountArgs} args - Arguments to filter Levels to count.
     * @example
     * // Count the number of Levels
     * const count = await prisma.level.count({
     *   where: {
     *     // ... the filter for the Levels we want to count
     *   }
     * })
    **/
    count<T extends LevelCountArgs>(
      args?: Subset<T, LevelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LevelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Level.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LevelAggregateArgs>(args: Subset<T, LevelAggregateArgs>): Prisma.PrismaPromise<GetLevelAggregateType<T>>

    /**
     * Group by Level.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LevelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LevelGroupByArgs['orderBy'] }
        : { orderBy?: LevelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LevelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLevelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Level model
   */
  readonly fields: LevelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Level.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LevelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    AttributeAndValues<T extends Level$AttributeAndValuesArgs<ExtArgs> = {}>(args?: Subset<T, Level$AttributeAndValuesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LevelAttributeAndValuePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    parent<T extends Level$parentArgs<ExtArgs> = {}>(args?: Subset<T, Level$parentArgs<ExtArgs>>): Prisma__LevelClient<$Result.GetResult<Prisma.$LevelPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    instance<T extends InstanceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InstanceDefaultArgs<ExtArgs>>): Prisma__InstanceClient<$Result.GetResult<Prisma.$InstancePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    currency<T extends CurrencyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CurrencyDefaultArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    childLevels<T extends Level$childLevelsArgs<ExtArgs> = {}>(args?: Subset<T, Level$childLevelsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LevelPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    modelData<T extends Level$modelDataArgs<ExtArgs> = {}>(args?: Subset<T, Level$modelDataArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModelDataPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    modeldataCalculations<T extends Level$modeldataCalculationsArgs<ExtArgs> = {}>(args?: Subset<T, Level$modeldataCalculationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModelDataCalculationsPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Level model
   */ 
  interface LevelFieldRefs {
    readonly id: FieldRef<"Level", 'String'>
    readonly code: FieldRef<"Level", 'String'>
    readonly name: FieldRef<"Level", 'String'>
    readonly isRoot: FieldRef<"Level", 'Boolean'>
    readonly description: FieldRef<"Level", 'String'>
    readonly parentId: FieldRef<"Level", 'String'>
    readonly clientId: FieldRef<"Level", 'String'>
    readonly instanceId: FieldRef<"Level", 'String'>
    readonly currencyId: FieldRef<"Level", 'String'>
    readonly createdAt: FieldRef<"Level", 'DateTime'>
    readonly updatedAt: FieldRef<"Level", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Level findUnique
   */
  export type LevelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Level
     */
    omit?: LevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelInclude<ExtArgs> | null
    /**
     * Filter, which Level to fetch.
     */
    where: LevelWhereUniqueInput
  }

  /**
   * Level findUniqueOrThrow
   */
  export type LevelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Level
     */
    omit?: LevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelInclude<ExtArgs> | null
    /**
     * Filter, which Level to fetch.
     */
    where: LevelWhereUniqueInput
  }

  /**
   * Level findFirst
   */
  export type LevelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Level
     */
    omit?: LevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelInclude<ExtArgs> | null
    /**
     * Filter, which Level to fetch.
     */
    where?: LevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Levels to fetch.
     */
    orderBy?: LevelOrderByWithRelationInput | LevelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Levels.
     */
    cursor?: LevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Levels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Levels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Levels.
     */
    distinct?: LevelScalarFieldEnum | LevelScalarFieldEnum[]
  }

  /**
   * Level findFirstOrThrow
   */
  export type LevelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Level
     */
    omit?: LevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelInclude<ExtArgs> | null
    /**
     * Filter, which Level to fetch.
     */
    where?: LevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Levels to fetch.
     */
    orderBy?: LevelOrderByWithRelationInput | LevelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Levels.
     */
    cursor?: LevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Levels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Levels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Levels.
     */
    distinct?: LevelScalarFieldEnum | LevelScalarFieldEnum[]
  }

  /**
   * Level findMany
   */
  export type LevelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Level
     */
    omit?: LevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelInclude<ExtArgs> | null
    /**
     * Filter, which Levels to fetch.
     */
    where?: LevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Levels to fetch.
     */
    orderBy?: LevelOrderByWithRelationInput | LevelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Levels.
     */
    cursor?: LevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Levels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Levels.
     */
    skip?: number
    distinct?: LevelScalarFieldEnum | LevelScalarFieldEnum[]
  }

  /**
   * Level create
   */
  export type LevelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Level
     */
    omit?: LevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelInclude<ExtArgs> | null
    /**
     * The data needed to create a Level.
     */
    data: XOR<LevelCreateInput, LevelUncheckedCreateInput>
  }

  /**
   * Level createMany
   */
  export type LevelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Levels.
     */
    data: LevelCreateManyInput | LevelCreateManyInput[]
  }

  /**
   * Level update
   */
  export type LevelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Level
     */
    omit?: LevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelInclude<ExtArgs> | null
    /**
     * The data needed to update a Level.
     */
    data: XOR<LevelUpdateInput, LevelUncheckedUpdateInput>
    /**
     * Choose, which Level to update.
     */
    where: LevelWhereUniqueInput
  }

  /**
   * Level updateMany
   */
  export type LevelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Levels.
     */
    data: XOR<LevelUpdateManyMutationInput, LevelUncheckedUpdateManyInput>
    /**
     * Filter which Levels to update
     */
    where?: LevelWhereInput
    /**
     * Limit how many Levels to update.
     */
    limit?: number
  }

  /**
   * Level upsert
   */
  export type LevelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Level
     */
    omit?: LevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelInclude<ExtArgs> | null
    /**
     * The filter to search for the Level to update in case it exists.
     */
    where: LevelWhereUniqueInput
    /**
     * In case the Level found by the `where` argument doesn't exist, create a new Level with this data.
     */
    create: XOR<LevelCreateInput, LevelUncheckedCreateInput>
    /**
     * In case the Level was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LevelUpdateInput, LevelUncheckedUpdateInput>
  }

  /**
   * Level delete
   */
  export type LevelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Level
     */
    omit?: LevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelInclude<ExtArgs> | null
    /**
     * Filter which Level to delete.
     */
    where: LevelWhereUniqueInput
  }

  /**
   * Level deleteMany
   */
  export type LevelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Levels to delete
     */
    where?: LevelWhereInput
    /**
     * Limit how many Levels to delete.
     */
    limit?: number
  }

  /**
   * Level findRaw
   */
  export type LevelFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Level aggregateRaw
   */
  export type LevelAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Level.AttributeAndValues
   */
  export type Level$AttributeAndValuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LevelAttributeAndValue
     */
    select?: LevelAttributeAndValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LevelAttributeAndValue
     */
    omit?: LevelAttributeAndValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelAttributeAndValueInclude<ExtArgs> | null
    where?: LevelAttributeAndValueWhereInput
    orderBy?: LevelAttributeAndValueOrderByWithRelationInput | LevelAttributeAndValueOrderByWithRelationInput[]
    cursor?: LevelAttributeAndValueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LevelAttributeAndValueScalarFieldEnum | LevelAttributeAndValueScalarFieldEnum[]
  }

  /**
   * Level.parent
   */
  export type Level$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Level
     */
    omit?: LevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelInclude<ExtArgs> | null
    where?: LevelWhereInput
  }

  /**
   * Level.childLevels
   */
  export type Level$childLevelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Level
     */
    omit?: LevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelInclude<ExtArgs> | null
    where?: LevelWhereInput
    orderBy?: LevelOrderByWithRelationInput | LevelOrderByWithRelationInput[]
    cursor?: LevelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LevelScalarFieldEnum | LevelScalarFieldEnum[]
  }

  /**
   * Level.modelData
   */
  export type Level$modelDataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelData
     */
    select?: ModelDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelData
     */
    omit?: ModelDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelDataInclude<ExtArgs> | null
    where?: ModelDataWhereInput
    orderBy?: ModelDataOrderByWithRelationInput | ModelDataOrderByWithRelationInput[]
    cursor?: ModelDataWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ModelDataScalarFieldEnum | ModelDataScalarFieldEnum[]
  }

  /**
   * Level.modeldataCalculations
   */
  export type Level$modeldataCalculationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelDataCalculations
     */
    select?: ModelDataCalculationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelDataCalculations
     */
    omit?: ModelDataCalculationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelDataCalculationsInclude<ExtArgs> | null
    where?: ModelDataCalculationsWhereInput
    orderBy?: ModelDataCalculationsOrderByWithRelationInput | ModelDataCalculationsOrderByWithRelationInput[]
    cursor?: ModelDataCalculationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ModelDataCalculationsScalarFieldEnum | ModelDataCalculationsScalarFieldEnum[]
  }

  /**
   * Level without action
   */
  export type LevelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Level
     */
    omit?: LevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelInclude<ExtArgs> | null
  }


  /**
   * Model LevelAttributeAndValue
   */

  export type AggregateLevelAttributeAndValue = {
    _count: LevelAttributeAndValueCountAggregateOutputType | null
    _min: LevelAttributeAndValueMinAggregateOutputType | null
    _max: LevelAttributeAndValueMaxAggregateOutputType | null
  }

  export type LevelAttributeAndValueMinAggregateOutputType = {
    id: string | null
    levelId: string | null
    clientId: string | null
    instanceId: string | null
    attributeId: string | null
    attributeValueId: string | null
    levelCode: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LevelAttributeAndValueMaxAggregateOutputType = {
    id: string | null
    levelId: string | null
    clientId: string | null
    instanceId: string | null
    attributeId: string | null
    attributeValueId: string | null
    levelCode: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LevelAttributeAndValueCountAggregateOutputType = {
    id: number
    levelId: number
    clientId: number
    instanceId: number
    attributeId: number
    attributeValueId: number
    levelCode: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LevelAttributeAndValueMinAggregateInputType = {
    id?: true
    levelId?: true
    clientId?: true
    instanceId?: true
    attributeId?: true
    attributeValueId?: true
    levelCode?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LevelAttributeAndValueMaxAggregateInputType = {
    id?: true
    levelId?: true
    clientId?: true
    instanceId?: true
    attributeId?: true
    attributeValueId?: true
    levelCode?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LevelAttributeAndValueCountAggregateInputType = {
    id?: true
    levelId?: true
    clientId?: true
    instanceId?: true
    attributeId?: true
    attributeValueId?: true
    levelCode?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LevelAttributeAndValueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LevelAttributeAndValue to aggregate.
     */
    where?: LevelAttributeAndValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LevelAttributeAndValues to fetch.
     */
    orderBy?: LevelAttributeAndValueOrderByWithRelationInput | LevelAttributeAndValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LevelAttributeAndValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LevelAttributeAndValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LevelAttributeAndValues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LevelAttributeAndValues
    **/
    _count?: true | LevelAttributeAndValueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LevelAttributeAndValueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LevelAttributeAndValueMaxAggregateInputType
  }

  export type GetLevelAttributeAndValueAggregateType<T extends LevelAttributeAndValueAggregateArgs> = {
        [P in keyof T & keyof AggregateLevelAttributeAndValue]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLevelAttributeAndValue[P]>
      : GetScalarType<T[P], AggregateLevelAttributeAndValue[P]>
  }




  export type LevelAttributeAndValueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LevelAttributeAndValueWhereInput
    orderBy?: LevelAttributeAndValueOrderByWithAggregationInput | LevelAttributeAndValueOrderByWithAggregationInput[]
    by: LevelAttributeAndValueScalarFieldEnum[] | LevelAttributeAndValueScalarFieldEnum
    having?: LevelAttributeAndValueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LevelAttributeAndValueCountAggregateInputType | true
    _min?: LevelAttributeAndValueMinAggregateInputType
    _max?: LevelAttributeAndValueMaxAggregateInputType
  }

  export type LevelAttributeAndValueGroupByOutputType = {
    id: string
    levelId: string
    clientId: string
    instanceId: string
    attributeId: string
    attributeValueId: string
    levelCode: string
    createdAt: Date | null
    updatedAt: Date | null
    _count: LevelAttributeAndValueCountAggregateOutputType | null
    _min: LevelAttributeAndValueMinAggregateOutputType | null
    _max: LevelAttributeAndValueMaxAggregateOutputType | null
  }

  type GetLevelAttributeAndValueGroupByPayload<T extends LevelAttributeAndValueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LevelAttributeAndValueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LevelAttributeAndValueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LevelAttributeAndValueGroupByOutputType[P]>
            : GetScalarType<T[P], LevelAttributeAndValueGroupByOutputType[P]>
        }
      >
    >


  export type LevelAttributeAndValueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    levelId?: boolean
    clientId?: boolean
    instanceId?: boolean
    attributeId?: boolean
    attributeValueId?: boolean
    levelCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    level?: boolean | LevelAttributeAndValue$levelArgs<ExtArgs>
    attribute?: boolean | LevelAttributeAndValue$attributeArgs<ExtArgs>
    attributeValue?: boolean | LevelAttributeAndValue$attributeValueArgs<ExtArgs>
  }, ExtArgs["result"]["levelAttributeAndValue"]>



  export type LevelAttributeAndValueSelectScalar = {
    id?: boolean
    levelId?: boolean
    clientId?: boolean
    instanceId?: boolean
    attributeId?: boolean
    attributeValueId?: boolean
    levelCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LevelAttributeAndValueOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "levelId" | "clientId" | "instanceId" | "attributeId" | "attributeValueId" | "levelCode" | "createdAt" | "updatedAt", ExtArgs["result"]["levelAttributeAndValue"]>
  export type LevelAttributeAndValueInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    level?: boolean | LevelAttributeAndValue$levelArgs<ExtArgs>
    attribute?: boolean | LevelAttributeAndValue$attributeArgs<ExtArgs>
    attributeValue?: boolean | LevelAttributeAndValue$attributeValueArgs<ExtArgs>
  }

  export type $LevelAttributeAndValuePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LevelAttributeAndValue"
    objects: {
      level: Prisma.$LevelPayload<ExtArgs> | null
      attribute: Prisma.$LevelAttributePayload<ExtArgs> | null
      attributeValue: Prisma.$LevelAttributeValuePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      levelId: string
      clientId: string
      instanceId: string
      attributeId: string
      attributeValueId: string
      levelCode: string
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["levelAttributeAndValue"]>
    composites: {}
  }

  type LevelAttributeAndValueGetPayload<S extends boolean | null | undefined | LevelAttributeAndValueDefaultArgs> = $Result.GetResult<Prisma.$LevelAttributeAndValuePayload, S>

  type LevelAttributeAndValueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LevelAttributeAndValueFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LevelAttributeAndValueCountAggregateInputType | true
    }

  export interface LevelAttributeAndValueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LevelAttributeAndValue'], meta: { name: 'LevelAttributeAndValue' } }
    /**
     * Find zero or one LevelAttributeAndValue that matches the filter.
     * @param {LevelAttributeAndValueFindUniqueArgs} args - Arguments to find a LevelAttributeAndValue
     * @example
     * // Get one LevelAttributeAndValue
     * const levelAttributeAndValue = await prisma.levelAttributeAndValue.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LevelAttributeAndValueFindUniqueArgs>(args: SelectSubset<T, LevelAttributeAndValueFindUniqueArgs<ExtArgs>>): Prisma__LevelAttributeAndValueClient<$Result.GetResult<Prisma.$LevelAttributeAndValuePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one LevelAttributeAndValue that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LevelAttributeAndValueFindUniqueOrThrowArgs} args - Arguments to find a LevelAttributeAndValue
     * @example
     * // Get one LevelAttributeAndValue
     * const levelAttributeAndValue = await prisma.levelAttributeAndValue.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LevelAttributeAndValueFindUniqueOrThrowArgs>(args: SelectSubset<T, LevelAttributeAndValueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LevelAttributeAndValueClient<$Result.GetResult<Prisma.$LevelAttributeAndValuePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first LevelAttributeAndValue that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevelAttributeAndValueFindFirstArgs} args - Arguments to find a LevelAttributeAndValue
     * @example
     * // Get one LevelAttributeAndValue
     * const levelAttributeAndValue = await prisma.levelAttributeAndValue.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LevelAttributeAndValueFindFirstArgs>(args?: SelectSubset<T, LevelAttributeAndValueFindFirstArgs<ExtArgs>>): Prisma__LevelAttributeAndValueClient<$Result.GetResult<Prisma.$LevelAttributeAndValuePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first LevelAttributeAndValue that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevelAttributeAndValueFindFirstOrThrowArgs} args - Arguments to find a LevelAttributeAndValue
     * @example
     * // Get one LevelAttributeAndValue
     * const levelAttributeAndValue = await prisma.levelAttributeAndValue.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LevelAttributeAndValueFindFirstOrThrowArgs>(args?: SelectSubset<T, LevelAttributeAndValueFindFirstOrThrowArgs<ExtArgs>>): Prisma__LevelAttributeAndValueClient<$Result.GetResult<Prisma.$LevelAttributeAndValuePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more LevelAttributeAndValues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevelAttributeAndValueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LevelAttributeAndValues
     * const levelAttributeAndValues = await prisma.levelAttributeAndValue.findMany()
     * 
     * // Get first 10 LevelAttributeAndValues
     * const levelAttributeAndValues = await prisma.levelAttributeAndValue.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const levelAttributeAndValueWithIdOnly = await prisma.levelAttributeAndValue.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LevelAttributeAndValueFindManyArgs>(args?: SelectSubset<T, LevelAttributeAndValueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LevelAttributeAndValuePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a LevelAttributeAndValue.
     * @param {LevelAttributeAndValueCreateArgs} args - Arguments to create a LevelAttributeAndValue.
     * @example
     * // Create one LevelAttributeAndValue
     * const LevelAttributeAndValue = await prisma.levelAttributeAndValue.create({
     *   data: {
     *     // ... data to create a LevelAttributeAndValue
     *   }
     * })
     * 
     */
    create<T extends LevelAttributeAndValueCreateArgs>(args: SelectSubset<T, LevelAttributeAndValueCreateArgs<ExtArgs>>): Prisma__LevelAttributeAndValueClient<$Result.GetResult<Prisma.$LevelAttributeAndValuePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many LevelAttributeAndValues.
     * @param {LevelAttributeAndValueCreateManyArgs} args - Arguments to create many LevelAttributeAndValues.
     * @example
     * // Create many LevelAttributeAndValues
     * const levelAttributeAndValue = await prisma.levelAttributeAndValue.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LevelAttributeAndValueCreateManyArgs>(args?: SelectSubset<T, LevelAttributeAndValueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LevelAttributeAndValue.
     * @param {LevelAttributeAndValueDeleteArgs} args - Arguments to delete one LevelAttributeAndValue.
     * @example
     * // Delete one LevelAttributeAndValue
     * const LevelAttributeAndValue = await prisma.levelAttributeAndValue.delete({
     *   where: {
     *     // ... filter to delete one LevelAttributeAndValue
     *   }
     * })
     * 
     */
    delete<T extends LevelAttributeAndValueDeleteArgs>(args: SelectSubset<T, LevelAttributeAndValueDeleteArgs<ExtArgs>>): Prisma__LevelAttributeAndValueClient<$Result.GetResult<Prisma.$LevelAttributeAndValuePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one LevelAttributeAndValue.
     * @param {LevelAttributeAndValueUpdateArgs} args - Arguments to update one LevelAttributeAndValue.
     * @example
     * // Update one LevelAttributeAndValue
     * const levelAttributeAndValue = await prisma.levelAttributeAndValue.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LevelAttributeAndValueUpdateArgs>(args: SelectSubset<T, LevelAttributeAndValueUpdateArgs<ExtArgs>>): Prisma__LevelAttributeAndValueClient<$Result.GetResult<Prisma.$LevelAttributeAndValuePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more LevelAttributeAndValues.
     * @param {LevelAttributeAndValueDeleteManyArgs} args - Arguments to filter LevelAttributeAndValues to delete.
     * @example
     * // Delete a few LevelAttributeAndValues
     * const { count } = await prisma.levelAttributeAndValue.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LevelAttributeAndValueDeleteManyArgs>(args?: SelectSubset<T, LevelAttributeAndValueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LevelAttributeAndValues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevelAttributeAndValueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LevelAttributeAndValues
     * const levelAttributeAndValue = await prisma.levelAttributeAndValue.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LevelAttributeAndValueUpdateManyArgs>(args: SelectSubset<T, LevelAttributeAndValueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LevelAttributeAndValue.
     * @param {LevelAttributeAndValueUpsertArgs} args - Arguments to update or create a LevelAttributeAndValue.
     * @example
     * // Update or create a LevelAttributeAndValue
     * const levelAttributeAndValue = await prisma.levelAttributeAndValue.upsert({
     *   create: {
     *     // ... data to create a LevelAttributeAndValue
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LevelAttributeAndValue we want to update
     *   }
     * })
     */
    upsert<T extends LevelAttributeAndValueUpsertArgs>(args: SelectSubset<T, LevelAttributeAndValueUpsertArgs<ExtArgs>>): Prisma__LevelAttributeAndValueClient<$Result.GetResult<Prisma.$LevelAttributeAndValuePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more LevelAttributeAndValues that matches the filter.
     * @param {LevelAttributeAndValueFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const levelAttributeAndValue = await prisma.levelAttributeAndValue.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: LevelAttributeAndValueFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a LevelAttributeAndValue.
     * @param {LevelAttributeAndValueAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const levelAttributeAndValue = await prisma.levelAttributeAndValue.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: LevelAttributeAndValueAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of LevelAttributeAndValues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevelAttributeAndValueCountArgs} args - Arguments to filter LevelAttributeAndValues to count.
     * @example
     * // Count the number of LevelAttributeAndValues
     * const count = await prisma.levelAttributeAndValue.count({
     *   where: {
     *     // ... the filter for the LevelAttributeAndValues we want to count
     *   }
     * })
    **/
    count<T extends LevelAttributeAndValueCountArgs>(
      args?: Subset<T, LevelAttributeAndValueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LevelAttributeAndValueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LevelAttributeAndValue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevelAttributeAndValueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LevelAttributeAndValueAggregateArgs>(args: Subset<T, LevelAttributeAndValueAggregateArgs>): Prisma.PrismaPromise<GetLevelAttributeAndValueAggregateType<T>>

    /**
     * Group by LevelAttributeAndValue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevelAttributeAndValueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LevelAttributeAndValueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LevelAttributeAndValueGroupByArgs['orderBy'] }
        : { orderBy?: LevelAttributeAndValueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LevelAttributeAndValueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLevelAttributeAndValueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LevelAttributeAndValue model
   */
  readonly fields: LevelAttributeAndValueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LevelAttributeAndValue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LevelAttributeAndValueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    level<T extends LevelAttributeAndValue$levelArgs<ExtArgs> = {}>(args?: Subset<T, LevelAttributeAndValue$levelArgs<ExtArgs>>): Prisma__LevelClient<$Result.GetResult<Prisma.$LevelPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    attribute<T extends LevelAttributeAndValue$attributeArgs<ExtArgs> = {}>(args?: Subset<T, LevelAttributeAndValue$attributeArgs<ExtArgs>>): Prisma__LevelAttributeClient<$Result.GetResult<Prisma.$LevelAttributePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    attributeValue<T extends LevelAttributeAndValue$attributeValueArgs<ExtArgs> = {}>(args?: Subset<T, LevelAttributeAndValue$attributeValueArgs<ExtArgs>>): Prisma__LevelAttributeValueClient<$Result.GetResult<Prisma.$LevelAttributeValuePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LevelAttributeAndValue model
   */ 
  interface LevelAttributeAndValueFieldRefs {
    readonly id: FieldRef<"LevelAttributeAndValue", 'String'>
    readonly levelId: FieldRef<"LevelAttributeAndValue", 'String'>
    readonly clientId: FieldRef<"LevelAttributeAndValue", 'String'>
    readonly instanceId: FieldRef<"LevelAttributeAndValue", 'String'>
    readonly attributeId: FieldRef<"LevelAttributeAndValue", 'String'>
    readonly attributeValueId: FieldRef<"LevelAttributeAndValue", 'String'>
    readonly levelCode: FieldRef<"LevelAttributeAndValue", 'String'>
    readonly createdAt: FieldRef<"LevelAttributeAndValue", 'DateTime'>
    readonly updatedAt: FieldRef<"LevelAttributeAndValue", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LevelAttributeAndValue findUnique
   */
  export type LevelAttributeAndValueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LevelAttributeAndValue
     */
    select?: LevelAttributeAndValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LevelAttributeAndValue
     */
    omit?: LevelAttributeAndValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelAttributeAndValueInclude<ExtArgs> | null
    /**
     * Filter, which LevelAttributeAndValue to fetch.
     */
    where: LevelAttributeAndValueWhereUniqueInput
  }

  /**
   * LevelAttributeAndValue findUniqueOrThrow
   */
  export type LevelAttributeAndValueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LevelAttributeAndValue
     */
    select?: LevelAttributeAndValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LevelAttributeAndValue
     */
    omit?: LevelAttributeAndValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelAttributeAndValueInclude<ExtArgs> | null
    /**
     * Filter, which LevelAttributeAndValue to fetch.
     */
    where: LevelAttributeAndValueWhereUniqueInput
  }

  /**
   * LevelAttributeAndValue findFirst
   */
  export type LevelAttributeAndValueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LevelAttributeAndValue
     */
    select?: LevelAttributeAndValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LevelAttributeAndValue
     */
    omit?: LevelAttributeAndValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelAttributeAndValueInclude<ExtArgs> | null
    /**
     * Filter, which LevelAttributeAndValue to fetch.
     */
    where?: LevelAttributeAndValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LevelAttributeAndValues to fetch.
     */
    orderBy?: LevelAttributeAndValueOrderByWithRelationInput | LevelAttributeAndValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LevelAttributeAndValues.
     */
    cursor?: LevelAttributeAndValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LevelAttributeAndValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LevelAttributeAndValues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LevelAttributeAndValues.
     */
    distinct?: LevelAttributeAndValueScalarFieldEnum | LevelAttributeAndValueScalarFieldEnum[]
  }

  /**
   * LevelAttributeAndValue findFirstOrThrow
   */
  export type LevelAttributeAndValueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LevelAttributeAndValue
     */
    select?: LevelAttributeAndValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LevelAttributeAndValue
     */
    omit?: LevelAttributeAndValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelAttributeAndValueInclude<ExtArgs> | null
    /**
     * Filter, which LevelAttributeAndValue to fetch.
     */
    where?: LevelAttributeAndValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LevelAttributeAndValues to fetch.
     */
    orderBy?: LevelAttributeAndValueOrderByWithRelationInput | LevelAttributeAndValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LevelAttributeAndValues.
     */
    cursor?: LevelAttributeAndValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LevelAttributeAndValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LevelAttributeAndValues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LevelAttributeAndValues.
     */
    distinct?: LevelAttributeAndValueScalarFieldEnum | LevelAttributeAndValueScalarFieldEnum[]
  }

  /**
   * LevelAttributeAndValue findMany
   */
  export type LevelAttributeAndValueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LevelAttributeAndValue
     */
    select?: LevelAttributeAndValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LevelAttributeAndValue
     */
    omit?: LevelAttributeAndValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelAttributeAndValueInclude<ExtArgs> | null
    /**
     * Filter, which LevelAttributeAndValues to fetch.
     */
    where?: LevelAttributeAndValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LevelAttributeAndValues to fetch.
     */
    orderBy?: LevelAttributeAndValueOrderByWithRelationInput | LevelAttributeAndValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LevelAttributeAndValues.
     */
    cursor?: LevelAttributeAndValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LevelAttributeAndValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LevelAttributeAndValues.
     */
    skip?: number
    distinct?: LevelAttributeAndValueScalarFieldEnum | LevelAttributeAndValueScalarFieldEnum[]
  }

  /**
   * LevelAttributeAndValue create
   */
  export type LevelAttributeAndValueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LevelAttributeAndValue
     */
    select?: LevelAttributeAndValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LevelAttributeAndValue
     */
    omit?: LevelAttributeAndValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelAttributeAndValueInclude<ExtArgs> | null
    /**
     * The data needed to create a LevelAttributeAndValue.
     */
    data: XOR<LevelAttributeAndValueCreateInput, LevelAttributeAndValueUncheckedCreateInput>
  }

  /**
   * LevelAttributeAndValue createMany
   */
  export type LevelAttributeAndValueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LevelAttributeAndValues.
     */
    data: LevelAttributeAndValueCreateManyInput | LevelAttributeAndValueCreateManyInput[]
  }

  /**
   * LevelAttributeAndValue update
   */
  export type LevelAttributeAndValueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LevelAttributeAndValue
     */
    select?: LevelAttributeAndValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LevelAttributeAndValue
     */
    omit?: LevelAttributeAndValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelAttributeAndValueInclude<ExtArgs> | null
    /**
     * The data needed to update a LevelAttributeAndValue.
     */
    data: XOR<LevelAttributeAndValueUpdateInput, LevelAttributeAndValueUncheckedUpdateInput>
    /**
     * Choose, which LevelAttributeAndValue to update.
     */
    where: LevelAttributeAndValueWhereUniqueInput
  }

  /**
   * LevelAttributeAndValue updateMany
   */
  export type LevelAttributeAndValueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LevelAttributeAndValues.
     */
    data: XOR<LevelAttributeAndValueUpdateManyMutationInput, LevelAttributeAndValueUncheckedUpdateManyInput>
    /**
     * Filter which LevelAttributeAndValues to update
     */
    where?: LevelAttributeAndValueWhereInput
    /**
     * Limit how many LevelAttributeAndValues to update.
     */
    limit?: number
  }

  /**
   * LevelAttributeAndValue upsert
   */
  export type LevelAttributeAndValueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LevelAttributeAndValue
     */
    select?: LevelAttributeAndValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LevelAttributeAndValue
     */
    omit?: LevelAttributeAndValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelAttributeAndValueInclude<ExtArgs> | null
    /**
     * The filter to search for the LevelAttributeAndValue to update in case it exists.
     */
    where: LevelAttributeAndValueWhereUniqueInput
    /**
     * In case the LevelAttributeAndValue found by the `where` argument doesn't exist, create a new LevelAttributeAndValue with this data.
     */
    create: XOR<LevelAttributeAndValueCreateInput, LevelAttributeAndValueUncheckedCreateInput>
    /**
     * In case the LevelAttributeAndValue was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LevelAttributeAndValueUpdateInput, LevelAttributeAndValueUncheckedUpdateInput>
  }

  /**
   * LevelAttributeAndValue delete
   */
  export type LevelAttributeAndValueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LevelAttributeAndValue
     */
    select?: LevelAttributeAndValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LevelAttributeAndValue
     */
    omit?: LevelAttributeAndValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelAttributeAndValueInclude<ExtArgs> | null
    /**
     * Filter which LevelAttributeAndValue to delete.
     */
    where: LevelAttributeAndValueWhereUniqueInput
  }

  /**
   * LevelAttributeAndValue deleteMany
   */
  export type LevelAttributeAndValueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LevelAttributeAndValues to delete
     */
    where?: LevelAttributeAndValueWhereInput
    /**
     * Limit how many LevelAttributeAndValues to delete.
     */
    limit?: number
  }

  /**
   * LevelAttributeAndValue findRaw
   */
  export type LevelAttributeAndValueFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * LevelAttributeAndValue aggregateRaw
   */
  export type LevelAttributeAndValueAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * LevelAttributeAndValue.level
   */
  export type LevelAttributeAndValue$levelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Level
     */
    omit?: LevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelInclude<ExtArgs> | null
    where?: LevelWhereInput
  }

  /**
   * LevelAttributeAndValue.attribute
   */
  export type LevelAttributeAndValue$attributeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LevelAttribute
     */
    select?: LevelAttributeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LevelAttribute
     */
    omit?: LevelAttributeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelAttributeInclude<ExtArgs> | null
    where?: LevelAttributeWhereInput
  }

  /**
   * LevelAttributeAndValue.attributeValue
   */
  export type LevelAttributeAndValue$attributeValueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LevelAttributeValue
     */
    select?: LevelAttributeValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LevelAttributeValue
     */
    omit?: LevelAttributeValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelAttributeValueInclude<ExtArgs> | null
    where?: LevelAttributeValueWhereInput
  }

  /**
   * LevelAttributeAndValue without action
   */
  export type LevelAttributeAndValueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LevelAttributeAndValue
     */
    select?: LevelAttributeAndValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LevelAttributeAndValue
     */
    omit?: LevelAttributeAndValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelAttributeAndValueInclude<ExtArgs> | null
  }


  /**
   * Model LevelAttributeValue
   */

  export type AggregateLevelAttributeValue = {
    _count: LevelAttributeValueCountAggregateOutputType | null
    _min: LevelAttributeValueMinAggregateOutputType | null
    _max: LevelAttributeValueMaxAggregateOutputType | null
  }

  export type LevelAttributeValueMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    attributeId: string | null
    parentId: string | null
    clientId: string | null
    instanceId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LevelAttributeValueMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    attributeId: string | null
    parentId: string | null
    clientId: string | null
    instanceId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LevelAttributeValueCountAggregateOutputType = {
    id: number
    code: number
    name: number
    attributeId: number
    parentId: number
    clientId: number
    instanceId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LevelAttributeValueMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    attributeId?: true
    parentId?: true
    clientId?: true
    instanceId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LevelAttributeValueMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    attributeId?: true
    parentId?: true
    clientId?: true
    instanceId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LevelAttributeValueCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    attributeId?: true
    parentId?: true
    clientId?: true
    instanceId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LevelAttributeValueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LevelAttributeValue to aggregate.
     */
    where?: LevelAttributeValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LevelAttributeValues to fetch.
     */
    orderBy?: LevelAttributeValueOrderByWithRelationInput | LevelAttributeValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LevelAttributeValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LevelAttributeValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LevelAttributeValues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LevelAttributeValues
    **/
    _count?: true | LevelAttributeValueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LevelAttributeValueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LevelAttributeValueMaxAggregateInputType
  }

  export type GetLevelAttributeValueAggregateType<T extends LevelAttributeValueAggregateArgs> = {
        [P in keyof T & keyof AggregateLevelAttributeValue]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLevelAttributeValue[P]>
      : GetScalarType<T[P], AggregateLevelAttributeValue[P]>
  }




  export type LevelAttributeValueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LevelAttributeValueWhereInput
    orderBy?: LevelAttributeValueOrderByWithAggregationInput | LevelAttributeValueOrderByWithAggregationInput[]
    by: LevelAttributeValueScalarFieldEnum[] | LevelAttributeValueScalarFieldEnum
    having?: LevelAttributeValueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LevelAttributeValueCountAggregateInputType | true
    _min?: LevelAttributeValueMinAggregateInputType
    _max?: LevelAttributeValueMaxAggregateInputType
  }

  export type LevelAttributeValueGroupByOutputType = {
    id: string
    code: string
    name: string
    attributeId: string
    parentId: string | null
    clientId: string
    instanceId: string
    createdAt: Date | null
    updatedAt: Date | null
    _count: LevelAttributeValueCountAggregateOutputType | null
    _min: LevelAttributeValueMinAggregateOutputType | null
    _max: LevelAttributeValueMaxAggregateOutputType | null
  }

  type GetLevelAttributeValueGroupByPayload<T extends LevelAttributeValueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LevelAttributeValueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LevelAttributeValueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LevelAttributeValueGroupByOutputType[P]>
            : GetScalarType<T[P], LevelAttributeValueGroupByOutputType[P]>
        }
      >
    >


  export type LevelAttributeValueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    attributeId?: boolean
    parentId?: boolean
    clientId?: boolean
    instanceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parent?: boolean | LevelAttributeValue$parentArgs<ExtArgs>
    childAttributeValues?: boolean | LevelAttributeValue$childAttributeValuesArgs<ExtArgs>
    instance?: boolean | InstanceDefaultArgs<ExtArgs>
    levelAttribute?: boolean | LevelAttributeDefaultArgs<ExtArgs>
    levelAttributeAndValues?: boolean | LevelAttributeValue$levelAttributeAndValuesArgs<ExtArgs>
    _count?: boolean | LevelAttributeValueCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["levelAttributeValue"]>



  export type LevelAttributeValueSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    attributeId?: boolean
    parentId?: boolean
    clientId?: boolean
    instanceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LevelAttributeValueOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "name" | "attributeId" | "parentId" | "clientId" | "instanceId" | "createdAt" | "updatedAt", ExtArgs["result"]["levelAttributeValue"]>
  export type LevelAttributeValueInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | LevelAttributeValue$parentArgs<ExtArgs>
    childAttributeValues?: boolean | LevelAttributeValue$childAttributeValuesArgs<ExtArgs>
    instance?: boolean | InstanceDefaultArgs<ExtArgs>
    levelAttribute?: boolean | LevelAttributeDefaultArgs<ExtArgs>
    levelAttributeAndValues?: boolean | LevelAttributeValue$levelAttributeAndValuesArgs<ExtArgs>
    _count?: boolean | LevelAttributeValueCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $LevelAttributeValuePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LevelAttributeValue"
    objects: {
      parent: Prisma.$LevelAttributeValuePayload<ExtArgs> | null
      childAttributeValues: Prisma.$LevelAttributeValuePayload<ExtArgs>[]
      instance: Prisma.$InstancePayload<ExtArgs>
      levelAttribute: Prisma.$LevelAttributePayload<ExtArgs>
      levelAttributeAndValues: Prisma.$LevelAttributeAndValuePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      name: string
      attributeId: string
      parentId: string | null
      clientId: string
      instanceId: string
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["levelAttributeValue"]>
    composites: {}
  }

  type LevelAttributeValueGetPayload<S extends boolean | null | undefined | LevelAttributeValueDefaultArgs> = $Result.GetResult<Prisma.$LevelAttributeValuePayload, S>

  type LevelAttributeValueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LevelAttributeValueFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LevelAttributeValueCountAggregateInputType | true
    }

  export interface LevelAttributeValueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LevelAttributeValue'], meta: { name: 'LevelAttributeValue' } }
    /**
     * Find zero or one LevelAttributeValue that matches the filter.
     * @param {LevelAttributeValueFindUniqueArgs} args - Arguments to find a LevelAttributeValue
     * @example
     * // Get one LevelAttributeValue
     * const levelAttributeValue = await prisma.levelAttributeValue.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LevelAttributeValueFindUniqueArgs>(args: SelectSubset<T, LevelAttributeValueFindUniqueArgs<ExtArgs>>): Prisma__LevelAttributeValueClient<$Result.GetResult<Prisma.$LevelAttributeValuePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one LevelAttributeValue that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LevelAttributeValueFindUniqueOrThrowArgs} args - Arguments to find a LevelAttributeValue
     * @example
     * // Get one LevelAttributeValue
     * const levelAttributeValue = await prisma.levelAttributeValue.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LevelAttributeValueFindUniqueOrThrowArgs>(args: SelectSubset<T, LevelAttributeValueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LevelAttributeValueClient<$Result.GetResult<Prisma.$LevelAttributeValuePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first LevelAttributeValue that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevelAttributeValueFindFirstArgs} args - Arguments to find a LevelAttributeValue
     * @example
     * // Get one LevelAttributeValue
     * const levelAttributeValue = await prisma.levelAttributeValue.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LevelAttributeValueFindFirstArgs>(args?: SelectSubset<T, LevelAttributeValueFindFirstArgs<ExtArgs>>): Prisma__LevelAttributeValueClient<$Result.GetResult<Prisma.$LevelAttributeValuePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first LevelAttributeValue that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevelAttributeValueFindFirstOrThrowArgs} args - Arguments to find a LevelAttributeValue
     * @example
     * // Get one LevelAttributeValue
     * const levelAttributeValue = await prisma.levelAttributeValue.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LevelAttributeValueFindFirstOrThrowArgs>(args?: SelectSubset<T, LevelAttributeValueFindFirstOrThrowArgs<ExtArgs>>): Prisma__LevelAttributeValueClient<$Result.GetResult<Prisma.$LevelAttributeValuePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more LevelAttributeValues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevelAttributeValueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LevelAttributeValues
     * const levelAttributeValues = await prisma.levelAttributeValue.findMany()
     * 
     * // Get first 10 LevelAttributeValues
     * const levelAttributeValues = await prisma.levelAttributeValue.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const levelAttributeValueWithIdOnly = await prisma.levelAttributeValue.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LevelAttributeValueFindManyArgs>(args?: SelectSubset<T, LevelAttributeValueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LevelAttributeValuePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a LevelAttributeValue.
     * @param {LevelAttributeValueCreateArgs} args - Arguments to create a LevelAttributeValue.
     * @example
     * // Create one LevelAttributeValue
     * const LevelAttributeValue = await prisma.levelAttributeValue.create({
     *   data: {
     *     // ... data to create a LevelAttributeValue
     *   }
     * })
     * 
     */
    create<T extends LevelAttributeValueCreateArgs>(args: SelectSubset<T, LevelAttributeValueCreateArgs<ExtArgs>>): Prisma__LevelAttributeValueClient<$Result.GetResult<Prisma.$LevelAttributeValuePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many LevelAttributeValues.
     * @param {LevelAttributeValueCreateManyArgs} args - Arguments to create many LevelAttributeValues.
     * @example
     * // Create many LevelAttributeValues
     * const levelAttributeValue = await prisma.levelAttributeValue.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LevelAttributeValueCreateManyArgs>(args?: SelectSubset<T, LevelAttributeValueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LevelAttributeValue.
     * @param {LevelAttributeValueDeleteArgs} args - Arguments to delete one LevelAttributeValue.
     * @example
     * // Delete one LevelAttributeValue
     * const LevelAttributeValue = await prisma.levelAttributeValue.delete({
     *   where: {
     *     // ... filter to delete one LevelAttributeValue
     *   }
     * })
     * 
     */
    delete<T extends LevelAttributeValueDeleteArgs>(args: SelectSubset<T, LevelAttributeValueDeleteArgs<ExtArgs>>): Prisma__LevelAttributeValueClient<$Result.GetResult<Prisma.$LevelAttributeValuePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one LevelAttributeValue.
     * @param {LevelAttributeValueUpdateArgs} args - Arguments to update one LevelAttributeValue.
     * @example
     * // Update one LevelAttributeValue
     * const levelAttributeValue = await prisma.levelAttributeValue.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LevelAttributeValueUpdateArgs>(args: SelectSubset<T, LevelAttributeValueUpdateArgs<ExtArgs>>): Prisma__LevelAttributeValueClient<$Result.GetResult<Prisma.$LevelAttributeValuePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more LevelAttributeValues.
     * @param {LevelAttributeValueDeleteManyArgs} args - Arguments to filter LevelAttributeValues to delete.
     * @example
     * // Delete a few LevelAttributeValues
     * const { count } = await prisma.levelAttributeValue.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LevelAttributeValueDeleteManyArgs>(args?: SelectSubset<T, LevelAttributeValueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LevelAttributeValues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevelAttributeValueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LevelAttributeValues
     * const levelAttributeValue = await prisma.levelAttributeValue.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LevelAttributeValueUpdateManyArgs>(args: SelectSubset<T, LevelAttributeValueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LevelAttributeValue.
     * @param {LevelAttributeValueUpsertArgs} args - Arguments to update or create a LevelAttributeValue.
     * @example
     * // Update or create a LevelAttributeValue
     * const levelAttributeValue = await prisma.levelAttributeValue.upsert({
     *   create: {
     *     // ... data to create a LevelAttributeValue
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LevelAttributeValue we want to update
     *   }
     * })
     */
    upsert<T extends LevelAttributeValueUpsertArgs>(args: SelectSubset<T, LevelAttributeValueUpsertArgs<ExtArgs>>): Prisma__LevelAttributeValueClient<$Result.GetResult<Prisma.$LevelAttributeValuePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more LevelAttributeValues that matches the filter.
     * @param {LevelAttributeValueFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const levelAttributeValue = await prisma.levelAttributeValue.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: LevelAttributeValueFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a LevelAttributeValue.
     * @param {LevelAttributeValueAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const levelAttributeValue = await prisma.levelAttributeValue.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: LevelAttributeValueAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of LevelAttributeValues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevelAttributeValueCountArgs} args - Arguments to filter LevelAttributeValues to count.
     * @example
     * // Count the number of LevelAttributeValues
     * const count = await prisma.levelAttributeValue.count({
     *   where: {
     *     // ... the filter for the LevelAttributeValues we want to count
     *   }
     * })
    **/
    count<T extends LevelAttributeValueCountArgs>(
      args?: Subset<T, LevelAttributeValueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LevelAttributeValueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LevelAttributeValue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevelAttributeValueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LevelAttributeValueAggregateArgs>(args: Subset<T, LevelAttributeValueAggregateArgs>): Prisma.PrismaPromise<GetLevelAttributeValueAggregateType<T>>

    /**
     * Group by LevelAttributeValue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevelAttributeValueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LevelAttributeValueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LevelAttributeValueGroupByArgs['orderBy'] }
        : { orderBy?: LevelAttributeValueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LevelAttributeValueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLevelAttributeValueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LevelAttributeValue model
   */
  readonly fields: LevelAttributeValueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LevelAttributeValue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LevelAttributeValueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    parent<T extends LevelAttributeValue$parentArgs<ExtArgs> = {}>(args?: Subset<T, LevelAttributeValue$parentArgs<ExtArgs>>): Prisma__LevelAttributeValueClient<$Result.GetResult<Prisma.$LevelAttributeValuePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    childAttributeValues<T extends LevelAttributeValue$childAttributeValuesArgs<ExtArgs> = {}>(args?: Subset<T, LevelAttributeValue$childAttributeValuesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LevelAttributeValuePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    instance<T extends InstanceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InstanceDefaultArgs<ExtArgs>>): Prisma__InstanceClient<$Result.GetResult<Prisma.$InstancePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    levelAttribute<T extends LevelAttributeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LevelAttributeDefaultArgs<ExtArgs>>): Prisma__LevelAttributeClient<$Result.GetResult<Prisma.$LevelAttributePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    levelAttributeAndValues<T extends LevelAttributeValue$levelAttributeAndValuesArgs<ExtArgs> = {}>(args?: Subset<T, LevelAttributeValue$levelAttributeAndValuesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LevelAttributeAndValuePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LevelAttributeValue model
   */ 
  interface LevelAttributeValueFieldRefs {
    readonly id: FieldRef<"LevelAttributeValue", 'String'>
    readonly code: FieldRef<"LevelAttributeValue", 'String'>
    readonly name: FieldRef<"LevelAttributeValue", 'String'>
    readonly attributeId: FieldRef<"LevelAttributeValue", 'String'>
    readonly parentId: FieldRef<"LevelAttributeValue", 'String'>
    readonly clientId: FieldRef<"LevelAttributeValue", 'String'>
    readonly instanceId: FieldRef<"LevelAttributeValue", 'String'>
    readonly createdAt: FieldRef<"LevelAttributeValue", 'DateTime'>
    readonly updatedAt: FieldRef<"LevelAttributeValue", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LevelAttributeValue findUnique
   */
  export type LevelAttributeValueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LevelAttributeValue
     */
    select?: LevelAttributeValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LevelAttributeValue
     */
    omit?: LevelAttributeValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelAttributeValueInclude<ExtArgs> | null
    /**
     * Filter, which LevelAttributeValue to fetch.
     */
    where: LevelAttributeValueWhereUniqueInput
  }

  /**
   * LevelAttributeValue findUniqueOrThrow
   */
  export type LevelAttributeValueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LevelAttributeValue
     */
    select?: LevelAttributeValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LevelAttributeValue
     */
    omit?: LevelAttributeValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelAttributeValueInclude<ExtArgs> | null
    /**
     * Filter, which LevelAttributeValue to fetch.
     */
    where: LevelAttributeValueWhereUniqueInput
  }

  /**
   * LevelAttributeValue findFirst
   */
  export type LevelAttributeValueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LevelAttributeValue
     */
    select?: LevelAttributeValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LevelAttributeValue
     */
    omit?: LevelAttributeValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelAttributeValueInclude<ExtArgs> | null
    /**
     * Filter, which LevelAttributeValue to fetch.
     */
    where?: LevelAttributeValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LevelAttributeValues to fetch.
     */
    orderBy?: LevelAttributeValueOrderByWithRelationInput | LevelAttributeValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LevelAttributeValues.
     */
    cursor?: LevelAttributeValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LevelAttributeValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LevelAttributeValues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LevelAttributeValues.
     */
    distinct?: LevelAttributeValueScalarFieldEnum | LevelAttributeValueScalarFieldEnum[]
  }

  /**
   * LevelAttributeValue findFirstOrThrow
   */
  export type LevelAttributeValueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LevelAttributeValue
     */
    select?: LevelAttributeValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LevelAttributeValue
     */
    omit?: LevelAttributeValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelAttributeValueInclude<ExtArgs> | null
    /**
     * Filter, which LevelAttributeValue to fetch.
     */
    where?: LevelAttributeValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LevelAttributeValues to fetch.
     */
    orderBy?: LevelAttributeValueOrderByWithRelationInput | LevelAttributeValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LevelAttributeValues.
     */
    cursor?: LevelAttributeValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LevelAttributeValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LevelAttributeValues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LevelAttributeValues.
     */
    distinct?: LevelAttributeValueScalarFieldEnum | LevelAttributeValueScalarFieldEnum[]
  }

  /**
   * LevelAttributeValue findMany
   */
  export type LevelAttributeValueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LevelAttributeValue
     */
    select?: LevelAttributeValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LevelAttributeValue
     */
    omit?: LevelAttributeValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelAttributeValueInclude<ExtArgs> | null
    /**
     * Filter, which LevelAttributeValues to fetch.
     */
    where?: LevelAttributeValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LevelAttributeValues to fetch.
     */
    orderBy?: LevelAttributeValueOrderByWithRelationInput | LevelAttributeValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LevelAttributeValues.
     */
    cursor?: LevelAttributeValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LevelAttributeValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LevelAttributeValues.
     */
    skip?: number
    distinct?: LevelAttributeValueScalarFieldEnum | LevelAttributeValueScalarFieldEnum[]
  }

  /**
   * LevelAttributeValue create
   */
  export type LevelAttributeValueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LevelAttributeValue
     */
    select?: LevelAttributeValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LevelAttributeValue
     */
    omit?: LevelAttributeValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelAttributeValueInclude<ExtArgs> | null
    /**
     * The data needed to create a LevelAttributeValue.
     */
    data: XOR<LevelAttributeValueCreateInput, LevelAttributeValueUncheckedCreateInput>
  }

  /**
   * LevelAttributeValue createMany
   */
  export type LevelAttributeValueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LevelAttributeValues.
     */
    data: LevelAttributeValueCreateManyInput | LevelAttributeValueCreateManyInput[]
  }

  /**
   * LevelAttributeValue update
   */
  export type LevelAttributeValueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LevelAttributeValue
     */
    select?: LevelAttributeValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LevelAttributeValue
     */
    omit?: LevelAttributeValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelAttributeValueInclude<ExtArgs> | null
    /**
     * The data needed to update a LevelAttributeValue.
     */
    data: XOR<LevelAttributeValueUpdateInput, LevelAttributeValueUncheckedUpdateInput>
    /**
     * Choose, which LevelAttributeValue to update.
     */
    where: LevelAttributeValueWhereUniqueInput
  }

  /**
   * LevelAttributeValue updateMany
   */
  export type LevelAttributeValueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LevelAttributeValues.
     */
    data: XOR<LevelAttributeValueUpdateManyMutationInput, LevelAttributeValueUncheckedUpdateManyInput>
    /**
     * Filter which LevelAttributeValues to update
     */
    where?: LevelAttributeValueWhereInput
    /**
     * Limit how many LevelAttributeValues to update.
     */
    limit?: number
  }

  /**
   * LevelAttributeValue upsert
   */
  export type LevelAttributeValueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LevelAttributeValue
     */
    select?: LevelAttributeValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LevelAttributeValue
     */
    omit?: LevelAttributeValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelAttributeValueInclude<ExtArgs> | null
    /**
     * The filter to search for the LevelAttributeValue to update in case it exists.
     */
    where: LevelAttributeValueWhereUniqueInput
    /**
     * In case the LevelAttributeValue found by the `where` argument doesn't exist, create a new LevelAttributeValue with this data.
     */
    create: XOR<LevelAttributeValueCreateInput, LevelAttributeValueUncheckedCreateInput>
    /**
     * In case the LevelAttributeValue was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LevelAttributeValueUpdateInput, LevelAttributeValueUncheckedUpdateInput>
  }

  /**
   * LevelAttributeValue delete
   */
  export type LevelAttributeValueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LevelAttributeValue
     */
    select?: LevelAttributeValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LevelAttributeValue
     */
    omit?: LevelAttributeValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelAttributeValueInclude<ExtArgs> | null
    /**
     * Filter which LevelAttributeValue to delete.
     */
    where: LevelAttributeValueWhereUniqueInput
  }

  /**
   * LevelAttributeValue deleteMany
   */
  export type LevelAttributeValueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LevelAttributeValues to delete
     */
    where?: LevelAttributeValueWhereInput
    /**
     * Limit how many LevelAttributeValues to delete.
     */
    limit?: number
  }

  /**
   * LevelAttributeValue findRaw
   */
  export type LevelAttributeValueFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * LevelAttributeValue aggregateRaw
   */
  export type LevelAttributeValueAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * LevelAttributeValue.parent
   */
  export type LevelAttributeValue$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LevelAttributeValue
     */
    select?: LevelAttributeValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LevelAttributeValue
     */
    omit?: LevelAttributeValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelAttributeValueInclude<ExtArgs> | null
    where?: LevelAttributeValueWhereInput
  }

  /**
   * LevelAttributeValue.childAttributeValues
   */
  export type LevelAttributeValue$childAttributeValuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LevelAttributeValue
     */
    select?: LevelAttributeValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LevelAttributeValue
     */
    omit?: LevelAttributeValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelAttributeValueInclude<ExtArgs> | null
    where?: LevelAttributeValueWhereInput
    orderBy?: LevelAttributeValueOrderByWithRelationInput | LevelAttributeValueOrderByWithRelationInput[]
    cursor?: LevelAttributeValueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LevelAttributeValueScalarFieldEnum | LevelAttributeValueScalarFieldEnum[]
  }

  /**
   * LevelAttributeValue.levelAttributeAndValues
   */
  export type LevelAttributeValue$levelAttributeAndValuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LevelAttributeAndValue
     */
    select?: LevelAttributeAndValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LevelAttributeAndValue
     */
    omit?: LevelAttributeAndValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelAttributeAndValueInclude<ExtArgs> | null
    where?: LevelAttributeAndValueWhereInput
    orderBy?: LevelAttributeAndValueOrderByWithRelationInput | LevelAttributeAndValueOrderByWithRelationInput[]
    cursor?: LevelAttributeAndValueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LevelAttributeAndValueScalarFieldEnum | LevelAttributeAndValueScalarFieldEnum[]
  }

  /**
   * LevelAttributeValue without action
   */
  export type LevelAttributeValueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LevelAttributeValue
     */
    select?: LevelAttributeValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LevelAttributeValue
     */
    omit?: LevelAttributeValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelAttributeValueInclude<ExtArgs> | null
  }


  /**
   * Model LevelAttribute
   */

  export type AggregateLevelAttribute = {
    _count: LevelAttributeCountAggregateOutputType | null
    _min: LevelAttributeMinAggregateOutputType | null
    _max: LevelAttributeMaxAggregateOutputType | null
  }

  export type LevelAttributeMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    description: string | null
    clientId: string | null
    instanceId: string | null
    attributeValueDefault: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LevelAttributeMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    description: string | null
    clientId: string | null
    instanceId: string | null
    attributeValueDefault: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LevelAttributeCountAggregateOutputType = {
    id: number
    code: number
    name: number
    description: number
    clientId: number
    instanceId: number
    attributeValueDefault: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LevelAttributeMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    clientId?: true
    instanceId?: true
    attributeValueDefault?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LevelAttributeMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    clientId?: true
    instanceId?: true
    attributeValueDefault?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LevelAttributeCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    clientId?: true
    instanceId?: true
    attributeValueDefault?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LevelAttributeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LevelAttribute to aggregate.
     */
    where?: LevelAttributeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LevelAttributes to fetch.
     */
    orderBy?: LevelAttributeOrderByWithRelationInput | LevelAttributeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LevelAttributeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LevelAttributes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LevelAttributes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LevelAttributes
    **/
    _count?: true | LevelAttributeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LevelAttributeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LevelAttributeMaxAggregateInputType
  }

  export type GetLevelAttributeAggregateType<T extends LevelAttributeAggregateArgs> = {
        [P in keyof T & keyof AggregateLevelAttribute]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLevelAttribute[P]>
      : GetScalarType<T[P], AggregateLevelAttribute[P]>
  }




  export type LevelAttributeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LevelAttributeWhereInput
    orderBy?: LevelAttributeOrderByWithAggregationInput | LevelAttributeOrderByWithAggregationInput[]
    by: LevelAttributeScalarFieldEnum[] | LevelAttributeScalarFieldEnum
    having?: LevelAttributeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LevelAttributeCountAggregateInputType | true
    _min?: LevelAttributeMinAggregateInputType
    _max?: LevelAttributeMaxAggregateInputType
  }

  export type LevelAttributeGroupByOutputType = {
    id: string
    code: string
    name: string
    description: string | null
    clientId: string
    instanceId: string
    attributeValueDefault: string | null
    createdAt: Date | null
    updatedAt: Date | null
    _count: LevelAttributeCountAggregateOutputType | null
    _min: LevelAttributeMinAggregateOutputType | null
    _max: LevelAttributeMaxAggregateOutputType | null
  }

  type GetLevelAttributeGroupByPayload<T extends LevelAttributeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LevelAttributeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LevelAttributeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LevelAttributeGroupByOutputType[P]>
            : GetScalarType<T[P], LevelAttributeGroupByOutputType[P]>
        }
      >
    >


  export type LevelAttributeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    clientId?: boolean
    instanceId?: boolean
    attributeValueDefault?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    instance?: boolean | InstanceDefaultArgs<ExtArgs>
    levelAttributeValues?: boolean | LevelAttribute$levelAttributeValuesArgs<ExtArgs>
    levelAttributeAndValues?: boolean | LevelAttribute$levelAttributeAndValuesArgs<ExtArgs>
    _count?: boolean | LevelAttributeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["levelAttribute"]>



  export type LevelAttributeSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    clientId?: boolean
    instanceId?: boolean
    attributeValueDefault?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LevelAttributeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "name" | "description" | "clientId" | "instanceId" | "attributeValueDefault" | "createdAt" | "updatedAt", ExtArgs["result"]["levelAttribute"]>
  export type LevelAttributeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    instance?: boolean | InstanceDefaultArgs<ExtArgs>
    levelAttributeValues?: boolean | LevelAttribute$levelAttributeValuesArgs<ExtArgs>
    levelAttributeAndValues?: boolean | LevelAttribute$levelAttributeAndValuesArgs<ExtArgs>
    _count?: boolean | LevelAttributeCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $LevelAttributePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LevelAttribute"
    objects: {
      instance: Prisma.$InstancePayload<ExtArgs>
      levelAttributeValues: Prisma.$LevelAttributeValuePayload<ExtArgs>[]
      levelAttributeAndValues: Prisma.$LevelAttributeAndValuePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      name: string
      description: string | null
      clientId: string
      instanceId: string
      attributeValueDefault: string | null
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["levelAttribute"]>
    composites: {}
  }

  type LevelAttributeGetPayload<S extends boolean | null | undefined | LevelAttributeDefaultArgs> = $Result.GetResult<Prisma.$LevelAttributePayload, S>

  type LevelAttributeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LevelAttributeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LevelAttributeCountAggregateInputType | true
    }

  export interface LevelAttributeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LevelAttribute'], meta: { name: 'LevelAttribute' } }
    /**
     * Find zero or one LevelAttribute that matches the filter.
     * @param {LevelAttributeFindUniqueArgs} args - Arguments to find a LevelAttribute
     * @example
     * // Get one LevelAttribute
     * const levelAttribute = await prisma.levelAttribute.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LevelAttributeFindUniqueArgs>(args: SelectSubset<T, LevelAttributeFindUniqueArgs<ExtArgs>>): Prisma__LevelAttributeClient<$Result.GetResult<Prisma.$LevelAttributePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one LevelAttribute that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LevelAttributeFindUniqueOrThrowArgs} args - Arguments to find a LevelAttribute
     * @example
     * // Get one LevelAttribute
     * const levelAttribute = await prisma.levelAttribute.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LevelAttributeFindUniqueOrThrowArgs>(args: SelectSubset<T, LevelAttributeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LevelAttributeClient<$Result.GetResult<Prisma.$LevelAttributePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first LevelAttribute that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevelAttributeFindFirstArgs} args - Arguments to find a LevelAttribute
     * @example
     * // Get one LevelAttribute
     * const levelAttribute = await prisma.levelAttribute.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LevelAttributeFindFirstArgs>(args?: SelectSubset<T, LevelAttributeFindFirstArgs<ExtArgs>>): Prisma__LevelAttributeClient<$Result.GetResult<Prisma.$LevelAttributePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first LevelAttribute that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevelAttributeFindFirstOrThrowArgs} args - Arguments to find a LevelAttribute
     * @example
     * // Get one LevelAttribute
     * const levelAttribute = await prisma.levelAttribute.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LevelAttributeFindFirstOrThrowArgs>(args?: SelectSubset<T, LevelAttributeFindFirstOrThrowArgs<ExtArgs>>): Prisma__LevelAttributeClient<$Result.GetResult<Prisma.$LevelAttributePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more LevelAttributes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevelAttributeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LevelAttributes
     * const levelAttributes = await prisma.levelAttribute.findMany()
     * 
     * // Get first 10 LevelAttributes
     * const levelAttributes = await prisma.levelAttribute.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const levelAttributeWithIdOnly = await prisma.levelAttribute.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LevelAttributeFindManyArgs>(args?: SelectSubset<T, LevelAttributeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LevelAttributePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a LevelAttribute.
     * @param {LevelAttributeCreateArgs} args - Arguments to create a LevelAttribute.
     * @example
     * // Create one LevelAttribute
     * const LevelAttribute = await prisma.levelAttribute.create({
     *   data: {
     *     // ... data to create a LevelAttribute
     *   }
     * })
     * 
     */
    create<T extends LevelAttributeCreateArgs>(args: SelectSubset<T, LevelAttributeCreateArgs<ExtArgs>>): Prisma__LevelAttributeClient<$Result.GetResult<Prisma.$LevelAttributePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many LevelAttributes.
     * @param {LevelAttributeCreateManyArgs} args - Arguments to create many LevelAttributes.
     * @example
     * // Create many LevelAttributes
     * const levelAttribute = await prisma.levelAttribute.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LevelAttributeCreateManyArgs>(args?: SelectSubset<T, LevelAttributeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LevelAttribute.
     * @param {LevelAttributeDeleteArgs} args - Arguments to delete one LevelAttribute.
     * @example
     * // Delete one LevelAttribute
     * const LevelAttribute = await prisma.levelAttribute.delete({
     *   where: {
     *     // ... filter to delete one LevelAttribute
     *   }
     * })
     * 
     */
    delete<T extends LevelAttributeDeleteArgs>(args: SelectSubset<T, LevelAttributeDeleteArgs<ExtArgs>>): Prisma__LevelAttributeClient<$Result.GetResult<Prisma.$LevelAttributePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one LevelAttribute.
     * @param {LevelAttributeUpdateArgs} args - Arguments to update one LevelAttribute.
     * @example
     * // Update one LevelAttribute
     * const levelAttribute = await prisma.levelAttribute.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LevelAttributeUpdateArgs>(args: SelectSubset<T, LevelAttributeUpdateArgs<ExtArgs>>): Prisma__LevelAttributeClient<$Result.GetResult<Prisma.$LevelAttributePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more LevelAttributes.
     * @param {LevelAttributeDeleteManyArgs} args - Arguments to filter LevelAttributes to delete.
     * @example
     * // Delete a few LevelAttributes
     * const { count } = await prisma.levelAttribute.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LevelAttributeDeleteManyArgs>(args?: SelectSubset<T, LevelAttributeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LevelAttributes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevelAttributeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LevelAttributes
     * const levelAttribute = await prisma.levelAttribute.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LevelAttributeUpdateManyArgs>(args: SelectSubset<T, LevelAttributeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LevelAttribute.
     * @param {LevelAttributeUpsertArgs} args - Arguments to update or create a LevelAttribute.
     * @example
     * // Update or create a LevelAttribute
     * const levelAttribute = await prisma.levelAttribute.upsert({
     *   create: {
     *     // ... data to create a LevelAttribute
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LevelAttribute we want to update
     *   }
     * })
     */
    upsert<T extends LevelAttributeUpsertArgs>(args: SelectSubset<T, LevelAttributeUpsertArgs<ExtArgs>>): Prisma__LevelAttributeClient<$Result.GetResult<Prisma.$LevelAttributePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more LevelAttributes that matches the filter.
     * @param {LevelAttributeFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const levelAttribute = await prisma.levelAttribute.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: LevelAttributeFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a LevelAttribute.
     * @param {LevelAttributeAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const levelAttribute = await prisma.levelAttribute.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: LevelAttributeAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of LevelAttributes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevelAttributeCountArgs} args - Arguments to filter LevelAttributes to count.
     * @example
     * // Count the number of LevelAttributes
     * const count = await prisma.levelAttribute.count({
     *   where: {
     *     // ... the filter for the LevelAttributes we want to count
     *   }
     * })
    **/
    count<T extends LevelAttributeCountArgs>(
      args?: Subset<T, LevelAttributeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LevelAttributeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LevelAttribute.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevelAttributeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LevelAttributeAggregateArgs>(args: Subset<T, LevelAttributeAggregateArgs>): Prisma.PrismaPromise<GetLevelAttributeAggregateType<T>>

    /**
     * Group by LevelAttribute.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevelAttributeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LevelAttributeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LevelAttributeGroupByArgs['orderBy'] }
        : { orderBy?: LevelAttributeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LevelAttributeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLevelAttributeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LevelAttribute model
   */
  readonly fields: LevelAttributeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LevelAttribute.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LevelAttributeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    instance<T extends InstanceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InstanceDefaultArgs<ExtArgs>>): Prisma__InstanceClient<$Result.GetResult<Prisma.$InstancePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    levelAttributeValues<T extends LevelAttribute$levelAttributeValuesArgs<ExtArgs> = {}>(args?: Subset<T, LevelAttribute$levelAttributeValuesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LevelAttributeValuePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    levelAttributeAndValues<T extends LevelAttribute$levelAttributeAndValuesArgs<ExtArgs> = {}>(args?: Subset<T, LevelAttribute$levelAttributeAndValuesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LevelAttributeAndValuePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LevelAttribute model
   */ 
  interface LevelAttributeFieldRefs {
    readonly id: FieldRef<"LevelAttribute", 'String'>
    readonly code: FieldRef<"LevelAttribute", 'String'>
    readonly name: FieldRef<"LevelAttribute", 'String'>
    readonly description: FieldRef<"LevelAttribute", 'String'>
    readonly clientId: FieldRef<"LevelAttribute", 'String'>
    readonly instanceId: FieldRef<"LevelAttribute", 'String'>
    readonly attributeValueDefault: FieldRef<"LevelAttribute", 'String'>
    readonly createdAt: FieldRef<"LevelAttribute", 'DateTime'>
    readonly updatedAt: FieldRef<"LevelAttribute", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LevelAttribute findUnique
   */
  export type LevelAttributeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LevelAttribute
     */
    select?: LevelAttributeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LevelAttribute
     */
    omit?: LevelAttributeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelAttributeInclude<ExtArgs> | null
    /**
     * Filter, which LevelAttribute to fetch.
     */
    where: LevelAttributeWhereUniqueInput
  }

  /**
   * LevelAttribute findUniqueOrThrow
   */
  export type LevelAttributeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LevelAttribute
     */
    select?: LevelAttributeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LevelAttribute
     */
    omit?: LevelAttributeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelAttributeInclude<ExtArgs> | null
    /**
     * Filter, which LevelAttribute to fetch.
     */
    where: LevelAttributeWhereUniqueInput
  }

  /**
   * LevelAttribute findFirst
   */
  export type LevelAttributeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LevelAttribute
     */
    select?: LevelAttributeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LevelAttribute
     */
    omit?: LevelAttributeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelAttributeInclude<ExtArgs> | null
    /**
     * Filter, which LevelAttribute to fetch.
     */
    where?: LevelAttributeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LevelAttributes to fetch.
     */
    orderBy?: LevelAttributeOrderByWithRelationInput | LevelAttributeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LevelAttributes.
     */
    cursor?: LevelAttributeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LevelAttributes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LevelAttributes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LevelAttributes.
     */
    distinct?: LevelAttributeScalarFieldEnum | LevelAttributeScalarFieldEnum[]
  }

  /**
   * LevelAttribute findFirstOrThrow
   */
  export type LevelAttributeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LevelAttribute
     */
    select?: LevelAttributeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LevelAttribute
     */
    omit?: LevelAttributeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelAttributeInclude<ExtArgs> | null
    /**
     * Filter, which LevelAttribute to fetch.
     */
    where?: LevelAttributeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LevelAttributes to fetch.
     */
    orderBy?: LevelAttributeOrderByWithRelationInput | LevelAttributeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LevelAttributes.
     */
    cursor?: LevelAttributeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LevelAttributes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LevelAttributes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LevelAttributes.
     */
    distinct?: LevelAttributeScalarFieldEnum | LevelAttributeScalarFieldEnum[]
  }

  /**
   * LevelAttribute findMany
   */
  export type LevelAttributeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LevelAttribute
     */
    select?: LevelAttributeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LevelAttribute
     */
    omit?: LevelAttributeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelAttributeInclude<ExtArgs> | null
    /**
     * Filter, which LevelAttributes to fetch.
     */
    where?: LevelAttributeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LevelAttributes to fetch.
     */
    orderBy?: LevelAttributeOrderByWithRelationInput | LevelAttributeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LevelAttributes.
     */
    cursor?: LevelAttributeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LevelAttributes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LevelAttributes.
     */
    skip?: number
    distinct?: LevelAttributeScalarFieldEnum | LevelAttributeScalarFieldEnum[]
  }

  /**
   * LevelAttribute create
   */
  export type LevelAttributeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LevelAttribute
     */
    select?: LevelAttributeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LevelAttribute
     */
    omit?: LevelAttributeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelAttributeInclude<ExtArgs> | null
    /**
     * The data needed to create a LevelAttribute.
     */
    data: XOR<LevelAttributeCreateInput, LevelAttributeUncheckedCreateInput>
  }

  /**
   * LevelAttribute createMany
   */
  export type LevelAttributeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LevelAttributes.
     */
    data: LevelAttributeCreateManyInput | LevelAttributeCreateManyInput[]
  }

  /**
   * LevelAttribute update
   */
  export type LevelAttributeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LevelAttribute
     */
    select?: LevelAttributeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LevelAttribute
     */
    omit?: LevelAttributeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelAttributeInclude<ExtArgs> | null
    /**
     * The data needed to update a LevelAttribute.
     */
    data: XOR<LevelAttributeUpdateInput, LevelAttributeUncheckedUpdateInput>
    /**
     * Choose, which LevelAttribute to update.
     */
    where: LevelAttributeWhereUniqueInput
  }

  /**
   * LevelAttribute updateMany
   */
  export type LevelAttributeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LevelAttributes.
     */
    data: XOR<LevelAttributeUpdateManyMutationInput, LevelAttributeUncheckedUpdateManyInput>
    /**
     * Filter which LevelAttributes to update
     */
    where?: LevelAttributeWhereInput
    /**
     * Limit how many LevelAttributes to update.
     */
    limit?: number
  }

  /**
   * LevelAttribute upsert
   */
  export type LevelAttributeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LevelAttribute
     */
    select?: LevelAttributeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LevelAttribute
     */
    omit?: LevelAttributeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelAttributeInclude<ExtArgs> | null
    /**
     * The filter to search for the LevelAttribute to update in case it exists.
     */
    where: LevelAttributeWhereUniqueInput
    /**
     * In case the LevelAttribute found by the `where` argument doesn't exist, create a new LevelAttribute with this data.
     */
    create: XOR<LevelAttributeCreateInput, LevelAttributeUncheckedCreateInput>
    /**
     * In case the LevelAttribute was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LevelAttributeUpdateInput, LevelAttributeUncheckedUpdateInput>
  }

  /**
   * LevelAttribute delete
   */
  export type LevelAttributeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LevelAttribute
     */
    select?: LevelAttributeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LevelAttribute
     */
    omit?: LevelAttributeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelAttributeInclude<ExtArgs> | null
    /**
     * Filter which LevelAttribute to delete.
     */
    where: LevelAttributeWhereUniqueInput
  }

  /**
   * LevelAttribute deleteMany
   */
  export type LevelAttributeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LevelAttributes to delete
     */
    where?: LevelAttributeWhereInput
    /**
     * Limit how many LevelAttributes to delete.
     */
    limit?: number
  }

  /**
   * LevelAttribute findRaw
   */
  export type LevelAttributeFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * LevelAttribute aggregateRaw
   */
  export type LevelAttributeAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * LevelAttribute.levelAttributeValues
   */
  export type LevelAttribute$levelAttributeValuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LevelAttributeValue
     */
    select?: LevelAttributeValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LevelAttributeValue
     */
    omit?: LevelAttributeValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelAttributeValueInclude<ExtArgs> | null
    where?: LevelAttributeValueWhereInput
    orderBy?: LevelAttributeValueOrderByWithRelationInput | LevelAttributeValueOrderByWithRelationInput[]
    cursor?: LevelAttributeValueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LevelAttributeValueScalarFieldEnum | LevelAttributeValueScalarFieldEnum[]
  }

  /**
   * LevelAttribute.levelAttributeAndValues
   */
  export type LevelAttribute$levelAttributeAndValuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LevelAttributeAndValue
     */
    select?: LevelAttributeAndValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LevelAttributeAndValue
     */
    omit?: LevelAttributeAndValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelAttributeAndValueInclude<ExtArgs> | null
    where?: LevelAttributeAndValueWhereInput
    orderBy?: LevelAttributeAndValueOrderByWithRelationInput | LevelAttributeAndValueOrderByWithRelationInput[]
    cursor?: LevelAttributeAndValueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LevelAttributeAndValueScalarFieldEnum | LevelAttributeAndValueScalarFieldEnum[]
  }

  /**
   * LevelAttribute without action
   */
  export type LevelAttributeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LevelAttribute
     */
    select?: LevelAttributeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LevelAttribute
     */
    omit?: LevelAttributeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelAttributeInclude<ExtArgs> | null
  }


  /**
   * Model AccountAttribute
   */

  export type AggregateAccountAttribute = {
    _count: AccountAttributeCountAggregateOutputType | null
    _min: AccountAttributeMinAggregateOutputType | null
    _max: AccountAttributeMaxAggregateOutputType | null
  }

  export type AccountAttributeMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    description: string | null
    attributeValueDefault: string | null
    clientId: string | null
    instanceId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountAttributeMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    description: string | null
    attributeValueDefault: string | null
    clientId: string | null
    instanceId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountAttributeCountAggregateOutputType = {
    id: number
    code: number
    name: number
    description: number
    attributeValueDefault: number
    clientId: number
    instanceId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AccountAttributeMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    attributeValueDefault?: true
    clientId?: true
    instanceId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountAttributeMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    attributeValueDefault?: true
    clientId?: true
    instanceId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountAttributeCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    attributeValueDefault?: true
    clientId?: true
    instanceId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AccountAttributeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AccountAttribute to aggregate.
     */
    where?: AccountAttributeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountAttributes to fetch.
     */
    orderBy?: AccountAttributeOrderByWithRelationInput | AccountAttributeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountAttributeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountAttributes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountAttributes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AccountAttributes
    **/
    _count?: true | AccountAttributeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountAttributeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountAttributeMaxAggregateInputType
  }

  export type GetAccountAttributeAggregateType<T extends AccountAttributeAggregateArgs> = {
        [P in keyof T & keyof AggregateAccountAttribute]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccountAttribute[P]>
      : GetScalarType<T[P], AggregateAccountAttribute[P]>
  }




  export type AccountAttributeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountAttributeWhereInput
    orderBy?: AccountAttributeOrderByWithAggregationInput | AccountAttributeOrderByWithAggregationInput[]
    by: AccountAttributeScalarFieldEnum[] | AccountAttributeScalarFieldEnum
    having?: AccountAttributeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountAttributeCountAggregateInputType | true
    _min?: AccountAttributeMinAggregateInputType
    _max?: AccountAttributeMaxAggregateInputType
  }

  export type AccountAttributeGroupByOutputType = {
    id: string
    code: string
    name: string
    description: string | null
    attributeValueDefault: string | null
    clientId: string
    instanceId: string
    createdAt: Date | null
    updatedAt: Date | null
    _count: AccountAttributeCountAggregateOutputType | null
    _min: AccountAttributeMinAggregateOutputType | null
    _max: AccountAttributeMaxAggregateOutputType | null
  }

  type GetAccountAttributeGroupByPayload<T extends AccountAttributeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountAttributeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountAttributeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountAttributeGroupByOutputType[P]>
            : GetScalarType<T[P], AccountAttributeGroupByOutputType[P]>
        }
      >
    >


  export type AccountAttributeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    attributeValueDefault?: boolean
    clientId?: boolean
    instanceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    instance?: boolean | InstanceDefaultArgs<ExtArgs>
    accountAttributeValues?: boolean | AccountAttribute$accountAttributeValuesArgs<ExtArgs>
    AttributeAndValues?: boolean | AccountAttribute$AttributeAndValuesArgs<ExtArgs>
    _count?: boolean | AccountAttributeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["accountAttribute"]>



  export type AccountAttributeSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    attributeValueDefault?: boolean
    clientId?: boolean
    instanceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AccountAttributeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "name" | "description" | "attributeValueDefault" | "clientId" | "instanceId" | "createdAt" | "updatedAt", ExtArgs["result"]["accountAttribute"]>
  export type AccountAttributeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    instance?: boolean | InstanceDefaultArgs<ExtArgs>
    accountAttributeValues?: boolean | AccountAttribute$accountAttributeValuesArgs<ExtArgs>
    AttributeAndValues?: boolean | AccountAttribute$AttributeAndValuesArgs<ExtArgs>
    _count?: boolean | AccountAttributeCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $AccountAttributePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AccountAttribute"
    objects: {
      instance: Prisma.$InstancePayload<ExtArgs>
      accountAttributeValues: Prisma.$AccountAttributeValuePayload<ExtArgs>[]
      AttributeAndValues: Prisma.$AccountAttributeAndValuePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      name: string
      description: string | null
      attributeValueDefault: string | null
      clientId: string
      instanceId: string
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["accountAttribute"]>
    composites: {}
  }

  type AccountAttributeGetPayload<S extends boolean | null | undefined | AccountAttributeDefaultArgs> = $Result.GetResult<Prisma.$AccountAttributePayload, S>

  type AccountAttributeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountAttributeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountAttributeCountAggregateInputType | true
    }

  export interface AccountAttributeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AccountAttribute'], meta: { name: 'AccountAttribute' } }
    /**
     * Find zero or one AccountAttribute that matches the filter.
     * @param {AccountAttributeFindUniqueArgs} args - Arguments to find a AccountAttribute
     * @example
     * // Get one AccountAttribute
     * const accountAttribute = await prisma.accountAttribute.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountAttributeFindUniqueArgs>(args: SelectSubset<T, AccountAttributeFindUniqueArgs<ExtArgs>>): Prisma__AccountAttributeClient<$Result.GetResult<Prisma.$AccountAttributePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one AccountAttribute that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountAttributeFindUniqueOrThrowArgs} args - Arguments to find a AccountAttribute
     * @example
     * // Get one AccountAttribute
     * const accountAttribute = await prisma.accountAttribute.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountAttributeFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountAttributeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountAttributeClient<$Result.GetResult<Prisma.$AccountAttributePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first AccountAttribute that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAttributeFindFirstArgs} args - Arguments to find a AccountAttribute
     * @example
     * // Get one AccountAttribute
     * const accountAttribute = await prisma.accountAttribute.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountAttributeFindFirstArgs>(args?: SelectSubset<T, AccountAttributeFindFirstArgs<ExtArgs>>): Prisma__AccountAttributeClient<$Result.GetResult<Prisma.$AccountAttributePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first AccountAttribute that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAttributeFindFirstOrThrowArgs} args - Arguments to find a AccountAttribute
     * @example
     * // Get one AccountAttribute
     * const accountAttribute = await prisma.accountAttribute.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountAttributeFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountAttributeFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountAttributeClient<$Result.GetResult<Prisma.$AccountAttributePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more AccountAttributes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAttributeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AccountAttributes
     * const accountAttributes = await prisma.accountAttribute.findMany()
     * 
     * // Get first 10 AccountAttributes
     * const accountAttributes = await prisma.accountAttribute.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountAttributeWithIdOnly = await prisma.accountAttribute.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountAttributeFindManyArgs>(args?: SelectSubset<T, AccountAttributeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountAttributePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a AccountAttribute.
     * @param {AccountAttributeCreateArgs} args - Arguments to create a AccountAttribute.
     * @example
     * // Create one AccountAttribute
     * const AccountAttribute = await prisma.accountAttribute.create({
     *   data: {
     *     // ... data to create a AccountAttribute
     *   }
     * })
     * 
     */
    create<T extends AccountAttributeCreateArgs>(args: SelectSubset<T, AccountAttributeCreateArgs<ExtArgs>>): Prisma__AccountAttributeClient<$Result.GetResult<Prisma.$AccountAttributePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many AccountAttributes.
     * @param {AccountAttributeCreateManyArgs} args - Arguments to create many AccountAttributes.
     * @example
     * // Create many AccountAttributes
     * const accountAttribute = await prisma.accountAttribute.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountAttributeCreateManyArgs>(args?: SelectSubset<T, AccountAttributeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AccountAttribute.
     * @param {AccountAttributeDeleteArgs} args - Arguments to delete one AccountAttribute.
     * @example
     * // Delete one AccountAttribute
     * const AccountAttribute = await prisma.accountAttribute.delete({
     *   where: {
     *     // ... filter to delete one AccountAttribute
     *   }
     * })
     * 
     */
    delete<T extends AccountAttributeDeleteArgs>(args: SelectSubset<T, AccountAttributeDeleteArgs<ExtArgs>>): Prisma__AccountAttributeClient<$Result.GetResult<Prisma.$AccountAttributePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one AccountAttribute.
     * @param {AccountAttributeUpdateArgs} args - Arguments to update one AccountAttribute.
     * @example
     * // Update one AccountAttribute
     * const accountAttribute = await prisma.accountAttribute.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountAttributeUpdateArgs>(args: SelectSubset<T, AccountAttributeUpdateArgs<ExtArgs>>): Prisma__AccountAttributeClient<$Result.GetResult<Prisma.$AccountAttributePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more AccountAttributes.
     * @param {AccountAttributeDeleteManyArgs} args - Arguments to filter AccountAttributes to delete.
     * @example
     * // Delete a few AccountAttributes
     * const { count } = await prisma.accountAttribute.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountAttributeDeleteManyArgs>(args?: SelectSubset<T, AccountAttributeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AccountAttributes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAttributeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AccountAttributes
     * const accountAttribute = await prisma.accountAttribute.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountAttributeUpdateManyArgs>(args: SelectSubset<T, AccountAttributeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AccountAttribute.
     * @param {AccountAttributeUpsertArgs} args - Arguments to update or create a AccountAttribute.
     * @example
     * // Update or create a AccountAttribute
     * const accountAttribute = await prisma.accountAttribute.upsert({
     *   create: {
     *     // ... data to create a AccountAttribute
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AccountAttribute we want to update
     *   }
     * })
     */
    upsert<T extends AccountAttributeUpsertArgs>(args: SelectSubset<T, AccountAttributeUpsertArgs<ExtArgs>>): Prisma__AccountAttributeClient<$Result.GetResult<Prisma.$AccountAttributePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more AccountAttributes that matches the filter.
     * @param {AccountAttributeFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const accountAttribute = await prisma.accountAttribute.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: AccountAttributeFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a AccountAttribute.
     * @param {AccountAttributeAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const accountAttribute = await prisma.accountAttribute.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: AccountAttributeAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of AccountAttributes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAttributeCountArgs} args - Arguments to filter AccountAttributes to count.
     * @example
     * // Count the number of AccountAttributes
     * const count = await prisma.accountAttribute.count({
     *   where: {
     *     // ... the filter for the AccountAttributes we want to count
     *   }
     * })
    **/
    count<T extends AccountAttributeCountArgs>(
      args?: Subset<T, AccountAttributeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountAttributeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AccountAttribute.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAttributeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAttributeAggregateArgs>(args: Subset<T, AccountAttributeAggregateArgs>): Prisma.PrismaPromise<GetAccountAttributeAggregateType<T>>

    /**
     * Group by AccountAttribute.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAttributeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountAttributeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountAttributeGroupByArgs['orderBy'] }
        : { orderBy?: AccountAttributeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountAttributeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountAttributeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AccountAttribute model
   */
  readonly fields: AccountAttributeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AccountAttribute.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountAttributeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    instance<T extends InstanceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InstanceDefaultArgs<ExtArgs>>): Prisma__InstanceClient<$Result.GetResult<Prisma.$InstancePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    accountAttributeValues<T extends AccountAttribute$accountAttributeValuesArgs<ExtArgs> = {}>(args?: Subset<T, AccountAttribute$accountAttributeValuesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountAttributeValuePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    AttributeAndValues<T extends AccountAttribute$AttributeAndValuesArgs<ExtArgs> = {}>(args?: Subset<T, AccountAttribute$AttributeAndValuesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountAttributeAndValuePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AccountAttribute model
   */ 
  interface AccountAttributeFieldRefs {
    readonly id: FieldRef<"AccountAttribute", 'String'>
    readonly code: FieldRef<"AccountAttribute", 'String'>
    readonly name: FieldRef<"AccountAttribute", 'String'>
    readonly description: FieldRef<"AccountAttribute", 'String'>
    readonly attributeValueDefault: FieldRef<"AccountAttribute", 'String'>
    readonly clientId: FieldRef<"AccountAttribute", 'String'>
    readonly instanceId: FieldRef<"AccountAttribute", 'String'>
    readonly createdAt: FieldRef<"AccountAttribute", 'DateTime'>
    readonly updatedAt: FieldRef<"AccountAttribute", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AccountAttribute findUnique
   */
  export type AccountAttributeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountAttribute
     */
    select?: AccountAttributeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountAttribute
     */
    omit?: AccountAttributeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountAttributeInclude<ExtArgs> | null
    /**
     * Filter, which AccountAttribute to fetch.
     */
    where: AccountAttributeWhereUniqueInput
  }

  /**
   * AccountAttribute findUniqueOrThrow
   */
  export type AccountAttributeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountAttribute
     */
    select?: AccountAttributeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountAttribute
     */
    omit?: AccountAttributeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountAttributeInclude<ExtArgs> | null
    /**
     * Filter, which AccountAttribute to fetch.
     */
    where: AccountAttributeWhereUniqueInput
  }

  /**
   * AccountAttribute findFirst
   */
  export type AccountAttributeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountAttribute
     */
    select?: AccountAttributeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountAttribute
     */
    omit?: AccountAttributeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountAttributeInclude<ExtArgs> | null
    /**
     * Filter, which AccountAttribute to fetch.
     */
    where?: AccountAttributeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountAttributes to fetch.
     */
    orderBy?: AccountAttributeOrderByWithRelationInput | AccountAttributeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AccountAttributes.
     */
    cursor?: AccountAttributeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountAttributes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountAttributes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AccountAttributes.
     */
    distinct?: AccountAttributeScalarFieldEnum | AccountAttributeScalarFieldEnum[]
  }

  /**
   * AccountAttribute findFirstOrThrow
   */
  export type AccountAttributeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountAttribute
     */
    select?: AccountAttributeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountAttribute
     */
    omit?: AccountAttributeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountAttributeInclude<ExtArgs> | null
    /**
     * Filter, which AccountAttribute to fetch.
     */
    where?: AccountAttributeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountAttributes to fetch.
     */
    orderBy?: AccountAttributeOrderByWithRelationInput | AccountAttributeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AccountAttributes.
     */
    cursor?: AccountAttributeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountAttributes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountAttributes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AccountAttributes.
     */
    distinct?: AccountAttributeScalarFieldEnum | AccountAttributeScalarFieldEnum[]
  }

  /**
   * AccountAttribute findMany
   */
  export type AccountAttributeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountAttribute
     */
    select?: AccountAttributeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountAttribute
     */
    omit?: AccountAttributeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountAttributeInclude<ExtArgs> | null
    /**
     * Filter, which AccountAttributes to fetch.
     */
    where?: AccountAttributeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountAttributes to fetch.
     */
    orderBy?: AccountAttributeOrderByWithRelationInput | AccountAttributeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AccountAttributes.
     */
    cursor?: AccountAttributeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountAttributes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountAttributes.
     */
    skip?: number
    distinct?: AccountAttributeScalarFieldEnum | AccountAttributeScalarFieldEnum[]
  }

  /**
   * AccountAttribute create
   */
  export type AccountAttributeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountAttribute
     */
    select?: AccountAttributeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountAttribute
     */
    omit?: AccountAttributeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountAttributeInclude<ExtArgs> | null
    /**
     * The data needed to create a AccountAttribute.
     */
    data: XOR<AccountAttributeCreateInput, AccountAttributeUncheckedCreateInput>
  }

  /**
   * AccountAttribute createMany
   */
  export type AccountAttributeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AccountAttributes.
     */
    data: AccountAttributeCreateManyInput | AccountAttributeCreateManyInput[]
  }

  /**
   * AccountAttribute update
   */
  export type AccountAttributeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountAttribute
     */
    select?: AccountAttributeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountAttribute
     */
    omit?: AccountAttributeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountAttributeInclude<ExtArgs> | null
    /**
     * The data needed to update a AccountAttribute.
     */
    data: XOR<AccountAttributeUpdateInput, AccountAttributeUncheckedUpdateInput>
    /**
     * Choose, which AccountAttribute to update.
     */
    where: AccountAttributeWhereUniqueInput
  }

  /**
   * AccountAttribute updateMany
   */
  export type AccountAttributeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AccountAttributes.
     */
    data: XOR<AccountAttributeUpdateManyMutationInput, AccountAttributeUncheckedUpdateManyInput>
    /**
     * Filter which AccountAttributes to update
     */
    where?: AccountAttributeWhereInput
    /**
     * Limit how many AccountAttributes to update.
     */
    limit?: number
  }

  /**
   * AccountAttribute upsert
   */
  export type AccountAttributeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountAttribute
     */
    select?: AccountAttributeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountAttribute
     */
    omit?: AccountAttributeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountAttributeInclude<ExtArgs> | null
    /**
     * The filter to search for the AccountAttribute to update in case it exists.
     */
    where: AccountAttributeWhereUniqueInput
    /**
     * In case the AccountAttribute found by the `where` argument doesn't exist, create a new AccountAttribute with this data.
     */
    create: XOR<AccountAttributeCreateInput, AccountAttributeUncheckedCreateInput>
    /**
     * In case the AccountAttribute was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountAttributeUpdateInput, AccountAttributeUncheckedUpdateInput>
  }

  /**
   * AccountAttribute delete
   */
  export type AccountAttributeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountAttribute
     */
    select?: AccountAttributeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountAttribute
     */
    omit?: AccountAttributeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountAttributeInclude<ExtArgs> | null
    /**
     * Filter which AccountAttribute to delete.
     */
    where: AccountAttributeWhereUniqueInput
  }

  /**
   * AccountAttribute deleteMany
   */
  export type AccountAttributeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AccountAttributes to delete
     */
    where?: AccountAttributeWhereInput
    /**
     * Limit how many AccountAttributes to delete.
     */
    limit?: number
  }

  /**
   * AccountAttribute findRaw
   */
  export type AccountAttributeFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * AccountAttribute aggregateRaw
   */
  export type AccountAttributeAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * AccountAttribute.accountAttributeValues
   */
  export type AccountAttribute$accountAttributeValuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountAttributeValue
     */
    select?: AccountAttributeValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountAttributeValue
     */
    omit?: AccountAttributeValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountAttributeValueInclude<ExtArgs> | null
    where?: AccountAttributeValueWhereInput
    orderBy?: AccountAttributeValueOrderByWithRelationInput | AccountAttributeValueOrderByWithRelationInput[]
    cursor?: AccountAttributeValueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountAttributeValueScalarFieldEnum | AccountAttributeValueScalarFieldEnum[]
  }

  /**
   * AccountAttribute.AttributeAndValues
   */
  export type AccountAttribute$AttributeAndValuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountAttributeAndValue
     */
    select?: AccountAttributeAndValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountAttributeAndValue
     */
    omit?: AccountAttributeAndValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountAttributeAndValueInclude<ExtArgs> | null
    where?: AccountAttributeAndValueWhereInput
    orderBy?: AccountAttributeAndValueOrderByWithRelationInput | AccountAttributeAndValueOrderByWithRelationInput[]
    cursor?: AccountAttributeAndValueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountAttributeAndValueScalarFieldEnum | AccountAttributeAndValueScalarFieldEnum[]
  }

  /**
   * AccountAttribute without action
   */
  export type AccountAttributeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountAttribute
     */
    select?: AccountAttributeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountAttribute
     */
    omit?: AccountAttributeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountAttributeInclude<ExtArgs> | null
  }


  /**
   * Model AccountAttributeValue
   */

  export type AggregateAccountAttributeValue = {
    _count: AccountAttributeValueCountAggregateOutputType | null
    _min: AccountAttributeValueMinAggregateOutputType | null
    _max: AccountAttributeValueMaxAggregateOutputType | null
  }

  export type AccountAttributeValueMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    attributeId: string | null
    parentId: string | null
    clientId: string | null
    instanceId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountAttributeValueMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    attributeId: string | null
    parentId: string | null
    clientId: string | null
    instanceId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountAttributeValueCountAggregateOutputType = {
    id: number
    code: number
    name: number
    attributeId: number
    parentId: number
    clientId: number
    instanceId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AccountAttributeValueMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    attributeId?: true
    parentId?: true
    clientId?: true
    instanceId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountAttributeValueMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    attributeId?: true
    parentId?: true
    clientId?: true
    instanceId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountAttributeValueCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    attributeId?: true
    parentId?: true
    clientId?: true
    instanceId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AccountAttributeValueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AccountAttributeValue to aggregate.
     */
    where?: AccountAttributeValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountAttributeValues to fetch.
     */
    orderBy?: AccountAttributeValueOrderByWithRelationInput | AccountAttributeValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountAttributeValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountAttributeValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountAttributeValues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AccountAttributeValues
    **/
    _count?: true | AccountAttributeValueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountAttributeValueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountAttributeValueMaxAggregateInputType
  }

  export type GetAccountAttributeValueAggregateType<T extends AccountAttributeValueAggregateArgs> = {
        [P in keyof T & keyof AggregateAccountAttributeValue]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccountAttributeValue[P]>
      : GetScalarType<T[P], AggregateAccountAttributeValue[P]>
  }




  export type AccountAttributeValueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountAttributeValueWhereInput
    orderBy?: AccountAttributeValueOrderByWithAggregationInput | AccountAttributeValueOrderByWithAggregationInput[]
    by: AccountAttributeValueScalarFieldEnum[] | AccountAttributeValueScalarFieldEnum
    having?: AccountAttributeValueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountAttributeValueCountAggregateInputType | true
    _min?: AccountAttributeValueMinAggregateInputType
    _max?: AccountAttributeValueMaxAggregateInputType
  }

  export type AccountAttributeValueGroupByOutputType = {
    id: string
    code: string
    name: string
    attributeId: string
    parentId: string | null
    clientId: string
    instanceId: string
    createdAt: Date | null
    updatedAt: Date | null
    _count: AccountAttributeValueCountAggregateOutputType | null
    _min: AccountAttributeValueMinAggregateOutputType | null
    _max: AccountAttributeValueMaxAggregateOutputType | null
  }

  type GetAccountAttributeValueGroupByPayload<T extends AccountAttributeValueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountAttributeValueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountAttributeValueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountAttributeValueGroupByOutputType[P]>
            : GetScalarType<T[P], AccountAttributeValueGroupByOutputType[P]>
        }
      >
    >


  export type AccountAttributeValueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    attributeId?: boolean
    parentId?: boolean
    clientId?: boolean
    instanceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parent?: boolean | AccountAttributeValue$parentArgs<ExtArgs>
    childAttributeValues?: boolean | AccountAttributeValue$childAttributeValuesArgs<ExtArgs>
    accountAttribute?: boolean | AccountAttributeDefaultArgs<ExtArgs>
    instance?: boolean | InstanceDefaultArgs<ExtArgs>
    AttributeAndValues?: boolean | AccountAttributeValue$AttributeAndValuesArgs<ExtArgs>
    _count?: boolean | AccountAttributeValueCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["accountAttributeValue"]>



  export type AccountAttributeValueSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    attributeId?: boolean
    parentId?: boolean
    clientId?: boolean
    instanceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AccountAttributeValueOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "name" | "attributeId" | "parentId" | "clientId" | "instanceId" | "createdAt" | "updatedAt", ExtArgs["result"]["accountAttributeValue"]>
  export type AccountAttributeValueInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | AccountAttributeValue$parentArgs<ExtArgs>
    childAttributeValues?: boolean | AccountAttributeValue$childAttributeValuesArgs<ExtArgs>
    accountAttribute?: boolean | AccountAttributeDefaultArgs<ExtArgs>
    instance?: boolean | InstanceDefaultArgs<ExtArgs>
    AttributeAndValues?: boolean | AccountAttributeValue$AttributeAndValuesArgs<ExtArgs>
    _count?: boolean | AccountAttributeValueCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $AccountAttributeValuePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AccountAttributeValue"
    objects: {
      parent: Prisma.$AccountAttributeValuePayload<ExtArgs> | null
      childAttributeValues: Prisma.$AccountAttributeValuePayload<ExtArgs>[]
      accountAttribute: Prisma.$AccountAttributePayload<ExtArgs>
      instance: Prisma.$InstancePayload<ExtArgs>
      AttributeAndValues: Prisma.$AccountAttributeAndValuePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      name: string
      attributeId: string
      parentId: string | null
      clientId: string
      instanceId: string
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["accountAttributeValue"]>
    composites: {}
  }

  type AccountAttributeValueGetPayload<S extends boolean | null | undefined | AccountAttributeValueDefaultArgs> = $Result.GetResult<Prisma.$AccountAttributeValuePayload, S>

  type AccountAttributeValueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountAttributeValueFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountAttributeValueCountAggregateInputType | true
    }

  export interface AccountAttributeValueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AccountAttributeValue'], meta: { name: 'AccountAttributeValue' } }
    /**
     * Find zero or one AccountAttributeValue that matches the filter.
     * @param {AccountAttributeValueFindUniqueArgs} args - Arguments to find a AccountAttributeValue
     * @example
     * // Get one AccountAttributeValue
     * const accountAttributeValue = await prisma.accountAttributeValue.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountAttributeValueFindUniqueArgs>(args: SelectSubset<T, AccountAttributeValueFindUniqueArgs<ExtArgs>>): Prisma__AccountAttributeValueClient<$Result.GetResult<Prisma.$AccountAttributeValuePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one AccountAttributeValue that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountAttributeValueFindUniqueOrThrowArgs} args - Arguments to find a AccountAttributeValue
     * @example
     * // Get one AccountAttributeValue
     * const accountAttributeValue = await prisma.accountAttributeValue.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountAttributeValueFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountAttributeValueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountAttributeValueClient<$Result.GetResult<Prisma.$AccountAttributeValuePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first AccountAttributeValue that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAttributeValueFindFirstArgs} args - Arguments to find a AccountAttributeValue
     * @example
     * // Get one AccountAttributeValue
     * const accountAttributeValue = await prisma.accountAttributeValue.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountAttributeValueFindFirstArgs>(args?: SelectSubset<T, AccountAttributeValueFindFirstArgs<ExtArgs>>): Prisma__AccountAttributeValueClient<$Result.GetResult<Prisma.$AccountAttributeValuePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first AccountAttributeValue that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAttributeValueFindFirstOrThrowArgs} args - Arguments to find a AccountAttributeValue
     * @example
     * // Get one AccountAttributeValue
     * const accountAttributeValue = await prisma.accountAttributeValue.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountAttributeValueFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountAttributeValueFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountAttributeValueClient<$Result.GetResult<Prisma.$AccountAttributeValuePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more AccountAttributeValues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAttributeValueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AccountAttributeValues
     * const accountAttributeValues = await prisma.accountAttributeValue.findMany()
     * 
     * // Get first 10 AccountAttributeValues
     * const accountAttributeValues = await prisma.accountAttributeValue.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountAttributeValueWithIdOnly = await prisma.accountAttributeValue.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountAttributeValueFindManyArgs>(args?: SelectSubset<T, AccountAttributeValueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountAttributeValuePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a AccountAttributeValue.
     * @param {AccountAttributeValueCreateArgs} args - Arguments to create a AccountAttributeValue.
     * @example
     * // Create one AccountAttributeValue
     * const AccountAttributeValue = await prisma.accountAttributeValue.create({
     *   data: {
     *     // ... data to create a AccountAttributeValue
     *   }
     * })
     * 
     */
    create<T extends AccountAttributeValueCreateArgs>(args: SelectSubset<T, AccountAttributeValueCreateArgs<ExtArgs>>): Prisma__AccountAttributeValueClient<$Result.GetResult<Prisma.$AccountAttributeValuePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many AccountAttributeValues.
     * @param {AccountAttributeValueCreateManyArgs} args - Arguments to create many AccountAttributeValues.
     * @example
     * // Create many AccountAttributeValues
     * const accountAttributeValue = await prisma.accountAttributeValue.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountAttributeValueCreateManyArgs>(args?: SelectSubset<T, AccountAttributeValueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AccountAttributeValue.
     * @param {AccountAttributeValueDeleteArgs} args - Arguments to delete one AccountAttributeValue.
     * @example
     * // Delete one AccountAttributeValue
     * const AccountAttributeValue = await prisma.accountAttributeValue.delete({
     *   where: {
     *     // ... filter to delete one AccountAttributeValue
     *   }
     * })
     * 
     */
    delete<T extends AccountAttributeValueDeleteArgs>(args: SelectSubset<T, AccountAttributeValueDeleteArgs<ExtArgs>>): Prisma__AccountAttributeValueClient<$Result.GetResult<Prisma.$AccountAttributeValuePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one AccountAttributeValue.
     * @param {AccountAttributeValueUpdateArgs} args - Arguments to update one AccountAttributeValue.
     * @example
     * // Update one AccountAttributeValue
     * const accountAttributeValue = await prisma.accountAttributeValue.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountAttributeValueUpdateArgs>(args: SelectSubset<T, AccountAttributeValueUpdateArgs<ExtArgs>>): Prisma__AccountAttributeValueClient<$Result.GetResult<Prisma.$AccountAttributeValuePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more AccountAttributeValues.
     * @param {AccountAttributeValueDeleteManyArgs} args - Arguments to filter AccountAttributeValues to delete.
     * @example
     * // Delete a few AccountAttributeValues
     * const { count } = await prisma.accountAttributeValue.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountAttributeValueDeleteManyArgs>(args?: SelectSubset<T, AccountAttributeValueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AccountAttributeValues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAttributeValueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AccountAttributeValues
     * const accountAttributeValue = await prisma.accountAttributeValue.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountAttributeValueUpdateManyArgs>(args: SelectSubset<T, AccountAttributeValueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AccountAttributeValue.
     * @param {AccountAttributeValueUpsertArgs} args - Arguments to update or create a AccountAttributeValue.
     * @example
     * // Update or create a AccountAttributeValue
     * const accountAttributeValue = await prisma.accountAttributeValue.upsert({
     *   create: {
     *     // ... data to create a AccountAttributeValue
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AccountAttributeValue we want to update
     *   }
     * })
     */
    upsert<T extends AccountAttributeValueUpsertArgs>(args: SelectSubset<T, AccountAttributeValueUpsertArgs<ExtArgs>>): Prisma__AccountAttributeValueClient<$Result.GetResult<Prisma.$AccountAttributeValuePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more AccountAttributeValues that matches the filter.
     * @param {AccountAttributeValueFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const accountAttributeValue = await prisma.accountAttributeValue.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: AccountAttributeValueFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a AccountAttributeValue.
     * @param {AccountAttributeValueAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const accountAttributeValue = await prisma.accountAttributeValue.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: AccountAttributeValueAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of AccountAttributeValues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAttributeValueCountArgs} args - Arguments to filter AccountAttributeValues to count.
     * @example
     * // Count the number of AccountAttributeValues
     * const count = await prisma.accountAttributeValue.count({
     *   where: {
     *     // ... the filter for the AccountAttributeValues we want to count
     *   }
     * })
    **/
    count<T extends AccountAttributeValueCountArgs>(
      args?: Subset<T, AccountAttributeValueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountAttributeValueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AccountAttributeValue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAttributeValueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAttributeValueAggregateArgs>(args: Subset<T, AccountAttributeValueAggregateArgs>): Prisma.PrismaPromise<GetAccountAttributeValueAggregateType<T>>

    /**
     * Group by AccountAttributeValue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAttributeValueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountAttributeValueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountAttributeValueGroupByArgs['orderBy'] }
        : { orderBy?: AccountAttributeValueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountAttributeValueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountAttributeValueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AccountAttributeValue model
   */
  readonly fields: AccountAttributeValueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AccountAttributeValue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountAttributeValueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    parent<T extends AccountAttributeValue$parentArgs<ExtArgs> = {}>(args?: Subset<T, AccountAttributeValue$parentArgs<ExtArgs>>): Prisma__AccountAttributeValueClient<$Result.GetResult<Prisma.$AccountAttributeValuePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    childAttributeValues<T extends AccountAttributeValue$childAttributeValuesArgs<ExtArgs> = {}>(args?: Subset<T, AccountAttributeValue$childAttributeValuesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountAttributeValuePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    accountAttribute<T extends AccountAttributeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountAttributeDefaultArgs<ExtArgs>>): Prisma__AccountAttributeClient<$Result.GetResult<Prisma.$AccountAttributePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    instance<T extends InstanceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InstanceDefaultArgs<ExtArgs>>): Prisma__InstanceClient<$Result.GetResult<Prisma.$InstancePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    AttributeAndValues<T extends AccountAttributeValue$AttributeAndValuesArgs<ExtArgs> = {}>(args?: Subset<T, AccountAttributeValue$AttributeAndValuesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountAttributeAndValuePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AccountAttributeValue model
   */ 
  interface AccountAttributeValueFieldRefs {
    readonly id: FieldRef<"AccountAttributeValue", 'String'>
    readonly code: FieldRef<"AccountAttributeValue", 'String'>
    readonly name: FieldRef<"AccountAttributeValue", 'String'>
    readonly attributeId: FieldRef<"AccountAttributeValue", 'String'>
    readonly parentId: FieldRef<"AccountAttributeValue", 'String'>
    readonly clientId: FieldRef<"AccountAttributeValue", 'String'>
    readonly instanceId: FieldRef<"AccountAttributeValue", 'String'>
    readonly createdAt: FieldRef<"AccountAttributeValue", 'DateTime'>
    readonly updatedAt: FieldRef<"AccountAttributeValue", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AccountAttributeValue findUnique
   */
  export type AccountAttributeValueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountAttributeValue
     */
    select?: AccountAttributeValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountAttributeValue
     */
    omit?: AccountAttributeValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountAttributeValueInclude<ExtArgs> | null
    /**
     * Filter, which AccountAttributeValue to fetch.
     */
    where: AccountAttributeValueWhereUniqueInput
  }

  /**
   * AccountAttributeValue findUniqueOrThrow
   */
  export type AccountAttributeValueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountAttributeValue
     */
    select?: AccountAttributeValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountAttributeValue
     */
    omit?: AccountAttributeValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountAttributeValueInclude<ExtArgs> | null
    /**
     * Filter, which AccountAttributeValue to fetch.
     */
    where: AccountAttributeValueWhereUniqueInput
  }

  /**
   * AccountAttributeValue findFirst
   */
  export type AccountAttributeValueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountAttributeValue
     */
    select?: AccountAttributeValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountAttributeValue
     */
    omit?: AccountAttributeValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountAttributeValueInclude<ExtArgs> | null
    /**
     * Filter, which AccountAttributeValue to fetch.
     */
    where?: AccountAttributeValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountAttributeValues to fetch.
     */
    orderBy?: AccountAttributeValueOrderByWithRelationInput | AccountAttributeValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AccountAttributeValues.
     */
    cursor?: AccountAttributeValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountAttributeValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountAttributeValues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AccountAttributeValues.
     */
    distinct?: AccountAttributeValueScalarFieldEnum | AccountAttributeValueScalarFieldEnum[]
  }

  /**
   * AccountAttributeValue findFirstOrThrow
   */
  export type AccountAttributeValueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountAttributeValue
     */
    select?: AccountAttributeValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountAttributeValue
     */
    omit?: AccountAttributeValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountAttributeValueInclude<ExtArgs> | null
    /**
     * Filter, which AccountAttributeValue to fetch.
     */
    where?: AccountAttributeValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountAttributeValues to fetch.
     */
    orderBy?: AccountAttributeValueOrderByWithRelationInput | AccountAttributeValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AccountAttributeValues.
     */
    cursor?: AccountAttributeValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountAttributeValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountAttributeValues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AccountAttributeValues.
     */
    distinct?: AccountAttributeValueScalarFieldEnum | AccountAttributeValueScalarFieldEnum[]
  }

  /**
   * AccountAttributeValue findMany
   */
  export type AccountAttributeValueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountAttributeValue
     */
    select?: AccountAttributeValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountAttributeValue
     */
    omit?: AccountAttributeValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountAttributeValueInclude<ExtArgs> | null
    /**
     * Filter, which AccountAttributeValues to fetch.
     */
    where?: AccountAttributeValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountAttributeValues to fetch.
     */
    orderBy?: AccountAttributeValueOrderByWithRelationInput | AccountAttributeValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AccountAttributeValues.
     */
    cursor?: AccountAttributeValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountAttributeValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountAttributeValues.
     */
    skip?: number
    distinct?: AccountAttributeValueScalarFieldEnum | AccountAttributeValueScalarFieldEnum[]
  }

  /**
   * AccountAttributeValue create
   */
  export type AccountAttributeValueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountAttributeValue
     */
    select?: AccountAttributeValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountAttributeValue
     */
    omit?: AccountAttributeValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountAttributeValueInclude<ExtArgs> | null
    /**
     * The data needed to create a AccountAttributeValue.
     */
    data: XOR<AccountAttributeValueCreateInput, AccountAttributeValueUncheckedCreateInput>
  }

  /**
   * AccountAttributeValue createMany
   */
  export type AccountAttributeValueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AccountAttributeValues.
     */
    data: AccountAttributeValueCreateManyInput | AccountAttributeValueCreateManyInput[]
  }

  /**
   * AccountAttributeValue update
   */
  export type AccountAttributeValueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountAttributeValue
     */
    select?: AccountAttributeValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountAttributeValue
     */
    omit?: AccountAttributeValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountAttributeValueInclude<ExtArgs> | null
    /**
     * The data needed to update a AccountAttributeValue.
     */
    data: XOR<AccountAttributeValueUpdateInput, AccountAttributeValueUncheckedUpdateInput>
    /**
     * Choose, which AccountAttributeValue to update.
     */
    where: AccountAttributeValueWhereUniqueInput
  }

  /**
   * AccountAttributeValue updateMany
   */
  export type AccountAttributeValueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AccountAttributeValues.
     */
    data: XOR<AccountAttributeValueUpdateManyMutationInput, AccountAttributeValueUncheckedUpdateManyInput>
    /**
     * Filter which AccountAttributeValues to update
     */
    where?: AccountAttributeValueWhereInput
    /**
     * Limit how many AccountAttributeValues to update.
     */
    limit?: number
  }

  /**
   * AccountAttributeValue upsert
   */
  export type AccountAttributeValueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountAttributeValue
     */
    select?: AccountAttributeValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountAttributeValue
     */
    omit?: AccountAttributeValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountAttributeValueInclude<ExtArgs> | null
    /**
     * The filter to search for the AccountAttributeValue to update in case it exists.
     */
    where: AccountAttributeValueWhereUniqueInput
    /**
     * In case the AccountAttributeValue found by the `where` argument doesn't exist, create a new AccountAttributeValue with this data.
     */
    create: XOR<AccountAttributeValueCreateInput, AccountAttributeValueUncheckedCreateInput>
    /**
     * In case the AccountAttributeValue was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountAttributeValueUpdateInput, AccountAttributeValueUncheckedUpdateInput>
  }

  /**
   * AccountAttributeValue delete
   */
  export type AccountAttributeValueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountAttributeValue
     */
    select?: AccountAttributeValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountAttributeValue
     */
    omit?: AccountAttributeValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountAttributeValueInclude<ExtArgs> | null
    /**
     * Filter which AccountAttributeValue to delete.
     */
    where: AccountAttributeValueWhereUniqueInput
  }

  /**
   * AccountAttributeValue deleteMany
   */
  export type AccountAttributeValueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AccountAttributeValues to delete
     */
    where?: AccountAttributeValueWhereInput
    /**
     * Limit how many AccountAttributeValues to delete.
     */
    limit?: number
  }

  /**
   * AccountAttributeValue findRaw
   */
  export type AccountAttributeValueFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * AccountAttributeValue aggregateRaw
   */
  export type AccountAttributeValueAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * AccountAttributeValue.parent
   */
  export type AccountAttributeValue$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountAttributeValue
     */
    select?: AccountAttributeValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountAttributeValue
     */
    omit?: AccountAttributeValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountAttributeValueInclude<ExtArgs> | null
    where?: AccountAttributeValueWhereInput
  }

  /**
   * AccountAttributeValue.childAttributeValues
   */
  export type AccountAttributeValue$childAttributeValuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountAttributeValue
     */
    select?: AccountAttributeValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountAttributeValue
     */
    omit?: AccountAttributeValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountAttributeValueInclude<ExtArgs> | null
    where?: AccountAttributeValueWhereInput
    orderBy?: AccountAttributeValueOrderByWithRelationInput | AccountAttributeValueOrderByWithRelationInput[]
    cursor?: AccountAttributeValueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountAttributeValueScalarFieldEnum | AccountAttributeValueScalarFieldEnum[]
  }

  /**
   * AccountAttributeValue.AttributeAndValues
   */
  export type AccountAttributeValue$AttributeAndValuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountAttributeAndValue
     */
    select?: AccountAttributeAndValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountAttributeAndValue
     */
    omit?: AccountAttributeAndValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountAttributeAndValueInclude<ExtArgs> | null
    where?: AccountAttributeAndValueWhereInput
    orderBy?: AccountAttributeAndValueOrderByWithRelationInput | AccountAttributeAndValueOrderByWithRelationInput[]
    cursor?: AccountAttributeAndValueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountAttributeAndValueScalarFieldEnum | AccountAttributeAndValueScalarFieldEnum[]
  }

  /**
   * AccountAttributeValue without action
   */
  export type AccountAttributeValueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountAttributeValue
     */
    select?: AccountAttributeValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountAttributeValue
     */
    omit?: AccountAttributeValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountAttributeValueInclude<ExtArgs> | null
  }


  /**
   * Model AccountAttributeAndValue
   */

  export type AggregateAccountAttributeAndValue = {
    _count: AccountAttributeAndValueCountAggregateOutputType | null
    _min: AccountAttributeAndValueMinAggregateOutputType | null
    _max: AccountAttributeAndValueMaxAggregateOutputType | null
  }

  export type AccountAttributeAndValueMinAggregateOutputType = {
    id: string | null
    accountId: string | null
    clientId: string | null
    instanceId: string | null
    attributeId: string | null
    attributeValueId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountAttributeAndValueMaxAggregateOutputType = {
    id: string | null
    accountId: string | null
    clientId: string | null
    instanceId: string | null
    attributeId: string | null
    attributeValueId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountAttributeAndValueCountAggregateOutputType = {
    id: number
    accountId: number
    clientId: number
    instanceId: number
    attributeId: number
    attributeValueId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AccountAttributeAndValueMinAggregateInputType = {
    id?: true
    accountId?: true
    clientId?: true
    instanceId?: true
    attributeId?: true
    attributeValueId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountAttributeAndValueMaxAggregateInputType = {
    id?: true
    accountId?: true
    clientId?: true
    instanceId?: true
    attributeId?: true
    attributeValueId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountAttributeAndValueCountAggregateInputType = {
    id?: true
    accountId?: true
    clientId?: true
    instanceId?: true
    attributeId?: true
    attributeValueId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AccountAttributeAndValueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AccountAttributeAndValue to aggregate.
     */
    where?: AccountAttributeAndValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountAttributeAndValues to fetch.
     */
    orderBy?: AccountAttributeAndValueOrderByWithRelationInput | AccountAttributeAndValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountAttributeAndValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountAttributeAndValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountAttributeAndValues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AccountAttributeAndValues
    **/
    _count?: true | AccountAttributeAndValueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountAttributeAndValueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountAttributeAndValueMaxAggregateInputType
  }

  export type GetAccountAttributeAndValueAggregateType<T extends AccountAttributeAndValueAggregateArgs> = {
        [P in keyof T & keyof AggregateAccountAttributeAndValue]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccountAttributeAndValue[P]>
      : GetScalarType<T[P], AggregateAccountAttributeAndValue[P]>
  }




  export type AccountAttributeAndValueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountAttributeAndValueWhereInput
    orderBy?: AccountAttributeAndValueOrderByWithAggregationInput | AccountAttributeAndValueOrderByWithAggregationInput[]
    by: AccountAttributeAndValueScalarFieldEnum[] | AccountAttributeAndValueScalarFieldEnum
    having?: AccountAttributeAndValueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountAttributeAndValueCountAggregateInputType | true
    _min?: AccountAttributeAndValueMinAggregateInputType
    _max?: AccountAttributeAndValueMaxAggregateInputType
  }

  export type AccountAttributeAndValueGroupByOutputType = {
    id: string
    accountId: string
    clientId: string
    instanceId: string
    attributeId: string
    attributeValueId: string
    createdAt: Date | null
    updatedAt: Date | null
    _count: AccountAttributeAndValueCountAggregateOutputType | null
    _min: AccountAttributeAndValueMinAggregateOutputType | null
    _max: AccountAttributeAndValueMaxAggregateOutputType | null
  }

  type GetAccountAttributeAndValueGroupByPayload<T extends AccountAttributeAndValueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountAttributeAndValueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountAttributeAndValueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountAttributeAndValueGroupByOutputType[P]>
            : GetScalarType<T[P], AccountAttributeAndValueGroupByOutputType[P]>
        }
      >
    >


  export type AccountAttributeAndValueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    clientId?: boolean
    instanceId?: boolean
    attributeId?: boolean
    attributeValueId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    account?: boolean | AccountAttributeAndValue$accountArgs<ExtArgs>
    attribute?: boolean | AccountAttributeAndValue$attributeArgs<ExtArgs>
    attributeValue?: boolean | AccountAttributeAndValue$attributeValueArgs<ExtArgs>
  }, ExtArgs["result"]["accountAttributeAndValue"]>



  export type AccountAttributeAndValueSelectScalar = {
    id?: boolean
    accountId?: boolean
    clientId?: boolean
    instanceId?: boolean
    attributeId?: boolean
    attributeValueId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AccountAttributeAndValueOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "accountId" | "clientId" | "instanceId" | "attributeId" | "attributeValueId" | "createdAt" | "updatedAt", ExtArgs["result"]["accountAttributeAndValue"]>
  export type AccountAttributeAndValueInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | AccountAttributeAndValue$accountArgs<ExtArgs>
    attribute?: boolean | AccountAttributeAndValue$attributeArgs<ExtArgs>
    attributeValue?: boolean | AccountAttributeAndValue$attributeValueArgs<ExtArgs>
  }

  export type $AccountAttributeAndValuePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AccountAttributeAndValue"
    objects: {
      account: Prisma.$AccountPayload<ExtArgs> | null
      attribute: Prisma.$AccountAttributePayload<ExtArgs> | null
      attributeValue: Prisma.$AccountAttributeValuePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      accountId: string
      clientId: string
      instanceId: string
      attributeId: string
      attributeValueId: string
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["accountAttributeAndValue"]>
    composites: {}
  }

  type AccountAttributeAndValueGetPayload<S extends boolean | null | undefined | AccountAttributeAndValueDefaultArgs> = $Result.GetResult<Prisma.$AccountAttributeAndValuePayload, S>

  type AccountAttributeAndValueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountAttributeAndValueFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountAttributeAndValueCountAggregateInputType | true
    }

  export interface AccountAttributeAndValueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AccountAttributeAndValue'], meta: { name: 'AccountAttributeAndValue' } }
    /**
     * Find zero or one AccountAttributeAndValue that matches the filter.
     * @param {AccountAttributeAndValueFindUniqueArgs} args - Arguments to find a AccountAttributeAndValue
     * @example
     * // Get one AccountAttributeAndValue
     * const accountAttributeAndValue = await prisma.accountAttributeAndValue.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountAttributeAndValueFindUniqueArgs>(args: SelectSubset<T, AccountAttributeAndValueFindUniqueArgs<ExtArgs>>): Prisma__AccountAttributeAndValueClient<$Result.GetResult<Prisma.$AccountAttributeAndValuePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one AccountAttributeAndValue that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountAttributeAndValueFindUniqueOrThrowArgs} args - Arguments to find a AccountAttributeAndValue
     * @example
     * // Get one AccountAttributeAndValue
     * const accountAttributeAndValue = await prisma.accountAttributeAndValue.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountAttributeAndValueFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountAttributeAndValueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountAttributeAndValueClient<$Result.GetResult<Prisma.$AccountAttributeAndValuePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first AccountAttributeAndValue that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAttributeAndValueFindFirstArgs} args - Arguments to find a AccountAttributeAndValue
     * @example
     * // Get one AccountAttributeAndValue
     * const accountAttributeAndValue = await prisma.accountAttributeAndValue.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountAttributeAndValueFindFirstArgs>(args?: SelectSubset<T, AccountAttributeAndValueFindFirstArgs<ExtArgs>>): Prisma__AccountAttributeAndValueClient<$Result.GetResult<Prisma.$AccountAttributeAndValuePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first AccountAttributeAndValue that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAttributeAndValueFindFirstOrThrowArgs} args - Arguments to find a AccountAttributeAndValue
     * @example
     * // Get one AccountAttributeAndValue
     * const accountAttributeAndValue = await prisma.accountAttributeAndValue.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountAttributeAndValueFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountAttributeAndValueFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountAttributeAndValueClient<$Result.GetResult<Prisma.$AccountAttributeAndValuePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more AccountAttributeAndValues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAttributeAndValueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AccountAttributeAndValues
     * const accountAttributeAndValues = await prisma.accountAttributeAndValue.findMany()
     * 
     * // Get first 10 AccountAttributeAndValues
     * const accountAttributeAndValues = await prisma.accountAttributeAndValue.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountAttributeAndValueWithIdOnly = await prisma.accountAttributeAndValue.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountAttributeAndValueFindManyArgs>(args?: SelectSubset<T, AccountAttributeAndValueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountAttributeAndValuePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a AccountAttributeAndValue.
     * @param {AccountAttributeAndValueCreateArgs} args - Arguments to create a AccountAttributeAndValue.
     * @example
     * // Create one AccountAttributeAndValue
     * const AccountAttributeAndValue = await prisma.accountAttributeAndValue.create({
     *   data: {
     *     // ... data to create a AccountAttributeAndValue
     *   }
     * })
     * 
     */
    create<T extends AccountAttributeAndValueCreateArgs>(args: SelectSubset<T, AccountAttributeAndValueCreateArgs<ExtArgs>>): Prisma__AccountAttributeAndValueClient<$Result.GetResult<Prisma.$AccountAttributeAndValuePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many AccountAttributeAndValues.
     * @param {AccountAttributeAndValueCreateManyArgs} args - Arguments to create many AccountAttributeAndValues.
     * @example
     * // Create many AccountAttributeAndValues
     * const accountAttributeAndValue = await prisma.accountAttributeAndValue.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountAttributeAndValueCreateManyArgs>(args?: SelectSubset<T, AccountAttributeAndValueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AccountAttributeAndValue.
     * @param {AccountAttributeAndValueDeleteArgs} args - Arguments to delete one AccountAttributeAndValue.
     * @example
     * // Delete one AccountAttributeAndValue
     * const AccountAttributeAndValue = await prisma.accountAttributeAndValue.delete({
     *   where: {
     *     // ... filter to delete one AccountAttributeAndValue
     *   }
     * })
     * 
     */
    delete<T extends AccountAttributeAndValueDeleteArgs>(args: SelectSubset<T, AccountAttributeAndValueDeleteArgs<ExtArgs>>): Prisma__AccountAttributeAndValueClient<$Result.GetResult<Prisma.$AccountAttributeAndValuePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one AccountAttributeAndValue.
     * @param {AccountAttributeAndValueUpdateArgs} args - Arguments to update one AccountAttributeAndValue.
     * @example
     * // Update one AccountAttributeAndValue
     * const accountAttributeAndValue = await prisma.accountAttributeAndValue.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountAttributeAndValueUpdateArgs>(args: SelectSubset<T, AccountAttributeAndValueUpdateArgs<ExtArgs>>): Prisma__AccountAttributeAndValueClient<$Result.GetResult<Prisma.$AccountAttributeAndValuePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more AccountAttributeAndValues.
     * @param {AccountAttributeAndValueDeleteManyArgs} args - Arguments to filter AccountAttributeAndValues to delete.
     * @example
     * // Delete a few AccountAttributeAndValues
     * const { count } = await prisma.accountAttributeAndValue.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountAttributeAndValueDeleteManyArgs>(args?: SelectSubset<T, AccountAttributeAndValueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AccountAttributeAndValues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAttributeAndValueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AccountAttributeAndValues
     * const accountAttributeAndValue = await prisma.accountAttributeAndValue.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountAttributeAndValueUpdateManyArgs>(args: SelectSubset<T, AccountAttributeAndValueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AccountAttributeAndValue.
     * @param {AccountAttributeAndValueUpsertArgs} args - Arguments to update or create a AccountAttributeAndValue.
     * @example
     * // Update or create a AccountAttributeAndValue
     * const accountAttributeAndValue = await prisma.accountAttributeAndValue.upsert({
     *   create: {
     *     // ... data to create a AccountAttributeAndValue
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AccountAttributeAndValue we want to update
     *   }
     * })
     */
    upsert<T extends AccountAttributeAndValueUpsertArgs>(args: SelectSubset<T, AccountAttributeAndValueUpsertArgs<ExtArgs>>): Prisma__AccountAttributeAndValueClient<$Result.GetResult<Prisma.$AccountAttributeAndValuePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more AccountAttributeAndValues that matches the filter.
     * @param {AccountAttributeAndValueFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const accountAttributeAndValue = await prisma.accountAttributeAndValue.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: AccountAttributeAndValueFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a AccountAttributeAndValue.
     * @param {AccountAttributeAndValueAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const accountAttributeAndValue = await prisma.accountAttributeAndValue.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: AccountAttributeAndValueAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of AccountAttributeAndValues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAttributeAndValueCountArgs} args - Arguments to filter AccountAttributeAndValues to count.
     * @example
     * // Count the number of AccountAttributeAndValues
     * const count = await prisma.accountAttributeAndValue.count({
     *   where: {
     *     // ... the filter for the AccountAttributeAndValues we want to count
     *   }
     * })
    **/
    count<T extends AccountAttributeAndValueCountArgs>(
      args?: Subset<T, AccountAttributeAndValueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountAttributeAndValueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AccountAttributeAndValue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAttributeAndValueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAttributeAndValueAggregateArgs>(args: Subset<T, AccountAttributeAndValueAggregateArgs>): Prisma.PrismaPromise<GetAccountAttributeAndValueAggregateType<T>>

    /**
     * Group by AccountAttributeAndValue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAttributeAndValueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountAttributeAndValueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountAttributeAndValueGroupByArgs['orderBy'] }
        : { orderBy?: AccountAttributeAndValueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountAttributeAndValueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountAttributeAndValueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AccountAttributeAndValue model
   */
  readonly fields: AccountAttributeAndValueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AccountAttributeAndValue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountAttributeAndValueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    account<T extends AccountAttributeAndValue$accountArgs<ExtArgs> = {}>(args?: Subset<T, AccountAttributeAndValue$accountArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    attribute<T extends AccountAttributeAndValue$attributeArgs<ExtArgs> = {}>(args?: Subset<T, AccountAttributeAndValue$attributeArgs<ExtArgs>>): Prisma__AccountAttributeClient<$Result.GetResult<Prisma.$AccountAttributePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    attributeValue<T extends AccountAttributeAndValue$attributeValueArgs<ExtArgs> = {}>(args?: Subset<T, AccountAttributeAndValue$attributeValueArgs<ExtArgs>>): Prisma__AccountAttributeValueClient<$Result.GetResult<Prisma.$AccountAttributeValuePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AccountAttributeAndValue model
   */ 
  interface AccountAttributeAndValueFieldRefs {
    readonly id: FieldRef<"AccountAttributeAndValue", 'String'>
    readonly accountId: FieldRef<"AccountAttributeAndValue", 'String'>
    readonly clientId: FieldRef<"AccountAttributeAndValue", 'String'>
    readonly instanceId: FieldRef<"AccountAttributeAndValue", 'String'>
    readonly attributeId: FieldRef<"AccountAttributeAndValue", 'String'>
    readonly attributeValueId: FieldRef<"AccountAttributeAndValue", 'String'>
    readonly createdAt: FieldRef<"AccountAttributeAndValue", 'DateTime'>
    readonly updatedAt: FieldRef<"AccountAttributeAndValue", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AccountAttributeAndValue findUnique
   */
  export type AccountAttributeAndValueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountAttributeAndValue
     */
    select?: AccountAttributeAndValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountAttributeAndValue
     */
    omit?: AccountAttributeAndValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountAttributeAndValueInclude<ExtArgs> | null
    /**
     * Filter, which AccountAttributeAndValue to fetch.
     */
    where: AccountAttributeAndValueWhereUniqueInput
  }

  /**
   * AccountAttributeAndValue findUniqueOrThrow
   */
  export type AccountAttributeAndValueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountAttributeAndValue
     */
    select?: AccountAttributeAndValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountAttributeAndValue
     */
    omit?: AccountAttributeAndValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountAttributeAndValueInclude<ExtArgs> | null
    /**
     * Filter, which AccountAttributeAndValue to fetch.
     */
    where: AccountAttributeAndValueWhereUniqueInput
  }

  /**
   * AccountAttributeAndValue findFirst
   */
  export type AccountAttributeAndValueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountAttributeAndValue
     */
    select?: AccountAttributeAndValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountAttributeAndValue
     */
    omit?: AccountAttributeAndValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountAttributeAndValueInclude<ExtArgs> | null
    /**
     * Filter, which AccountAttributeAndValue to fetch.
     */
    where?: AccountAttributeAndValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountAttributeAndValues to fetch.
     */
    orderBy?: AccountAttributeAndValueOrderByWithRelationInput | AccountAttributeAndValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AccountAttributeAndValues.
     */
    cursor?: AccountAttributeAndValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountAttributeAndValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountAttributeAndValues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AccountAttributeAndValues.
     */
    distinct?: AccountAttributeAndValueScalarFieldEnum | AccountAttributeAndValueScalarFieldEnum[]
  }

  /**
   * AccountAttributeAndValue findFirstOrThrow
   */
  export type AccountAttributeAndValueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountAttributeAndValue
     */
    select?: AccountAttributeAndValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountAttributeAndValue
     */
    omit?: AccountAttributeAndValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountAttributeAndValueInclude<ExtArgs> | null
    /**
     * Filter, which AccountAttributeAndValue to fetch.
     */
    where?: AccountAttributeAndValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountAttributeAndValues to fetch.
     */
    orderBy?: AccountAttributeAndValueOrderByWithRelationInput | AccountAttributeAndValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AccountAttributeAndValues.
     */
    cursor?: AccountAttributeAndValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountAttributeAndValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountAttributeAndValues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AccountAttributeAndValues.
     */
    distinct?: AccountAttributeAndValueScalarFieldEnum | AccountAttributeAndValueScalarFieldEnum[]
  }

  /**
   * AccountAttributeAndValue findMany
   */
  export type AccountAttributeAndValueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountAttributeAndValue
     */
    select?: AccountAttributeAndValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountAttributeAndValue
     */
    omit?: AccountAttributeAndValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountAttributeAndValueInclude<ExtArgs> | null
    /**
     * Filter, which AccountAttributeAndValues to fetch.
     */
    where?: AccountAttributeAndValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountAttributeAndValues to fetch.
     */
    orderBy?: AccountAttributeAndValueOrderByWithRelationInput | AccountAttributeAndValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AccountAttributeAndValues.
     */
    cursor?: AccountAttributeAndValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountAttributeAndValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountAttributeAndValues.
     */
    skip?: number
    distinct?: AccountAttributeAndValueScalarFieldEnum | AccountAttributeAndValueScalarFieldEnum[]
  }

  /**
   * AccountAttributeAndValue create
   */
  export type AccountAttributeAndValueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountAttributeAndValue
     */
    select?: AccountAttributeAndValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountAttributeAndValue
     */
    omit?: AccountAttributeAndValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountAttributeAndValueInclude<ExtArgs> | null
    /**
     * The data needed to create a AccountAttributeAndValue.
     */
    data: XOR<AccountAttributeAndValueCreateInput, AccountAttributeAndValueUncheckedCreateInput>
  }

  /**
   * AccountAttributeAndValue createMany
   */
  export type AccountAttributeAndValueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AccountAttributeAndValues.
     */
    data: AccountAttributeAndValueCreateManyInput | AccountAttributeAndValueCreateManyInput[]
  }

  /**
   * AccountAttributeAndValue update
   */
  export type AccountAttributeAndValueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountAttributeAndValue
     */
    select?: AccountAttributeAndValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountAttributeAndValue
     */
    omit?: AccountAttributeAndValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountAttributeAndValueInclude<ExtArgs> | null
    /**
     * The data needed to update a AccountAttributeAndValue.
     */
    data: XOR<AccountAttributeAndValueUpdateInput, AccountAttributeAndValueUncheckedUpdateInput>
    /**
     * Choose, which AccountAttributeAndValue to update.
     */
    where: AccountAttributeAndValueWhereUniqueInput
  }

  /**
   * AccountAttributeAndValue updateMany
   */
  export type AccountAttributeAndValueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AccountAttributeAndValues.
     */
    data: XOR<AccountAttributeAndValueUpdateManyMutationInput, AccountAttributeAndValueUncheckedUpdateManyInput>
    /**
     * Filter which AccountAttributeAndValues to update
     */
    where?: AccountAttributeAndValueWhereInput
    /**
     * Limit how many AccountAttributeAndValues to update.
     */
    limit?: number
  }

  /**
   * AccountAttributeAndValue upsert
   */
  export type AccountAttributeAndValueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountAttributeAndValue
     */
    select?: AccountAttributeAndValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountAttributeAndValue
     */
    omit?: AccountAttributeAndValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountAttributeAndValueInclude<ExtArgs> | null
    /**
     * The filter to search for the AccountAttributeAndValue to update in case it exists.
     */
    where: AccountAttributeAndValueWhereUniqueInput
    /**
     * In case the AccountAttributeAndValue found by the `where` argument doesn't exist, create a new AccountAttributeAndValue with this data.
     */
    create: XOR<AccountAttributeAndValueCreateInput, AccountAttributeAndValueUncheckedCreateInput>
    /**
     * In case the AccountAttributeAndValue was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountAttributeAndValueUpdateInput, AccountAttributeAndValueUncheckedUpdateInput>
  }

  /**
   * AccountAttributeAndValue delete
   */
  export type AccountAttributeAndValueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountAttributeAndValue
     */
    select?: AccountAttributeAndValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountAttributeAndValue
     */
    omit?: AccountAttributeAndValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountAttributeAndValueInclude<ExtArgs> | null
    /**
     * Filter which AccountAttributeAndValue to delete.
     */
    where: AccountAttributeAndValueWhereUniqueInput
  }

  /**
   * AccountAttributeAndValue deleteMany
   */
  export type AccountAttributeAndValueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AccountAttributeAndValues to delete
     */
    where?: AccountAttributeAndValueWhereInput
    /**
     * Limit how many AccountAttributeAndValues to delete.
     */
    limit?: number
  }

  /**
   * AccountAttributeAndValue findRaw
   */
  export type AccountAttributeAndValueFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * AccountAttributeAndValue aggregateRaw
   */
  export type AccountAttributeAndValueAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * AccountAttributeAndValue.account
   */
  export type AccountAttributeAndValue$accountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
  }

  /**
   * AccountAttributeAndValue.attribute
   */
  export type AccountAttributeAndValue$attributeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountAttribute
     */
    select?: AccountAttributeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountAttribute
     */
    omit?: AccountAttributeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountAttributeInclude<ExtArgs> | null
    where?: AccountAttributeWhereInput
  }

  /**
   * AccountAttributeAndValue.attributeValue
   */
  export type AccountAttributeAndValue$attributeValueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountAttributeValue
     */
    select?: AccountAttributeValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountAttributeValue
     */
    omit?: AccountAttributeValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountAttributeValueInclude<ExtArgs> | null
    where?: AccountAttributeValueWhereInput
  }

  /**
   * AccountAttributeAndValue without action
   */
  export type AccountAttributeAndValueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountAttributeAndValue
     */
    select?: AccountAttributeAndValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountAttributeAndValue
     */
    omit?: AccountAttributeAndValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountAttributeAndValueInclude<ExtArgs> | null
  }


  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    isRoot: boolean | null
    isModelRoot: boolean | null
    accountType: $Enums.AccountType | null
    accountTypeTag: $Enums.AccountTypeTag | null
    group: $Enums.YesNo | null
    plannedBy: $Enums.ActPlanBy | null
    actualsBy: $Enums.ActActualsBy | null
    displayAs: $Enums.ActDisplayAs | null
    containsSalaryInfo: $Enums.YesNo | null
    description: string | null
    instanceId: string | null
    clientId: string | null
    parentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    isRoot: boolean | null
    isModelRoot: boolean | null
    accountType: $Enums.AccountType | null
    accountTypeTag: $Enums.AccountTypeTag | null
    group: $Enums.YesNo | null
    plannedBy: $Enums.ActPlanBy | null
    actualsBy: $Enums.ActActualsBy | null
    displayAs: $Enums.ActDisplayAs | null
    containsSalaryInfo: $Enums.YesNo | null
    description: string | null
    instanceId: string | null
    clientId: string | null
    parentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    code: number
    name: number
    isRoot: number
    isModelRoot: number
    accountType: number
    accountTypeTag: number
    group: number
    plannedBy: number
    actualsBy: number
    displayAs: number
    containsSalaryInfo: number
    description: number
    instanceId: number
    clientId: number
    parentId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AccountMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    isRoot?: true
    isModelRoot?: true
    accountType?: true
    accountTypeTag?: true
    group?: true
    plannedBy?: true
    actualsBy?: true
    displayAs?: true
    containsSalaryInfo?: true
    description?: true
    instanceId?: true
    clientId?: true
    parentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    isRoot?: true
    isModelRoot?: true
    accountType?: true
    accountTypeTag?: true
    group?: true
    plannedBy?: true
    actualsBy?: true
    displayAs?: true
    containsSalaryInfo?: true
    description?: true
    instanceId?: true
    clientId?: true
    parentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    isRoot?: true
    isModelRoot?: true
    accountType?: true
    accountTypeTag?: true
    group?: true
    plannedBy?: true
    actualsBy?: true
    displayAs?: true
    containsSalaryInfo?: true
    description?: true
    instanceId?: true
    clientId?: true
    parentId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    code: string
    name: string
    isRoot: boolean
    isModelRoot: boolean
    accountType: $Enums.AccountType
    accountTypeTag: $Enums.AccountTypeTag
    group: $Enums.YesNo
    plannedBy: $Enums.ActPlanBy | null
    actualsBy: $Enums.ActActualsBy | null
    displayAs: $Enums.ActDisplayAs
    containsSalaryInfo: $Enums.YesNo
    description: string | null
    instanceId: string
    clientId: string
    parentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    isRoot?: boolean
    isModelRoot?: boolean
    accountType?: boolean
    accountTypeTag?: boolean
    group?: boolean
    plannedBy?: boolean
    actualsBy?: boolean
    displayAs?: boolean
    containsSalaryInfo?: boolean
    description?: boolean
    instanceId?: boolean
    clientId?: boolean
    parentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    instance?: boolean | InstanceDefaultArgs<ExtArgs>
    parent?: boolean | Account$parentArgs<ExtArgs>
    childAccounts?: boolean | Account$childAccountsArgs<ExtArgs>
    AttributeAndValues?: boolean | Account$AttributeAndValuesArgs<ExtArgs>
    modelAccounts?: boolean | Account$modelAccountsArgs<ExtArgs>
    modelData?: boolean | Account$modelDataArgs<ExtArgs>
    modeldataCalculations?: boolean | Account$modeldataCalculationsArgs<ExtArgs>
    _count?: boolean | AccountCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>



  export type AccountSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    isRoot?: boolean
    isModelRoot?: boolean
    accountType?: boolean
    accountTypeTag?: boolean
    group?: boolean
    plannedBy?: boolean
    actualsBy?: boolean
    displayAs?: boolean
    containsSalaryInfo?: boolean
    description?: boolean
    instanceId?: boolean
    clientId?: boolean
    parentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "name" | "isRoot" | "isModelRoot" | "accountType" | "accountTypeTag" | "group" | "plannedBy" | "actualsBy" | "displayAs" | "containsSalaryInfo" | "description" | "instanceId" | "clientId" | "parentId" | "createdAt" | "updatedAt", ExtArgs["result"]["account"]>
  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    instance?: boolean | InstanceDefaultArgs<ExtArgs>
    parent?: boolean | Account$parentArgs<ExtArgs>
    childAccounts?: boolean | Account$childAccountsArgs<ExtArgs>
    AttributeAndValues?: boolean | Account$AttributeAndValuesArgs<ExtArgs>
    modelAccounts?: boolean | Account$modelAccountsArgs<ExtArgs>
    modelData?: boolean | Account$modelDataArgs<ExtArgs>
    modeldataCalculations?: boolean | Account$modeldataCalculationsArgs<ExtArgs>
    _count?: boolean | AccountCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      instance: Prisma.$InstancePayload<ExtArgs>
      parent: Prisma.$AccountPayload<ExtArgs> | null
      childAccounts: Prisma.$AccountPayload<ExtArgs>[]
      AttributeAndValues: Prisma.$AccountAttributeAndValuePayload<ExtArgs>[]
      modelAccounts: Prisma.$ModelAccountStructurePayload<ExtArgs>[]
      modelData: Prisma.$ModelDataPayload<ExtArgs>[]
      modeldataCalculations: Prisma.$ModelDataCalculationsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      name: string
      isRoot: boolean
      isModelRoot: boolean
      accountType: $Enums.AccountType
      accountTypeTag: $Enums.AccountTypeTag
      group: $Enums.YesNo
      plannedBy: $Enums.ActPlanBy | null
      actualsBy: $Enums.ActActualsBy | null
      displayAs: $Enums.ActDisplayAs
      containsSalaryInfo: $Enums.YesNo
      description: string | null
      instanceId: string
      clientId: string
      parentId: string | null
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * @param {AccountFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const account = await prisma.account.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: AccountFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Account.
     * @param {AccountAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const account = await prisma.account.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: AccountAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    instance<T extends InstanceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InstanceDefaultArgs<ExtArgs>>): Prisma__InstanceClient<$Result.GetResult<Prisma.$InstancePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    parent<T extends Account$parentArgs<ExtArgs> = {}>(args?: Subset<T, Account$parentArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    childAccounts<T extends Account$childAccountsArgs<ExtArgs> = {}>(args?: Subset<T, Account$childAccountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    AttributeAndValues<T extends Account$AttributeAndValuesArgs<ExtArgs> = {}>(args?: Subset<T, Account$AttributeAndValuesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountAttributeAndValuePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    modelAccounts<T extends Account$modelAccountsArgs<ExtArgs> = {}>(args?: Subset<T, Account$modelAccountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModelAccountStructurePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    modelData<T extends Account$modelDataArgs<ExtArgs> = {}>(args?: Subset<T, Account$modelDataArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModelDataPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    modeldataCalculations<T extends Account$modeldataCalculationsArgs<ExtArgs> = {}>(args?: Subset<T, Account$modeldataCalculationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModelDataCalculationsPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */ 
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly code: FieldRef<"Account", 'String'>
    readonly name: FieldRef<"Account", 'String'>
    readonly isRoot: FieldRef<"Account", 'Boolean'>
    readonly isModelRoot: FieldRef<"Account", 'Boolean'>
    readonly accountType: FieldRef<"Account", 'AccountType'>
    readonly accountTypeTag: FieldRef<"Account", 'AccountTypeTag'>
    readonly group: FieldRef<"Account", 'YesNo'>
    readonly plannedBy: FieldRef<"Account", 'ActPlanBy'>
    readonly actualsBy: FieldRef<"Account", 'ActActualsBy'>
    readonly displayAs: FieldRef<"Account", 'ActDisplayAs'>
    readonly containsSalaryInfo: FieldRef<"Account", 'YesNo'>
    readonly description: FieldRef<"Account", 'String'>
    readonly instanceId: FieldRef<"Account", 'String'>
    readonly clientId: FieldRef<"Account", 'String'>
    readonly parentId: FieldRef<"Account", 'String'>
    readonly createdAt: FieldRef<"Account", 'DateTime'>
    readonly updatedAt: FieldRef<"Account", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to delete.
     */
    limit?: number
  }

  /**
   * Account findRaw
   */
  export type AccountFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Account aggregateRaw
   */
  export type AccountAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Account.parent
   */
  export type Account$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
  }

  /**
   * Account.childAccounts
   */
  export type Account$childAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account.AttributeAndValues
   */
  export type Account$AttributeAndValuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountAttributeAndValue
     */
    select?: AccountAttributeAndValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountAttributeAndValue
     */
    omit?: AccountAttributeAndValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountAttributeAndValueInclude<ExtArgs> | null
    where?: AccountAttributeAndValueWhereInput
    orderBy?: AccountAttributeAndValueOrderByWithRelationInput | AccountAttributeAndValueOrderByWithRelationInput[]
    cursor?: AccountAttributeAndValueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountAttributeAndValueScalarFieldEnum | AccountAttributeAndValueScalarFieldEnum[]
  }

  /**
   * Account.modelAccounts
   */
  export type Account$modelAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelAccountStructure
     */
    select?: ModelAccountStructureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelAccountStructure
     */
    omit?: ModelAccountStructureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelAccountStructureInclude<ExtArgs> | null
    where?: ModelAccountStructureWhereInput
    orderBy?: ModelAccountStructureOrderByWithRelationInput | ModelAccountStructureOrderByWithRelationInput[]
    cursor?: ModelAccountStructureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ModelAccountStructureScalarFieldEnum | ModelAccountStructureScalarFieldEnum[]
  }

  /**
   * Account.modelData
   */
  export type Account$modelDataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelData
     */
    select?: ModelDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelData
     */
    omit?: ModelDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelDataInclude<ExtArgs> | null
    where?: ModelDataWhereInput
    orderBy?: ModelDataOrderByWithRelationInput | ModelDataOrderByWithRelationInput[]
    cursor?: ModelDataWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ModelDataScalarFieldEnum | ModelDataScalarFieldEnum[]
  }

  /**
   * Account.modeldataCalculations
   */
  export type Account$modeldataCalculationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelDataCalculations
     */
    select?: ModelDataCalculationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelDataCalculations
     */
    omit?: ModelDataCalculationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelDataCalculationsInclude<ExtArgs> | null
    where?: ModelDataCalculationsWhereInput
    orderBy?: ModelDataCalculationsOrderByWithRelationInput | ModelDataCalculationsOrderByWithRelationInput[]
    cursor?: ModelDataCalculationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ModelDataCalculationsScalarFieldEnum | ModelDataCalculationsScalarFieldEnum[]
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model Dimension
   */

  export type AggregateDimension = {
    _count: DimensionCountAggregateOutputType | null
    _min: DimensionMinAggregateOutputType | null
    _max: DimensionMaxAggregateOutputType | null
  }

  export type DimensionMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    description: string | null
    dimensionValueDefault: string | null
    clientId: string | null
    instanceId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DimensionMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    description: string | null
    dimensionValueDefault: string | null
    clientId: string | null
    instanceId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DimensionCountAggregateOutputType = {
    id: number
    code: number
    name: number
    description: number
    dimensionValueDefault: number
    clientId: number
    instanceId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DimensionMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    dimensionValueDefault?: true
    clientId?: true
    instanceId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DimensionMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    dimensionValueDefault?: true
    clientId?: true
    instanceId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DimensionCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    dimensionValueDefault?: true
    clientId?: true
    instanceId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DimensionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Dimension to aggregate.
     */
    where?: DimensionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dimensions to fetch.
     */
    orderBy?: DimensionOrderByWithRelationInput | DimensionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DimensionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dimensions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dimensions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Dimensions
    **/
    _count?: true | DimensionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DimensionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DimensionMaxAggregateInputType
  }

  export type GetDimensionAggregateType<T extends DimensionAggregateArgs> = {
        [P in keyof T & keyof AggregateDimension]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDimension[P]>
      : GetScalarType<T[P], AggregateDimension[P]>
  }




  export type DimensionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DimensionWhereInput
    orderBy?: DimensionOrderByWithAggregationInput | DimensionOrderByWithAggregationInput[]
    by: DimensionScalarFieldEnum[] | DimensionScalarFieldEnum
    having?: DimensionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DimensionCountAggregateInputType | true
    _min?: DimensionMinAggregateInputType
    _max?: DimensionMaxAggregateInputType
  }

  export type DimensionGroupByOutputType = {
    id: string
    code: string
    name: string
    description: string | null
    dimensionValueDefault: string | null
    clientId: string
    instanceId: string
    createdAt: Date | null
    updatedAt: Date | null
    _count: DimensionCountAggregateOutputType | null
    _min: DimensionMinAggregateOutputType | null
    _max: DimensionMaxAggregateOutputType | null
  }

  type GetDimensionGroupByPayload<T extends DimensionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DimensionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DimensionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DimensionGroupByOutputType[P]>
            : GetScalarType<T[P], DimensionGroupByOutputType[P]>
        }
      >
    >


  export type DimensionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    dimensionValueDefault?: boolean
    clientId?: boolean
    instanceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    instance?: boolean | InstanceDefaultArgs<ExtArgs>
    dimensionValues?: boolean | Dimension$dimensionValuesArgs<ExtArgs>
    _count?: boolean | DimensionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dimension"]>



  export type DimensionSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    dimensionValueDefault?: boolean
    clientId?: boolean
    instanceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DimensionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "name" | "description" | "dimensionValueDefault" | "clientId" | "instanceId" | "createdAt" | "updatedAt", ExtArgs["result"]["dimension"]>
  export type DimensionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    instance?: boolean | InstanceDefaultArgs<ExtArgs>
    dimensionValues?: boolean | Dimension$dimensionValuesArgs<ExtArgs>
    _count?: boolean | DimensionCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $DimensionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Dimension"
    objects: {
      instance: Prisma.$InstancePayload<ExtArgs>
      dimensionValues: Prisma.$DimensionValuePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      name: string
      description: string | null
      dimensionValueDefault: string | null
      clientId: string
      instanceId: string
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["dimension"]>
    composites: {}
  }

  type DimensionGetPayload<S extends boolean | null | undefined | DimensionDefaultArgs> = $Result.GetResult<Prisma.$DimensionPayload, S>

  type DimensionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DimensionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DimensionCountAggregateInputType | true
    }

  export interface DimensionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Dimension'], meta: { name: 'Dimension' } }
    /**
     * Find zero or one Dimension that matches the filter.
     * @param {DimensionFindUniqueArgs} args - Arguments to find a Dimension
     * @example
     * // Get one Dimension
     * const dimension = await prisma.dimension.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DimensionFindUniqueArgs>(args: SelectSubset<T, DimensionFindUniqueArgs<ExtArgs>>): Prisma__DimensionClient<$Result.GetResult<Prisma.$DimensionPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Dimension that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DimensionFindUniqueOrThrowArgs} args - Arguments to find a Dimension
     * @example
     * // Get one Dimension
     * const dimension = await prisma.dimension.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DimensionFindUniqueOrThrowArgs>(args: SelectSubset<T, DimensionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DimensionClient<$Result.GetResult<Prisma.$DimensionPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Dimension that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimensionFindFirstArgs} args - Arguments to find a Dimension
     * @example
     * // Get one Dimension
     * const dimension = await prisma.dimension.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DimensionFindFirstArgs>(args?: SelectSubset<T, DimensionFindFirstArgs<ExtArgs>>): Prisma__DimensionClient<$Result.GetResult<Prisma.$DimensionPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Dimension that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimensionFindFirstOrThrowArgs} args - Arguments to find a Dimension
     * @example
     * // Get one Dimension
     * const dimension = await prisma.dimension.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DimensionFindFirstOrThrowArgs>(args?: SelectSubset<T, DimensionFindFirstOrThrowArgs<ExtArgs>>): Prisma__DimensionClient<$Result.GetResult<Prisma.$DimensionPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Dimensions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimensionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Dimensions
     * const dimensions = await prisma.dimension.findMany()
     * 
     * // Get first 10 Dimensions
     * const dimensions = await prisma.dimension.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dimensionWithIdOnly = await prisma.dimension.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DimensionFindManyArgs>(args?: SelectSubset<T, DimensionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DimensionPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Dimension.
     * @param {DimensionCreateArgs} args - Arguments to create a Dimension.
     * @example
     * // Create one Dimension
     * const Dimension = await prisma.dimension.create({
     *   data: {
     *     // ... data to create a Dimension
     *   }
     * })
     * 
     */
    create<T extends DimensionCreateArgs>(args: SelectSubset<T, DimensionCreateArgs<ExtArgs>>): Prisma__DimensionClient<$Result.GetResult<Prisma.$DimensionPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Dimensions.
     * @param {DimensionCreateManyArgs} args - Arguments to create many Dimensions.
     * @example
     * // Create many Dimensions
     * const dimension = await prisma.dimension.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DimensionCreateManyArgs>(args?: SelectSubset<T, DimensionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Dimension.
     * @param {DimensionDeleteArgs} args - Arguments to delete one Dimension.
     * @example
     * // Delete one Dimension
     * const Dimension = await prisma.dimension.delete({
     *   where: {
     *     // ... filter to delete one Dimension
     *   }
     * })
     * 
     */
    delete<T extends DimensionDeleteArgs>(args: SelectSubset<T, DimensionDeleteArgs<ExtArgs>>): Prisma__DimensionClient<$Result.GetResult<Prisma.$DimensionPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Dimension.
     * @param {DimensionUpdateArgs} args - Arguments to update one Dimension.
     * @example
     * // Update one Dimension
     * const dimension = await prisma.dimension.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DimensionUpdateArgs>(args: SelectSubset<T, DimensionUpdateArgs<ExtArgs>>): Prisma__DimensionClient<$Result.GetResult<Prisma.$DimensionPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Dimensions.
     * @param {DimensionDeleteManyArgs} args - Arguments to filter Dimensions to delete.
     * @example
     * // Delete a few Dimensions
     * const { count } = await prisma.dimension.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DimensionDeleteManyArgs>(args?: SelectSubset<T, DimensionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Dimensions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimensionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Dimensions
     * const dimension = await prisma.dimension.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DimensionUpdateManyArgs>(args: SelectSubset<T, DimensionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Dimension.
     * @param {DimensionUpsertArgs} args - Arguments to update or create a Dimension.
     * @example
     * // Update or create a Dimension
     * const dimension = await prisma.dimension.upsert({
     *   create: {
     *     // ... data to create a Dimension
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Dimension we want to update
     *   }
     * })
     */
    upsert<T extends DimensionUpsertArgs>(args: SelectSubset<T, DimensionUpsertArgs<ExtArgs>>): Prisma__DimensionClient<$Result.GetResult<Prisma.$DimensionPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Dimensions that matches the filter.
     * @param {DimensionFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const dimension = await prisma.dimension.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: DimensionFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Dimension.
     * @param {DimensionAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const dimension = await prisma.dimension.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: DimensionAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Dimensions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimensionCountArgs} args - Arguments to filter Dimensions to count.
     * @example
     * // Count the number of Dimensions
     * const count = await prisma.dimension.count({
     *   where: {
     *     // ... the filter for the Dimensions we want to count
     *   }
     * })
    **/
    count<T extends DimensionCountArgs>(
      args?: Subset<T, DimensionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DimensionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Dimension.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimensionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DimensionAggregateArgs>(args: Subset<T, DimensionAggregateArgs>): Prisma.PrismaPromise<GetDimensionAggregateType<T>>

    /**
     * Group by Dimension.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimensionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DimensionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DimensionGroupByArgs['orderBy'] }
        : { orderBy?: DimensionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DimensionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDimensionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Dimension model
   */
  readonly fields: DimensionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Dimension.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DimensionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    instance<T extends InstanceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InstanceDefaultArgs<ExtArgs>>): Prisma__InstanceClient<$Result.GetResult<Prisma.$InstancePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    dimensionValues<T extends Dimension$dimensionValuesArgs<ExtArgs> = {}>(args?: Subset<T, Dimension$dimensionValuesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DimensionValuePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Dimension model
   */ 
  interface DimensionFieldRefs {
    readonly id: FieldRef<"Dimension", 'String'>
    readonly code: FieldRef<"Dimension", 'String'>
    readonly name: FieldRef<"Dimension", 'String'>
    readonly description: FieldRef<"Dimension", 'String'>
    readonly dimensionValueDefault: FieldRef<"Dimension", 'String'>
    readonly clientId: FieldRef<"Dimension", 'String'>
    readonly instanceId: FieldRef<"Dimension", 'String'>
    readonly createdAt: FieldRef<"Dimension", 'DateTime'>
    readonly updatedAt: FieldRef<"Dimension", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Dimension findUnique
   */
  export type DimensionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dimension
     */
    select?: DimensionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dimension
     */
    omit?: DimensionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimensionInclude<ExtArgs> | null
    /**
     * Filter, which Dimension to fetch.
     */
    where: DimensionWhereUniqueInput
  }

  /**
   * Dimension findUniqueOrThrow
   */
  export type DimensionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dimension
     */
    select?: DimensionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dimension
     */
    omit?: DimensionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimensionInclude<ExtArgs> | null
    /**
     * Filter, which Dimension to fetch.
     */
    where: DimensionWhereUniqueInput
  }

  /**
   * Dimension findFirst
   */
  export type DimensionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dimension
     */
    select?: DimensionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dimension
     */
    omit?: DimensionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimensionInclude<ExtArgs> | null
    /**
     * Filter, which Dimension to fetch.
     */
    where?: DimensionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dimensions to fetch.
     */
    orderBy?: DimensionOrderByWithRelationInput | DimensionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Dimensions.
     */
    cursor?: DimensionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dimensions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dimensions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Dimensions.
     */
    distinct?: DimensionScalarFieldEnum | DimensionScalarFieldEnum[]
  }

  /**
   * Dimension findFirstOrThrow
   */
  export type DimensionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dimension
     */
    select?: DimensionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dimension
     */
    omit?: DimensionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimensionInclude<ExtArgs> | null
    /**
     * Filter, which Dimension to fetch.
     */
    where?: DimensionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dimensions to fetch.
     */
    orderBy?: DimensionOrderByWithRelationInput | DimensionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Dimensions.
     */
    cursor?: DimensionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dimensions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dimensions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Dimensions.
     */
    distinct?: DimensionScalarFieldEnum | DimensionScalarFieldEnum[]
  }

  /**
   * Dimension findMany
   */
  export type DimensionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dimension
     */
    select?: DimensionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dimension
     */
    omit?: DimensionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimensionInclude<ExtArgs> | null
    /**
     * Filter, which Dimensions to fetch.
     */
    where?: DimensionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dimensions to fetch.
     */
    orderBy?: DimensionOrderByWithRelationInput | DimensionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Dimensions.
     */
    cursor?: DimensionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dimensions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dimensions.
     */
    skip?: number
    distinct?: DimensionScalarFieldEnum | DimensionScalarFieldEnum[]
  }

  /**
   * Dimension create
   */
  export type DimensionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dimension
     */
    select?: DimensionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dimension
     */
    omit?: DimensionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimensionInclude<ExtArgs> | null
    /**
     * The data needed to create a Dimension.
     */
    data: XOR<DimensionCreateInput, DimensionUncheckedCreateInput>
  }

  /**
   * Dimension createMany
   */
  export type DimensionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Dimensions.
     */
    data: DimensionCreateManyInput | DimensionCreateManyInput[]
  }

  /**
   * Dimension update
   */
  export type DimensionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dimension
     */
    select?: DimensionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dimension
     */
    omit?: DimensionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimensionInclude<ExtArgs> | null
    /**
     * The data needed to update a Dimension.
     */
    data: XOR<DimensionUpdateInput, DimensionUncheckedUpdateInput>
    /**
     * Choose, which Dimension to update.
     */
    where: DimensionWhereUniqueInput
  }

  /**
   * Dimension updateMany
   */
  export type DimensionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Dimensions.
     */
    data: XOR<DimensionUpdateManyMutationInput, DimensionUncheckedUpdateManyInput>
    /**
     * Filter which Dimensions to update
     */
    where?: DimensionWhereInput
    /**
     * Limit how many Dimensions to update.
     */
    limit?: number
  }

  /**
   * Dimension upsert
   */
  export type DimensionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dimension
     */
    select?: DimensionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dimension
     */
    omit?: DimensionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimensionInclude<ExtArgs> | null
    /**
     * The filter to search for the Dimension to update in case it exists.
     */
    where: DimensionWhereUniqueInput
    /**
     * In case the Dimension found by the `where` argument doesn't exist, create a new Dimension with this data.
     */
    create: XOR<DimensionCreateInput, DimensionUncheckedCreateInput>
    /**
     * In case the Dimension was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DimensionUpdateInput, DimensionUncheckedUpdateInput>
  }

  /**
   * Dimension delete
   */
  export type DimensionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dimension
     */
    select?: DimensionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dimension
     */
    omit?: DimensionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimensionInclude<ExtArgs> | null
    /**
     * Filter which Dimension to delete.
     */
    where: DimensionWhereUniqueInput
  }

  /**
   * Dimension deleteMany
   */
  export type DimensionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Dimensions to delete
     */
    where?: DimensionWhereInput
    /**
     * Limit how many Dimensions to delete.
     */
    limit?: number
  }

  /**
   * Dimension findRaw
   */
  export type DimensionFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Dimension aggregateRaw
   */
  export type DimensionAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Dimension.dimensionValues
   */
  export type Dimension$dimensionValuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimensionValue
     */
    select?: DimensionValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DimensionValue
     */
    omit?: DimensionValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimensionValueInclude<ExtArgs> | null
    where?: DimensionValueWhereInput
    orderBy?: DimensionValueOrderByWithRelationInput | DimensionValueOrderByWithRelationInput[]
    cursor?: DimensionValueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DimensionValueScalarFieldEnum | DimensionValueScalarFieldEnum[]
  }

  /**
   * Dimension without action
   */
  export type DimensionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dimension
     */
    select?: DimensionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dimension
     */
    omit?: DimensionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimensionInclude<ExtArgs> | null
  }


  /**
   * Model DimensionValue
   */

  export type AggregateDimensionValue = {
    _count: DimensionValueCountAggregateOutputType | null
    _min: DimensionValueMinAggregateOutputType | null
    _max: DimensionValueMaxAggregateOutputType | null
  }

  export type DimensionValueMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    parentId: string | null
    clientId: string | null
    instanceId: string | null
    dimensionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DimensionValueMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    parentId: string | null
    clientId: string | null
    instanceId: string | null
    dimensionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DimensionValueCountAggregateOutputType = {
    id: number
    code: number
    name: number
    parentId: number
    clientId: number
    instanceId: number
    dimensionId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DimensionValueMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    parentId?: true
    clientId?: true
    instanceId?: true
    dimensionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DimensionValueMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    parentId?: true
    clientId?: true
    instanceId?: true
    dimensionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DimensionValueCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    parentId?: true
    clientId?: true
    instanceId?: true
    dimensionId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DimensionValueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DimensionValue to aggregate.
     */
    where?: DimensionValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DimensionValues to fetch.
     */
    orderBy?: DimensionValueOrderByWithRelationInput | DimensionValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DimensionValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DimensionValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DimensionValues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DimensionValues
    **/
    _count?: true | DimensionValueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DimensionValueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DimensionValueMaxAggregateInputType
  }

  export type GetDimensionValueAggregateType<T extends DimensionValueAggregateArgs> = {
        [P in keyof T & keyof AggregateDimensionValue]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDimensionValue[P]>
      : GetScalarType<T[P], AggregateDimensionValue[P]>
  }




  export type DimensionValueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DimensionValueWhereInput
    orderBy?: DimensionValueOrderByWithAggregationInput | DimensionValueOrderByWithAggregationInput[]
    by: DimensionValueScalarFieldEnum[] | DimensionValueScalarFieldEnum
    having?: DimensionValueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DimensionValueCountAggregateInputType | true
    _min?: DimensionValueMinAggregateInputType
    _max?: DimensionValueMaxAggregateInputType
  }

  export type DimensionValueGroupByOutputType = {
    id: string
    code: string
    name: string
    parentId: string | null
    clientId: string
    instanceId: string
    dimensionId: string
    createdAt: Date | null
    updatedAt: Date | null
    _count: DimensionValueCountAggregateOutputType | null
    _min: DimensionValueMinAggregateOutputType | null
    _max: DimensionValueMaxAggregateOutputType | null
  }

  type GetDimensionValueGroupByPayload<T extends DimensionValueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DimensionValueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DimensionValueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DimensionValueGroupByOutputType[P]>
            : GetScalarType<T[P], DimensionValueGroupByOutputType[P]>
        }
      >
    >


  export type DimensionValueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    parentId?: boolean
    clientId?: boolean
    instanceId?: boolean
    dimensionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parent?: boolean | DimensionValue$parentArgs<ExtArgs>
    childDimensionValues?: boolean | DimensionValue$childDimensionValuesArgs<ExtArgs>
    AttributeAndValues?: boolean | DimensionValue$AttributeAndValuesArgs<ExtArgs>
    instance?: boolean | InstanceDefaultArgs<ExtArgs>
    dimension?: boolean | DimensionDefaultArgs<ExtArgs>
    _count?: boolean | DimensionValueCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dimensionValue"]>



  export type DimensionValueSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    parentId?: boolean
    clientId?: boolean
    instanceId?: boolean
    dimensionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DimensionValueOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "name" | "parentId" | "clientId" | "instanceId" | "dimensionId" | "createdAt" | "updatedAt", ExtArgs["result"]["dimensionValue"]>
  export type DimensionValueInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | DimensionValue$parentArgs<ExtArgs>
    childDimensionValues?: boolean | DimensionValue$childDimensionValuesArgs<ExtArgs>
    AttributeAndValues?: boolean | DimensionValue$AttributeAndValuesArgs<ExtArgs>
    instance?: boolean | InstanceDefaultArgs<ExtArgs>
    dimension?: boolean | DimensionDefaultArgs<ExtArgs>
    _count?: boolean | DimensionValueCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $DimensionValuePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DimensionValue"
    objects: {
      parent: Prisma.$DimensionValuePayload<ExtArgs> | null
      childDimensionValues: Prisma.$DimensionValuePayload<ExtArgs>[]
      AttributeAndValues: Prisma.$DimensionValueAttributeAndValuePayload<ExtArgs>[]
      instance: Prisma.$InstancePayload<ExtArgs>
      dimension: Prisma.$DimensionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      name: string
      parentId: string | null
      clientId: string
      instanceId: string
      dimensionId: string
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["dimensionValue"]>
    composites: {}
  }

  type DimensionValueGetPayload<S extends boolean | null | undefined | DimensionValueDefaultArgs> = $Result.GetResult<Prisma.$DimensionValuePayload, S>

  type DimensionValueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DimensionValueFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DimensionValueCountAggregateInputType | true
    }

  export interface DimensionValueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DimensionValue'], meta: { name: 'DimensionValue' } }
    /**
     * Find zero or one DimensionValue that matches the filter.
     * @param {DimensionValueFindUniqueArgs} args - Arguments to find a DimensionValue
     * @example
     * // Get one DimensionValue
     * const dimensionValue = await prisma.dimensionValue.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DimensionValueFindUniqueArgs>(args: SelectSubset<T, DimensionValueFindUniqueArgs<ExtArgs>>): Prisma__DimensionValueClient<$Result.GetResult<Prisma.$DimensionValuePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one DimensionValue that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DimensionValueFindUniqueOrThrowArgs} args - Arguments to find a DimensionValue
     * @example
     * // Get one DimensionValue
     * const dimensionValue = await prisma.dimensionValue.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DimensionValueFindUniqueOrThrowArgs>(args: SelectSubset<T, DimensionValueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DimensionValueClient<$Result.GetResult<Prisma.$DimensionValuePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first DimensionValue that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimensionValueFindFirstArgs} args - Arguments to find a DimensionValue
     * @example
     * // Get one DimensionValue
     * const dimensionValue = await prisma.dimensionValue.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DimensionValueFindFirstArgs>(args?: SelectSubset<T, DimensionValueFindFirstArgs<ExtArgs>>): Prisma__DimensionValueClient<$Result.GetResult<Prisma.$DimensionValuePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first DimensionValue that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimensionValueFindFirstOrThrowArgs} args - Arguments to find a DimensionValue
     * @example
     * // Get one DimensionValue
     * const dimensionValue = await prisma.dimensionValue.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DimensionValueFindFirstOrThrowArgs>(args?: SelectSubset<T, DimensionValueFindFirstOrThrowArgs<ExtArgs>>): Prisma__DimensionValueClient<$Result.GetResult<Prisma.$DimensionValuePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more DimensionValues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimensionValueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DimensionValues
     * const dimensionValues = await prisma.dimensionValue.findMany()
     * 
     * // Get first 10 DimensionValues
     * const dimensionValues = await prisma.dimensionValue.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dimensionValueWithIdOnly = await prisma.dimensionValue.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DimensionValueFindManyArgs>(args?: SelectSubset<T, DimensionValueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DimensionValuePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a DimensionValue.
     * @param {DimensionValueCreateArgs} args - Arguments to create a DimensionValue.
     * @example
     * // Create one DimensionValue
     * const DimensionValue = await prisma.dimensionValue.create({
     *   data: {
     *     // ... data to create a DimensionValue
     *   }
     * })
     * 
     */
    create<T extends DimensionValueCreateArgs>(args: SelectSubset<T, DimensionValueCreateArgs<ExtArgs>>): Prisma__DimensionValueClient<$Result.GetResult<Prisma.$DimensionValuePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many DimensionValues.
     * @param {DimensionValueCreateManyArgs} args - Arguments to create many DimensionValues.
     * @example
     * // Create many DimensionValues
     * const dimensionValue = await prisma.dimensionValue.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DimensionValueCreateManyArgs>(args?: SelectSubset<T, DimensionValueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DimensionValue.
     * @param {DimensionValueDeleteArgs} args - Arguments to delete one DimensionValue.
     * @example
     * // Delete one DimensionValue
     * const DimensionValue = await prisma.dimensionValue.delete({
     *   where: {
     *     // ... filter to delete one DimensionValue
     *   }
     * })
     * 
     */
    delete<T extends DimensionValueDeleteArgs>(args: SelectSubset<T, DimensionValueDeleteArgs<ExtArgs>>): Prisma__DimensionValueClient<$Result.GetResult<Prisma.$DimensionValuePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one DimensionValue.
     * @param {DimensionValueUpdateArgs} args - Arguments to update one DimensionValue.
     * @example
     * // Update one DimensionValue
     * const dimensionValue = await prisma.dimensionValue.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DimensionValueUpdateArgs>(args: SelectSubset<T, DimensionValueUpdateArgs<ExtArgs>>): Prisma__DimensionValueClient<$Result.GetResult<Prisma.$DimensionValuePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more DimensionValues.
     * @param {DimensionValueDeleteManyArgs} args - Arguments to filter DimensionValues to delete.
     * @example
     * // Delete a few DimensionValues
     * const { count } = await prisma.dimensionValue.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DimensionValueDeleteManyArgs>(args?: SelectSubset<T, DimensionValueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DimensionValues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimensionValueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DimensionValues
     * const dimensionValue = await prisma.dimensionValue.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DimensionValueUpdateManyArgs>(args: SelectSubset<T, DimensionValueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DimensionValue.
     * @param {DimensionValueUpsertArgs} args - Arguments to update or create a DimensionValue.
     * @example
     * // Update or create a DimensionValue
     * const dimensionValue = await prisma.dimensionValue.upsert({
     *   create: {
     *     // ... data to create a DimensionValue
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DimensionValue we want to update
     *   }
     * })
     */
    upsert<T extends DimensionValueUpsertArgs>(args: SelectSubset<T, DimensionValueUpsertArgs<ExtArgs>>): Prisma__DimensionValueClient<$Result.GetResult<Prisma.$DimensionValuePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more DimensionValues that matches the filter.
     * @param {DimensionValueFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const dimensionValue = await prisma.dimensionValue.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: DimensionValueFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a DimensionValue.
     * @param {DimensionValueAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const dimensionValue = await prisma.dimensionValue.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: DimensionValueAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of DimensionValues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimensionValueCountArgs} args - Arguments to filter DimensionValues to count.
     * @example
     * // Count the number of DimensionValues
     * const count = await prisma.dimensionValue.count({
     *   where: {
     *     // ... the filter for the DimensionValues we want to count
     *   }
     * })
    **/
    count<T extends DimensionValueCountArgs>(
      args?: Subset<T, DimensionValueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DimensionValueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DimensionValue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimensionValueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DimensionValueAggregateArgs>(args: Subset<T, DimensionValueAggregateArgs>): Prisma.PrismaPromise<GetDimensionValueAggregateType<T>>

    /**
     * Group by DimensionValue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimensionValueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DimensionValueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DimensionValueGroupByArgs['orderBy'] }
        : { orderBy?: DimensionValueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DimensionValueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDimensionValueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DimensionValue model
   */
  readonly fields: DimensionValueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DimensionValue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DimensionValueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    parent<T extends DimensionValue$parentArgs<ExtArgs> = {}>(args?: Subset<T, DimensionValue$parentArgs<ExtArgs>>): Prisma__DimensionValueClient<$Result.GetResult<Prisma.$DimensionValuePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    childDimensionValues<T extends DimensionValue$childDimensionValuesArgs<ExtArgs> = {}>(args?: Subset<T, DimensionValue$childDimensionValuesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DimensionValuePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    AttributeAndValues<T extends DimensionValue$AttributeAndValuesArgs<ExtArgs> = {}>(args?: Subset<T, DimensionValue$AttributeAndValuesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DimensionValueAttributeAndValuePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    instance<T extends InstanceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InstanceDefaultArgs<ExtArgs>>): Prisma__InstanceClient<$Result.GetResult<Prisma.$InstancePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    dimension<T extends DimensionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DimensionDefaultArgs<ExtArgs>>): Prisma__DimensionClient<$Result.GetResult<Prisma.$DimensionPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DimensionValue model
   */ 
  interface DimensionValueFieldRefs {
    readonly id: FieldRef<"DimensionValue", 'String'>
    readonly code: FieldRef<"DimensionValue", 'String'>
    readonly name: FieldRef<"DimensionValue", 'String'>
    readonly parentId: FieldRef<"DimensionValue", 'String'>
    readonly clientId: FieldRef<"DimensionValue", 'String'>
    readonly instanceId: FieldRef<"DimensionValue", 'String'>
    readonly dimensionId: FieldRef<"DimensionValue", 'String'>
    readonly createdAt: FieldRef<"DimensionValue", 'DateTime'>
    readonly updatedAt: FieldRef<"DimensionValue", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DimensionValue findUnique
   */
  export type DimensionValueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimensionValue
     */
    select?: DimensionValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DimensionValue
     */
    omit?: DimensionValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimensionValueInclude<ExtArgs> | null
    /**
     * Filter, which DimensionValue to fetch.
     */
    where: DimensionValueWhereUniqueInput
  }

  /**
   * DimensionValue findUniqueOrThrow
   */
  export type DimensionValueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimensionValue
     */
    select?: DimensionValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DimensionValue
     */
    omit?: DimensionValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimensionValueInclude<ExtArgs> | null
    /**
     * Filter, which DimensionValue to fetch.
     */
    where: DimensionValueWhereUniqueInput
  }

  /**
   * DimensionValue findFirst
   */
  export type DimensionValueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimensionValue
     */
    select?: DimensionValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DimensionValue
     */
    omit?: DimensionValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimensionValueInclude<ExtArgs> | null
    /**
     * Filter, which DimensionValue to fetch.
     */
    where?: DimensionValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DimensionValues to fetch.
     */
    orderBy?: DimensionValueOrderByWithRelationInput | DimensionValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DimensionValues.
     */
    cursor?: DimensionValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DimensionValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DimensionValues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DimensionValues.
     */
    distinct?: DimensionValueScalarFieldEnum | DimensionValueScalarFieldEnum[]
  }

  /**
   * DimensionValue findFirstOrThrow
   */
  export type DimensionValueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimensionValue
     */
    select?: DimensionValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DimensionValue
     */
    omit?: DimensionValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimensionValueInclude<ExtArgs> | null
    /**
     * Filter, which DimensionValue to fetch.
     */
    where?: DimensionValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DimensionValues to fetch.
     */
    orderBy?: DimensionValueOrderByWithRelationInput | DimensionValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DimensionValues.
     */
    cursor?: DimensionValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DimensionValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DimensionValues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DimensionValues.
     */
    distinct?: DimensionValueScalarFieldEnum | DimensionValueScalarFieldEnum[]
  }

  /**
   * DimensionValue findMany
   */
  export type DimensionValueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimensionValue
     */
    select?: DimensionValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DimensionValue
     */
    omit?: DimensionValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimensionValueInclude<ExtArgs> | null
    /**
     * Filter, which DimensionValues to fetch.
     */
    where?: DimensionValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DimensionValues to fetch.
     */
    orderBy?: DimensionValueOrderByWithRelationInput | DimensionValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DimensionValues.
     */
    cursor?: DimensionValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DimensionValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DimensionValues.
     */
    skip?: number
    distinct?: DimensionValueScalarFieldEnum | DimensionValueScalarFieldEnum[]
  }

  /**
   * DimensionValue create
   */
  export type DimensionValueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimensionValue
     */
    select?: DimensionValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DimensionValue
     */
    omit?: DimensionValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimensionValueInclude<ExtArgs> | null
    /**
     * The data needed to create a DimensionValue.
     */
    data: XOR<DimensionValueCreateInput, DimensionValueUncheckedCreateInput>
  }

  /**
   * DimensionValue createMany
   */
  export type DimensionValueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DimensionValues.
     */
    data: DimensionValueCreateManyInput | DimensionValueCreateManyInput[]
  }

  /**
   * DimensionValue update
   */
  export type DimensionValueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimensionValue
     */
    select?: DimensionValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DimensionValue
     */
    omit?: DimensionValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimensionValueInclude<ExtArgs> | null
    /**
     * The data needed to update a DimensionValue.
     */
    data: XOR<DimensionValueUpdateInput, DimensionValueUncheckedUpdateInput>
    /**
     * Choose, which DimensionValue to update.
     */
    where: DimensionValueWhereUniqueInput
  }

  /**
   * DimensionValue updateMany
   */
  export type DimensionValueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DimensionValues.
     */
    data: XOR<DimensionValueUpdateManyMutationInput, DimensionValueUncheckedUpdateManyInput>
    /**
     * Filter which DimensionValues to update
     */
    where?: DimensionValueWhereInput
    /**
     * Limit how many DimensionValues to update.
     */
    limit?: number
  }

  /**
   * DimensionValue upsert
   */
  export type DimensionValueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimensionValue
     */
    select?: DimensionValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DimensionValue
     */
    omit?: DimensionValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimensionValueInclude<ExtArgs> | null
    /**
     * The filter to search for the DimensionValue to update in case it exists.
     */
    where: DimensionValueWhereUniqueInput
    /**
     * In case the DimensionValue found by the `where` argument doesn't exist, create a new DimensionValue with this data.
     */
    create: XOR<DimensionValueCreateInput, DimensionValueUncheckedCreateInput>
    /**
     * In case the DimensionValue was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DimensionValueUpdateInput, DimensionValueUncheckedUpdateInput>
  }

  /**
   * DimensionValue delete
   */
  export type DimensionValueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimensionValue
     */
    select?: DimensionValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DimensionValue
     */
    omit?: DimensionValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimensionValueInclude<ExtArgs> | null
    /**
     * Filter which DimensionValue to delete.
     */
    where: DimensionValueWhereUniqueInput
  }

  /**
   * DimensionValue deleteMany
   */
  export type DimensionValueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DimensionValues to delete
     */
    where?: DimensionValueWhereInput
    /**
     * Limit how many DimensionValues to delete.
     */
    limit?: number
  }

  /**
   * DimensionValue findRaw
   */
  export type DimensionValueFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * DimensionValue aggregateRaw
   */
  export type DimensionValueAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * DimensionValue.parent
   */
  export type DimensionValue$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimensionValue
     */
    select?: DimensionValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DimensionValue
     */
    omit?: DimensionValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimensionValueInclude<ExtArgs> | null
    where?: DimensionValueWhereInput
  }

  /**
   * DimensionValue.childDimensionValues
   */
  export type DimensionValue$childDimensionValuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimensionValue
     */
    select?: DimensionValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DimensionValue
     */
    omit?: DimensionValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimensionValueInclude<ExtArgs> | null
    where?: DimensionValueWhereInput
    orderBy?: DimensionValueOrderByWithRelationInput | DimensionValueOrderByWithRelationInput[]
    cursor?: DimensionValueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DimensionValueScalarFieldEnum | DimensionValueScalarFieldEnum[]
  }

  /**
   * DimensionValue.AttributeAndValues
   */
  export type DimensionValue$AttributeAndValuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimensionValueAttributeAndValue
     */
    select?: DimensionValueAttributeAndValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DimensionValueAttributeAndValue
     */
    omit?: DimensionValueAttributeAndValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimensionValueAttributeAndValueInclude<ExtArgs> | null
    where?: DimensionValueAttributeAndValueWhereInput
    orderBy?: DimensionValueAttributeAndValueOrderByWithRelationInput | DimensionValueAttributeAndValueOrderByWithRelationInput[]
    cursor?: DimensionValueAttributeAndValueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DimensionValueAttributeAndValueScalarFieldEnum | DimensionValueAttributeAndValueScalarFieldEnum[]
  }

  /**
   * DimensionValue without action
   */
  export type DimensionValueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimensionValue
     */
    select?: DimensionValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DimensionValue
     */
    omit?: DimensionValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimensionValueInclude<ExtArgs> | null
  }


  /**
   * Model DimensionValueAttribute
   */

  export type AggregateDimensionValueAttribute = {
    _count: DimensionValueAttributeCountAggregateOutputType | null
    _min: DimensionValueAttributeMinAggregateOutputType | null
    _max: DimensionValueAttributeMaxAggregateOutputType | null
  }

  export type DimensionValueAttributeMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    description: string | null
    clientId: string | null
    instanceId: string | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type DimensionValueAttributeMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    description: string | null
    clientId: string | null
    instanceId: string | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type DimensionValueAttributeCountAggregateOutputType = {
    id: number
    code: number
    name: number
    description: number
    clientId: number
    instanceId: number
    updatedAt: number
    createdAt: number
    _all: number
  }


  export type DimensionValueAttributeMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    clientId?: true
    instanceId?: true
    updatedAt?: true
    createdAt?: true
  }

  export type DimensionValueAttributeMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    clientId?: true
    instanceId?: true
    updatedAt?: true
    createdAt?: true
  }

  export type DimensionValueAttributeCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    clientId?: true
    instanceId?: true
    updatedAt?: true
    createdAt?: true
    _all?: true
  }

  export type DimensionValueAttributeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DimensionValueAttribute to aggregate.
     */
    where?: DimensionValueAttributeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DimensionValueAttributes to fetch.
     */
    orderBy?: DimensionValueAttributeOrderByWithRelationInput | DimensionValueAttributeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DimensionValueAttributeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DimensionValueAttributes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DimensionValueAttributes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DimensionValueAttributes
    **/
    _count?: true | DimensionValueAttributeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DimensionValueAttributeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DimensionValueAttributeMaxAggregateInputType
  }

  export type GetDimensionValueAttributeAggregateType<T extends DimensionValueAttributeAggregateArgs> = {
        [P in keyof T & keyof AggregateDimensionValueAttribute]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDimensionValueAttribute[P]>
      : GetScalarType<T[P], AggregateDimensionValueAttribute[P]>
  }




  export type DimensionValueAttributeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DimensionValueAttributeWhereInput
    orderBy?: DimensionValueAttributeOrderByWithAggregationInput | DimensionValueAttributeOrderByWithAggregationInput[]
    by: DimensionValueAttributeScalarFieldEnum[] | DimensionValueAttributeScalarFieldEnum
    having?: DimensionValueAttributeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DimensionValueAttributeCountAggregateInputType | true
    _min?: DimensionValueAttributeMinAggregateInputType
    _max?: DimensionValueAttributeMaxAggregateInputType
  }

  export type DimensionValueAttributeGroupByOutputType = {
    id: string
    code: string
    name: string
    description: string | null
    clientId: string
    instanceId: string
    updatedAt: Date | null
    createdAt: Date | null
    _count: DimensionValueAttributeCountAggregateOutputType | null
    _min: DimensionValueAttributeMinAggregateOutputType | null
    _max: DimensionValueAttributeMaxAggregateOutputType | null
  }

  type GetDimensionValueAttributeGroupByPayload<T extends DimensionValueAttributeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DimensionValueAttributeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DimensionValueAttributeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DimensionValueAttributeGroupByOutputType[P]>
            : GetScalarType<T[P], DimensionValueAttributeGroupByOutputType[P]>
        }
      >
    >


  export type DimensionValueAttributeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    clientId?: boolean
    instanceId?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    instance?: boolean | InstanceDefaultArgs<ExtArgs>
    AttributeValues?: boolean | DimensionValueAttribute$AttributeValuesArgs<ExtArgs>
    AttributeAndValues?: boolean | DimensionValueAttribute$AttributeAndValuesArgs<ExtArgs>
    _count?: boolean | DimensionValueAttributeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dimensionValueAttribute"]>



  export type DimensionValueAttributeSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    clientId?: boolean
    instanceId?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }

  export type DimensionValueAttributeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "name" | "description" | "clientId" | "instanceId" | "updatedAt" | "createdAt", ExtArgs["result"]["dimensionValueAttribute"]>
  export type DimensionValueAttributeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    instance?: boolean | InstanceDefaultArgs<ExtArgs>
    AttributeValues?: boolean | DimensionValueAttribute$AttributeValuesArgs<ExtArgs>
    AttributeAndValues?: boolean | DimensionValueAttribute$AttributeAndValuesArgs<ExtArgs>
    _count?: boolean | DimensionValueAttributeCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $DimensionValueAttributePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DimensionValueAttribute"
    objects: {
      instance: Prisma.$InstancePayload<ExtArgs>
      AttributeValues: Prisma.$DimensionValueAttributeValuePayload<ExtArgs>[]
      AttributeAndValues: Prisma.$DimensionValueAttributeAndValuePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      name: string
      description: string | null
      clientId: string
      instanceId: string
      updatedAt: Date | null
      createdAt: Date | null
    }, ExtArgs["result"]["dimensionValueAttribute"]>
    composites: {}
  }

  type DimensionValueAttributeGetPayload<S extends boolean | null | undefined | DimensionValueAttributeDefaultArgs> = $Result.GetResult<Prisma.$DimensionValueAttributePayload, S>

  type DimensionValueAttributeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DimensionValueAttributeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DimensionValueAttributeCountAggregateInputType | true
    }

  export interface DimensionValueAttributeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DimensionValueAttribute'], meta: { name: 'DimensionValueAttribute' } }
    /**
     * Find zero or one DimensionValueAttribute that matches the filter.
     * @param {DimensionValueAttributeFindUniqueArgs} args - Arguments to find a DimensionValueAttribute
     * @example
     * // Get one DimensionValueAttribute
     * const dimensionValueAttribute = await prisma.dimensionValueAttribute.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DimensionValueAttributeFindUniqueArgs>(args: SelectSubset<T, DimensionValueAttributeFindUniqueArgs<ExtArgs>>): Prisma__DimensionValueAttributeClient<$Result.GetResult<Prisma.$DimensionValueAttributePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one DimensionValueAttribute that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DimensionValueAttributeFindUniqueOrThrowArgs} args - Arguments to find a DimensionValueAttribute
     * @example
     * // Get one DimensionValueAttribute
     * const dimensionValueAttribute = await prisma.dimensionValueAttribute.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DimensionValueAttributeFindUniqueOrThrowArgs>(args: SelectSubset<T, DimensionValueAttributeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DimensionValueAttributeClient<$Result.GetResult<Prisma.$DimensionValueAttributePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first DimensionValueAttribute that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimensionValueAttributeFindFirstArgs} args - Arguments to find a DimensionValueAttribute
     * @example
     * // Get one DimensionValueAttribute
     * const dimensionValueAttribute = await prisma.dimensionValueAttribute.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DimensionValueAttributeFindFirstArgs>(args?: SelectSubset<T, DimensionValueAttributeFindFirstArgs<ExtArgs>>): Prisma__DimensionValueAttributeClient<$Result.GetResult<Prisma.$DimensionValueAttributePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first DimensionValueAttribute that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimensionValueAttributeFindFirstOrThrowArgs} args - Arguments to find a DimensionValueAttribute
     * @example
     * // Get one DimensionValueAttribute
     * const dimensionValueAttribute = await prisma.dimensionValueAttribute.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DimensionValueAttributeFindFirstOrThrowArgs>(args?: SelectSubset<T, DimensionValueAttributeFindFirstOrThrowArgs<ExtArgs>>): Prisma__DimensionValueAttributeClient<$Result.GetResult<Prisma.$DimensionValueAttributePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more DimensionValueAttributes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimensionValueAttributeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DimensionValueAttributes
     * const dimensionValueAttributes = await prisma.dimensionValueAttribute.findMany()
     * 
     * // Get first 10 DimensionValueAttributes
     * const dimensionValueAttributes = await prisma.dimensionValueAttribute.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dimensionValueAttributeWithIdOnly = await prisma.dimensionValueAttribute.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DimensionValueAttributeFindManyArgs>(args?: SelectSubset<T, DimensionValueAttributeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DimensionValueAttributePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a DimensionValueAttribute.
     * @param {DimensionValueAttributeCreateArgs} args - Arguments to create a DimensionValueAttribute.
     * @example
     * // Create one DimensionValueAttribute
     * const DimensionValueAttribute = await prisma.dimensionValueAttribute.create({
     *   data: {
     *     // ... data to create a DimensionValueAttribute
     *   }
     * })
     * 
     */
    create<T extends DimensionValueAttributeCreateArgs>(args: SelectSubset<T, DimensionValueAttributeCreateArgs<ExtArgs>>): Prisma__DimensionValueAttributeClient<$Result.GetResult<Prisma.$DimensionValueAttributePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many DimensionValueAttributes.
     * @param {DimensionValueAttributeCreateManyArgs} args - Arguments to create many DimensionValueAttributes.
     * @example
     * // Create many DimensionValueAttributes
     * const dimensionValueAttribute = await prisma.dimensionValueAttribute.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DimensionValueAttributeCreateManyArgs>(args?: SelectSubset<T, DimensionValueAttributeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DimensionValueAttribute.
     * @param {DimensionValueAttributeDeleteArgs} args - Arguments to delete one DimensionValueAttribute.
     * @example
     * // Delete one DimensionValueAttribute
     * const DimensionValueAttribute = await prisma.dimensionValueAttribute.delete({
     *   where: {
     *     // ... filter to delete one DimensionValueAttribute
     *   }
     * })
     * 
     */
    delete<T extends DimensionValueAttributeDeleteArgs>(args: SelectSubset<T, DimensionValueAttributeDeleteArgs<ExtArgs>>): Prisma__DimensionValueAttributeClient<$Result.GetResult<Prisma.$DimensionValueAttributePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one DimensionValueAttribute.
     * @param {DimensionValueAttributeUpdateArgs} args - Arguments to update one DimensionValueAttribute.
     * @example
     * // Update one DimensionValueAttribute
     * const dimensionValueAttribute = await prisma.dimensionValueAttribute.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DimensionValueAttributeUpdateArgs>(args: SelectSubset<T, DimensionValueAttributeUpdateArgs<ExtArgs>>): Prisma__DimensionValueAttributeClient<$Result.GetResult<Prisma.$DimensionValueAttributePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more DimensionValueAttributes.
     * @param {DimensionValueAttributeDeleteManyArgs} args - Arguments to filter DimensionValueAttributes to delete.
     * @example
     * // Delete a few DimensionValueAttributes
     * const { count } = await prisma.dimensionValueAttribute.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DimensionValueAttributeDeleteManyArgs>(args?: SelectSubset<T, DimensionValueAttributeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DimensionValueAttributes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimensionValueAttributeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DimensionValueAttributes
     * const dimensionValueAttribute = await prisma.dimensionValueAttribute.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DimensionValueAttributeUpdateManyArgs>(args: SelectSubset<T, DimensionValueAttributeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DimensionValueAttribute.
     * @param {DimensionValueAttributeUpsertArgs} args - Arguments to update or create a DimensionValueAttribute.
     * @example
     * // Update or create a DimensionValueAttribute
     * const dimensionValueAttribute = await prisma.dimensionValueAttribute.upsert({
     *   create: {
     *     // ... data to create a DimensionValueAttribute
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DimensionValueAttribute we want to update
     *   }
     * })
     */
    upsert<T extends DimensionValueAttributeUpsertArgs>(args: SelectSubset<T, DimensionValueAttributeUpsertArgs<ExtArgs>>): Prisma__DimensionValueAttributeClient<$Result.GetResult<Prisma.$DimensionValueAttributePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more DimensionValueAttributes that matches the filter.
     * @param {DimensionValueAttributeFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const dimensionValueAttribute = await prisma.dimensionValueAttribute.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: DimensionValueAttributeFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a DimensionValueAttribute.
     * @param {DimensionValueAttributeAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const dimensionValueAttribute = await prisma.dimensionValueAttribute.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: DimensionValueAttributeAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of DimensionValueAttributes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimensionValueAttributeCountArgs} args - Arguments to filter DimensionValueAttributes to count.
     * @example
     * // Count the number of DimensionValueAttributes
     * const count = await prisma.dimensionValueAttribute.count({
     *   where: {
     *     // ... the filter for the DimensionValueAttributes we want to count
     *   }
     * })
    **/
    count<T extends DimensionValueAttributeCountArgs>(
      args?: Subset<T, DimensionValueAttributeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DimensionValueAttributeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DimensionValueAttribute.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimensionValueAttributeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DimensionValueAttributeAggregateArgs>(args: Subset<T, DimensionValueAttributeAggregateArgs>): Prisma.PrismaPromise<GetDimensionValueAttributeAggregateType<T>>

    /**
     * Group by DimensionValueAttribute.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimensionValueAttributeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DimensionValueAttributeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DimensionValueAttributeGroupByArgs['orderBy'] }
        : { orderBy?: DimensionValueAttributeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DimensionValueAttributeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDimensionValueAttributeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DimensionValueAttribute model
   */
  readonly fields: DimensionValueAttributeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DimensionValueAttribute.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DimensionValueAttributeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    instance<T extends InstanceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InstanceDefaultArgs<ExtArgs>>): Prisma__InstanceClient<$Result.GetResult<Prisma.$InstancePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    AttributeValues<T extends DimensionValueAttribute$AttributeValuesArgs<ExtArgs> = {}>(args?: Subset<T, DimensionValueAttribute$AttributeValuesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DimensionValueAttributeValuePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    AttributeAndValues<T extends DimensionValueAttribute$AttributeAndValuesArgs<ExtArgs> = {}>(args?: Subset<T, DimensionValueAttribute$AttributeAndValuesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DimensionValueAttributeAndValuePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DimensionValueAttribute model
   */ 
  interface DimensionValueAttributeFieldRefs {
    readonly id: FieldRef<"DimensionValueAttribute", 'String'>
    readonly code: FieldRef<"DimensionValueAttribute", 'String'>
    readonly name: FieldRef<"DimensionValueAttribute", 'String'>
    readonly description: FieldRef<"DimensionValueAttribute", 'String'>
    readonly clientId: FieldRef<"DimensionValueAttribute", 'String'>
    readonly instanceId: FieldRef<"DimensionValueAttribute", 'String'>
    readonly updatedAt: FieldRef<"DimensionValueAttribute", 'DateTime'>
    readonly createdAt: FieldRef<"DimensionValueAttribute", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DimensionValueAttribute findUnique
   */
  export type DimensionValueAttributeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimensionValueAttribute
     */
    select?: DimensionValueAttributeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DimensionValueAttribute
     */
    omit?: DimensionValueAttributeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimensionValueAttributeInclude<ExtArgs> | null
    /**
     * Filter, which DimensionValueAttribute to fetch.
     */
    where: DimensionValueAttributeWhereUniqueInput
  }

  /**
   * DimensionValueAttribute findUniqueOrThrow
   */
  export type DimensionValueAttributeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimensionValueAttribute
     */
    select?: DimensionValueAttributeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DimensionValueAttribute
     */
    omit?: DimensionValueAttributeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimensionValueAttributeInclude<ExtArgs> | null
    /**
     * Filter, which DimensionValueAttribute to fetch.
     */
    where: DimensionValueAttributeWhereUniqueInput
  }

  /**
   * DimensionValueAttribute findFirst
   */
  export type DimensionValueAttributeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimensionValueAttribute
     */
    select?: DimensionValueAttributeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DimensionValueAttribute
     */
    omit?: DimensionValueAttributeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimensionValueAttributeInclude<ExtArgs> | null
    /**
     * Filter, which DimensionValueAttribute to fetch.
     */
    where?: DimensionValueAttributeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DimensionValueAttributes to fetch.
     */
    orderBy?: DimensionValueAttributeOrderByWithRelationInput | DimensionValueAttributeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DimensionValueAttributes.
     */
    cursor?: DimensionValueAttributeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DimensionValueAttributes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DimensionValueAttributes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DimensionValueAttributes.
     */
    distinct?: DimensionValueAttributeScalarFieldEnum | DimensionValueAttributeScalarFieldEnum[]
  }

  /**
   * DimensionValueAttribute findFirstOrThrow
   */
  export type DimensionValueAttributeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimensionValueAttribute
     */
    select?: DimensionValueAttributeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DimensionValueAttribute
     */
    omit?: DimensionValueAttributeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimensionValueAttributeInclude<ExtArgs> | null
    /**
     * Filter, which DimensionValueAttribute to fetch.
     */
    where?: DimensionValueAttributeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DimensionValueAttributes to fetch.
     */
    orderBy?: DimensionValueAttributeOrderByWithRelationInput | DimensionValueAttributeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DimensionValueAttributes.
     */
    cursor?: DimensionValueAttributeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DimensionValueAttributes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DimensionValueAttributes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DimensionValueAttributes.
     */
    distinct?: DimensionValueAttributeScalarFieldEnum | DimensionValueAttributeScalarFieldEnum[]
  }

  /**
   * DimensionValueAttribute findMany
   */
  export type DimensionValueAttributeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimensionValueAttribute
     */
    select?: DimensionValueAttributeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DimensionValueAttribute
     */
    omit?: DimensionValueAttributeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimensionValueAttributeInclude<ExtArgs> | null
    /**
     * Filter, which DimensionValueAttributes to fetch.
     */
    where?: DimensionValueAttributeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DimensionValueAttributes to fetch.
     */
    orderBy?: DimensionValueAttributeOrderByWithRelationInput | DimensionValueAttributeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DimensionValueAttributes.
     */
    cursor?: DimensionValueAttributeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DimensionValueAttributes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DimensionValueAttributes.
     */
    skip?: number
    distinct?: DimensionValueAttributeScalarFieldEnum | DimensionValueAttributeScalarFieldEnum[]
  }

  /**
   * DimensionValueAttribute create
   */
  export type DimensionValueAttributeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimensionValueAttribute
     */
    select?: DimensionValueAttributeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DimensionValueAttribute
     */
    omit?: DimensionValueAttributeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimensionValueAttributeInclude<ExtArgs> | null
    /**
     * The data needed to create a DimensionValueAttribute.
     */
    data: XOR<DimensionValueAttributeCreateInput, DimensionValueAttributeUncheckedCreateInput>
  }

  /**
   * DimensionValueAttribute createMany
   */
  export type DimensionValueAttributeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DimensionValueAttributes.
     */
    data: DimensionValueAttributeCreateManyInput | DimensionValueAttributeCreateManyInput[]
  }

  /**
   * DimensionValueAttribute update
   */
  export type DimensionValueAttributeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimensionValueAttribute
     */
    select?: DimensionValueAttributeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DimensionValueAttribute
     */
    omit?: DimensionValueAttributeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimensionValueAttributeInclude<ExtArgs> | null
    /**
     * The data needed to update a DimensionValueAttribute.
     */
    data: XOR<DimensionValueAttributeUpdateInput, DimensionValueAttributeUncheckedUpdateInput>
    /**
     * Choose, which DimensionValueAttribute to update.
     */
    where: DimensionValueAttributeWhereUniqueInput
  }

  /**
   * DimensionValueAttribute updateMany
   */
  export type DimensionValueAttributeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DimensionValueAttributes.
     */
    data: XOR<DimensionValueAttributeUpdateManyMutationInput, DimensionValueAttributeUncheckedUpdateManyInput>
    /**
     * Filter which DimensionValueAttributes to update
     */
    where?: DimensionValueAttributeWhereInput
    /**
     * Limit how many DimensionValueAttributes to update.
     */
    limit?: number
  }

  /**
   * DimensionValueAttribute upsert
   */
  export type DimensionValueAttributeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimensionValueAttribute
     */
    select?: DimensionValueAttributeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DimensionValueAttribute
     */
    omit?: DimensionValueAttributeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimensionValueAttributeInclude<ExtArgs> | null
    /**
     * The filter to search for the DimensionValueAttribute to update in case it exists.
     */
    where: DimensionValueAttributeWhereUniqueInput
    /**
     * In case the DimensionValueAttribute found by the `where` argument doesn't exist, create a new DimensionValueAttribute with this data.
     */
    create: XOR<DimensionValueAttributeCreateInput, DimensionValueAttributeUncheckedCreateInput>
    /**
     * In case the DimensionValueAttribute was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DimensionValueAttributeUpdateInput, DimensionValueAttributeUncheckedUpdateInput>
  }

  /**
   * DimensionValueAttribute delete
   */
  export type DimensionValueAttributeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimensionValueAttribute
     */
    select?: DimensionValueAttributeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DimensionValueAttribute
     */
    omit?: DimensionValueAttributeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimensionValueAttributeInclude<ExtArgs> | null
    /**
     * Filter which DimensionValueAttribute to delete.
     */
    where: DimensionValueAttributeWhereUniqueInput
  }

  /**
   * DimensionValueAttribute deleteMany
   */
  export type DimensionValueAttributeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DimensionValueAttributes to delete
     */
    where?: DimensionValueAttributeWhereInput
    /**
     * Limit how many DimensionValueAttributes to delete.
     */
    limit?: number
  }

  /**
   * DimensionValueAttribute findRaw
   */
  export type DimensionValueAttributeFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * DimensionValueAttribute aggregateRaw
   */
  export type DimensionValueAttributeAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * DimensionValueAttribute.AttributeValues
   */
  export type DimensionValueAttribute$AttributeValuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimensionValueAttributeValue
     */
    select?: DimensionValueAttributeValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DimensionValueAttributeValue
     */
    omit?: DimensionValueAttributeValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimensionValueAttributeValueInclude<ExtArgs> | null
    where?: DimensionValueAttributeValueWhereInput
    orderBy?: DimensionValueAttributeValueOrderByWithRelationInput | DimensionValueAttributeValueOrderByWithRelationInput[]
    cursor?: DimensionValueAttributeValueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DimensionValueAttributeValueScalarFieldEnum | DimensionValueAttributeValueScalarFieldEnum[]
  }

  /**
   * DimensionValueAttribute.AttributeAndValues
   */
  export type DimensionValueAttribute$AttributeAndValuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimensionValueAttributeAndValue
     */
    select?: DimensionValueAttributeAndValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DimensionValueAttributeAndValue
     */
    omit?: DimensionValueAttributeAndValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimensionValueAttributeAndValueInclude<ExtArgs> | null
    where?: DimensionValueAttributeAndValueWhereInput
    orderBy?: DimensionValueAttributeAndValueOrderByWithRelationInput | DimensionValueAttributeAndValueOrderByWithRelationInput[]
    cursor?: DimensionValueAttributeAndValueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DimensionValueAttributeAndValueScalarFieldEnum | DimensionValueAttributeAndValueScalarFieldEnum[]
  }

  /**
   * DimensionValueAttribute without action
   */
  export type DimensionValueAttributeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimensionValueAttribute
     */
    select?: DimensionValueAttributeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DimensionValueAttribute
     */
    omit?: DimensionValueAttributeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimensionValueAttributeInclude<ExtArgs> | null
  }


  /**
   * Model DimensionValueAttributeValue
   */

  export type AggregateDimensionValueAttributeValue = {
    _count: DimensionValueAttributeValueCountAggregateOutputType | null
    _min: DimensionValueAttributeValueMinAggregateOutputType | null
    _max: DimensionValueAttributeValueMaxAggregateOutputType | null
  }

  export type DimensionValueAttributeValueMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    attributeId: string | null
    clientId: string | null
    parentId: string | null
    instanceId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DimensionValueAttributeValueMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    attributeId: string | null
    clientId: string | null
    parentId: string | null
    instanceId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DimensionValueAttributeValueCountAggregateOutputType = {
    id: number
    code: number
    name: number
    attributeId: number
    clientId: number
    parentId: number
    instanceId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DimensionValueAttributeValueMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    attributeId?: true
    clientId?: true
    parentId?: true
    instanceId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DimensionValueAttributeValueMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    attributeId?: true
    clientId?: true
    parentId?: true
    instanceId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DimensionValueAttributeValueCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    attributeId?: true
    clientId?: true
    parentId?: true
    instanceId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DimensionValueAttributeValueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DimensionValueAttributeValue to aggregate.
     */
    where?: DimensionValueAttributeValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DimensionValueAttributeValues to fetch.
     */
    orderBy?: DimensionValueAttributeValueOrderByWithRelationInput | DimensionValueAttributeValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DimensionValueAttributeValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DimensionValueAttributeValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DimensionValueAttributeValues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DimensionValueAttributeValues
    **/
    _count?: true | DimensionValueAttributeValueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DimensionValueAttributeValueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DimensionValueAttributeValueMaxAggregateInputType
  }

  export type GetDimensionValueAttributeValueAggregateType<T extends DimensionValueAttributeValueAggregateArgs> = {
        [P in keyof T & keyof AggregateDimensionValueAttributeValue]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDimensionValueAttributeValue[P]>
      : GetScalarType<T[P], AggregateDimensionValueAttributeValue[P]>
  }




  export type DimensionValueAttributeValueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DimensionValueAttributeValueWhereInput
    orderBy?: DimensionValueAttributeValueOrderByWithAggregationInput | DimensionValueAttributeValueOrderByWithAggregationInput[]
    by: DimensionValueAttributeValueScalarFieldEnum[] | DimensionValueAttributeValueScalarFieldEnum
    having?: DimensionValueAttributeValueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DimensionValueAttributeValueCountAggregateInputType | true
    _min?: DimensionValueAttributeValueMinAggregateInputType
    _max?: DimensionValueAttributeValueMaxAggregateInputType
  }

  export type DimensionValueAttributeValueGroupByOutputType = {
    id: string
    code: string
    name: string
    attributeId: string
    clientId: string
    parentId: string | null
    instanceId: string
    createdAt: Date | null
    updatedAt: Date | null
    _count: DimensionValueAttributeValueCountAggregateOutputType | null
    _min: DimensionValueAttributeValueMinAggregateOutputType | null
    _max: DimensionValueAttributeValueMaxAggregateOutputType | null
  }

  type GetDimensionValueAttributeValueGroupByPayload<T extends DimensionValueAttributeValueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DimensionValueAttributeValueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DimensionValueAttributeValueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DimensionValueAttributeValueGroupByOutputType[P]>
            : GetScalarType<T[P], DimensionValueAttributeValueGroupByOutputType[P]>
        }
      >
    >


  export type DimensionValueAttributeValueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    attributeId?: boolean
    clientId?: boolean
    parentId?: boolean
    instanceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    instance?: boolean | InstanceDefaultArgs<ExtArgs>
    parent?: boolean | DimensionValueAttributeValue$parentArgs<ExtArgs>
    childAttributeValues?: boolean | DimensionValueAttributeValue$childAttributeValuesArgs<ExtArgs>
    dimensionValueAttribute?: boolean | DimensionValueAttributeDefaultArgs<ExtArgs>
    dimensionAttributeAndValues?: boolean | DimensionValueAttributeValue$dimensionAttributeAndValuesArgs<ExtArgs>
    _count?: boolean | DimensionValueAttributeValueCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dimensionValueAttributeValue"]>



  export type DimensionValueAttributeValueSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    attributeId?: boolean
    clientId?: boolean
    parentId?: boolean
    instanceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DimensionValueAttributeValueOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "name" | "attributeId" | "clientId" | "parentId" | "instanceId" | "createdAt" | "updatedAt", ExtArgs["result"]["dimensionValueAttributeValue"]>
  export type DimensionValueAttributeValueInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    instance?: boolean | InstanceDefaultArgs<ExtArgs>
    parent?: boolean | DimensionValueAttributeValue$parentArgs<ExtArgs>
    childAttributeValues?: boolean | DimensionValueAttributeValue$childAttributeValuesArgs<ExtArgs>
    dimensionValueAttribute?: boolean | DimensionValueAttributeDefaultArgs<ExtArgs>
    dimensionAttributeAndValues?: boolean | DimensionValueAttributeValue$dimensionAttributeAndValuesArgs<ExtArgs>
    _count?: boolean | DimensionValueAttributeValueCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $DimensionValueAttributeValuePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DimensionValueAttributeValue"
    objects: {
      instance: Prisma.$InstancePayload<ExtArgs>
      parent: Prisma.$DimensionValueAttributeValuePayload<ExtArgs> | null
      childAttributeValues: Prisma.$DimensionValueAttributeValuePayload<ExtArgs>[]
      dimensionValueAttribute: Prisma.$DimensionValueAttributePayload<ExtArgs>
      dimensionAttributeAndValues: Prisma.$DimensionValueAttributeAndValuePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      name: string
      attributeId: string
      clientId: string
      parentId: string | null
      instanceId: string
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["dimensionValueAttributeValue"]>
    composites: {}
  }

  type DimensionValueAttributeValueGetPayload<S extends boolean | null | undefined | DimensionValueAttributeValueDefaultArgs> = $Result.GetResult<Prisma.$DimensionValueAttributeValuePayload, S>

  type DimensionValueAttributeValueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DimensionValueAttributeValueFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DimensionValueAttributeValueCountAggregateInputType | true
    }

  export interface DimensionValueAttributeValueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DimensionValueAttributeValue'], meta: { name: 'DimensionValueAttributeValue' } }
    /**
     * Find zero or one DimensionValueAttributeValue that matches the filter.
     * @param {DimensionValueAttributeValueFindUniqueArgs} args - Arguments to find a DimensionValueAttributeValue
     * @example
     * // Get one DimensionValueAttributeValue
     * const dimensionValueAttributeValue = await prisma.dimensionValueAttributeValue.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DimensionValueAttributeValueFindUniqueArgs>(args: SelectSubset<T, DimensionValueAttributeValueFindUniqueArgs<ExtArgs>>): Prisma__DimensionValueAttributeValueClient<$Result.GetResult<Prisma.$DimensionValueAttributeValuePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one DimensionValueAttributeValue that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DimensionValueAttributeValueFindUniqueOrThrowArgs} args - Arguments to find a DimensionValueAttributeValue
     * @example
     * // Get one DimensionValueAttributeValue
     * const dimensionValueAttributeValue = await prisma.dimensionValueAttributeValue.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DimensionValueAttributeValueFindUniqueOrThrowArgs>(args: SelectSubset<T, DimensionValueAttributeValueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DimensionValueAttributeValueClient<$Result.GetResult<Prisma.$DimensionValueAttributeValuePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first DimensionValueAttributeValue that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimensionValueAttributeValueFindFirstArgs} args - Arguments to find a DimensionValueAttributeValue
     * @example
     * // Get one DimensionValueAttributeValue
     * const dimensionValueAttributeValue = await prisma.dimensionValueAttributeValue.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DimensionValueAttributeValueFindFirstArgs>(args?: SelectSubset<T, DimensionValueAttributeValueFindFirstArgs<ExtArgs>>): Prisma__DimensionValueAttributeValueClient<$Result.GetResult<Prisma.$DimensionValueAttributeValuePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first DimensionValueAttributeValue that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimensionValueAttributeValueFindFirstOrThrowArgs} args - Arguments to find a DimensionValueAttributeValue
     * @example
     * // Get one DimensionValueAttributeValue
     * const dimensionValueAttributeValue = await prisma.dimensionValueAttributeValue.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DimensionValueAttributeValueFindFirstOrThrowArgs>(args?: SelectSubset<T, DimensionValueAttributeValueFindFirstOrThrowArgs<ExtArgs>>): Prisma__DimensionValueAttributeValueClient<$Result.GetResult<Prisma.$DimensionValueAttributeValuePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more DimensionValueAttributeValues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimensionValueAttributeValueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DimensionValueAttributeValues
     * const dimensionValueAttributeValues = await prisma.dimensionValueAttributeValue.findMany()
     * 
     * // Get first 10 DimensionValueAttributeValues
     * const dimensionValueAttributeValues = await prisma.dimensionValueAttributeValue.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dimensionValueAttributeValueWithIdOnly = await prisma.dimensionValueAttributeValue.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DimensionValueAttributeValueFindManyArgs>(args?: SelectSubset<T, DimensionValueAttributeValueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DimensionValueAttributeValuePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a DimensionValueAttributeValue.
     * @param {DimensionValueAttributeValueCreateArgs} args - Arguments to create a DimensionValueAttributeValue.
     * @example
     * // Create one DimensionValueAttributeValue
     * const DimensionValueAttributeValue = await prisma.dimensionValueAttributeValue.create({
     *   data: {
     *     // ... data to create a DimensionValueAttributeValue
     *   }
     * })
     * 
     */
    create<T extends DimensionValueAttributeValueCreateArgs>(args: SelectSubset<T, DimensionValueAttributeValueCreateArgs<ExtArgs>>): Prisma__DimensionValueAttributeValueClient<$Result.GetResult<Prisma.$DimensionValueAttributeValuePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many DimensionValueAttributeValues.
     * @param {DimensionValueAttributeValueCreateManyArgs} args - Arguments to create many DimensionValueAttributeValues.
     * @example
     * // Create many DimensionValueAttributeValues
     * const dimensionValueAttributeValue = await prisma.dimensionValueAttributeValue.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DimensionValueAttributeValueCreateManyArgs>(args?: SelectSubset<T, DimensionValueAttributeValueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DimensionValueAttributeValue.
     * @param {DimensionValueAttributeValueDeleteArgs} args - Arguments to delete one DimensionValueAttributeValue.
     * @example
     * // Delete one DimensionValueAttributeValue
     * const DimensionValueAttributeValue = await prisma.dimensionValueAttributeValue.delete({
     *   where: {
     *     // ... filter to delete one DimensionValueAttributeValue
     *   }
     * })
     * 
     */
    delete<T extends DimensionValueAttributeValueDeleteArgs>(args: SelectSubset<T, DimensionValueAttributeValueDeleteArgs<ExtArgs>>): Prisma__DimensionValueAttributeValueClient<$Result.GetResult<Prisma.$DimensionValueAttributeValuePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one DimensionValueAttributeValue.
     * @param {DimensionValueAttributeValueUpdateArgs} args - Arguments to update one DimensionValueAttributeValue.
     * @example
     * // Update one DimensionValueAttributeValue
     * const dimensionValueAttributeValue = await prisma.dimensionValueAttributeValue.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DimensionValueAttributeValueUpdateArgs>(args: SelectSubset<T, DimensionValueAttributeValueUpdateArgs<ExtArgs>>): Prisma__DimensionValueAttributeValueClient<$Result.GetResult<Prisma.$DimensionValueAttributeValuePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more DimensionValueAttributeValues.
     * @param {DimensionValueAttributeValueDeleteManyArgs} args - Arguments to filter DimensionValueAttributeValues to delete.
     * @example
     * // Delete a few DimensionValueAttributeValues
     * const { count } = await prisma.dimensionValueAttributeValue.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DimensionValueAttributeValueDeleteManyArgs>(args?: SelectSubset<T, DimensionValueAttributeValueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DimensionValueAttributeValues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimensionValueAttributeValueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DimensionValueAttributeValues
     * const dimensionValueAttributeValue = await prisma.dimensionValueAttributeValue.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DimensionValueAttributeValueUpdateManyArgs>(args: SelectSubset<T, DimensionValueAttributeValueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DimensionValueAttributeValue.
     * @param {DimensionValueAttributeValueUpsertArgs} args - Arguments to update or create a DimensionValueAttributeValue.
     * @example
     * // Update or create a DimensionValueAttributeValue
     * const dimensionValueAttributeValue = await prisma.dimensionValueAttributeValue.upsert({
     *   create: {
     *     // ... data to create a DimensionValueAttributeValue
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DimensionValueAttributeValue we want to update
     *   }
     * })
     */
    upsert<T extends DimensionValueAttributeValueUpsertArgs>(args: SelectSubset<T, DimensionValueAttributeValueUpsertArgs<ExtArgs>>): Prisma__DimensionValueAttributeValueClient<$Result.GetResult<Prisma.$DimensionValueAttributeValuePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more DimensionValueAttributeValues that matches the filter.
     * @param {DimensionValueAttributeValueFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const dimensionValueAttributeValue = await prisma.dimensionValueAttributeValue.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: DimensionValueAttributeValueFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a DimensionValueAttributeValue.
     * @param {DimensionValueAttributeValueAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const dimensionValueAttributeValue = await prisma.dimensionValueAttributeValue.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: DimensionValueAttributeValueAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of DimensionValueAttributeValues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimensionValueAttributeValueCountArgs} args - Arguments to filter DimensionValueAttributeValues to count.
     * @example
     * // Count the number of DimensionValueAttributeValues
     * const count = await prisma.dimensionValueAttributeValue.count({
     *   where: {
     *     // ... the filter for the DimensionValueAttributeValues we want to count
     *   }
     * })
    **/
    count<T extends DimensionValueAttributeValueCountArgs>(
      args?: Subset<T, DimensionValueAttributeValueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DimensionValueAttributeValueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DimensionValueAttributeValue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimensionValueAttributeValueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DimensionValueAttributeValueAggregateArgs>(args: Subset<T, DimensionValueAttributeValueAggregateArgs>): Prisma.PrismaPromise<GetDimensionValueAttributeValueAggregateType<T>>

    /**
     * Group by DimensionValueAttributeValue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimensionValueAttributeValueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DimensionValueAttributeValueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DimensionValueAttributeValueGroupByArgs['orderBy'] }
        : { orderBy?: DimensionValueAttributeValueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DimensionValueAttributeValueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDimensionValueAttributeValueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DimensionValueAttributeValue model
   */
  readonly fields: DimensionValueAttributeValueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DimensionValueAttributeValue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DimensionValueAttributeValueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    instance<T extends InstanceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InstanceDefaultArgs<ExtArgs>>): Prisma__InstanceClient<$Result.GetResult<Prisma.$InstancePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    parent<T extends DimensionValueAttributeValue$parentArgs<ExtArgs> = {}>(args?: Subset<T, DimensionValueAttributeValue$parentArgs<ExtArgs>>): Prisma__DimensionValueAttributeValueClient<$Result.GetResult<Prisma.$DimensionValueAttributeValuePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    childAttributeValues<T extends DimensionValueAttributeValue$childAttributeValuesArgs<ExtArgs> = {}>(args?: Subset<T, DimensionValueAttributeValue$childAttributeValuesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DimensionValueAttributeValuePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    dimensionValueAttribute<T extends DimensionValueAttributeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DimensionValueAttributeDefaultArgs<ExtArgs>>): Prisma__DimensionValueAttributeClient<$Result.GetResult<Prisma.$DimensionValueAttributePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    dimensionAttributeAndValues<T extends DimensionValueAttributeValue$dimensionAttributeAndValuesArgs<ExtArgs> = {}>(args?: Subset<T, DimensionValueAttributeValue$dimensionAttributeAndValuesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DimensionValueAttributeAndValuePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DimensionValueAttributeValue model
   */ 
  interface DimensionValueAttributeValueFieldRefs {
    readonly id: FieldRef<"DimensionValueAttributeValue", 'String'>
    readonly code: FieldRef<"DimensionValueAttributeValue", 'String'>
    readonly name: FieldRef<"DimensionValueAttributeValue", 'String'>
    readonly attributeId: FieldRef<"DimensionValueAttributeValue", 'String'>
    readonly clientId: FieldRef<"DimensionValueAttributeValue", 'String'>
    readonly parentId: FieldRef<"DimensionValueAttributeValue", 'String'>
    readonly instanceId: FieldRef<"DimensionValueAttributeValue", 'String'>
    readonly createdAt: FieldRef<"DimensionValueAttributeValue", 'DateTime'>
    readonly updatedAt: FieldRef<"DimensionValueAttributeValue", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DimensionValueAttributeValue findUnique
   */
  export type DimensionValueAttributeValueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimensionValueAttributeValue
     */
    select?: DimensionValueAttributeValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DimensionValueAttributeValue
     */
    omit?: DimensionValueAttributeValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimensionValueAttributeValueInclude<ExtArgs> | null
    /**
     * Filter, which DimensionValueAttributeValue to fetch.
     */
    where: DimensionValueAttributeValueWhereUniqueInput
  }

  /**
   * DimensionValueAttributeValue findUniqueOrThrow
   */
  export type DimensionValueAttributeValueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimensionValueAttributeValue
     */
    select?: DimensionValueAttributeValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DimensionValueAttributeValue
     */
    omit?: DimensionValueAttributeValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimensionValueAttributeValueInclude<ExtArgs> | null
    /**
     * Filter, which DimensionValueAttributeValue to fetch.
     */
    where: DimensionValueAttributeValueWhereUniqueInput
  }

  /**
   * DimensionValueAttributeValue findFirst
   */
  export type DimensionValueAttributeValueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimensionValueAttributeValue
     */
    select?: DimensionValueAttributeValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DimensionValueAttributeValue
     */
    omit?: DimensionValueAttributeValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimensionValueAttributeValueInclude<ExtArgs> | null
    /**
     * Filter, which DimensionValueAttributeValue to fetch.
     */
    where?: DimensionValueAttributeValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DimensionValueAttributeValues to fetch.
     */
    orderBy?: DimensionValueAttributeValueOrderByWithRelationInput | DimensionValueAttributeValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DimensionValueAttributeValues.
     */
    cursor?: DimensionValueAttributeValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DimensionValueAttributeValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DimensionValueAttributeValues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DimensionValueAttributeValues.
     */
    distinct?: DimensionValueAttributeValueScalarFieldEnum | DimensionValueAttributeValueScalarFieldEnum[]
  }

  /**
   * DimensionValueAttributeValue findFirstOrThrow
   */
  export type DimensionValueAttributeValueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimensionValueAttributeValue
     */
    select?: DimensionValueAttributeValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DimensionValueAttributeValue
     */
    omit?: DimensionValueAttributeValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimensionValueAttributeValueInclude<ExtArgs> | null
    /**
     * Filter, which DimensionValueAttributeValue to fetch.
     */
    where?: DimensionValueAttributeValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DimensionValueAttributeValues to fetch.
     */
    orderBy?: DimensionValueAttributeValueOrderByWithRelationInput | DimensionValueAttributeValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DimensionValueAttributeValues.
     */
    cursor?: DimensionValueAttributeValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DimensionValueAttributeValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DimensionValueAttributeValues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DimensionValueAttributeValues.
     */
    distinct?: DimensionValueAttributeValueScalarFieldEnum | DimensionValueAttributeValueScalarFieldEnum[]
  }

  /**
   * DimensionValueAttributeValue findMany
   */
  export type DimensionValueAttributeValueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimensionValueAttributeValue
     */
    select?: DimensionValueAttributeValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DimensionValueAttributeValue
     */
    omit?: DimensionValueAttributeValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimensionValueAttributeValueInclude<ExtArgs> | null
    /**
     * Filter, which DimensionValueAttributeValues to fetch.
     */
    where?: DimensionValueAttributeValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DimensionValueAttributeValues to fetch.
     */
    orderBy?: DimensionValueAttributeValueOrderByWithRelationInput | DimensionValueAttributeValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DimensionValueAttributeValues.
     */
    cursor?: DimensionValueAttributeValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DimensionValueAttributeValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DimensionValueAttributeValues.
     */
    skip?: number
    distinct?: DimensionValueAttributeValueScalarFieldEnum | DimensionValueAttributeValueScalarFieldEnum[]
  }

  /**
   * DimensionValueAttributeValue create
   */
  export type DimensionValueAttributeValueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimensionValueAttributeValue
     */
    select?: DimensionValueAttributeValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DimensionValueAttributeValue
     */
    omit?: DimensionValueAttributeValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimensionValueAttributeValueInclude<ExtArgs> | null
    /**
     * The data needed to create a DimensionValueAttributeValue.
     */
    data: XOR<DimensionValueAttributeValueCreateInput, DimensionValueAttributeValueUncheckedCreateInput>
  }

  /**
   * DimensionValueAttributeValue createMany
   */
  export type DimensionValueAttributeValueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DimensionValueAttributeValues.
     */
    data: DimensionValueAttributeValueCreateManyInput | DimensionValueAttributeValueCreateManyInput[]
  }

  /**
   * DimensionValueAttributeValue update
   */
  export type DimensionValueAttributeValueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimensionValueAttributeValue
     */
    select?: DimensionValueAttributeValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DimensionValueAttributeValue
     */
    omit?: DimensionValueAttributeValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimensionValueAttributeValueInclude<ExtArgs> | null
    /**
     * The data needed to update a DimensionValueAttributeValue.
     */
    data: XOR<DimensionValueAttributeValueUpdateInput, DimensionValueAttributeValueUncheckedUpdateInput>
    /**
     * Choose, which DimensionValueAttributeValue to update.
     */
    where: DimensionValueAttributeValueWhereUniqueInput
  }

  /**
   * DimensionValueAttributeValue updateMany
   */
  export type DimensionValueAttributeValueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DimensionValueAttributeValues.
     */
    data: XOR<DimensionValueAttributeValueUpdateManyMutationInput, DimensionValueAttributeValueUncheckedUpdateManyInput>
    /**
     * Filter which DimensionValueAttributeValues to update
     */
    where?: DimensionValueAttributeValueWhereInput
    /**
     * Limit how many DimensionValueAttributeValues to update.
     */
    limit?: number
  }

  /**
   * DimensionValueAttributeValue upsert
   */
  export type DimensionValueAttributeValueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimensionValueAttributeValue
     */
    select?: DimensionValueAttributeValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DimensionValueAttributeValue
     */
    omit?: DimensionValueAttributeValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimensionValueAttributeValueInclude<ExtArgs> | null
    /**
     * The filter to search for the DimensionValueAttributeValue to update in case it exists.
     */
    where: DimensionValueAttributeValueWhereUniqueInput
    /**
     * In case the DimensionValueAttributeValue found by the `where` argument doesn't exist, create a new DimensionValueAttributeValue with this data.
     */
    create: XOR<DimensionValueAttributeValueCreateInput, DimensionValueAttributeValueUncheckedCreateInput>
    /**
     * In case the DimensionValueAttributeValue was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DimensionValueAttributeValueUpdateInput, DimensionValueAttributeValueUncheckedUpdateInput>
  }

  /**
   * DimensionValueAttributeValue delete
   */
  export type DimensionValueAttributeValueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimensionValueAttributeValue
     */
    select?: DimensionValueAttributeValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DimensionValueAttributeValue
     */
    omit?: DimensionValueAttributeValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimensionValueAttributeValueInclude<ExtArgs> | null
    /**
     * Filter which DimensionValueAttributeValue to delete.
     */
    where: DimensionValueAttributeValueWhereUniqueInput
  }

  /**
   * DimensionValueAttributeValue deleteMany
   */
  export type DimensionValueAttributeValueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DimensionValueAttributeValues to delete
     */
    where?: DimensionValueAttributeValueWhereInput
    /**
     * Limit how many DimensionValueAttributeValues to delete.
     */
    limit?: number
  }

  /**
   * DimensionValueAttributeValue findRaw
   */
  export type DimensionValueAttributeValueFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * DimensionValueAttributeValue aggregateRaw
   */
  export type DimensionValueAttributeValueAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * DimensionValueAttributeValue.parent
   */
  export type DimensionValueAttributeValue$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimensionValueAttributeValue
     */
    select?: DimensionValueAttributeValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DimensionValueAttributeValue
     */
    omit?: DimensionValueAttributeValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimensionValueAttributeValueInclude<ExtArgs> | null
    where?: DimensionValueAttributeValueWhereInput
  }

  /**
   * DimensionValueAttributeValue.childAttributeValues
   */
  export type DimensionValueAttributeValue$childAttributeValuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimensionValueAttributeValue
     */
    select?: DimensionValueAttributeValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DimensionValueAttributeValue
     */
    omit?: DimensionValueAttributeValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimensionValueAttributeValueInclude<ExtArgs> | null
    where?: DimensionValueAttributeValueWhereInput
    orderBy?: DimensionValueAttributeValueOrderByWithRelationInput | DimensionValueAttributeValueOrderByWithRelationInput[]
    cursor?: DimensionValueAttributeValueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DimensionValueAttributeValueScalarFieldEnum | DimensionValueAttributeValueScalarFieldEnum[]
  }

  /**
   * DimensionValueAttributeValue.dimensionAttributeAndValues
   */
  export type DimensionValueAttributeValue$dimensionAttributeAndValuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimensionValueAttributeAndValue
     */
    select?: DimensionValueAttributeAndValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DimensionValueAttributeAndValue
     */
    omit?: DimensionValueAttributeAndValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimensionValueAttributeAndValueInclude<ExtArgs> | null
    where?: DimensionValueAttributeAndValueWhereInput
    orderBy?: DimensionValueAttributeAndValueOrderByWithRelationInput | DimensionValueAttributeAndValueOrderByWithRelationInput[]
    cursor?: DimensionValueAttributeAndValueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DimensionValueAttributeAndValueScalarFieldEnum | DimensionValueAttributeAndValueScalarFieldEnum[]
  }

  /**
   * DimensionValueAttributeValue without action
   */
  export type DimensionValueAttributeValueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimensionValueAttributeValue
     */
    select?: DimensionValueAttributeValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DimensionValueAttributeValue
     */
    omit?: DimensionValueAttributeValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimensionValueAttributeValueInclude<ExtArgs> | null
  }


  /**
   * Model DimensionValueAttributeAndValue
   */

  export type AggregateDimensionValueAttributeAndValue = {
    _count: DimensionValueAttributeAndValueCountAggregateOutputType | null
    _min: DimensionValueAttributeAndValueMinAggregateOutputType | null
    _max: DimensionValueAttributeAndValueMaxAggregateOutputType | null
  }

  export type DimensionValueAttributeAndValueMinAggregateOutputType = {
    id: string | null
    clientId: string | null
    instanceId: string | null
    attributeId: string | null
    attributeValueId: string | null
    dimensionValueId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DimensionValueAttributeAndValueMaxAggregateOutputType = {
    id: string | null
    clientId: string | null
    instanceId: string | null
    attributeId: string | null
    attributeValueId: string | null
    dimensionValueId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DimensionValueAttributeAndValueCountAggregateOutputType = {
    id: number
    clientId: number
    instanceId: number
    attributeId: number
    attributeValueId: number
    dimensionValueId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DimensionValueAttributeAndValueMinAggregateInputType = {
    id?: true
    clientId?: true
    instanceId?: true
    attributeId?: true
    attributeValueId?: true
    dimensionValueId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DimensionValueAttributeAndValueMaxAggregateInputType = {
    id?: true
    clientId?: true
    instanceId?: true
    attributeId?: true
    attributeValueId?: true
    dimensionValueId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DimensionValueAttributeAndValueCountAggregateInputType = {
    id?: true
    clientId?: true
    instanceId?: true
    attributeId?: true
    attributeValueId?: true
    dimensionValueId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DimensionValueAttributeAndValueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DimensionValueAttributeAndValue to aggregate.
     */
    where?: DimensionValueAttributeAndValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DimensionValueAttributeAndValues to fetch.
     */
    orderBy?: DimensionValueAttributeAndValueOrderByWithRelationInput | DimensionValueAttributeAndValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DimensionValueAttributeAndValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DimensionValueAttributeAndValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DimensionValueAttributeAndValues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DimensionValueAttributeAndValues
    **/
    _count?: true | DimensionValueAttributeAndValueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DimensionValueAttributeAndValueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DimensionValueAttributeAndValueMaxAggregateInputType
  }

  export type GetDimensionValueAttributeAndValueAggregateType<T extends DimensionValueAttributeAndValueAggregateArgs> = {
        [P in keyof T & keyof AggregateDimensionValueAttributeAndValue]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDimensionValueAttributeAndValue[P]>
      : GetScalarType<T[P], AggregateDimensionValueAttributeAndValue[P]>
  }




  export type DimensionValueAttributeAndValueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DimensionValueAttributeAndValueWhereInput
    orderBy?: DimensionValueAttributeAndValueOrderByWithAggregationInput | DimensionValueAttributeAndValueOrderByWithAggregationInput[]
    by: DimensionValueAttributeAndValueScalarFieldEnum[] | DimensionValueAttributeAndValueScalarFieldEnum
    having?: DimensionValueAttributeAndValueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DimensionValueAttributeAndValueCountAggregateInputType | true
    _min?: DimensionValueAttributeAndValueMinAggregateInputType
    _max?: DimensionValueAttributeAndValueMaxAggregateInputType
  }

  export type DimensionValueAttributeAndValueGroupByOutputType = {
    id: string
    clientId: string
    instanceId: string
    attributeId: string
    attributeValueId: string
    dimensionValueId: string
    createdAt: Date | null
    updatedAt: Date | null
    _count: DimensionValueAttributeAndValueCountAggregateOutputType | null
    _min: DimensionValueAttributeAndValueMinAggregateOutputType | null
    _max: DimensionValueAttributeAndValueMaxAggregateOutputType | null
  }

  type GetDimensionValueAttributeAndValueGroupByPayload<T extends DimensionValueAttributeAndValueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DimensionValueAttributeAndValueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DimensionValueAttributeAndValueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DimensionValueAttributeAndValueGroupByOutputType[P]>
            : GetScalarType<T[P], DimensionValueAttributeAndValueGroupByOutputType[P]>
        }
      >
    >


  export type DimensionValueAttributeAndValueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    instanceId?: boolean
    attributeId?: boolean
    attributeValueId?: boolean
    dimensionValueId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    dimensionValue?: boolean | DimensionValueAttributeAndValue$dimensionValueArgs<ExtArgs>
    attribute?: boolean | DimensionValueAttributeAndValue$attributeArgs<ExtArgs>
    attributeValue?: boolean | DimensionValueAttributeAndValue$attributeValueArgs<ExtArgs>
  }, ExtArgs["result"]["dimensionValueAttributeAndValue"]>



  export type DimensionValueAttributeAndValueSelectScalar = {
    id?: boolean
    clientId?: boolean
    instanceId?: boolean
    attributeId?: boolean
    attributeValueId?: boolean
    dimensionValueId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DimensionValueAttributeAndValueOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "clientId" | "instanceId" | "attributeId" | "attributeValueId" | "dimensionValueId" | "createdAt" | "updatedAt", ExtArgs["result"]["dimensionValueAttributeAndValue"]>
  export type DimensionValueAttributeAndValueInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dimensionValue?: boolean | DimensionValueAttributeAndValue$dimensionValueArgs<ExtArgs>
    attribute?: boolean | DimensionValueAttributeAndValue$attributeArgs<ExtArgs>
    attributeValue?: boolean | DimensionValueAttributeAndValue$attributeValueArgs<ExtArgs>
  }

  export type $DimensionValueAttributeAndValuePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DimensionValueAttributeAndValue"
    objects: {
      dimensionValue: Prisma.$DimensionValuePayload<ExtArgs> | null
      attribute: Prisma.$DimensionValueAttributePayload<ExtArgs> | null
      attributeValue: Prisma.$DimensionValueAttributeValuePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clientId: string
      instanceId: string
      attributeId: string
      attributeValueId: string
      dimensionValueId: string
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["dimensionValueAttributeAndValue"]>
    composites: {}
  }

  type DimensionValueAttributeAndValueGetPayload<S extends boolean | null | undefined | DimensionValueAttributeAndValueDefaultArgs> = $Result.GetResult<Prisma.$DimensionValueAttributeAndValuePayload, S>

  type DimensionValueAttributeAndValueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DimensionValueAttributeAndValueFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DimensionValueAttributeAndValueCountAggregateInputType | true
    }

  export interface DimensionValueAttributeAndValueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DimensionValueAttributeAndValue'], meta: { name: 'DimensionValueAttributeAndValue' } }
    /**
     * Find zero or one DimensionValueAttributeAndValue that matches the filter.
     * @param {DimensionValueAttributeAndValueFindUniqueArgs} args - Arguments to find a DimensionValueAttributeAndValue
     * @example
     * // Get one DimensionValueAttributeAndValue
     * const dimensionValueAttributeAndValue = await prisma.dimensionValueAttributeAndValue.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DimensionValueAttributeAndValueFindUniqueArgs>(args: SelectSubset<T, DimensionValueAttributeAndValueFindUniqueArgs<ExtArgs>>): Prisma__DimensionValueAttributeAndValueClient<$Result.GetResult<Prisma.$DimensionValueAttributeAndValuePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one DimensionValueAttributeAndValue that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DimensionValueAttributeAndValueFindUniqueOrThrowArgs} args - Arguments to find a DimensionValueAttributeAndValue
     * @example
     * // Get one DimensionValueAttributeAndValue
     * const dimensionValueAttributeAndValue = await prisma.dimensionValueAttributeAndValue.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DimensionValueAttributeAndValueFindUniqueOrThrowArgs>(args: SelectSubset<T, DimensionValueAttributeAndValueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DimensionValueAttributeAndValueClient<$Result.GetResult<Prisma.$DimensionValueAttributeAndValuePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first DimensionValueAttributeAndValue that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimensionValueAttributeAndValueFindFirstArgs} args - Arguments to find a DimensionValueAttributeAndValue
     * @example
     * // Get one DimensionValueAttributeAndValue
     * const dimensionValueAttributeAndValue = await prisma.dimensionValueAttributeAndValue.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DimensionValueAttributeAndValueFindFirstArgs>(args?: SelectSubset<T, DimensionValueAttributeAndValueFindFirstArgs<ExtArgs>>): Prisma__DimensionValueAttributeAndValueClient<$Result.GetResult<Prisma.$DimensionValueAttributeAndValuePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first DimensionValueAttributeAndValue that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimensionValueAttributeAndValueFindFirstOrThrowArgs} args - Arguments to find a DimensionValueAttributeAndValue
     * @example
     * // Get one DimensionValueAttributeAndValue
     * const dimensionValueAttributeAndValue = await prisma.dimensionValueAttributeAndValue.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DimensionValueAttributeAndValueFindFirstOrThrowArgs>(args?: SelectSubset<T, DimensionValueAttributeAndValueFindFirstOrThrowArgs<ExtArgs>>): Prisma__DimensionValueAttributeAndValueClient<$Result.GetResult<Prisma.$DimensionValueAttributeAndValuePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more DimensionValueAttributeAndValues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimensionValueAttributeAndValueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DimensionValueAttributeAndValues
     * const dimensionValueAttributeAndValues = await prisma.dimensionValueAttributeAndValue.findMany()
     * 
     * // Get first 10 DimensionValueAttributeAndValues
     * const dimensionValueAttributeAndValues = await prisma.dimensionValueAttributeAndValue.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dimensionValueAttributeAndValueWithIdOnly = await prisma.dimensionValueAttributeAndValue.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DimensionValueAttributeAndValueFindManyArgs>(args?: SelectSubset<T, DimensionValueAttributeAndValueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DimensionValueAttributeAndValuePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a DimensionValueAttributeAndValue.
     * @param {DimensionValueAttributeAndValueCreateArgs} args - Arguments to create a DimensionValueAttributeAndValue.
     * @example
     * // Create one DimensionValueAttributeAndValue
     * const DimensionValueAttributeAndValue = await prisma.dimensionValueAttributeAndValue.create({
     *   data: {
     *     // ... data to create a DimensionValueAttributeAndValue
     *   }
     * })
     * 
     */
    create<T extends DimensionValueAttributeAndValueCreateArgs>(args: SelectSubset<T, DimensionValueAttributeAndValueCreateArgs<ExtArgs>>): Prisma__DimensionValueAttributeAndValueClient<$Result.GetResult<Prisma.$DimensionValueAttributeAndValuePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many DimensionValueAttributeAndValues.
     * @param {DimensionValueAttributeAndValueCreateManyArgs} args - Arguments to create many DimensionValueAttributeAndValues.
     * @example
     * // Create many DimensionValueAttributeAndValues
     * const dimensionValueAttributeAndValue = await prisma.dimensionValueAttributeAndValue.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DimensionValueAttributeAndValueCreateManyArgs>(args?: SelectSubset<T, DimensionValueAttributeAndValueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DimensionValueAttributeAndValue.
     * @param {DimensionValueAttributeAndValueDeleteArgs} args - Arguments to delete one DimensionValueAttributeAndValue.
     * @example
     * // Delete one DimensionValueAttributeAndValue
     * const DimensionValueAttributeAndValue = await prisma.dimensionValueAttributeAndValue.delete({
     *   where: {
     *     // ... filter to delete one DimensionValueAttributeAndValue
     *   }
     * })
     * 
     */
    delete<T extends DimensionValueAttributeAndValueDeleteArgs>(args: SelectSubset<T, DimensionValueAttributeAndValueDeleteArgs<ExtArgs>>): Prisma__DimensionValueAttributeAndValueClient<$Result.GetResult<Prisma.$DimensionValueAttributeAndValuePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one DimensionValueAttributeAndValue.
     * @param {DimensionValueAttributeAndValueUpdateArgs} args - Arguments to update one DimensionValueAttributeAndValue.
     * @example
     * // Update one DimensionValueAttributeAndValue
     * const dimensionValueAttributeAndValue = await prisma.dimensionValueAttributeAndValue.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DimensionValueAttributeAndValueUpdateArgs>(args: SelectSubset<T, DimensionValueAttributeAndValueUpdateArgs<ExtArgs>>): Prisma__DimensionValueAttributeAndValueClient<$Result.GetResult<Prisma.$DimensionValueAttributeAndValuePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more DimensionValueAttributeAndValues.
     * @param {DimensionValueAttributeAndValueDeleteManyArgs} args - Arguments to filter DimensionValueAttributeAndValues to delete.
     * @example
     * // Delete a few DimensionValueAttributeAndValues
     * const { count } = await prisma.dimensionValueAttributeAndValue.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DimensionValueAttributeAndValueDeleteManyArgs>(args?: SelectSubset<T, DimensionValueAttributeAndValueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DimensionValueAttributeAndValues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimensionValueAttributeAndValueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DimensionValueAttributeAndValues
     * const dimensionValueAttributeAndValue = await prisma.dimensionValueAttributeAndValue.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DimensionValueAttributeAndValueUpdateManyArgs>(args: SelectSubset<T, DimensionValueAttributeAndValueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DimensionValueAttributeAndValue.
     * @param {DimensionValueAttributeAndValueUpsertArgs} args - Arguments to update or create a DimensionValueAttributeAndValue.
     * @example
     * // Update or create a DimensionValueAttributeAndValue
     * const dimensionValueAttributeAndValue = await prisma.dimensionValueAttributeAndValue.upsert({
     *   create: {
     *     // ... data to create a DimensionValueAttributeAndValue
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DimensionValueAttributeAndValue we want to update
     *   }
     * })
     */
    upsert<T extends DimensionValueAttributeAndValueUpsertArgs>(args: SelectSubset<T, DimensionValueAttributeAndValueUpsertArgs<ExtArgs>>): Prisma__DimensionValueAttributeAndValueClient<$Result.GetResult<Prisma.$DimensionValueAttributeAndValuePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more DimensionValueAttributeAndValues that matches the filter.
     * @param {DimensionValueAttributeAndValueFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const dimensionValueAttributeAndValue = await prisma.dimensionValueAttributeAndValue.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: DimensionValueAttributeAndValueFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a DimensionValueAttributeAndValue.
     * @param {DimensionValueAttributeAndValueAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const dimensionValueAttributeAndValue = await prisma.dimensionValueAttributeAndValue.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: DimensionValueAttributeAndValueAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of DimensionValueAttributeAndValues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimensionValueAttributeAndValueCountArgs} args - Arguments to filter DimensionValueAttributeAndValues to count.
     * @example
     * // Count the number of DimensionValueAttributeAndValues
     * const count = await prisma.dimensionValueAttributeAndValue.count({
     *   where: {
     *     // ... the filter for the DimensionValueAttributeAndValues we want to count
     *   }
     * })
    **/
    count<T extends DimensionValueAttributeAndValueCountArgs>(
      args?: Subset<T, DimensionValueAttributeAndValueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DimensionValueAttributeAndValueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DimensionValueAttributeAndValue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimensionValueAttributeAndValueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DimensionValueAttributeAndValueAggregateArgs>(args: Subset<T, DimensionValueAttributeAndValueAggregateArgs>): Prisma.PrismaPromise<GetDimensionValueAttributeAndValueAggregateType<T>>

    /**
     * Group by DimensionValueAttributeAndValue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimensionValueAttributeAndValueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DimensionValueAttributeAndValueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DimensionValueAttributeAndValueGroupByArgs['orderBy'] }
        : { orderBy?: DimensionValueAttributeAndValueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DimensionValueAttributeAndValueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDimensionValueAttributeAndValueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DimensionValueAttributeAndValue model
   */
  readonly fields: DimensionValueAttributeAndValueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DimensionValueAttributeAndValue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DimensionValueAttributeAndValueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    dimensionValue<T extends DimensionValueAttributeAndValue$dimensionValueArgs<ExtArgs> = {}>(args?: Subset<T, DimensionValueAttributeAndValue$dimensionValueArgs<ExtArgs>>): Prisma__DimensionValueClient<$Result.GetResult<Prisma.$DimensionValuePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    attribute<T extends DimensionValueAttributeAndValue$attributeArgs<ExtArgs> = {}>(args?: Subset<T, DimensionValueAttributeAndValue$attributeArgs<ExtArgs>>): Prisma__DimensionValueAttributeClient<$Result.GetResult<Prisma.$DimensionValueAttributePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    attributeValue<T extends DimensionValueAttributeAndValue$attributeValueArgs<ExtArgs> = {}>(args?: Subset<T, DimensionValueAttributeAndValue$attributeValueArgs<ExtArgs>>): Prisma__DimensionValueAttributeValueClient<$Result.GetResult<Prisma.$DimensionValueAttributeValuePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DimensionValueAttributeAndValue model
   */ 
  interface DimensionValueAttributeAndValueFieldRefs {
    readonly id: FieldRef<"DimensionValueAttributeAndValue", 'String'>
    readonly clientId: FieldRef<"DimensionValueAttributeAndValue", 'String'>
    readonly instanceId: FieldRef<"DimensionValueAttributeAndValue", 'String'>
    readonly attributeId: FieldRef<"DimensionValueAttributeAndValue", 'String'>
    readonly attributeValueId: FieldRef<"DimensionValueAttributeAndValue", 'String'>
    readonly dimensionValueId: FieldRef<"DimensionValueAttributeAndValue", 'String'>
    readonly createdAt: FieldRef<"DimensionValueAttributeAndValue", 'DateTime'>
    readonly updatedAt: FieldRef<"DimensionValueAttributeAndValue", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DimensionValueAttributeAndValue findUnique
   */
  export type DimensionValueAttributeAndValueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimensionValueAttributeAndValue
     */
    select?: DimensionValueAttributeAndValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DimensionValueAttributeAndValue
     */
    omit?: DimensionValueAttributeAndValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimensionValueAttributeAndValueInclude<ExtArgs> | null
    /**
     * Filter, which DimensionValueAttributeAndValue to fetch.
     */
    where: DimensionValueAttributeAndValueWhereUniqueInput
  }

  /**
   * DimensionValueAttributeAndValue findUniqueOrThrow
   */
  export type DimensionValueAttributeAndValueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimensionValueAttributeAndValue
     */
    select?: DimensionValueAttributeAndValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DimensionValueAttributeAndValue
     */
    omit?: DimensionValueAttributeAndValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimensionValueAttributeAndValueInclude<ExtArgs> | null
    /**
     * Filter, which DimensionValueAttributeAndValue to fetch.
     */
    where: DimensionValueAttributeAndValueWhereUniqueInput
  }

  /**
   * DimensionValueAttributeAndValue findFirst
   */
  export type DimensionValueAttributeAndValueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimensionValueAttributeAndValue
     */
    select?: DimensionValueAttributeAndValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DimensionValueAttributeAndValue
     */
    omit?: DimensionValueAttributeAndValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimensionValueAttributeAndValueInclude<ExtArgs> | null
    /**
     * Filter, which DimensionValueAttributeAndValue to fetch.
     */
    where?: DimensionValueAttributeAndValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DimensionValueAttributeAndValues to fetch.
     */
    orderBy?: DimensionValueAttributeAndValueOrderByWithRelationInput | DimensionValueAttributeAndValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DimensionValueAttributeAndValues.
     */
    cursor?: DimensionValueAttributeAndValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DimensionValueAttributeAndValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DimensionValueAttributeAndValues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DimensionValueAttributeAndValues.
     */
    distinct?: DimensionValueAttributeAndValueScalarFieldEnum | DimensionValueAttributeAndValueScalarFieldEnum[]
  }

  /**
   * DimensionValueAttributeAndValue findFirstOrThrow
   */
  export type DimensionValueAttributeAndValueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimensionValueAttributeAndValue
     */
    select?: DimensionValueAttributeAndValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DimensionValueAttributeAndValue
     */
    omit?: DimensionValueAttributeAndValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimensionValueAttributeAndValueInclude<ExtArgs> | null
    /**
     * Filter, which DimensionValueAttributeAndValue to fetch.
     */
    where?: DimensionValueAttributeAndValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DimensionValueAttributeAndValues to fetch.
     */
    orderBy?: DimensionValueAttributeAndValueOrderByWithRelationInput | DimensionValueAttributeAndValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DimensionValueAttributeAndValues.
     */
    cursor?: DimensionValueAttributeAndValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DimensionValueAttributeAndValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DimensionValueAttributeAndValues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DimensionValueAttributeAndValues.
     */
    distinct?: DimensionValueAttributeAndValueScalarFieldEnum | DimensionValueAttributeAndValueScalarFieldEnum[]
  }

  /**
   * DimensionValueAttributeAndValue findMany
   */
  export type DimensionValueAttributeAndValueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimensionValueAttributeAndValue
     */
    select?: DimensionValueAttributeAndValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DimensionValueAttributeAndValue
     */
    omit?: DimensionValueAttributeAndValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimensionValueAttributeAndValueInclude<ExtArgs> | null
    /**
     * Filter, which DimensionValueAttributeAndValues to fetch.
     */
    where?: DimensionValueAttributeAndValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DimensionValueAttributeAndValues to fetch.
     */
    orderBy?: DimensionValueAttributeAndValueOrderByWithRelationInput | DimensionValueAttributeAndValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DimensionValueAttributeAndValues.
     */
    cursor?: DimensionValueAttributeAndValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DimensionValueAttributeAndValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DimensionValueAttributeAndValues.
     */
    skip?: number
    distinct?: DimensionValueAttributeAndValueScalarFieldEnum | DimensionValueAttributeAndValueScalarFieldEnum[]
  }

  /**
   * DimensionValueAttributeAndValue create
   */
  export type DimensionValueAttributeAndValueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimensionValueAttributeAndValue
     */
    select?: DimensionValueAttributeAndValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DimensionValueAttributeAndValue
     */
    omit?: DimensionValueAttributeAndValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimensionValueAttributeAndValueInclude<ExtArgs> | null
    /**
     * The data needed to create a DimensionValueAttributeAndValue.
     */
    data: XOR<DimensionValueAttributeAndValueCreateInput, DimensionValueAttributeAndValueUncheckedCreateInput>
  }

  /**
   * DimensionValueAttributeAndValue createMany
   */
  export type DimensionValueAttributeAndValueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DimensionValueAttributeAndValues.
     */
    data: DimensionValueAttributeAndValueCreateManyInput | DimensionValueAttributeAndValueCreateManyInput[]
  }

  /**
   * DimensionValueAttributeAndValue update
   */
  export type DimensionValueAttributeAndValueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimensionValueAttributeAndValue
     */
    select?: DimensionValueAttributeAndValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DimensionValueAttributeAndValue
     */
    omit?: DimensionValueAttributeAndValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimensionValueAttributeAndValueInclude<ExtArgs> | null
    /**
     * The data needed to update a DimensionValueAttributeAndValue.
     */
    data: XOR<DimensionValueAttributeAndValueUpdateInput, DimensionValueAttributeAndValueUncheckedUpdateInput>
    /**
     * Choose, which DimensionValueAttributeAndValue to update.
     */
    where: DimensionValueAttributeAndValueWhereUniqueInput
  }

  /**
   * DimensionValueAttributeAndValue updateMany
   */
  export type DimensionValueAttributeAndValueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DimensionValueAttributeAndValues.
     */
    data: XOR<DimensionValueAttributeAndValueUpdateManyMutationInput, DimensionValueAttributeAndValueUncheckedUpdateManyInput>
    /**
     * Filter which DimensionValueAttributeAndValues to update
     */
    where?: DimensionValueAttributeAndValueWhereInput
    /**
     * Limit how many DimensionValueAttributeAndValues to update.
     */
    limit?: number
  }

  /**
   * DimensionValueAttributeAndValue upsert
   */
  export type DimensionValueAttributeAndValueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimensionValueAttributeAndValue
     */
    select?: DimensionValueAttributeAndValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DimensionValueAttributeAndValue
     */
    omit?: DimensionValueAttributeAndValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimensionValueAttributeAndValueInclude<ExtArgs> | null
    /**
     * The filter to search for the DimensionValueAttributeAndValue to update in case it exists.
     */
    where: DimensionValueAttributeAndValueWhereUniqueInput
    /**
     * In case the DimensionValueAttributeAndValue found by the `where` argument doesn't exist, create a new DimensionValueAttributeAndValue with this data.
     */
    create: XOR<DimensionValueAttributeAndValueCreateInput, DimensionValueAttributeAndValueUncheckedCreateInput>
    /**
     * In case the DimensionValueAttributeAndValue was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DimensionValueAttributeAndValueUpdateInput, DimensionValueAttributeAndValueUncheckedUpdateInput>
  }

  /**
   * DimensionValueAttributeAndValue delete
   */
  export type DimensionValueAttributeAndValueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimensionValueAttributeAndValue
     */
    select?: DimensionValueAttributeAndValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DimensionValueAttributeAndValue
     */
    omit?: DimensionValueAttributeAndValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimensionValueAttributeAndValueInclude<ExtArgs> | null
    /**
     * Filter which DimensionValueAttributeAndValue to delete.
     */
    where: DimensionValueAttributeAndValueWhereUniqueInput
  }

  /**
   * DimensionValueAttributeAndValue deleteMany
   */
  export type DimensionValueAttributeAndValueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DimensionValueAttributeAndValues to delete
     */
    where?: DimensionValueAttributeAndValueWhereInput
    /**
     * Limit how many DimensionValueAttributeAndValues to delete.
     */
    limit?: number
  }

  /**
   * DimensionValueAttributeAndValue findRaw
   */
  export type DimensionValueAttributeAndValueFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * DimensionValueAttributeAndValue aggregateRaw
   */
  export type DimensionValueAttributeAndValueAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * DimensionValueAttributeAndValue.dimensionValue
   */
  export type DimensionValueAttributeAndValue$dimensionValueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimensionValue
     */
    select?: DimensionValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DimensionValue
     */
    omit?: DimensionValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimensionValueInclude<ExtArgs> | null
    where?: DimensionValueWhereInput
  }

  /**
   * DimensionValueAttributeAndValue.attribute
   */
  export type DimensionValueAttributeAndValue$attributeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimensionValueAttribute
     */
    select?: DimensionValueAttributeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DimensionValueAttribute
     */
    omit?: DimensionValueAttributeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimensionValueAttributeInclude<ExtArgs> | null
    where?: DimensionValueAttributeWhereInput
  }

  /**
   * DimensionValueAttributeAndValue.attributeValue
   */
  export type DimensionValueAttributeAndValue$attributeValueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimensionValueAttributeValue
     */
    select?: DimensionValueAttributeValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DimensionValueAttributeValue
     */
    omit?: DimensionValueAttributeValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimensionValueAttributeValueInclude<ExtArgs> | null
    where?: DimensionValueAttributeValueWhereInput
  }

  /**
   * DimensionValueAttributeAndValue without action
   */
  export type DimensionValueAttributeAndValueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimensionValueAttributeAndValue
     */
    select?: DimensionValueAttributeAndValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DimensionValueAttributeAndValue
     */
    omit?: DimensionValueAttributeAndValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimensionValueAttributeAndValueInclude<ExtArgs> | null
  }


  /**
   * Model Model
   */

  export type AggregateModel = {
    _count: ModelCountAggregateOutputType | null
    _min: ModelMinAggregateOutputType | null
    _max: ModelMaxAggregateOutputType | null
  }

  export type ModelMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    description: string | null
    status: $Enums.ModelStatus | null
    isDefault: boolean | null
    instanceId: string | null
    clientId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    rootAccountId: string | null
  }

  export type ModelMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    description: string | null
    status: $Enums.ModelStatus | null
    isDefault: boolean | null
    instanceId: string | null
    clientId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    rootAccountId: string | null
  }

  export type ModelCountAggregateOutputType = {
    id: number
    code: number
    name: number
    description: number
    dimensionality: number
    status: number
    isDefault: number
    instanceId: number
    clientId: number
    createdAt: number
    updatedAt: number
    rootAccountId: number
    _all: number
  }


  export type ModelMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    status?: true
    isDefault?: true
    instanceId?: true
    clientId?: true
    createdAt?: true
    updatedAt?: true
    rootAccountId?: true
  }

  export type ModelMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    status?: true
    isDefault?: true
    instanceId?: true
    clientId?: true
    createdAt?: true
    updatedAt?: true
    rootAccountId?: true
  }

  export type ModelCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    dimensionality?: true
    status?: true
    isDefault?: true
    instanceId?: true
    clientId?: true
    createdAt?: true
    updatedAt?: true
    rootAccountId?: true
    _all?: true
  }

  export type ModelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Model to aggregate.
     */
    where?: ModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Models to fetch.
     */
    orderBy?: ModelOrderByWithRelationInput | ModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Models from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Models.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Models
    **/
    _count?: true | ModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ModelMaxAggregateInputType
  }

  export type GetModelAggregateType<T extends ModelAggregateArgs> = {
        [P in keyof T & keyof AggregateModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateModel[P]>
      : GetScalarType<T[P], AggregateModel[P]>
  }




  export type ModelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModelWhereInput
    orderBy?: ModelOrderByWithAggregationInput | ModelOrderByWithAggregationInput[]
    by: ModelScalarFieldEnum[] | ModelScalarFieldEnum
    having?: ModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ModelCountAggregateInputType | true
    _min?: ModelMinAggregateInputType
    _max?: ModelMaxAggregateInputType
  }

  export type ModelGroupByOutputType = {
    id: string
    code: string
    name: string
    description: string | null
    dimensionality: string[]
    status: $Enums.ModelStatus
    isDefault: boolean
    instanceId: string
    clientId: string
    createdAt: Date | null
    updatedAt: Date | null
    rootAccountId: string
    _count: ModelCountAggregateOutputType | null
    _min: ModelMinAggregateOutputType | null
    _max: ModelMaxAggregateOutputType | null
  }

  type GetModelGroupByPayload<T extends ModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ModelGroupByOutputType[P]>
            : GetScalarType<T[P], ModelGroupByOutputType[P]>
        }
      >
    >


  export type ModelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    dimensionality?: boolean
    status?: boolean
    isDefault?: boolean
    instanceId?: boolean
    clientId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    rootAccountId?: boolean
    instance?: boolean | InstanceDefaultArgs<ExtArgs>
    modelData?: boolean | Model$modelDataArgs<ExtArgs>
    modelAccounts?: boolean | Model$modelAccountsArgs<ExtArgs>
    modelDataCalculations?: boolean | Model$modelDataCalculationsArgs<ExtArgs>
    _count?: boolean | ModelCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["model"]>



  export type ModelSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    dimensionality?: boolean
    status?: boolean
    isDefault?: boolean
    instanceId?: boolean
    clientId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    rootAccountId?: boolean
  }

  export type ModelOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "name" | "description" | "dimensionality" | "status" | "isDefault" | "instanceId" | "clientId" | "createdAt" | "updatedAt" | "rootAccountId", ExtArgs["result"]["model"]>
  export type ModelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    instance?: boolean | InstanceDefaultArgs<ExtArgs>
    modelData?: boolean | Model$modelDataArgs<ExtArgs>
    modelAccounts?: boolean | Model$modelAccountsArgs<ExtArgs>
    modelDataCalculations?: boolean | Model$modelDataCalculationsArgs<ExtArgs>
    _count?: boolean | ModelCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ModelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Model"
    objects: {
      instance: Prisma.$InstancePayload<ExtArgs>
      modelData: Prisma.$ModelDataPayload<ExtArgs>[]
      modelAccounts: Prisma.$ModelAccountStructurePayload<ExtArgs>[]
      modelDataCalculations: Prisma.$ModelDataCalculationsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      name: string
      description: string | null
      dimensionality: string[]
      status: $Enums.ModelStatus
      isDefault: boolean
      instanceId: string
      clientId: string
      createdAt: Date | null
      updatedAt: Date | null
      rootAccountId: string
    }, ExtArgs["result"]["model"]>
    composites: {}
  }

  type ModelGetPayload<S extends boolean | null | undefined | ModelDefaultArgs> = $Result.GetResult<Prisma.$ModelPayload, S>

  type ModelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ModelFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ModelCountAggregateInputType | true
    }

  export interface ModelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Model'], meta: { name: 'Model' } }
    /**
     * Find zero or one Model that matches the filter.
     * @param {ModelFindUniqueArgs} args - Arguments to find a Model
     * @example
     * // Get one Model
     * const model = await prisma.model.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ModelFindUniqueArgs>(args: SelectSubset<T, ModelFindUniqueArgs<ExtArgs>>): Prisma__ModelClient<$Result.GetResult<Prisma.$ModelPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Model that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ModelFindUniqueOrThrowArgs} args - Arguments to find a Model
     * @example
     * // Get one Model
     * const model = await prisma.model.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ModelFindUniqueOrThrowArgs>(args: SelectSubset<T, ModelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ModelClient<$Result.GetResult<Prisma.$ModelPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Model that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelFindFirstArgs} args - Arguments to find a Model
     * @example
     * // Get one Model
     * const model = await prisma.model.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ModelFindFirstArgs>(args?: SelectSubset<T, ModelFindFirstArgs<ExtArgs>>): Prisma__ModelClient<$Result.GetResult<Prisma.$ModelPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Model that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelFindFirstOrThrowArgs} args - Arguments to find a Model
     * @example
     * // Get one Model
     * const model = await prisma.model.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ModelFindFirstOrThrowArgs>(args?: SelectSubset<T, ModelFindFirstOrThrowArgs<ExtArgs>>): Prisma__ModelClient<$Result.GetResult<Prisma.$ModelPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Models that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Models
     * const models = await prisma.model.findMany()
     * 
     * // Get first 10 Models
     * const models = await prisma.model.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const modelWithIdOnly = await prisma.model.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ModelFindManyArgs>(args?: SelectSubset<T, ModelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModelPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Model.
     * @param {ModelCreateArgs} args - Arguments to create a Model.
     * @example
     * // Create one Model
     * const Model = await prisma.model.create({
     *   data: {
     *     // ... data to create a Model
     *   }
     * })
     * 
     */
    create<T extends ModelCreateArgs>(args: SelectSubset<T, ModelCreateArgs<ExtArgs>>): Prisma__ModelClient<$Result.GetResult<Prisma.$ModelPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Models.
     * @param {ModelCreateManyArgs} args - Arguments to create many Models.
     * @example
     * // Create many Models
     * const model = await prisma.model.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ModelCreateManyArgs>(args?: SelectSubset<T, ModelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Model.
     * @param {ModelDeleteArgs} args - Arguments to delete one Model.
     * @example
     * // Delete one Model
     * const Model = await prisma.model.delete({
     *   where: {
     *     // ... filter to delete one Model
     *   }
     * })
     * 
     */
    delete<T extends ModelDeleteArgs>(args: SelectSubset<T, ModelDeleteArgs<ExtArgs>>): Prisma__ModelClient<$Result.GetResult<Prisma.$ModelPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Model.
     * @param {ModelUpdateArgs} args - Arguments to update one Model.
     * @example
     * // Update one Model
     * const model = await prisma.model.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ModelUpdateArgs>(args: SelectSubset<T, ModelUpdateArgs<ExtArgs>>): Prisma__ModelClient<$Result.GetResult<Prisma.$ModelPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Models.
     * @param {ModelDeleteManyArgs} args - Arguments to filter Models to delete.
     * @example
     * // Delete a few Models
     * const { count } = await prisma.model.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ModelDeleteManyArgs>(args?: SelectSubset<T, ModelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Models.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Models
     * const model = await prisma.model.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ModelUpdateManyArgs>(args: SelectSubset<T, ModelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Model.
     * @param {ModelUpsertArgs} args - Arguments to update or create a Model.
     * @example
     * // Update or create a Model
     * const model = await prisma.model.upsert({
     *   create: {
     *     // ... data to create a Model
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Model we want to update
     *   }
     * })
     */
    upsert<T extends ModelUpsertArgs>(args: SelectSubset<T, ModelUpsertArgs<ExtArgs>>): Prisma__ModelClient<$Result.GetResult<Prisma.$ModelPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Models that matches the filter.
     * @param {ModelFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const model = await prisma.model.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: ModelFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Model.
     * @param {ModelAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const model = await prisma.model.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ModelAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Models.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelCountArgs} args - Arguments to filter Models to count.
     * @example
     * // Count the number of Models
     * const count = await prisma.model.count({
     *   where: {
     *     // ... the filter for the Models we want to count
     *   }
     * })
    **/
    count<T extends ModelCountArgs>(
      args?: Subset<T, ModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Model.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ModelAggregateArgs>(args: Subset<T, ModelAggregateArgs>): Prisma.PrismaPromise<GetModelAggregateType<T>>

    /**
     * Group by Model.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ModelGroupByArgs['orderBy'] }
        : { orderBy?: ModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Model model
   */
  readonly fields: ModelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Model.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ModelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    instance<T extends InstanceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InstanceDefaultArgs<ExtArgs>>): Prisma__InstanceClient<$Result.GetResult<Prisma.$InstancePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    modelData<T extends Model$modelDataArgs<ExtArgs> = {}>(args?: Subset<T, Model$modelDataArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModelDataPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    modelAccounts<T extends Model$modelAccountsArgs<ExtArgs> = {}>(args?: Subset<T, Model$modelAccountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModelAccountStructurePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    modelDataCalculations<T extends Model$modelDataCalculationsArgs<ExtArgs> = {}>(args?: Subset<T, Model$modelDataCalculationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModelDataCalculationsPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Model model
   */ 
  interface ModelFieldRefs {
    readonly id: FieldRef<"Model", 'String'>
    readonly code: FieldRef<"Model", 'String'>
    readonly name: FieldRef<"Model", 'String'>
    readonly description: FieldRef<"Model", 'String'>
    readonly dimensionality: FieldRef<"Model", 'String[]'>
    readonly status: FieldRef<"Model", 'ModelStatus'>
    readonly isDefault: FieldRef<"Model", 'Boolean'>
    readonly instanceId: FieldRef<"Model", 'String'>
    readonly clientId: FieldRef<"Model", 'String'>
    readonly createdAt: FieldRef<"Model", 'DateTime'>
    readonly updatedAt: FieldRef<"Model", 'DateTime'>
    readonly rootAccountId: FieldRef<"Model", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Model findUnique
   */
  export type ModelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Model
     */
    select?: ModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Model
     */
    omit?: ModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelInclude<ExtArgs> | null
    /**
     * Filter, which Model to fetch.
     */
    where: ModelWhereUniqueInput
  }

  /**
   * Model findUniqueOrThrow
   */
  export type ModelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Model
     */
    select?: ModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Model
     */
    omit?: ModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelInclude<ExtArgs> | null
    /**
     * Filter, which Model to fetch.
     */
    where: ModelWhereUniqueInput
  }

  /**
   * Model findFirst
   */
  export type ModelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Model
     */
    select?: ModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Model
     */
    omit?: ModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelInclude<ExtArgs> | null
    /**
     * Filter, which Model to fetch.
     */
    where?: ModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Models to fetch.
     */
    orderBy?: ModelOrderByWithRelationInput | ModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Models.
     */
    cursor?: ModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Models from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Models.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Models.
     */
    distinct?: ModelScalarFieldEnum | ModelScalarFieldEnum[]
  }

  /**
   * Model findFirstOrThrow
   */
  export type ModelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Model
     */
    select?: ModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Model
     */
    omit?: ModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelInclude<ExtArgs> | null
    /**
     * Filter, which Model to fetch.
     */
    where?: ModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Models to fetch.
     */
    orderBy?: ModelOrderByWithRelationInput | ModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Models.
     */
    cursor?: ModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Models from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Models.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Models.
     */
    distinct?: ModelScalarFieldEnum | ModelScalarFieldEnum[]
  }

  /**
   * Model findMany
   */
  export type ModelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Model
     */
    select?: ModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Model
     */
    omit?: ModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelInclude<ExtArgs> | null
    /**
     * Filter, which Models to fetch.
     */
    where?: ModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Models to fetch.
     */
    orderBy?: ModelOrderByWithRelationInput | ModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Models.
     */
    cursor?: ModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Models from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Models.
     */
    skip?: number
    distinct?: ModelScalarFieldEnum | ModelScalarFieldEnum[]
  }

  /**
   * Model create
   */
  export type ModelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Model
     */
    select?: ModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Model
     */
    omit?: ModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelInclude<ExtArgs> | null
    /**
     * The data needed to create a Model.
     */
    data: XOR<ModelCreateInput, ModelUncheckedCreateInput>
  }

  /**
   * Model createMany
   */
  export type ModelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Models.
     */
    data: ModelCreateManyInput | ModelCreateManyInput[]
  }

  /**
   * Model update
   */
  export type ModelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Model
     */
    select?: ModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Model
     */
    omit?: ModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelInclude<ExtArgs> | null
    /**
     * The data needed to update a Model.
     */
    data: XOR<ModelUpdateInput, ModelUncheckedUpdateInput>
    /**
     * Choose, which Model to update.
     */
    where: ModelWhereUniqueInput
  }

  /**
   * Model updateMany
   */
  export type ModelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Models.
     */
    data: XOR<ModelUpdateManyMutationInput, ModelUncheckedUpdateManyInput>
    /**
     * Filter which Models to update
     */
    where?: ModelWhereInput
    /**
     * Limit how many Models to update.
     */
    limit?: number
  }

  /**
   * Model upsert
   */
  export type ModelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Model
     */
    select?: ModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Model
     */
    omit?: ModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelInclude<ExtArgs> | null
    /**
     * The filter to search for the Model to update in case it exists.
     */
    where: ModelWhereUniqueInput
    /**
     * In case the Model found by the `where` argument doesn't exist, create a new Model with this data.
     */
    create: XOR<ModelCreateInput, ModelUncheckedCreateInput>
    /**
     * In case the Model was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ModelUpdateInput, ModelUncheckedUpdateInput>
  }

  /**
   * Model delete
   */
  export type ModelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Model
     */
    select?: ModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Model
     */
    omit?: ModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelInclude<ExtArgs> | null
    /**
     * Filter which Model to delete.
     */
    where: ModelWhereUniqueInput
  }

  /**
   * Model deleteMany
   */
  export type ModelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Models to delete
     */
    where?: ModelWhereInput
    /**
     * Limit how many Models to delete.
     */
    limit?: number
  }

  /**
   * Model findRaw
   */
  export type ModelFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Model aggregateRaw
   */
  export type ModelAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Model.modelData
   */
  export type Model$modelDataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelData
     */
    select?: ModelDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelData
     */
    omit?: ModelDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelDataInclude<ExtArgs> | null
    where?: ModelDataWhereInput
    orderBy?: ModelDataOrderByWithRelationInput | ModelDataOrderByWithRelationInput[]
    cursor?: ModelDataWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ModelDataScalarFieldEnum | ModelDataScalarFieldEnum[]
  }

  /**
   * Model.modelAccounts
   */
  export type Model$modelAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelAccountStructure
     */
    select?: ModelAccountStructureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelAccountStructure
     */
    omit?: ModelAccountStructureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelAccountStructureInclude<ExtArgs> | null
    where?: ModelAccountStructureWhereInput
    orderBy?: ModelAccountStructureOrderByWithRelationInput | ModelAccountStructureOrderByWithRelationInput[]
    cursor?: ModelAccountStructureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ModelAccountStructureScalarFieldEnum | ModelAccountStructureScalarFieldEnum[]
  }

  /**
   * Model.modelDataCalculations
   */
  export type Model$modelDataCalculationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelDataCalculations
     */
    select?: ModelDataCalculationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelDataCalculations
     */
    omit?: ModelDataCalculationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelDataCalculationsInclude<ExtArgs> | null
    where?: ModelDataCalculationsWhereInput
    orderBy?: ModelDataCalculationsOrderByWithRelationInput | ModelDataCalculationsOrderByWithRelationInput[]
    cursor?: ModelDataCalculationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ModelDataCalculationsScalarFieldEnum | ModelDataCalculationsScalarFieldEnum[]
  }

  /**
   * Model without action
   */
  export type ModelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Model
     */
    select?: ModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Model
     */
    omit?: ModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelInclude<ExtArgs> | null
  }


  /**
   * Model ModelAccountStructure
   */

  export type AggregateModelAccountStructure = {
    _count: ModelAccountStructureCountAggregateOutputType | null
    _min: ModelAccountStructureMinAggregateOutputType | null
    _max: ModelAccountStructureMaxAggregateOutputType | null
  }

  export type ModelAccountStructureMinAggregateOutputType = {
    id: string | null
    instanceId: string | null
    isRoot: boolean | null
    clientId: string | null
    parentId: string | null
    modelId: string | null
    accountId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ModelAccountStructureMaxAggregateOutputType = {
    id: string | null
    instanceId: string | null
    isRoot: boolean | null
    clientId: string | null
    parentId: string | null
    modelId: string | null
    accountId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ModelAccountStructureCountAggregateOutputType = {
    id: number
    instanceId: number
    isRoot: number
    clientId: number
    parentId: number
    modelId: number
    accountId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ModelAccountStructureMinAggregateInputType = {
    id?: true
    instanceId?: true
    isRoot?: true
    clientId?: true
    parentId?: true
    modelId?: true
    accountId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ModelAccountStructureMaxAggregateInputType = {
    id?: true
    instanceId?: true
    isRoot?: true
    clientId?: true
    parentId?: true
    modelId?: true
    accountId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ModelAccountStructureCountAggregateInputType = {
    id?: true
    instanceId?: true
    isRoot?: true
    clientId?: true
    parentId?: true
    modelId?: true
    accountId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ModelAccountStructureAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ModelAccountStructure to aggregate.
     */
    where?: ModelAccountStructureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModelAccountStructures to fetch.
     */
    orderBy?: ModelAccountStructureOrderByWithRelationInput | ModelAccountStructureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ModelAccountStructureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModelAccountStructures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModelAccountStructures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ModelAccountStructures
    **/
    _count?: true | ModelAccountStructureCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ModelAccountStructureMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ModelAccountStructureMaxAggregateInputType
  }

  export type GetModelAccountStructureAggregateType<T extends ModelAccountStructureAggregateArgs> = {
        [P in keyof T & keyof AggregateModelAccountStructure]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateModelAccountStructure[P]>
      : GetScalarType<T[P], AggregateModelAccountStructure[P]>
  }




  export type ModelAccountStructureGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModelAccountStructureWhereInput
    orderBy?: ModelAccountStructureOrderByWithAggregationInput | ModelAccountStructureOrderByWithAggregationInput[]
    by: ModelAccountStructureScalarFieldEnum[] | ModelAccountStructureScalarFieldEnum
    having?: ModelAccountStructureScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ModelAccountStructureCountAggregateInputType | true
    _min?: ModelAccountStructureMinAggregateInputType
    _max?: ModelAccountStructureMaxAggregateInputType
  }

  export type ModelAccountStructureGroupByOutputType = {
    id: string
    instanceId: string
    isRoot: boolean
    clientId: string
    parentId: string | null
    modelId: string
    accountId: string
    createdAt: Date | null
    updatedAt: Date | null
    _count: ModelAccountStructureCountAggregateOutputType | null
    _min: ModelAccountStructureMinAggregateOutputType | null
    _max: ModelAccountStructureMaxAggregateOutputType | null
  }

  type GetModelAccountStructureGroupByPayload<T extends ModelAccountStructureGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ModelAccountStructureGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ModelAccountStructureGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ModelAccountStructureGroupByOutputType[P]>
            : GetScalarType<T[P], ModelAccountStructureGroupByOutputType[P]>
        }
      >
    >


  export type ModelAccountStructureSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    instanceId?: boolean
    isRoot?: boolean
    clientId?: boolean
    parentId?: boolean
    modelId?: boolean
    accountId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    instance?: boolean | InstanceDefaultArgs<ExtArgs>
    model?: boolean | ModelDefaultArgs<ExtArgs>
    account?: boolean | AccountDefaultArgs<ExtArgs>
    modeldataCalculations?: boolean | ModelAccountStructure$modeldataCalculationsArgs<ExtArgs>
    parentAccount?: boolean | ModelAccountStructure$parentAccountArgs<ExtArgs>
    childAccounts?: boolean | ModelAccountStructure$childAccountsArgs<ExtArgs>
    _count?: boolean | ModelAccountStructureCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["modelAccountStructure"]>



  export type ModelAccountStructureSelectScalar = {
    id?: boolean
    instanceId?: boolean
    isRoot?: boolean
    clientId?: boolean
    parentId?: boolean
    modelId?: boolean
    accountId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ModelAccountStructureOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "instanceId" | "isRoot" | "clientId" | "parentId" | "modelId" | "accountId" | "createdAt" | "updatedAt", ExtArgs["result"]["modelAccountStructure"]>
  export type ModelAccountStructureInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    instance?: boolean | InstanceDefaultArgs<ExtArgs>
    model?: boolean | ModelDefaultArgs<ExtArgs>
    account?: boolean | AccountDefaultArgs<ExtArgs>
    modeldataCalculations?: boolean | ModelAccountStructure$modeldataCalculationsArgs<ExtArgs>
    parentAccount?: boolean | ModelAccountStructure$parentAccountArgs<ExtArgs>
    childAccounts?: boolean | ModelAccountStructure$childAccountsArgs<ExtArgs>
    _count?: boolean | ModelAccountStructureCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ModelAccountStructurePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ModelAccountStructure"
    objects: {
      instance: Prisma.$InstancePayload<ExtArgs>
      model: Prisma.$ModelPayload<ExtArgs>
      account: Prisma.$AccountPayload<ExtArgs>
      modeldataCalculations: Prisma.$ModelDataCalculationsPayload<ExtArgs>[]
      parentAccount: Prisma.$ModelAccountStructurePayload<ExtArgs> | null
      childAccounts: Prisma.$ModelAccountStructurePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      instanceId: string
      isRoot: boolean
      clientId: string
      parentId: string | null
      modelId: string
      accountId: string
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["modelAccountStructure"]>
    composites: {}
  }

  type ModelAccountStructureGetPayload<S extends boolean | null | undefined | ModelAccountStructureDefaultArgs> = $Result.GetResult<Prisma.$ModelAccountStructurePayload, S>

  type ModelAccountStructureCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ModelAccountStructureFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ModelAccountStructureCountAggregateInputType | true
    }

  export interface ModelAccountStructureDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ModelAccountStructure'], meta: { name: 'ModelAccountStructure' } }
    /**
     * Find zero or one ModelAccountStructure that matches the filter.
     * @param {ModelAccountStructureFindUniqueArgs} args - Arguments to find a ModelAccountStructure
     * @example
     * // Get one ModelAccountStructure
     * const modelAccountStructure = await prisma.modelAccountStructure.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ModelAccountStructureFindUniqueArgs>(args: SelectSubset<T, ModelAccountStructureFindUniqueArgs<ExtArgs>>): Prisma__ModelAccountStructureClient<$Result.GetResult<Prisma.$ModelAccountStructurePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one ModelAccountStructure that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ModelAccountStructureFindUniqueOrThrowArgs} args - Arguments to find a ModelAccountStructure
     * @example
     * // Get one ModelAccountStructure
     * const modelAccountStructure = await prisma.modelAccountStructure.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ModelAccountStructureFindUniqueOrThrowArgs>(args: SelectSubset<T, ModelAccountStructureFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ModelAccountStructureClient<$Result.GetResult<Prisma.$ModelAccountStructurePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first ModelAccountStructure that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelAccountStructureFindFirstArgs} args - Arguments to find a ModelAccountStructure
     * @example
     * // Get one ModelAccountStructure
     * const modelAccountStructure = await prisma.modelAccountStructure.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ModelAccountStructureFindFirstArgs>(args?: SelectSubset<T, ModelAccountStructureFindFirstArgs<ExtArgs>>): Prisma__ModelAccountStructureClient<$Result.GetResult<Prisma.$ModelAccountStructurePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first ModelAccountStructure that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelAccountStructureFindFirstOrThrowArgs} args - Arguments to find a ModelAccountStructure
     * @example
     * // Get one ModelAccountStructure
     * const modelAccountStructure = await prisma.modelAccountStructure.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ModelAccountStructureFindFirstOrThrowArgs>(args?: SelectSubset<T, ModelAccountStructureFindFirstOrThrowArgs<ExtArgs>>): Prisma__ModelAccountStructureClient<$Result.GetResult<Prisma.$ModelAccountStructurePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more ModelAccountStructures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelAccountStructureFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ModelAccountStructures
     * const modelAccountStructures = await prisma.modelAccountStructure.findMany()
     * 
     * // Get first 10 ModelAccountStructures
     * const modelAccountStructures = await prisma.modelAccountStructure.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const modelAccountStructureWithIdOnly = await prisma.modelAccountStructure.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ModelAccountStructureFindManyArgs>(args?: SelectSubset<T, ModelAccountStructureFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModelAccountStructurePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a ModelAccountStructure.
     * @param {ModelAccountStructureCreateArgs} args - Arguments to create a ModelAccountStructure.
     * @example
     * // Create one ModelAccountStructure
     * const ModelAccountStructure = await prisma.modelAccountStructure.create({
     *   data: {
     *     // ... data to create a ModelAccountStructure
     *   }
     * })
     * 
     */
    create<T extends ModelAccountStructureCreateArgs>(args: SelectSubset<T, ModelAccountStructureCreateArgs<ExtArgs>>): Prisma__ModelAccountStructureClient<$Result.GetResult<Prisma.$ModelAccountStructurePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many ModelAccountStructures.
     * @param {ModelAccountStructureCreateManyArgs} args - Arguments to create many ModelAccountStructures.
     * @example
     * // Create many ModelAccountStructures
     * const modelAccountStructure = await prisma.modelAccountStructure.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ModelAccountStructureCreateManyArgs>(args?: SelectSubset<T, ModelAccountStructureCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ModelAccountStructure.
     * @param {ModelAccountStructureDeleteArgs} args - Arguments to delete one ModelAccountStructure.
     * @example
     * // Delete one ModelAccountStructure
     * const ModelAccountStructure = await prisma.modelAccountStructure.delete({
     *   where: {
     *     // ... filter to delete one ModelAccountStructure
     *   }
     * })
     * 
     */
    delete<T extends ModelAccountStructureDeleteArgs>(args: SelectSubset<T, ModelAccountStructureDeleteArgs<ExtArgs>>): Prisma__ModelAccountStructureClient<$Result.GetResult<Prisma.$ModelAccountStructurePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one ModelAccountStructure.
     * @param {ModelAccountStructureUpdateArgs} args - Arguments to update one ModelAccountStructure.
     * @example
     * // Update one ModelAccountStructure
     * const modelAccountStructure = await prisma.modelAccountStructure.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ModelAccountStructureUpdateArgs>(args: SelectSubset<T, ModelAccountStructureUpdateArgs<ExtArgs>>): Prisma__ModelAccountStructureClient<$Result.GetResult<Prisma.$ModelAccountStructurePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more ModelAccountStructures.
     * @param {ModelAccountStructureDeleteManyArgs} args - Arguments to filter ModelAccountStructures to delete.
     * @example
     * // Delete a few ModelAccountStructures
     * const { count } = await prisma.modelAccountStructure.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ModelAccountStructureDeleteManyArgs>(args?: SelectSubset<T, ModelAccountStructureDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ModelAccountStructures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelAccountStructureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ModelAccountStructures
     * const modelAccountStructure = await prisma.modelAccountStructure.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ModelAccountStructureUpdateManyArgs>(args: SelectSubset<T, ModelAccountStructureUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ModelAccountStructure.
     * @param {ModelAccountStructureUpsertArgs} args - Arguments to update or create a ModelAccountStructure.
     * @example
     * // Update or create a ModelAccountStructure
     * const modelAccountStructure = await prisma.modelAccountStructure.upsert({
     *   create: {
     *     // ... data to create a ModelAccountStructure
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ModelAccountStructure we want to update
     *   }
     * })
     */
    upsert<T extends ModelAccountStructureUpsertArgs>(args: SelectSubset<T, ModelAccountStructureUpsertArgs<ExtArgs>>): Prisma__ModelAccountStructureClient<$Result.GetResult<Prisma.$ModelAccountStructurePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more ModelAccountStructures that matches the filter.
     * @param {ModelAccountStructureFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const modelAccountStructure = await prisma.modelAccountStructure.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: ModelAccountStructureFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a ModelAccountStructure.
     * @param {ModelAccountStructureAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const modelAccountStructure = await prisma.modelAccountStructure.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ModelAccountStructureAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of ModelAccountStructures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelAccountStructureCountArgs} args - Arguments to filter ModelAccountStructures to count.
     * @example
     * // Count the number of ModelAccountStructures
     * const count = await prisma.modelAccountStructure.count({
     *   where: {
     *     // ... the filter for the ModelAccountStructures we want to count
     *   }
     * })
    **/
    count<T extends ModelAccountStructureCountArgs>(
      args?: Subset<T, ModelAccountStructureCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ModelAccountStructureCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ModelAccountStructure.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelAccountStructureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ModelAccountStructureAggregateArgs>(args: Subset<T, ModelAccountStructureAggregateArgs>): Prisma.PrismaPromise<GetModelAccountStructureAggregateType<T>>

    /**
     * Group by ModelAccountStructure.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelAccountStructureGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ModelAccountStructureGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ModelAccountStructureGroupByArgs['orderBy'] }
        : { orderBy?: ModelAccountStructureGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ModelAccountStructureGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetModelAccountStructureGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ModelAccountStructure model
   */
  readonly fields: ModelAccountStructureFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ModelAccountStructure.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ModelAccountStructureClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    instance<T extends InstanceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InstanceDefaultArgs<ExtArgs>>): Prisma__InstanceClient<$Result.GetResult<Prisma.$InstancePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    model<T extends ModelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ModelDefaultArgs<ExtArgs>>): Prisma__ModelClient<$Result.GetResult<Prisma.$ModelPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    account<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    modeldataCalculations<T extends ModelAccountStructure$modeldataCalculationsArgs<ExtArgs> = {}>(args?: Subset<T, ModelAccountStructure$modeldataCalculationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModelDataCalculationsPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    parentAccount<T extends ModelAccountStructure$parentAccountArgs<ExtArgs> = {}>(args?: Subset<T, ModelAccountStructure$parentAccountArgs<ExtArgs>>): Prisma__ModelAccountStructureClient<$Result.GetResult<Prisma.$ModelAccountStructurePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    childAccounts<T extends ModelAccountStructure$childAccountsArgs<ExtArgs> = {}>(args?: Subset<T, ModelAccountStructure$childAccountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModelAccountStructurePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ModelAccountStructure model
   */ 
  interface ModelAccountStructureFieldRefs {
    readonly id: FieldRef<"ModelAccountStructure", 'String'>
    readonly instanceId: FieldRef<"ModelAccountStructure", 'String'>
    readonly isRoot: FieldRef<"ModelAccountStructure", 'Boolean'>
    readonly clientId: FieldRef<"ModelAccountStructure", 'String'>
    readonly parentId: FieldRef<"ModelAccountStructure", 'String'>
    readonly modelId: FieldRef<"ModelAccountStructure", 'String'>
    readonly accountId: FieldRef<"ModelAccountStructure", 'String'>
    readonly createdAt: FieldRef<"ModelAccountStructure", 'DateTime'>
    readonly updatedAt: FieldRef<"ModelAccountStructure", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ModelAccountStructure findUnique
   */
  export type ModelAccountStructureFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelAccountStructure
     */
    select?: ModelAccountStructureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelAccountStructure
     */
    omit?: ModelAccountStructureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelAccountStructureInclude<ExtArgs> | null
    /**
     * Filter, which ModelAccountStructure to fetch.
     */
    where: ModelAccountStructureWhereUniqueInput
  }

  /**
   * ModelAccountStructure findUniqueOrThrow
   */
  export type ModelAccountStructureFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelAccountStructure
     */
    select?: ModelAccountStructureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelAccountStructure
     */
    omit?: ModelAccountStructureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelAccountStructureInclude<ExtArgs> | null
    /**
     * Filter, which ModelAccountStructure to fetch.
     */
    where: ModelAccountStructureWhereUniqueInput
  }

  /**
   * ModelAccountStructure findFirst
   */
  export type ModelAccountStructureFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelAccountStructure
     */
    select?: ModelAccountStructureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelAccountStructure
     */
    omit?: ModelAccountStructureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelAccountStructureInclude<ExtArgs> | null
    /**
     * Filter, which ModelAccountStructure to fetch.
     */
    where?: ModelAccountStructureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModelAccountStructures to fetch.
     */
    orderBy?: ModelAccountStructureOrderByWithRelationInput | ModelAccountStructureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ModelAccountStructures.
     */
    cursor?: ModelAccountStructureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModelAccountStructures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModelAccountStructures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ModelAccountStructures.
     */
    distinct?: ModelAccountStructureScalarFieldEnum | ModelAccountStructureScalarFieldEnum[]
  }

  /**
   * ModelAccountStructure findFirstOrThrow
   */
  export type ModelAccountStructureFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelAccountStructure
     */
    select?: ModelAccountStructureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelAccountStructure
     */
    omit?: ModelAccountStructureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelAccountStructureInclude<ExtArgs> | null
    /**
     * Filter, which ModelAccountStructure to fetch.
     */
    where?: ModelAccountStructureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModelAccountStructures to fetch.
     */
    orderBy?: ModelAccountStructureOrderByWithRelationInput | ModelAccountStructureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ModelAccountStructures.
     */
    cursor?: ModelAccountStructureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModelAccountStructures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModelAccountStructures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ModelAccountStructures.
     */
    distinct?: ModelAccountStructureScalarFieldEnum | ModelAccountStructureScalarFieldEnum[]
  }

  /**
   * ModelAccountStructure findMany
   */
  export type ModelAccountStructureFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelAccountStructure
     */
    select?: ModelAccountStructureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelAccountStructure
     */
    omit?: ModelAccountStructureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelAccountStructureInclude<ExtArgs> | null
    /**
     * Filter, which ModelAccountStructures to fetch.
     */
    where?: ModelAccountStructureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModelAccountStructures to fetch.
     */
    orderBy?: ModelAccountStructureOrderByWithRelationInput | ModelAccountStructureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ModelAccountStructures.
     */
    cursor?: ModelAccountStructureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModelAccountStructures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModelAccountStructures.
     */
    skip?: number
    distinct?: ModelAccountStructureScalarFieldEnum | ModelAccountStructureScalarFieldEnum[]
  }

  /**
   * ModelAccountStructure create
   */
  export type ModelAccountStructureCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelAccountStructure
     */
    select?: ModelAccountStructureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelAccountStructure
     */
    omit?: ModelAccountStructureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelAccountStructureInclude<ExtArgs> | null
    /**
     * The data needed to create a ModelAccountStructure.
     */
    data: XOR<ModelAccountStructureCreateInput, ModelAccountStructureUncheckedCreateInput>
  }

  /**
   * ModelAccountStructure createMany
   */
  export type ModelAccountStructureCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ModelAccountStructures.
     */
    data: ModelAccountStructureCreateManyInput | ModelAccountStructureCreateManyInput[]
  }

  /**
   * ModelAccountStructure update
   */
  export type ModelAccountStructureUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelAccountStructure
     */
    select?: ModelAccountStructureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelAccountStructure
     */
    omit?: ModelAccountStructureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelAccountStructureInclude<ExtArgs> | null
    /**
     * The data needed to update a ModelAccountStructure.
     */
    data: XOR<ModelAccountStructureUpdateInput, ModelAccountStructureUncheckedUpdateInput>
    /**
     * Choose, which ModelAccountStructure to update.
     */
    where: ModelAccountStructureWhereUniqueInput
  }

  /**
   * ModelAccountStructure updateMany
   */
  export type ModelAccountStructureUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ModelAccountStructures.
     */
    data: XOR<ModelAccountStructureUpdateManyMutationInput, ModelAccountStructureUncheckedUpdateManyInput>
    /**
     * Filter which ModelAccountStructures to update
     */
    where?: ModelAccountStructureWhereInput
    /**
     * Limit how many ModelAccountStructures to update.
     */
    limit?: number
  }

  /**
   * ModelAccountStructure upsert
   */
  export type ModelAccountStructureUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelAccountStructure
     */
    select?: ModelAccountStructureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelAccountStructure
     */
    omit?: ModelAccountStructureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelAccountStructureInclude<ExtArgs> | null
    /**
     * The filter to search for the ModelAccountStructure to update in case it exists.
     */
    where: ModelAccountStructureWhereUniqueInput
    /**
     * In case the ModelAccountStructure found by the `where` argument doesn't exist, create a new ModelAccountStructure with this data.
     */
    create: XOR<ModelAccountStructureCreateInput, ModelAccountStructureUncheckedCreateInput>
    /**
     * In case the ModelAccountStructure was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ModelAccountStructureUpdateInput, ModelAccountStructureUncheckedUpdateInput>
  }

  /**
   * ModelAccountStructure delete
   */
  export type ModelAccountStructureDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelAccountStructure
     */
    select?: ModelAccountStructureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelAccountStructure
     */
    omit?: ModelAccountStructureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelAccountStructureInclude<ExtArgs> | null
    /**
     * Filter which ModelAccountStructure to delete.
     */
    where: ModelAccountStructureWhereUniqueInput
  }

  /**
   * ModelAccountStructure deleteMany
   */
  export type ModelAccountStructureDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ModelAccountStructures to delete
     */
    where?: ModelAccountStructureWhereInput
    /**
     * Limit how many ModelAccountStructures to delete.
     */
    limit?: number
  }

  /**
   * ModelAccountStructure findRaw
   */
  export type ModelAccountStructureFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ModelAccountStructure aggregateRaw
   */
  export type ModelAccountStructureAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ModelAccountStructure.modeldataCalculations
   */
  export type ModelAccountStructure$modeldataCalculationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelDataCalculations
     */
    select?: ModelDataCalculationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelDataCalculations
     */
    omit?: ModelDataCalculationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelDataCalculationsInclude<ExtArgs> | null
    where?: ModelDataCalculationsWhereInput
    orderBy?: ModelDataCalculationsOrderByWithRelationInput | ModelDataCalculationsOrderByWithRelationInput[]
    cursor?: ModelDataCalculationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ModelDataCalculationsScalarFieldEnum | ModelDataCalculationsScalarFieldEnum[]
  }

  /**
   * ModelAccountStructure.parentAccount
   */
  export type ModelAccountStructure$parentAccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelAccountStructure
     */
    select?: ModelAccountStructureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelAccountStructure
     */
    omit?: ModelAccountStructureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelAccountStructureInclude<ExtArgs> | null
    where?: ModelAccountStructureWhereInput
  }

  /**
   * ModelAccountStructure.childAccounts
   */
  export type ModelAccountStructure$childAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelAccountStructure
     */
    select?: ModelAccountStructureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelAccountStructure
     */
    omit?: ModelAccountStructureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelAccountStructureInclude<ExtArgs> | null
    where?: ModelAccountStructureWhereInput
    orderBy?: ModelAccountStructureOrderByWithRelationInput | ModelAccountStructureOrderByWithRelationInput[]
    cursor?: ModelAccountStructureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ModelAccountStructureScalarFieldEnum | ModelAccountStructureScalarFieldEnum[]
  }

  /**
   * ModelAccountStructure without action
   */
  export type ModelAccountStructureDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelAccountStructure
     */
    select?: ModelAccountStructureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelAccountStructure
     */
    omit?: ModelAccountStructureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelAccountStructureInclude<ExtArgs> | null
  }


  /**
   * Model ModelData
   */

  export type AggregateModelData = {
    _count: ModelDataCountAggregateOutputType | null
    _min: ModelDataMinAggregateOutputType | null
    _max: ModelDataMaxAggregateOutputType | null
  }

  export type ModelDataMinAggregateOutputType = {
    id: string | null
    clientId: string | null
    instanceId: string | null
    modelId: string | null
    versionId: string | null
    levelId: string | null
    accountId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ModelDataMaxAggregateOutputType = {
    id: string | null
    clientId: string | null
    instanceId: string | null
    modelId: string | null
    versionId: string | null
    levelId: string | null
    accountId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ModelDataCountAggregateOutputType = {
    id: number
    clientId: number
    instanceId: number
    modelId: number
    versionId: number
    levelId: number
    accountId: number
    timespan: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ModelDataMinAggregateInputType = {
    id?: true
    clientId?: true
    instanceId?: true
    modelId?: true
    versionId?: true
    levelId?: true
    accountId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ModelDataMaxAggregateInputType = {
    id?: true
    clientId?: true
    instanceId?: true
    modelId?: true
    versionId?: true
    levelId?: true
    accountId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ModelDataCountAggregateInputType = {
    id?: true
    clientId?: true
    instanceId?: true
    modelId?: true
    versionId?: true
    levelId?: true
    accountId?: true
    timespan?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ModelDataAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ModelData to aggregate.
     */
    where?: ModelDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModelData to fetch.
     */
    orderBy?: ModelDataOrderByWithRelationInput | ModelDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ModelDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModelData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModelData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ModelData
    **/
    _count?: true | ModelDataCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ModelDataMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ModelDataMaxAggregateInputType
  }

  export type GetModelDataAggregateType<T extends ModelDataAggregateArgs> = {
        [P in keyof T & keyof AggregateModelData]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateModelData[P]>
      : GetScalarType<T[P], AggregateModelData[P]>
  }




  export type ModelDataGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModelDataWhereInput
    orderBy?: ModelDataOrderByWithAggregationInput | ModelDataOrderByWithAggregationInput[]
    by: ModelDataScalarFieldEnum[] | ModelDataScalarFieldEnum
    having?: ModelDataScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ModelDataCountAggregateInputType | true
    _min?: ModelDataMinAggregateInputType
    _max?: ModelDataMaxAggregateInputType
  }

  export type ModelDataGroupByOutputType = {
    id: string
    clientId: string
    instanceId: string
    modelId: string
    versionId: string
    levelId: string
    accountId: string
    timespan: JsonValue
    createdAt: Date | null
    updatedAt: Date | null
    _count: ModelDataCountAggregateOutputType | null
    _min: ModelDataMinAggregateOutputType | null
    _max: ModelDataMaxAggregateOutputType | null
  }

  type GetModelDataGroupByPayload<T extends ModelDataGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ModelDataGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ModelDataGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ModelDataGroupByOutputType[P]>
            : GetScalarType<T[P], ModelDataGroupByOutputType[P]>
        }
      >
    >


  export type ModelDataSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    instanceId?: boolean
    modelId?: boolean
    versionId?: boolean
    levelId?: boolean
    accountId?: boolean
    dimensionality?: boolean | ModelDataDimensionalityDefaultArgs<ExtArgs>
    timespan?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    model?: boolean | ModelDefaultArgs<ExtArgs>
    level?: boolean | LevelDefaultArgs<ExtArgs>
    account?: boolean | AccountDefaultArgs<ExtArgs>
    version?: boolean | VersionDefaultArgs<ExtArgs>
    instance?: boolean | InstanceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["modelData"]>



  export type ModelDataSelectScalar = {
    id?: boolean
    clientId?: boolean
    instanceId?: boolean
    modelId?: boolean
    versionId?: boolean
    levelId?: boolean
    accountId?: boolean
    timespan?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ModelDataOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "clientId" | "instanceId" | "modelId" | "versionId" | "levelId" | "accountId" | "dimensionality" | "timespan" | "createdAt" | "updatedAt", ExtArgs["result"]["modelData"]>
  export type ModelDataInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    model?: boolean | ModelDefaultArgs<ExtArgs>
    level?: boolean | LevelDefaultArgs<ExtArgs>
    account?: boolean | AccountDefaultArgs<ExtArgs>
    version?: boolean | VersionDefaultArgs<ExtArgs>
    instance?: boolean | InstanceDefaultArgs<ExtArgs>
  }

  export type $ModelDataPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ModelData"
    objects: {
      model: Prisma.$ModelPayload<ExtArgs>
      level: Prisma.$LevelPayload<ExtArgs>
      account: Prisma.$AccountPayload<ExtArgs>
      version: Prisma.$VersionPayload<ExtArgs>
      instance: Prisma.$InstancePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clientId: string
      instanceId: string
      modelId: string
      versionId: string
      levelId: string
      accountId: string
      timespan: Prisma.JsonValue
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["modelData"]>
    composites: {
      dimensionality: Prisma.$ModelDataDimensionalityPayload[]
    }
  }

  type ModelDataGetPayload<S extends boolean | null | undefined | ModelDataDefaultArgs> = $Result.GetResult<Prisma.$ModelDataPayload, S>

  type ModelDataCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ModelDataFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ModelDataCountAggregateInputType | true
    }

  export interface ModelDataDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ModelData'], meta: { name: 'ModelData' } }
    /**
     * Find zero or one ModelData that matches the filter.
     * @param {ModelDataFindUniqueArgs} args - Arguments to find a ModelData
     * @example
     * // Get one ModelData
     * const modelData = await prisma.modelData.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ModelDataFindUniqueArgs>(args: SelectSubset<T, ModelDataFindUniqueArgs<ExtArgs>>): Prisma__ModelDataClient<$Result.GetResult<Prisma.$ModelDataPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one ModelData that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ModelDataFindUniqueOrThrowArgs} args - Arguments to find a ModelData
     * @example
     * // Get one ModelData
     * const modelData = await prisma.modelData.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ModelDataFindUniqueOrThrowArgs>(args: SelectSubset<T, ModelDataFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ModelDataClient<$Result.GetResult<Prisma.$ModelDataPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first ModelData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelDataFindFirstArgs} args - Arguments to find a ModelData
     * @example
     * // Get one ModelData
     * const modelData = await prisma.modelData.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ModelDataFindFirstArgs>(args?: SelectSubset<T, ModelDataFindFirstArgs<ExtArgs>>): Prisma__ModelDataClient<$Result.GetResult<Prisma.$ModelDataPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first ModelData that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelDataFindFirstOrThrowArgs} args - Arguments to find a ModelData
     * @example
     * // Get one ModelData
     * const modelData = await prisma.modelData.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ModelDataFindFirstOrThrowArgs>(args?: SelectSubset<T, ModelDataFindFirstOrThrowArgs<ExtArgs>>): Prisma__ModelDataClient<$Result.GetResult<Prisma.$ModelDataPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more ModelData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelDataFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ModelData
     * const modelData = await prisma.modelData.findMany()
     * 
     * // Get first 10 ModelData
     * const modelData = await prisma.modelData.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const modelDataWithIdOnly = await prisma.modelData.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ModelDataFindManyArgs>(args?: SelectSubset<T, ModelDataFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModelDataPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a ModelData.
     * @param {ModelDataCreateArgs} args - Arguments to create a ModelData.
     * @example
     * // Create one ModelData
     * const ModelData = await prisma.modelData.create({
     *   data: {
     *     // ... data to create a ModelData
     *   }
     * })
     * 
     */
    create<T extends ModelDataCreateArgs>(args: SelectSubset<T, ModelDataCreateArgs<ExtArgs>>): Prisma__ModelDataClient<$Result.GetResult<Prisma.$ModelDataPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many ModelData.
     * @param {ModelDataCreateManyArgs} args - Arguments to create many ModelData.
     * @example
     * // Create many ModelData
     * const modelData = await prisma.modelData.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ModelDataCreateManyArgs>(args?: SelectSubset<T, ModelDataCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ModelData.
     * @param {ModelDataDeleteArgs} args - Arguments to delete one ModelData.
     * @example
     * // Delete one ModelData
     * const ModelData = await prisma.modelData.delete({
     *   where: {
     *     // ... filter to delete one ModelData
     *   }
     * })
     * 
     */
    delete<T extends ModelDataDeleteArgs>(args: SelectSubset<T, ModelDataDeleteArgs<ExtArgs>>): Prisma__ModelDataClient<$Result.GetResult<Prisma.$ModelDataPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one ModelData.
     * @param {ModelDataUpdateArgs} args - Arguments to update one ModelData.
     * @example
     * // Update one ModelData
     * const modelData = await prisma.modelData.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ModelDataUpdateArgs>(args: SelectSubset<T, ModelDataUpdateArgs<ExtArgs>>): Prisma__ModelDataClient<$Result.GetResult<Prisma.$ModelDataPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more ModelData.
     * @param {ModelDataDeleteManyArgs} args - Arguments to filter ModelData to delete.
     * @example
     * // Delete a few ModelData
     * const { count } = await prisma.modelData.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ModelDataDeleteManyArgs>(args?: SelectSubset<T, ModelDataDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ModelData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelDataUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ModelData
     * const modelData = await prisma.modelData.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ModelDataUpdateManyArgs>(args: SelectSubset<T, ModelDataUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ModelData.
     * @param {ModelDataUpsertArgs} args - Arguments to update or create a ModelData.
     * @example
     * // Update or create a ModelData
     * const modelData = await prisma.modelData.upsert({
     *   create: {
     *     // ... data to create a ModelData
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ModelData we want to update
     *   }
     * })
     */
    upsert<T extends ModelDataUpsertArgs>(args: SelectSubset<T, ModelDataUpsertArgs<ExtArgs>>): Prisma__ModelDataClient<$Result.GetResult<Prisma.$ModelDataPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more ModelData that matches the filter.
     * @param {ModelDataFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const modelData = await prisma.modelData.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: ModelDataFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a ModelData.
     * @param {ModelDataAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const modelData = await prisma.modelData.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ModelDataAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of ModelData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelDataCountArgs} args - Arguments to filter ModelData to count.
     * @example
     * // Count the number of ModelData
     * const count = await prisma.modelData.count({
     *   where: {
     *     // ... the filter for the ModelData we want to count
     *   }
     * })
    **/
    count<T extends ModelDataCountArgs>(
      args?: Subset<T, ModelDataCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ModelDataCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ModelData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelDataAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ModelDataAggregateArgs>(args: Subset<T, ModelDataAggregateArgs>): Prisma.PrismaPromise<GetModelDataAggregateType<T>>

    /**
     * Group by ModelData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelDataGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ModelDataGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ModelDataGroupByArgs['orderBy'] }
        : { orderBy?: ModelDataGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ModelDataGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetModelDataGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ModelData model
   */
  readonly fields: ModelDataFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ModelData.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ModelDataClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    model<T extends ModelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ModelDefaultArgs<ExtArgs>>): Prisma__ModelClient<$Result.GetResult<Prisma.$ModelPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    level<T extends LevelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LevelDefaultArgs<ExtArgs>>): Prisma__LevelClient<$Result.GetResult<Prisma.$LevelPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    account<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    version<T extends VersionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VersionDefaultArgs<ExtArgs>>): Prisma__VersionClient<$Result.GetResult<Prisma.$VersionPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    instance<T extends InstanceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InstanceDefaultArgs<ExtArgs>>): Prisma__InstanceClient<$Result.GetResult<Prisma.$InstancePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ModelData model
   */ 
  interface ModelDataFieldRefs {
    readonly id: FieldRef<"ModelData", 'String'>
    readonly clientId: FieldRef<"ModelData", 'String'>
    readonly instanceId: FieldRef<"ModelData", 'String'>
    readonly modelId: FieldRef<"ModelData", 'String'>
    readonly versionId: FieldRef<"ModelData", 'String'>
    readonly levelId: FieldRef<"ModelData", 'String'>
    readonly accountId: FieldRef<"ModelData", 'String'>
    readonly timespan: FieldRef<"ModelData", 'Json'>
    readonly createdAt: FieldRef<"ModelData", 'DateTime'>
    readonly updatedAt: FieldRef<"ModelData", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ModelData findUnique
   */
  export type ModelDataFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelData
     */
    select?: ModelDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelData
     */
    omit?: ModelDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelDataInclude<ExtArgs> | null
    /**
     * Filter, which ModelData to fetch.
     */
    where: ModelDataWhereUniqueInput
  }

  /**
   * ModelData findUniqueOrThrow
   */
  export type ModelDataFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelData
     */
    select?: ModelDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelData
     */
    omit?: ModelDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelDataInclude<ExtArgs> | null
    /**
     * Filter, which ModelData to fetch.
     */
    where: ModelDataWhereUniqueInput
  }

  /**
   * ModelData findFirst
   */
  export type ModelDataFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelData
     */
    select?: ModelDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelData
     */
    omit?: ModelDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelDataInclude<ExtArgs> | null
    /**
     * Filter, which ModelData to fetch.
     */
    where?: ModelDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModelData to fetch.
     */
    orderBy?: ModelDataOrderByWithRelationInput | ModelDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ModelData.
     */
    cursor?: ModelDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModelData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModelData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ModelData.
     */
    distinct?: ModelDataScalarFieldEnum | ModelDataScalarFieldEnum[]
  }

  /**
   * ModelData findFirstOrThrow
   */
  export type ModelDataFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelData
     */
    select?: ModelDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelData
     */
    omit?: ModelDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelDataInclude<ExtArgs> | null
    /**
     * Filter, which ModelData to fetch.
     */
    where?: ModelDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModelData to fetch.
     */
    orderBy?: ModelDataOrderByWithRelationInput | ModelDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ModelData.
     */
    cursor?: ModelDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModelData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModelData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ModelData.
     */
    distinct?: ModelDataScalarFieldEnum | ModelDataScalarFieldEnum[]
  }

  /**
   * ModelData findMany
   */
  export type ModelDataFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelData
     */
    select?: ModelDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelData
     */
    omit?: ModelDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelDataInclude<ExtArgs> | null
    /**
     * Filter, which ModelData to fetch.
     */
    where?: ModelDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModelData to fetch.
     */
    orderBy?: ModelDataOrderByWithRelationInput | ModelDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ModelData.
     */
    cursor?: ModelDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModelData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModelData.
     */
    skip?: number
    distinct?: ModelDataScalarFieldEnum | ModelDataScalarFieldEnum[]
  }

  /**
   * ModelData create
   */
  export type ModelDataCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelData
     */
    select?: ModelDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelData
     */
    omit?: ModelDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelDataInclude<ExtArgs> | null
    /**
     * The data needed to create a ModelData.
     */
    data: XOR<ModelDataCreateInput, ModelDataUncheckedCreateInput>
  }

  /**
   * ModelData createMany
   */
  export type ModelDataCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ModelData.
     */
    data: ModelDataCreateManyInput | ModelDataCreateManyInput[]
  }

  /**
   * ModelData update
   */
  export type ModelDataUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelData
     */
    select?: ModelDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelData
     */
    omit?: ModelDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelDataInclude<ExtArgs> | null
    /**
     * The data needed to update a ModelData.
     */
    data: XOR<ModelDataUpdateInput, ModelDataUncheckedUpdateInput>
    /**
     * Choose, which ModelData to update.
     */
    where: ModelDataWhereUniqueInput
  }

  /**
   * ModelData updateMany
   */
  export type ModelDataUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ModelData.
     */
    data: XOR<ModelDataUpdateManyMutationInput, ModelDataUncheckedUpdateManyInput>
    /**
     * Filter which ModelData to update
     */
    where?: ModelDataWhereInput
    /**
     * Limit how many ModelData to update.
     */
    limit?: number
  }

  /**
   * ModelData upsert
   */
  export type ModelDataUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelData
     */
    select?: ModelDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelData
     */
    omit?: ModelDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelDataInclude<ExtArgs> | null
    /**
     * The filter to search for the ModelData to update in case it exists.
     */
    where: ModelDataWhereUniqueInput
    /**
     * In case the ModelData found by the `where` argument doesn't exist, create a new ModelData with this data.
     */
    create: XOR<ModelDataCreateInput, ModelDataUncheckedCreateInput>
    /**
     * In case the ModelData was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ModelDataUpdateInput, ModelDataUncheckedUpdateInput>
  }

  /**
   * ModelData delete
   */
  export type ModelDataDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelData
     */
    select?: ModelDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelData
     */
    omit?: ModelDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelDataInclude<ExtArgs> | null
    /**
     * Filter which ModelData to delete.
     */
    where: ModelDataWhereUniqueInput
  }

  /**
   * ModelData deleteMany
   */
  export type ModelDataDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ModelData to delete
     */
    where?: ModelDataWhereInput
    /**
     * Limit how many ModelData to delete.
     */
    limit?: number
  }

  /**
   * ModelData findRaw
   */
  export type ModelDataFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ModelData aggregateRaw
   */
  export type ModelDataAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ModelData without action
   */
  export type ModelDataDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelData
     */
    select?: ModelDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelData
     */
    omit?: ModelDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelDataInclude<ExtArgs> | null
  }


  /**
   * Model ModelDataCalculations
   */

  export type AggregateModelDataCalculations = {
    _count: ModelDataCalculationsCountAggregateOutputType | null
    _min: ModelDataCalculationsMinAggregateOutputType | null
    _max: ModelDataCalculationsMaxAggregateOutputType | null
  }

  export type ModelDataCalculationsMinAggregateOutputType = {
    id: string | null
    clientId: string | null
    instanceId: string | null
    modelId: string | null
    versionId: string | null
    levelId: string | null
    accountId: string | null
    modelAccountId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ModelDataCalculationsMaxAggregateOutputType = {
    id: string | null
    clientId: string | null
    instanceId: string | null
    modelId: string | null
    versionId: string | null
    levelId: string | null
    accountId: string | null
    modelAccountId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ModelDataCalculationsCountAggregateOutputType = {
    id: number
    clientId: number
    instanceId: number
    modelId: number
    versionId: number
    levelId: number
    accountId: number
    modelAccountId: number
    calculations: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ModelDataCalculationsMinAggregateInputType = {
    id?: true
    clientId?: true
    instanceId?: true
    modelId?: true
    versionId?: true
    levelId?: true
    accountId?: true
    modelAccountId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ModelDataCalculationsMaxAggregateInputType = {
    id?: true
    clientId?: true
    instanceId?: true
    modelId?: true
    versionId?: true
    levelId?: true
    accountId?: true
    modelAccountId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ModelDataCalculationsCountAggregateInputType = {
    id?: true
    clientId?: true
    instanceId?: true
    modelId?: true
    versionId?: true
    levelId?: true
    accountId?: true
    modelAccountId?: true
    calculations?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ModelDataCalculationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ModelDataCalculations to aggregate.
     */
    where?: ModelDataCalculationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModelDataCalculations to fetch.
     */
    orderBy?: ModelDataCalculationsOrderByWithRelationInput | ModelDataCalculationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ModelDataCalculationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModelDataCalculations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModelDataCalculations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ModelDataCalculations
    **/
    _count?: true | ModelDataCalculationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ModelDataCalculationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ModelDataCalculationsMaxAggregateInputType
  }

  export type GetModelDataCalculationsAggregateType<T extends ModelDataCalculationsAggregateArgs> = {
        [P in keyof T & keyof AggregateModelDataCalculations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateModelDataCalculations[P]>
      : GetScalarType<T[P], AggregateModelDataCalculations[P]>
  }




  export type ModelDataCalculationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModelDataCalculationsWhereInput
    orderBy?: ModelDataCalculationsOrderByWithAggregationInput | ModelDataCalculationsOrderByWithAggregationInput[]
    by: ModelDataCalculationsScalarFieldEnum[] | ModelDataCalculationsScalarFieldEnum
    having?: ModelDataCalculationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ModelDataCalculationsCountAggregateInputType | true
    _min?: ModelDataCalculationsMinAggregateInputType
    _max?: ModelDataCalculationsMaxAggregateInputType
  }

  export type ModelDataCalculationsGroupByOutputType = {
    id: string
    clientId: string
    instanceId: string
    modelId: string
    versionId: string
    levelId: string
    accountId: string
    modelAccountId: string
    calculations: JsonValue
    createdAt: Date | null
    updatedAt: Date | null
    _count: ModelDataCalculationsCountAggregateOutputType | null
    _min: ModelDataCalculationsMinAggregateOutputType | null
    _max: ModelDataCalculationsMaxAggregateOutputType | null
  }

  type GetModelDataCalculationsGroupByPayload<T extends ModelDataCalculationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ModelDataCalculationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ModelDataCalculationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ModelDataCalculationsGroupByOutputType[P]>
            : GetScalarType<T[P], ModelDataCalculationsGroupByOutputType[P]>
        }
      >
    >


  export type ModelDataCalculationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    instanceId?: boolean
    modelId?: boolean
    versionId?: boolean
    levelId?: boolean
    accountId?: boolean
    modelAccountId?: boolean
    calculations?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    model?: boolean | ModelDefaultArgs<ExtArgs>
    level?: boolean | LevelDefaultArgs<ExtArgs>
    account?: boolean | AccountDefaultArgs<ExtArgs>
    version?: boolean | VersionDefaultArgs<ExtArgs>
    instance?: boolean | InstanceDefaultArgs<ExtArgs>
    modelAccount?: boolean | ModelAccountStructureDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["modelDataCalculations"]>



  export type ModelDataCalculationsSelectScalar = {
    id?: boolean
    clientId?: boolean
    instanceId?: boolean
    modelId?: boolean
    versionId?: boolean
    levelId?: boolean
    accountId?: boolean
    modelAccountId?: boolean
    calculations?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ModelDataCalculationsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "clientId" | "instanceId" | "modelId" | "versionId" | "levelId" | "accountId" | "modelAccountId" | "calculations" | "createdAt" | "updatedAt", ExtArgs["result"]["modelDataCalculations"]>
  export type ModelDataCalculationsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    model?: boolean | ModelDefaultArgs<ExtArgs>
    level?: boolean | LevelDefaultArgs<ExtArgs>
    account?: boolean | AccountDefaultArgs<ExtArgs>
    version?: boolean | VersionDefaultArgs<ExtArgs>
    instance?: boolean | InstanceDefaultArgs<ExtArgs>
    modelAccount?: boolean | ModelAccountStructureDefaultArgs<ExtArgs>
  }

  export type $ModelDataCalculationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ModelDataCalculations"
    objects: {
      model: Prisma.$ModelPayload<ExtArgs>
      level: Prisma.$LevelPayload<ExtArgs>
      account: Prisma.$AccountPayload<ExtArgs>
      version: Prisma.$VersionPayload<ExtArgs>
      instance: Prisma.$InstancePayload<ExtArgs>
      modelAccount: Prisma.$ModelAccountStructurePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clientId: string
      instanceId: string
      modelId: string
      versionId: string
      levelId: string
      accountId: string
      modelAccountId: string
      calculations: Prisma.JsonValue
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["modelDataCalculations"]>
    composites: {}
  }

  type ModelDataCalculationsGetPayload<S extends boolean | null | undefined | ModelDataCalculationsDefaultArgs> = $Result.GetResult<Prisma.$ModelDataCalculationsPayload, S>

  type ModelDataCalculationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ModelDataCalculationsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ModelDataCalculationsCountAggregateInputType | true
    }

  export interface ModelDataCalculationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ModelDataCalculations'], meta: { name: 'ModelDataCalculations' } }
    /**
     * Find zero or one ModelDataCalculations that matches the filter.
     * @param {ModelDataCalculationsFindUniqueArgs} args - Arguments to find a ModelDataCalculations
     * @example
     * // Get one ModelDataCalculations
     * const modelDataCalculations = await prisma.modelDataCalculations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ModelDataCalculationsFindUniqueArgs>(args: SelectSubset<T, ModelDataCalculationsFindUniqueArgs<ExtArgs>>): Prisma__ModelDataCalculationsClient<$Result.GetResult<Prisma.$ModelDataCalculationsPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one ModelDataCalculations that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ModelDataCalculationsFindUniqueOrThrowArgs} args - Arguments to find a ModelDataCalculations
     * @example
     * // Get one ModelDataCalculations
     * const modelDataCalculations = await prisma.modelDataCalculations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ModelDataCalculationsFindUniqueOrThrowArgs>(args: SelectSubset<T, ModelDataCalculationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ModelDataCalculationsClient<$Result.GetResult<Prisma.$ModelDataCalculationsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first ModelDataCalculations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelDataCalculationsFindFirstArgs} args - Arguments to find a ModelDataCalculations
     * @example
     * // Get one ModelDataCalculations
     * const modelDataCalculations = await prisma.modelDataCalculations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ModelDataCalculationsFindFirstArgs>(args?: SelectSubset<T, ModelDataCalculationsFindFirstArgs<ExtArgs>>): Prisma__ModelDataCalculationsClient<$Result.GetResult<Prisma.$ModelDataCalculationsPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first ModelDataCalculations that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelDataCalculationsFindFirstOrThrowArgs} args - Arguments to find a ModelDataCalculations
     * @example
     * // Get one ModelDataCalculations
     * const modelDataCalculations = await prisma.modelDataCalculations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ModelDataCalculationsFindFirstOrThrowArgs>(args?: SelectSubset<T, ModelDataCalculationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ModelDataCalculationsClient<$Result.GetResult<Prisma.$ModelDataCalculationsPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more ModelDataCalculations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelDataCalculationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ModelDataCalculations
     * const modelDataCalculations = await prisma.modelDataCalculations.findMany()
     * 
     * // Get first 10 ModelDataCalculations
     * const modelDataCalculations = await prisma.modelDataCalculations.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const modelDataCalculationsWithIdOnly = await prisma.modelDataCalculations.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ModelDataCalculationsFindManyArgs>(args?: SelectSubset<T, ModelDataCalculationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModelDataCalculationsPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a ModelDataCalculations.
     * @param {ModelDataCalculationsCreateArgs} args - Arguments to create a ModelDataCalculations.
     * @example
     * // Create one ModelDataCalculations
     * const ModelDataCalculations = await prisma.modelDataCalculations.create({
     *   data: {
     *     // ... data to create a ModelDataCalculations
     *   }
     * })
     * 
     */
    create<T extends ModelDataCalculationsCreateArgs>(args: SelectSubset<T, ModelDataCalculationsCreateArgs<ExtArgs>>): Prisma__ModelDataCalculationsClient<$Result.GetResult<Prisma.$ModelDataCalculationsPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many ModelDataCalculations.
     * @param {ModelDataCalculationsCreateManyArgs} args - Arguments to create many ModelDataCalculations.
     * @example
     * // Create many ModelDataCalculations
     * const modelDataCalculations = await prisma.modelDataCalculations.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ModelDataCalculationsCreateManyArgs>(args?: SelectSubset<T, ModelDataCalculationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ModelDataCalculations.
     * @param {ModelDataCalculationsDeleteArgs} args - Arguments to delete one ModelDataCalculations.
     * @example
     * // Delete one ModelDataCalculations
     * const ModelDataCalculations = await prisma.modelDataCalculations.delete({
     *   where: {
     *     // ... filter to delete one ModelDataCalculations
     *   }
     * })
     * 
     */
    delete<T extends ModelDataCalculationsDeleteArgs>(args: SelectSubset<T, ModelDataCalculationsDeleteArgs<ExtArgs>>): Prisma__ModelDataCalculationsClient<$Result.GetResult<Prisma.$ModelDataCalculationsPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one ModelDataCalculations.
     * @param {ModelDataCalculationsUpdateArgs} args - Arguments to update one ModelDataCalculations.
     * @example
     * // Update one ModelDataCalculations
     * const modelDataCalculations = await prisma.modelDataCalculations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ModelDataCalculationsUpdateArgs>(args: SelectSubset<T, ModelDataCalculationsUpdateArgs<ExtArgs>>): Prisma__ModelDataCalculationsClient<$Result.GetResult<Prisma.$ModelDataCalculationsPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more ModelDataCalculations.
     * @param {ModelDataCalculationsDeleteManyArgs} args - Arguments to filter ModelDataCalculations to delete.
     * @example
     * // Delete a few ModelDataCalculations
     * const { count } = await prisma.modelDataCalculations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ModelDataCalculationsDeleteManyArgs>(args?: SelectSubset<T, ModelDataCalculationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ModelDataCalculations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelDataCalculationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ModelDataCalculations
     * const modelDataCalculations = await prisma.modelDataCalculations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ModelDataCalculationsUpdateManyArgs>(args: SelectSubset<T, ModelDataCalculationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ModelDataCalculations.
     * @param {ModelDataCalculationsUpsertArgs} args - Arguments to update or create a ModelDataCalculations.
     * @example
     * // Update or create a ModelDataCalculations
     * const modelDataCalculations = await prisma.modelDataCalculations.upsert({
     *   create: {
     *     // ... data to create a ModelDataCalculations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ModelDataCalculations we want to update
     *   }
     * })
     */
    upsert<T extends ModelDataCalculationsUpsertArgs>(args: SelectSubset<T, ModelDataCalculationsUpsertArgs<ExtArgs>>): Prisma__ModelDataCalculationsClient<$Result.GetResult<Prisma.$ModelDataCalculationsPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more ModelDataCalculations that matches the filter.
     * @param {ModelDataCalculationsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const modelDataCalculations = await prisma.modelDataCalculations.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: ModelDataCalculationsFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a ModelDataCalculations.
     * @param {ModelDataCalculationsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const modelDataCalculations = await prisma.modelDataCalculations.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ModelDataCalculationsAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of ModelDataCalculations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelDataCalculationsCountArgs} args - Arguments to filter ModelDataCalculations to count.
     * @example
     * // Count the number of ModelDataCalculations
     * const count = await prisma.modelDataCalculations.count({
     *   where: {
     *     // ... the filter for the ModelDataCalculations we want to count
     *   }
     * })
    **/
    count<T extends ModelDataCalculationsCountArgs>(
      args?: Subset<T, ModelDataCalculationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ModelDataCalculationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ModelDataCalculations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelDataCalculationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ModelDataCalculationsAggregateArgs>(args: Subset<T, ModelDataCalculationsAggregateArgs>): Prisma.PrismaPromise<GetModelDataCalculationsAggregateType<T>>

    /**
     * Group by ModelDataCalculations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelDataCalculationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ModelDataCalculationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ModelDataCalculationsGroupByArgs['orderBy'] }
        : { orderBy?: ModelDataCalculationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ModelDataCalculationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetModelDataCalculationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ModelDataCalculations model
   */
  readonly fields: ModelDataCalculationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ModelDataCalculations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ModelDataCalculationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    model<T extends ModelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ModelDefaultArgs<ExtArgs>>): Prisma__ModelClient<$Result.GetResult<Prisma.$ModelPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    level<T extends LevelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LevelDefaultArgs<ExtArgs>>): Prisma__LevelClient<$Result.GetResult<Prisma.$LevelPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    account<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    version<T extends VersionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VersionDefaultArgs<ExtArgs>>): Prisma__VersionClient<$Result.GetResult<Prisma.$VersionPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    instance<T extends InstanceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InstanceDefaultArgs<ExtArgs>>): Prisma__InstanceClient<$Result.GetResult<Prisma.$InstancePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    modelAccount<T extends ModelAccountStructureDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ModelAccountStructureDefaultArgs<ExtArgs>>): Prisma__ModelAccountStructureClient<$Result.GetResult<Prisma.$ModelAccountStructurePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ModelDataCalculations model
   */ 
  interface ModelDataCalculationsFieldRefs {
    readonly id: FieldRef<"ModelDataCalculations", 'String'>
    readonly clientId: FieldRef<"ModelDataCalculations", 'String'>
    readonly instanceId: FieldRef<"ModelDataCalculations", 'String'>
    readonly modelId: FieldRef<"ModelDataCalculations", 'String'>
    readonly versionId: FieldRef<"ModelDataCalculations", 'String'>
    readonly levelId: FieldRef<"ModelDataCalculations", 'String'>
    readonly accountId: FieldRef<"ModelDataCalculations", 'String'>
    readonly modelAccountId: FieldRef<"ModelDataCalculations", 'String'>
    readonly calculations: FieldRef<"ModelDataCalculations", 'Json'>
    readonly createdAt: FieldRef<"ModelDataCalculations", 'DateTime'>
    readonly updatedAt: FieldRef<"ModelDataCalculations", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ModelDataCalculations findUnique
   */
  export type ModelDataCalculationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelDataCalculations
     */
    select?: ModelDataCalculationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelDataCalculations
     */
    omit?: ModelDataCalculationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelDataCalculationsInclude<ExtArgs> | null
    /**
     * Filter, which ModelDataCalculations to fetch.
     */
    where: ModelDataCalculationsWhereUniqueInput
  }

  /**
   * ModelDataCalculations findUniqueOrThrow
   */
  export type ModelDataCalculationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelDataCalculations
     */
    select?: ModelDataCalculationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelDataCalculations
     */
    omit?: ModelDataCalculationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelDataCalculationsInclude<ExtArgs> | null
    /**
     * Filter, which ModelDataCalculations to fetch.
     */
    where: ModelDataCalculationsWhereUniqueInput
  }

  /**
   * ModelDataCalculations findFirst
   */
  export type ModelDataCalculationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelDataCalculations
     */
    select?: ModelDataCalculationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelDataCalculations
     */
    omit?: ModelDataCalculationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelDataCalculationsInclude<ExtArgs> | null
    /**
     * Filter, which ModelDataCalculations to fetch.
     */
    where?: ModelDataCalculationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModelDataCalculations to fetch.
     */
    orderBy?: ModelDataCalculationsOrderByWithRelationInput | ModelDataCalculationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ModelDataCalculations.
     */
    cursor?: ModelDataCalculationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModelDataCalculations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModelDataCalculations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ModelDataCalculations.
     */
    distinct?: ModelDataCalculationsScalarFieldEnum | ModelDataCalculationsScalarFieldEnum[]
  }

  /**
   * ModelDataCalculations findFirstOrThrow
   */
  export type ModelDataCalculationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelDataCalculations
     */
    select?: ModelDataCalculationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelDataCalculations
     */
    omit?: ModelDataCalculationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelDataCalculationsInclude<ExtArgs> | null
    /**
     * Filter, which ModelDataCalculations to fetch.
     */
    where?: ModelDataCalculationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModelDataCalculations to fetch.
     */
    orderBy?: ModelDataCalculationsOrderByWithRelationInput | ModelDataCalculationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ModelDataCalculations.
     */
    cursor?: ModelDataCalculationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModelDataCalculations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModelDataCalculations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ModelDataCalculations.
     */
    distinct?: ModelDataCalculationsScalarFieldEnum | ModelDataCalculationsScalarFieldEnum[]
  }

  /**
   * ModelDataCalculations findMany
   */
  export type ModelDataCalculationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelDataCalculations
     */
    select?: ModelDataCalculationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelDataCalculations
     */
    omit?: ModelDataCalculationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelDataCalculationsInclude<ExtArgs> | null
    /**
     * Filter, which ModelDataCalculations to fetch.
     */
    where?: ModelDataCalculationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModelDataCalculations to fetch.
     */
    orderBy?: ModelDataCalculationsOrderByWithRelationInput | ModelDataCalculationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ModelDataCalculations.
     */
    cursor?: ModelDataCalculationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModelDataCalculations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModelDataCalculations.
     */
    skip?: number
    distinct?: ModelDataCalculationsScalarFieldEnum | ModelDataCalculationsScalarFieldEnum[]
  }

  /**
   * ModelDataCalculations create
   */
  export type ModelDataCalculationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelDataCalculations
     */
    select?: ModelDataCalculationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelDataCalculations
     */
    omit?: ModelDataCalculationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelDataCalculationsInclude<ExtArgs> | null
    /**
     * The data needed to create a ModelDataCalculations.
     */
    data: XOR<ModelDataCalculationsCreateInput, ModelDataCalculationsUncheckedCreateInput>
  }

  /**
   * ModelDataCalculations createMany
   */
  export type ModelDataCalculationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ModelDataCalculations.
     */
    data: ModelDataCalculationsCreateManyInput | ModelDataCalculationsCreateManyInput[]
  }

  /**
   * ModelDataCalculations update
   */
  export type ModelDataCalculationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelDataCalculations
     */
    select?: ModelDataCalculationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelDataCalculations
     */
    omit?: ModelDataCalculationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelDataCalculationsInclude<ExtArgs> | null
    /**
     * The data needed to update a ModelDataCalculations.
     */
    data: XOR<ModelDataCalculationsUpdateInput, ModelDataCalculationsUncheckedUpdateInput>
    /**
     * Choose, which ModelDataCalculations to update.
     */
    where: ModelDataCalculationsWhereUniqueInput
  }

  /**
   * ModelDataCalculations updateMany
   */
  export type ModelDataCalculationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ModelDataCalculations.
     */
    data: XOR<ModelDataCalculationsUpdateManyMutationInput, ModelDataCalculationsUncheckedUpdateManyInput>
    /**
     * Filter which ModelDataCalculations to update
     */
    where?: ModelDataCalculationsWhereInput
    /**
     * Limit how many ModelDataCalculations to update.
     */
    limit?: number
  }

  /**
   * ModelDataCalculations upsert
   */
  export type ModelDataCalculationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelDataCalculations
     */
    select?: ModelDataCalculationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelDataCalculations
     */
    omit?: ModelDataCalculationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelDataCalculationsInclude<ExtArgs> | null
    /**
     * The filter to search for the ModelDataCalculations to update in case it exists.
     */
    where: ModelDataCalculationsWhereUniqueInput
    /**
     * In case the ModelDataCalculations found by the `where` argument doesn't exist, create a new ModelDataCalculations with this data.
     */
    create: XOR<ModelDataCalculationsCreateInput, ModelDataCalculationsUncheckedCreateInput>
    /**
     * In case the ModelDataCalculations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ModelDataCalculationsUpdateInput, ModelDataCalculationsUncheckedUpdateInput>
  }

  /**
   * ModelDataCalculations delete
   */
  export type ModelDataCalculationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelDataCalculations
     */
    select?: ModelDataCalculationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelDataCalculations
     */
    omit?: ModelDataCalculationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelDataCalculationsInclude<ExtArgs> | null
    /**
     * Filter which ModelDataCalculations to delete.
     */
    where: ModelDataCalculationsWhereUniqueInput
  }

  /**
   * ModelDataCalculations deleteMany
   */
  export type ModelDataCalculationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ModelDataCalculations to delete
     */
    where?: ModelDataCalculationsWhereInput
    /**
     * Limit how many ModelDataCalculations to delete.
     */
    limit?: number
  }

  /**
   * ModelDataCalculations findRaw
   */
  export type ModelDataCalculationsFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ModelDataCalculations aggregateRaw
   */
  export type ModelDataCalculationsAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ModelDataCalculations without action
   */
  export type ModelDataCalculationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelDataCalculations
     */
    select?: ModelDataCalculationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelDataCalculations
     */
    omit?: ModelDataCalculationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelDataCalculationsInclude<ExtArgs> | null
  }


  /**
   * Model Table
   */

  export type AggregateTable = {
    _count: TableCountAggregateOutputType | null
    _min: TableMinAggregateOutputType | null
    _max: TableMaxAggregateOutputType | null
  }

  export type TableMinAggregateOutputType = {
    id: string | null
    clientId: string | null
    instanceId: string | null
    name: string | null
    code: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    status: $Enums.ModelStatus | null
  }

  export type TableMaxAggregateOutputType = {
    id: string | null
    clientId: string | null
    instanceId: string | null
    name: string | null
    code: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    status: $Enums.ModelStatus | null
  }

  export type TableCountAggregateOutputType = {
    id: number
    clientId: number
    instanceId: number
    name: number
    code: number
    description: number
    createdAt: number
    updatedAt: number
    status: number
    _all: number
  }


  export type TableMinAggregateInputType = {
    id?: true
    clientId?: true
    instanceId?: true
    name?: true
    code?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type TableMaxAggregateInputType = {
    id?: true
    clientId?: true
    instanceId?: true
    name?: true
    code?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type TableCountAggregateInputType = {
    id?: true
    clientId?: true
    instanceId?: true
    name?: true
    code?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    _all?: true
  }

  export type TableAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Table to aggregate.
     */
    where?: TableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tables to fetch.
     */
    orderBy?: TableOrderByWithRelationInput | TableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tables
    **/
    _count?: true | TableCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TableMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TableMaxAggregateInputType
  }

  export type GetTableAggregateType<T extends TableAggregateArgs> = {
        [P in keyof T & keyof AggregateTable]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTable[P]>
      : GetScalarType<T[P], AggregateTable[P]>
  }




  export type TableGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TableWhereInput
    orderBy?: TableOrderByWithAggregationInput | TableOrderByWithAggregationInput[]
    by: TableScalarFieldEnum[] | TableScalarFieldEnum
    having?: TableScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TableCountAggregateInputType | true
    _min?: TableMinAggregateInputType
    _max?: TableMaxAggregateInputType
  }

  export type TableGroupByOutputType = {
    id: string
    clientId: string
    instanceId: string
    name: string
    code: string
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    status: $Enums.ModelStatus
    _count: TableCountAggregateOutputType | null
    _min: TableMinAggregateOutputType | null
    _max: TableMaxAggregateOutputType | null
  }

  type GetTableGroupByPayload<T extends TableGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TableGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TableGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TableGroupByOutputType[P]>
            : GetScalarType<T[P], TableGroupByOutputType[P]>
        }
      >
    >


  export type TableSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    instanceId?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    columnDefinitions?: boolean | TableColumnDefinitionDefaultArgs<ExtArgs>
    instance?: boolean | InstanceDefaultArgs<ExtArgs>
    tableData?: boolean | Table$tableDataArgs<ExtArgs>
    _count?: boolean | TableCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["table"]>



  export type TableSelectScalar = {
    id?: boolean
    clientId?: boolean
    instanceId?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
  }

  export type TableOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "clientId" | "instanceId" | "name" | "code" | "description" | "createdAt" | "updatedAt" | "status" | "columnDefinitions", ExtArgs["result"]["table"]>
  export type TableInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    instance?: boolean | InstanceDefaultArgs<ExtArgs>
    tableData?: boolean | Table$tableDataArgs<ExtArgs>
    _count?: boolean | TableCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $TablePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Table"
    objects: {
      instance: Prisma.$InstancePayload<ExtArgs>
      tableData: Prisma.$TableDataPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clientId: string
      instanceId: string
      name: string
      code: string
      description: string | null
      createdAt: Date | null
      updatedAt: Date | null
      status: $Enums.ModelStatus
    }, ExtArgs["result"]["table"]>
    composites: {
      columnDefinitions: Prisma.$TableColumnDefinitionPayload[]
    }
  }

  type TableGetPayload<S extends boolean | null | undefined | TableDefaultArgs> = $Result.GetResult<Prisma.$TablePayload, S>

  type TableCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TableFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TableCountAggregateInputType | true
    }

  export interface TableDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Table'], meta: { name: 'Table' } }
    /**
     * Find zero or one Table that matches the filter.
     * @param {TableFindUniqueArgs} args - Arguments to find a Table
     * @example
     * // Get one Table
     * const table = await prisma.table.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TableFindUniqueArgs>(args: SelectSubset<T, TableFindUniqueArgs<ExtArgs>>): Prisma__TableClient<$Result.GetResult<Prisma.$TablePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Table that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TableFindUniqueOrThrowArgs} args - Arguments to find a Table
     * @example
     * // Get one Table
     * const table = await prisma.table.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TableFindUniqueOrThrowArgs>(args: SelectSubset<T, TableFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TableClient<$Result.GetResult<Prisma.$TablePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Table that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TableFindFirstArgs} args - Arguments to find a Table
     * @example
     * // Get one Table
     * const table = await prisma.table.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TableFindFirstArgs>(args?: SelectSubset<T, TableFindFirstArgs<ExtArgs>>): Prisma__TableClient<$Result.GetResult<Prisma.$TablePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Table that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TableFindFirstOrThrowArgs} args - Arguments to find a Table
     * @example
     * // Get one Table
     * const table = await prisma.table.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TableFindFirstOrThrowArgs>(args?: SelectSubset<T, TableFindFirstOrThrowArgs<ExtArgs>>): Prisma__TableClient<$Result.GetResult<Prisma.$TablePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Tables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TableFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tables
     * const tables = await prisma.table.findMany()
     * 
     * // Get first 10 Tables
     * const tables = await prisma.table.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tableWithIdOnly = await prisma.table.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TableFindManyArgs>(args?: SelectSubset<T, TableFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TablePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Table.
     * @param {TableCreateArgs} args - Arguments to create a Table.
     * @example
     * // Create one Table
     * const Table = await prisma.table.create({
     *   data: {
     *     // ... data to create a Table
     *   }
     * })
     * 
     */
    create<T extends TableCreateArgs>(args: SelectSubset<T, TableCreateArgs<ExtArgs>>): Prisma__TableClient<$Result.GetResult<Prisma.$TablePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Tables.
     * @param {TableCreateManyArgs} args - Arguments to create many Tables.
     * @example
     * // Create many Tables
     * const table = await prisma.table.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TableCreateManyArgs>(args?: SelectSubset<T, TableCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Table.
     * @param {TableDeleteArgs} args - Arguments to delete one Table.
     * @example
     * // Delete one Table
     * const Table = await prisma.table.delete({
     *   where: {
     *     // ... filter to delete one Table
     *   }
     * })
     * 
     */
    delete<T extends TableDeleteArgs>(args: SelectSubset<T, TableDeleteArgs<ExtArgs>>): Prisma__TableClient<$Result.GetResult<Prisma.$TablePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Table.
     * @param {TableUpdateArgs} args - Arguments to update one Table.
     * @example
     * // Update one Table
     * const table = await prisma.table.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TableUpdateArgs>(args: SelectSubset<T, TableUpdateArgs<ExtArgs>>): Prisma__TableClient<$Result.GetResult<Prisma.$TablePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Tables.
     * @param {TableDeleteManyArgs} args - Arguments to filter Tables to delete.
     * @example
     * // Delete a few Tables
     * const { count } = await prisma.table.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TableDeleteManyArgs>(args?: SelectSubset<T, TableDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TableUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tables
     * const table = await prisma.table.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TableUpdateManyArgs>(args: SelectSubset<T, TableUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Table.
     * @param {TableUpsertArgs} args - Arguments to update or create a Table.
     * @example
     * // Update or create a Table
     * const table = await prisma.table.upsert({
     *   create: {
     *     // ... data to create a Table
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Table we want to update
     *   }
     * })
     */
    upsert<T extends TableUpsertArgs>(args: SelectSubset<T, TableUpsertArgs<ExtArgs>>): Prisma__TableClient<$Result.GetResult<Prisma.$TablePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Tables that matches the filter.
     * @param {TableFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const table = await prisma.table.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: TableFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Table.
     * @param {TableAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const table = await prisma.table.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: TableAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Tables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TableCountArgs} args - Arguments to filter Tables to count.
     * @example
     * // Count the number of Tables
     * const count = await prisma.table.count({
     *   where: {
     *     // ... the filter for the Tables we want to count
     *   }
     * })
    **/
    count<T extends TableCountArgs>(
      args?: Subset<T, TableCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TableCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Table.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TableAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TableAggregateArgs>(args: Subset<T, TableAggregateArgs>): Prisma.PrismaPromise<GetTableAggregateType<T>>

    /**
     * Group by Table.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TableGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TableGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TableGroupByArgs['orderBy'] }
        : { orderBy?: TableGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TableGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTableGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Table model
   */
  readonly fields: TableFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Table.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TableClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    instance<T extends InstanceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InstanceDefaultArgs<ExtArgs>>): Prisma__InstanceClient<$Result.GetResult<Prisma.$InstancePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    tableData<T extends Table$tableDataArgs<ExtArgs> = {}>(args?: Subset<T, Table$tableDataArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TableDataPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Table model
   */ 
  interface TableFieldRefs {
    readonly id: FieldRef<"Table", 'String'>
    readonly clientId: FieldRef<"Table", 'String'>
    readonly instanceId: FieldRef<"Table", 'String'>
    readonly name: FieldRef<"Table", 'String'>
    readonly code: FieldRef<"Table", 'String'>
    readonly description: FieldRef<"Table", 'String'>
    readonly createdAt: FieldRef<"Table", 'DateTime'>
    readonly updatedAt: FieldRef<"Table", 'DateTime'>
    readonly status: FieldRef<"Table", 'ModelStatus'>
  }
    

  // Custom InputTypes
  /**
   * Table findUnique
   */
  export type TableFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Table
     */
    select?: TableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Table
     */
    omit?: TableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableInclude<ExtArgs> | null
    /**
     * Filter, which Table to fetch.
     */
    where: TableWhereUniqueInput
  }

  /**
   * Table findUniqueOrThrow
   */
  export type TableFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Table
     */
    select?: TableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Table
     */
    omit?: TableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableInclude<ExtArgs> | null
    /**
     * Filter, which Table to fetch.
     */
    where: TableWhereUniqueInput
  }

  /**
   * Table findFirst
   */
  export type TableFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Table
     */
    select?: TableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Table
     */
    omit?: TableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableInclude<ExtArgs> | null
    /**
     * Filter, which Table to fetch.
     */
    where?: TableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tables to fetch.
     */
    orderBy?: TableOrderByWithRelationInput | TableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tables.
     */
    cursor?: TableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tables.
     */
    distinct?: TableScalarFieldEnum | TableScalarFieldEnum[]
  }

  /**
   * Table findFirstOrThrow
   */
  export type TableFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Table
     */
    select?: TableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Table
     */
    omit?: TableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableInclude<ExtArgs> | null
    /**
     * Filter, which Table to fetch.
     */
    where?: TableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tables to fetch.
     */
    orderBy?: TableOrderByWithRelationInput | TableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tables.
     */
    cursor?: TableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tables.
     */
    distinct?: TableScalarFieldEnum | TableScalarFieldEnum[]
  }

  /**
   * Table findMany
   */
  export type TableFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Table
     */
    select?: TableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Table
     */
    omit?: TableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableInclude<ExtArgs> | null
    /**
     * Filter, which Tables to fetch.
     */
    where?: TableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tables to fetch.
     */
    orderBy?: TableOrderByWithRelationInput | TableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tables.
     */
    cursor?: TableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tables.
     */
    skip?: number
    distinct?: TableScalarFieldEnum | TableScalarFieldEnum[]
  }

  /**
   * Table create
   */
  export type TableCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Table
     */
    select?: TableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Table
     */
    omit?: TableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableInclude<ExtArgs> | null
    /**
     * The data needed to create a Table.
     */
    data: XOR<TableCreateInput, TableUncheckedCreateInput>
  }

  /**
   * Table createMany
   */
  export type TableCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tables.
     */
    data: TableCreateManyInput | TableCreateManyInput[]
  }

  /**
   * Table update
   */
  export type TableUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Table
     */
    select?: TableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Table
     */
    omit?: TableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableInclude<ExtArgs> | null
    /**
     * The data needed to update a Table.
     */
    data: XOR<TableUpdateInput, TableUncheckedUpdateInput>
    /**
     * Choose, which Table to update.
     */
    where: TableWhereUniqueInput
  }

  /**
   * Table updateMany
   */
  export type TableUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tables.
     */
    data: XOR<TableUpdateManyMutationInput, TableUncheckedUpdateManyInput>
    /**
     * Filter which Tables to update
     */
    where?: TableWhereInput
    /**
     * Limit how many Tables to update.
     */
    limit?: number
  }

  /**
   * Table upsert
   */
  export type TableUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Table
     */
    select?: TableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Table
     */
    omit?: TableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableInclude<ExtArgs> | null
    /**
     * The filter to search for the Table to update in case it exists.
     */
    where: TableWhereUniqueInput
    /**
     * In case the Table found by the `where` argument doesn't exist, create a new Table with this data.
     */
    create: XOR<TableCreateInput, TableUncheckedCreateInput>
    /**
     * In case the Table was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TableUpdateInput, TableUncheckedUpdateInput>
  }

  /**
   * Table delete
   */
  export type TableDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Table
     */
    select?: TableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Table
     */
    omit?: TableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableInclude<ExtArgs> | null
    /**
     * Filter which Table to delete.
     */
    where: TableWhereUniqueInput
  }

  /**
   * Table deleteMany
   */
  export type TableDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tables to delete
     */
    where?: TableWhereInput
    /**
     * Limit how many Tables to delete.
     */
    limit?: number
  }

  /**
   * Table findRaw
   */
  export type TableFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Table aggregateRaw
   */
  export type TableAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Table.tableData
   */
  export type Table$tableDataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TableData
     */
    select?: TableDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TableData
     */
    omit?: TableDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableDataInclude<ExtArgs> | null
    where?: TableDataWhereInput
    orderBy?: TableDataOrderByWithRelationInput | TableDataOrderByWithRelationInput[]
    cursor?: TableDataWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TableDataScalarFieldEnum | TableDataScalarFieldEnum[]
  }

  /**
   * Table without action
   */
  export type TableDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Table
     */
    select?: TableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Table
     */
    omit?: TableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableInclude<ExtArgs> | null
  }


  /**
   * Model TableData
   */

  export type AggregateTableData = {
    _count: TableDataCountAggregateOutputType | null
    _min: TableDataMinAggregateOutputType | null
    _max: TableDataMaxAggregateOutputType | null
  }

  export type TableDataMinAggregateOutputType = {
    id: string | null
    clientId: string | null
    instanceId: string | null
    tableId: string | null
    rowKey: string | null
    versionId: string | null
    levelId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TableDataMaxAggregateOutputType = {
    id: string | null
    clientId: string | null
    instanceId: string | null
    tableId: string | null
    rowKey: string | null
    versionId: string | null
    levelId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TableDataCountAggregateOutputType = {
    id: number
    clientId: number
    instanceId: number
    tableId: number
    rowKey: number
    versionId: number
    levelId: number
    data: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TableDataMinAggregateInputType = {
    id?: true
    clientId?: true
    instanceId?: true
    tableId?: true
    rowKey?: true
    versionId?: true
    levelId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TableDataMaxAggregateInputType = {
    id?: true
    clientId?: true
    instanceId?: true
    tableId?: true
    rowKey?: true
    versionId?: true
    levelId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TableDataCountAggregateInputType = {
    id?: true
    clientId?: true
    instanceId?: true
    tableId?: true
    rowKey?: true
    versionId?: true
    levelId?: true
    data?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TableDataAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TableData to aggregate.
     */
    where?: TableDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TableData to fetch.
     */
    orderBy?: TableDataOrderByWithRelationInput | TableDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TableDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TableData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TableData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TableData
    **/
    _count?: true | TableDataCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TableDataMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TableDataMaxAggregateInputType
  }

  export type GetTableDataAggregateType<T extends TableDataAggregateArgs> = {
        [P in keyof T & keyof AggregateTableData]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTableData[P]>
      : GetScalarType<T[P], AggregateTableData[P]>
  }




  export type TableDataGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TableDataWhereInput
    orderBy?: TableDataOrderByWithAggregationInput | TableDataOrderByWithAggregationInput[]
    by: TableDataScalarFieldEnum[] | TableDataScalarFieldEnum
    having?: TableDataScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TableDataCountAggregateInputType | true
    _min?: TableDataMinAggregateInputType
    _max?: TableDataMaxAggregateInputType
  }

  export type TableDataGroupByOutputType = {
    id: string
    clientId: string
    instanceId: string
    tableId: string
    rowKey: string
    versionId: string
    levelId: string
    data: JsonValue
    createdAt: Date | null
    updatedAt: Date | null
    _count: TableDataCountAggregateOutputType | null
    _min: TableDataMinAggregateOutputType | null
    _max: TableDataMaxAggregateOutputType | null
  }

  type GetTableDataGroupByPayload<T extends TableDataGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TableDataGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TableDataGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TableDataGroupByOutputType[P]>
            : GetScalarType<T[P], TableDataGroupByOutputType[P]>
        }
      >
    >


  export type TableDataSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    instanceId?: boolean
    tableId?: boolean
    rowKey?: boolean
    versionId?: boolean
    levelId?: boolean
    data?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    table?: boolean | TableDefaultArgs<ExtArgs>
    instance?: boolean | InstanceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tableData"]>



  export type TableDataSelectScalar = {
    id?: boolean
    clientId?: boolean
    instanceId?: boolean
    tableId?: boolean
    rowKey?: boolean
    versionId?: boolean
    levelId?: boolean
    data?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TableDataOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "clientId" | "instanceId" | "tableId" | "rowKey" | "versionId" | "levelId" | "data" | "createdAt" | "updatedAt", ExtArgs["result"]["tableData"]>
  export type TableDataInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    table?: boolean | TableDefaultArgs<ExtArgs>
    instance?: boolean | InstanceDefaultArgs<ExtArgs>
  }

  export type $TableDataPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TableData"
    objects: {
      table: Prisma.$TablePayload<ExtArgs>
      instance: Prisma.$InstancePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clientId: string
      instanceId: string
      tableId: string
      rowKey: string
      versionId: string
      levelId: string
      data: Prisma.JsonValue
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["tableData"]>
    composites: {}
  }

  type TableDataGetPayload<S extends boolean | null | undefined | TableDataDefaultArgs> = $Result.GetResult<Prisma.$TableDataPayload, S>

  type TableDataCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TableDataFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TableDataCountAggregateInputType | true
    }

  export interface TableDataDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TableData'], meta: { name: 'TableData' } }
    /**
     * Find zero or one TableData that matches the filter.
     * @param {TableDataFindUniqueArgs} args - Arguments to find a TableData
     * @example
     * // Get one TableData
     * const tableData = await prisma.tableData.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TableDataFindUniqueArgs>(args: SelectSubset<T, TableDataFindUniqueArgs<ExtArgs>>): Prisma__TableDataClient<$Result.GetResult<Prisma.$TableDataPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one TableData that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TableDataFindUniqueOrThrowArgs} args - Arguments to find a TableData
     * @example
     * // Get one TableData
     * const tableData = await prisma.tableData.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TableDataFindUniqueOrThrowArgs>(args: SelectSubset<T, TableDataFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TableDataClient<$Result.GetResult<Prisma.$TableDataPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first TableData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TableDataFindFirstArgs} args - Arguments to find a TableData
     * @example
     * // Get one TableData
     * const tableData = await prisma.tableData.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TableDataFindFirstArgs>(args?: SelectSubset<T, TableDataFindFirstArgs<ExtArgs>>): Prisma__TableDataClient<$Result.GetResult<Prisma.$TableDataPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first TableData that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TableDataFindFirstOrThrowArgs} args - Arguments to find a TableData
     * @example
     * // Get one TableData
     * const tableData = await prisma.tableData.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TableDataFindFirstOrThrowArgs>(args?: SelectSubset<T, TableDataFindFirstOrThrowArgs<ExtArgs>>): Prisma__TableDataClient<$Result.GetResult<Prisma.$TableDataPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more TableData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TableDataFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TableData
     * const tableData = await prisma.tableData.findMany()
     * 
     * // Get first 10 TableData
     * const tableData = await prisma.tableData.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tableDataWithIdOnly = await prisma.tableData.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TableDataFindManyArgs>(args?: SelectSubset<T, TableDataFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TableDataPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a TableData.
     * @param {TableDataCreateArgs} args - Arguments to create a TableData.
     * @example
     * // Create one TableData
     * const TableData = await prisma.tableData.create({
     *   data: {
     *     // ... data to create a TableData
     *   }
     * })
     * 
     */
    create<T extends TableDataCreateArgs>(args: SelectSubset<T, TableDataCreateArgs<ExtArgs>>): Prisma__TableDataClient<$Result.GetResult<Prisma.$TableDataPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many TableData.
     * @param {TableDataCreateManyArgs} args - Arguments to create many TableData.
     * @example
     * // Create many TableData
     * const tableData = await prisma.tableData.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TableDataCreateManyArgs>(args?: SelectSubset<T, TableDataCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TableData.
     * @param {TableDataDeleteArgs} args - Arguments to delete one TableData.
     * @example
     * // Delete one TableData
     * const TableData = await prisma.tableData.delete({
     *   where: {
     *     // ... filter to delete one TableData
     *   }
     * })
     * 
     */
    delete<T extends TableDataDeleteArgs>(args: SelectSubset<T, TableDataDeleteArgs<ExtArgs>>): Prisma__TableDataClient<$Result.GetResult<Prisma.$TableDataPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one TableData.
     * @param {TableDataUpdateArgs} args - Arguments to update one TableData.
     * @example
     * // Update one TableData
     * const tableData = await prisma.tableData.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TableDataUpdateArgs>(args: SelectSubset<T, TableDataUpdateArgs<ExtArgs>>): Prisma__TableDataClient<$Result.GetResult<Prisma.$TableDataPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more TableData.
     * @param {TableDataDeleteManyArgs} args - Arguments to filter TableData to delete.
     * @example
     * // Delete a few TableData
     * const { count } = await prisma.tableData.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TableDataDeleteManyArgs>(args?: SelectSubset<T, TableDataDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TableData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TableDataUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TableData
     * const tableData = await prisma.tableData.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TableDataUpdateManyArgs>(args: SelectSubset<T, TableDataUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TableData.
     * @param {TableDataUpsertArgs} args - Arguments to update or create a TableData.
     * @example
     * // Update or create a TableData
     * const tableData = await prisma.tableData.upsert({
     *   create: {
     *     // ... data to create a TableData
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TableData we want to update
     *   }
     * })
     */
    upsert<T extends TableDataUpsertArgs>(args: SelectSubset<T, TableDataUpsertArgs<ExtArgs>>): Prisma__TableDataClient<$Result.GetResult<Prisma.$TableDataPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more TableData that matches the filter.
     * @param {TableDataFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const tableData = await prisma.tableData.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: TableDataFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a TableData.
     * @param {TableDataAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const tableData = await prisma.tableData.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: TableDataAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of TableData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TableDataCountArgs} args - Arguments to filter TableData to count.
     * @example
     * // Count the number of TableData
     * const count = await prisma.tableData.count({
     *   where: {
     *     // ... the filter for the TableData we want to count
     *   }
     * })
    **/
    count<T extends TableDataCountArgs>(
      args?: Subset<T, TableDataCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TableDataCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TableData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TableDataAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TableDataAggregateArgs>(args: Subset<T, TableDataAggregateArgs>): Prisma.PrismaPromise<GetTableDataAggregateType<T>>

    /**
     * Group by TableData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TableDataGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TableDataGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TableDataGroupByArgs['orderBy'] }
        : { orderBy?: TableDataGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TableDataGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTableDataGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TableData model
   */
  readonly fields: TableDataFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TableData.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TableDataClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    table<T extends TableDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TableDefaultArgs<ExtArgs>>): Prisma__TableClient<$Result.GetResult<Prisma.$TablePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    instance<T extends InstanceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InstanceDefaultArgs<ExtArgs>>): Prisma__InstanceClient<$Result.GetResult<Prisma.$InstancePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TableData model
   */ 
  interface TableDataFieldRefs {
    readonly id: FieldRef<"TableData", 'String'>
    readonly clientId: FieldRef<"TableData", 'String'>
    readonly instanceId: FieldRef<"TableData", 'String'>
    readonly tableId: FieldRef<"TableData", 'String'>
    readonly rowKey: FieldRef<"TableData", 'String'>
    readonly versionId: FieldRef<"TableData", 'String'>
    readonly levelId: FieldRef<"TableData", 'String'>
    readonly data: FieldRef<"TableData", 'Json'>
    readonly createdAt: FieldRef<"TableData", 'DateTime'>
    readonly updatedAt: FieldRef<"TableData", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TableData findUnique
   */
  export type TableDataFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TableData
     */
    select?: TableDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TableData
     */
    omit?: TableDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableDataInclude<ExtArgs> | null
    /**
     * Filter, which TableData to fetch.
     */
    where: TableDataWhereUniqueInput
  }

  /**
   * TableData findUniqueOrThrow
   */
  export type TableDataFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TableData
     */
    select?: TableDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TableData
     */
    omit?: TableDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableDataInclude<ExtArgs> | null
    /**
     * Filter, which TableData to fetch.
     */
    where: TableDataWhereUniqueInput
  }

  /**
   * TableData findFirst
   */
  export type TableDataFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TableData
     */
    select?: TableDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TableData
     */
    omit?: TableDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableDataInclude<ExtArgs> | null
    /**
     * Filter, which TableData to fetch.
     */
    where?: TableDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TableData to fetch.
     */
    orderBy?: TableDataOrderByWithRelationInput | TableDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TableData.
     */
    cursor?: TableDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TableData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TableData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TableData.
     */
    distinct?: TableDataScalarFieldEnum | TableDataScalarFieldEnum[]
  }

  /**
   * TableData findFirstOrThrow
   */
  export type TableDataFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TableData
     */
    select?: TableDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TableData
     */
    omit?: TableDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableDataInclude<ExtArgs> | null
    /**
     * Filter, which TableData to fetch.
     */
    where?: TableDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TableData to fetch.
     */
    orderBy?: TableDataOrderByWithRelationInput | TableDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TableData.
     */
    cursor?: TableDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TableData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TableData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TableData.
     */
    distinct?: TableDataScalarFieldEnum | TableDataScalarFieldEnum[]
  }

  /**
   * TableData findMany
   */
  export type TableDataFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TableData
     */
    select?: TableDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TableData
     */
    omit?: TableDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableDataInclude<ExtArgs> | null
    /**
     * Filter, which TableData to fetch.
     */
    where?: TableDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TableData to fetch.
     */
    orderBy?: TableDataOrderByWithRelationInput | TableDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TableData.
     */
    cursor?: TableDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TableData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TableData.
     */
    skip?: number
    distinct?: TableDataScalarFieldEnum | TableDataScalarFieldEnum[]
  }

  /**
   * TableData create
   */
  export type TableDataCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TableData
     */
    select?: TableDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TableData
     */
    omit?: TableDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableDataInclude<ExtArgs> | null
    /**
     * The data needed to create a TableData.
     */
    data: XOR<TableDataCreateInput, TableDataUncheckedCreateInput>
  }

  /**
   * TableData createMany
   */
  export type TableDataCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TableData.
     */
    data: TableDataCreateManyInput | TableDataCreateManyInput[]
  }

  /**
   * TableData update
   */
  export type TableDataUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TableData
     */
    select?: TableDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TableData
     */
    omit?: TableDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableDataInclude<ExtArgs> | null
    /**
     * The data needed to update a TableData.
     */
    data: XOR<TableDataUpdateInput, TableDataUncheckedUpdateInput>
    /**
     * Choose, which TableData to update.
     */
    where: TableDataWhereUniqueInput
  }

  /**
   * TableData updateMany
   */
  export type TableDataUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TableData.
     */
    data: XOR<TableDataUpdateManyMutationInput, TableDataUncheckedUpdateManyInput>
    /**
     * Filter which TableData to update
     */
    where?: TableDataWhereInput
    /**
     * Limit how many TableData to update.
     */
    limit?: number
  }

  /**
   * TableData upsert
   */
  export type TableDataUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TableData
     */
    select?: TableDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TableData
     */
    omit?: TableDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableDataInclude<ExtArgs> | null
    /**
     * The filter to search for the TableData to update in case it exists.
     */
    where: TableDataWhereUniqueInput
    /**
     * In case the TableData found by the `where` argument doesn't exist, create a new TableData with this data.
     */
    create: XOR<TableDataCreateInput, TableDataUncheckedCreateInput>
    /**
     * In case the TableData was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TableDataUpdateInput, TableDataUncheckedUpdateInput>
  }

  /**
   * TableData delete
   */
  export type TableDataDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TableData
     */
    select?: TableDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TableData
     */
    omit?: TableDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableDataInclude<ExtArgs> | null
    /**
     * Filter which TableData to delete.
     */
    where: TableDataWhereUniqueInput
  }

  /**
   * TableData deleteMany
   */
  export type TableDataDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TableData to delete
     */
    where?: TableDataWhereInput
    /**
     * Limit how many TableData to delete.
     */
    limit?: number
  }

  /**
   * TableData findRaw
   */
  export type TableDataFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * TableData aggregateRaw
   */
  export type TableDataAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * TableData without action
   */
  export type TableDataDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TableData
     */
    select?: TableDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TableData
     */
    omit?: TableDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableDataInclude<ExtArgs> | null
  }


  /**
   * Model DataSource
   */

  export type AggregateDataSource = {
    _count: DataSourceCountAggregateOutputType | null
    _min: DataSourceMinAggregateOutputType | null
    _max: DataSourceMaxAggregateOutputType | null
  }

  export type DataSourceMinAggregateOutputType = {
    id: string | null
    clientId: string | null
    instanceId: string | null
    name: string | null
    code: string | null
    credentialId: string | null
    description: string | null
    type: $Enums.DataSourceType | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DataSourceMaxAggregateOutputType = {
    id: string | null
    clientId: string | null
    instanceId: string | null
    name: string | null
    code: string | null
    credentialId: string | null
    description: string | null
    type: $Enums.DataSourceType | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DataSourceCountAggregateOutputType = {
    id: number
    clientId: number
    instanceId: number
    name: number
    code: number
    credentialId: number
    description: number
    type: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DataSourceMinAggregateInputType = {
    id?: true
    clientId?: true
    instanceId?: true
    name?: true
    code?: true
    credentialId?: true
    description?: true
    type?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DataSourceMaxAggregateInputType = {
    id?: true
    clientId?: true
    instanceId?: true
    name?: true
    code?: true
    credentialId?: true
    description?: true
    type?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DataSourceCountAggregateInputType = {
    id?: true
    clientId?: true
    instanceId?: true
    name?: true
    code?: true
    credentialId?: true
    description?: true
    type?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DataSourceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DataSource to aggregate.
     */
    where?: DataSourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataSources to fetch.
     */
    orderBy?: DataSourceOrderByWithRelationInput | DataSourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DataSourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataSources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataSources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DataSources
    **/
    _count?: true | DataSourceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DataSourceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DataSourceMaxAggregateInputType
  }

  export type GetDataSourceAggregateType<T extends DataSourceAggregateArgs> = {
        [P in keyof T & keyof AggregateDataSource]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDataSource[P]>
      : GetScalarType<T[P], AggregateDataSource[P]>
  }




  export type DataSourceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DataSourceWhereInput
    orderBy?: DataSourceOrderByWithAggregationInput | DataSourceOrderByWithAggregationInput[]
    by: DataSourceScalarFieldEnum[] | DataSourceScalarFieldEnum
    having?: DataSourceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DataSourceCountAggregateInputType | true
    _min?: DataSourceMinAggregateInputType
    _max?: DataSourceMaxAggregateInputType
  }

  export type DataSourceGroupByOutputType = {
    id: string
    clientId: string
    instanceId: string
    name: string
    code: string
    credentialId: string | null
    description: string | null
    type: $Enums.DataSourceType
    createdAt: Date | null
    updatedAt: Date | null
    _count: DataSourceCountAggregateOutputType | null
    _min: DataSourceMinAggregateOutputType | null
    _max: DataSourceMaxAggregateOutputType | null
  }

  type GetDataSourceGroupByPayload<T extends DataSourceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DataSourceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DataSourceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DataSourceGroupByOutputType[P]>
            : GetScalarType<T[P], DataSourceGroupByOutputType[P]>
        }
      >
    >


  export type DataSourceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    instanceId?: boolean
    name?: boolean
    code?: boolean
    credentialId?: boolean
    description?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    credential?: boolean | DataSource$credentialArgs<ExtArgs>
  }, ExtArgs["result"]["dataSource"]>



  export type DataSourceSelectScalar = {
    id?: boolean
    clientId?: boolean
    instanceId?: boolean
    name?: boolean
    code?: boolean
    credentialId?: boolean
    description?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DataSourceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "clientId" | "instanceId" | "name" | "code" | "credentialId" | "description" | "type" | "createdAt" | "updatedAt", ExtArgs["result"]["dataSource"]>
  export type DataSourceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    credential?: boolean | DataSource$credentialArgs<ExtArgs>
  }

  export type $DataSourcePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DataSource"
    objects: {
      credential: Prisma.$DataSourceCredentialPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clientId: string
      instanceId: string
      name: string
      code: string
      credentialId: string | null
      description: string | null
      type: $Enums.DataSourceType
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["dataSource"]>
    composites: {}
  }

  type DataSourceGetPayload<S extends boolean | null | undefined | DataSourceDefaultArgs> = $Result.GetResult<Prisma.$DataSourcePayload, S>

  type DataSourceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DataSourceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DataSourceCountAggregateInputType | true
    }

  export interface DataSourceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DataSource'], meta: { name: 'DataSource' } }
    /**
     * Find zero or one DataSource that matches the filter.
     * @param {DataSourceFindUniqueArgs} args - Arguments to find a DataSource
     * @example
     * // Get one DataSource
     * const dataSource = await prisma.dataSource.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DataSourceFindUniqueArgs>(args: SelectSubset<T, DataSourceFindUniqueArgs<ExtArgs>>): Prisma__DataSourceClient<$Result.GetResult<Prisma.$DataSourcePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one DataSource that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DataSourceFindUniqueOrThrowArgs} args - Arguments to find a DataSource
     * @example
     * // Get one DataSource
     * const dataSource = await prisma.dataSource.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DataSourceFindUniqueOrThrowArgs>(args: SelectSubset<T, DataSourceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DataSourceClient<$Result.GetResult<Prisma.$DataSourcePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first DataSource that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataSourceFindFirstArgs} args - Arguments to find a DataSource
     * @example
     * // Get one DataSource
     * const dataSource = await prisma.dataSource.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DataSourceFindFirstArgs>(args?: SelectSubset<T, DataSourceFindFirstArgs<ExtArgs>>): Prisma__DataSourceClient<$Result.GetResult<Prisma.$DataSourcePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first DataSource that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataSourceFindFirstOrThrowArgs} args - Arguments to find a DataSource
     * @example
     * // Get one DataSource
     * const dataSource = await prisma.dataSource.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DataSourceFindFirstOrThrowArgs>(args?: SelectSubset<T, DataSourceFindFirstOrThrowArgs<ExtArgs>>): Prisma__DataSourceClient<$Result.GetResult<Prisma.$DataSourcePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more DataSources that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataSourceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DataSources
     * const dataSources = await prisma.dataSource.findMany()
     * 
     * // Get first 10 DataSources
     * const dataSources = await prisma.dataSource.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dataSourceWithIdOnly = await prisma.dataSource.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DataSourceFindManyArgs>(args?: SelectSubset<T, DataSourceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DataSourcePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a DataSource.
     * @param {DataSourceCreateArgs} args - Arguments to create a DataSource.
     * @example
     * // Create one DataSource
     * const DataSource = await prisma.dataSource.create({
     *   data: {
     *     // ... data to create a DataSource
     *   }
     * })
     * 
     */
    create<T extends DataSourceCreateArgs>(args: SelectSubset<T, DataSourceCreateArgs<ExtArgs>>): Prisma__DataSourceClient<$Result.GetResult<Prisma.$DataSourcePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many DataSources.
     * @param {DataSourceCreateManyArgs} args - Arguments to create many DataSources.
     * @example
     * // Create many DataSources
     * const dataSource = await prisma.dataSource.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DataSourceCreateManyArgs>(args?: SelectSubset<T, DataSourceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DataSource.
     * @param {DataSourceDeleteArgs} args - Arguments to delete one DataSource.
     * @example
     * // Delete one DataSource
     * const DataSource = await prisma.dataSource.delete({
     *   where: {
     *     // ... filter to delete one DataSource
     *   }
     * })
     * 
     */
    delete<T extends DataSourceDeleteArgs>(args: SelectSubset<T, DataSourceDeleteArgs<ExtArgs>>): Prisma__DataSourceClient<$Result.GetResult<Prisma.$DataSourcePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one DataSource.
     * @param {DataSourceUpdateArgs} args - Arguments to update one DataSource.
     * @example
     * // Update one DataSource
     * const dataSource = await prisma.dataSource.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DataSourceUpdateArgs>(args: SelectSubset<T, DataSourceUpdateArgs<ExtArgs>>): Prisma__DataSourceClient<$Result.GetResult<Prisma.$DataSourcePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more DataSources.
     * @param {DataSourceDeleteManyArgs} args - Arguments to filter DataSources to delete.
     * @example
     * // Delete a few DataSources
     * const { count } = await prisma.dataSource.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DataSourceDeleteManyArgs>(args?: SelectSubset<T, DataSourceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DataSources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataSourceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DataSources
     * const dataSource = await prisma.dataSource.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DataSourceUpdateManyArgs>(args: SelectSubset<T, DataSourceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DataSource.
     * @param {DataSourceUpsertArgs} args - Arguments to update or create a DataSource.
     * @example
     * // Update or create a DataSource
     * const dataSource = await prisma.dataSource.upsert({
     *   create: {
     *     // ... data to create a DataSource
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DataSource we want to update
     *   }
     * })
     */
    upsert<T extends DataSourceUpsertArgs>(args: SelectSubset<T, DataSourceUpsertArgs<ExtArgs>>): Prisma__DataSourceClient<$Result.GetResult<Prisma.$DataSourcePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more DataSources that matches the filter.
     * @param {DataSourceFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const dataSource = await prisma.dataSource.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: DataSourceFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a DataSource.
     * @param {DataSourceAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const dataSource = await prisma.dataSource.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: DataSourceAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of DataSources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataSourceCountArgs} args - Arguments to filter DataSources to count.
     * @example
     * // Count the number of DataSources
     * const count = await prisma.dataSource.count({
     *   where: {
     *     // ... the filter for the DataSources we want to count
     *   }
     * })
    **/
    count<T extends DataSourceCountArgs>(
      args?: Subset<T, DataSourceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DataSourceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DataSource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataSourceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DataSourceAggregateArgs>(args: Subset<T, DataSourceAggregateArgs>): Prisma.PrismaPromise<GetDataSourceAggregateType<T>>

    /**
     * Group by DataSource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataSourceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DataSourceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DataSourceGroupByArgs['orderBy'] }
        : { orderBy?: DataSourceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DataSourceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDataSourceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DataSource model
   */
  readonly fields: DataSourceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DataSource.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DataSourceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    credential<T extends DataSource$credentialArgs<ExtArgs> = {}>(args?: Subset<T, DataSource$credentialArgs<ExtArgs>>): Prisma__DataSourceCredentialClient<$Result.GetResult<Prisma.$DataSourceCredentialPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DataSource model
   */ 
  interface DataSourceFieldRefs {
    readonly id: FieldRef<"DataSource", 'String'>
    readonly clientId: FieldRef<"DataSource", 'String'>
    readonly instanceId: FieldRef<"DataSource", 'String'>
    readonly name: FieldRef<"DataSource", 'String'>
    readonly code: FieldRef<"DataSource", 'String'>
    readonly credentialId: FieldRef<"DataSource", 'String'>
    readonly description: FieldRef<"DataSource", 'String'>
    readonly type: FieldRef<"DataSource", 'DataSourceType'>
    readonly createdAt: FieldRef<"DataSource", 'DateTime'>
    readonly updatedAt: FieldRef<"DataSource", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DataSource findUnique
   */
  export type DataSourceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataSource
     */
    select?: DataSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataSource
     */
    omit?: DataSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataSourceInclude<ExtArgs> | null
    /**
     * Filter, which DataSource to fetch.
     */
    where: DataSourceWhereUniqueInput
  }

  /**
   * DataSource findUniqueOrThrow
   */
  export type DataSourceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataSource
     */
    select?: DataSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataSource
     */
    omit?: DataSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataSourceInclude<ExtArgs> | null
    /**
     * Filter, which DataSource to fetch.
     */
    where: DataSourceWhereUniqueInput
  }

  /**
   * DataSource findFirst
   */
  export type DataSourceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataSource
     */
    select?: DataSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataSource
     */
    omit?: DataSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataSourceInclude<ExtArgs> | null
    /**
     * Filter, which DataSource to fetch.
     */
    where?: DataSourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataSources to fetch.
     */
    orderBy?: DataSourceOrderByWithRelationInput | DataSourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DataSources.
     */
    cursor?: DataSourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataSources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataSources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DataSources.
     */
    distinct?: DataSourceScalarFieldEnum | DataSourceScalarFieldEnum[]
  }

  /**
   * DataSource findFirstOrThrow
   */
  export type DataSourceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataSource
     */
    select?: DataSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataSource
     */
    omit?: DataSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataSourceInclude<ExtArgs> | null
    /**
     * Filter, which DataSource to fetch.
     */
    where?: DataSourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataSources to fetch.
     */
    orderBy?: DataSourceOrderByWithRelationInput | DataSourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DataSources.
     */
    cursor?: DataSourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataSources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataSources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DataSources.
     */
    distinct?: DataSourceScalarFieldEnum | DataSourceScalarFieldEnum[]
  }

  /**
   * DataSource findMany
   */
  export type DataSourceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataSource
     */
    select?: DataSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataSource
     */
    omit?: DataSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataSourceInclude<ExtArgs> | null
    /**
     * Filter, which DataSources to fetch.
     */
    where?: DataSourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataSources to fetch.
     */
    orderBy?: DataSourceOrderByWithRelationInput | DataSourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DataSources.
     */
    cursor?: DataSourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataSources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataSources.
     */
    skip?: number
    distinct?: DataSourceScalarFieldEnum | DataSourceScalarFieldEnum[]
  }

  /**
   * DataSource create
   */
  export type DataSourceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataSource
     */
    select?: DataSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataSource
     */
    omit?: DataSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataSourceInclude<ExtArgs> | null
    /**
     * The data needed to create a DataSource.
     */
    data: XOR<DataSourceCreateInput, DataSourceUncheckedCreateInput>
  }

  /**
   * DataSource createMany
   */
  export type DataSourceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DataSources.
     */
    data: DataSourceCreateManyInput | DataSourceCreateManyInput[]
  }

  /**
   * DataSource update
   */
  export type DataSourceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataSource
     */
    select?: DataSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataSource
     */
    omit?: DataSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataSourceInclude<ExtArgs> | null
    /**
     * The data needed to update a DataSource.
     */
    data: XOR<DataSourceUpdateInput, DataSourceUncheckedUpdateInput>
    /**
     * Choose, which DataSource to update.
     */
    where: DataSourceWhereUniqueInput
  }

  /**
   * DataSource updateMany
   */
  export type DataSourceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DataSources.
     */
    data: XOR<DataSourceUpdateManyMutationInput, DataSourceUncheckedUpdateManyInput>
    /**
     * Filter which DataSources to update
     */
    where?: DataSourceWhereInput
    /**
     * Limit how many DataSources to update.
     */
    limit?: number
  }

  /**
   * DataSource upsert
   */
  export type DataSourceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataSource
     */
    select?: DataSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataSource
     */
    omit?: DataSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataSourceInclude<ExtArgs> | null
    /**
     * The filter to search for the DataSource to update in case it exists.
     */
    where: DataSourceWhereUniqueInput
    /**
     * In case the DataSource found by the `where` argument doesn't exist, create a new DataSource with this data.
     */
    create: XOR<DataSourceCreateInput, DataSourceUncheckedCreateInput>
    /**
     * In case the DataSource was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DataSourceUpdateInput, DataSourceUncheckedUpdateInput>
  }

  /**
   * DataSource delete
   */
  export type DataSourceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataSource
     */
    select?: DataSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataSource
     */
    omit?: DataSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataSourceInclude<ExtArgs> | null
    /**
     * Filter which DataSource to delete.
     */
    where: DataSourceWhereUniqueInput
  }

  /**
   * DataSource deleteMany
   */
  export type DataSourceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DataSources to delete
     */
    where?: DataSourceWhereInput
    /**
     * Limit how many DataSources to delete.
     */
    limit?: number
  }

  /**
   * DataSource findRaw
   */
  export type DataSourceFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * DataSource aggregateRaw
   */
  export type DataSourceAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * DataSource.credential
   */
  export type DataSource$credentialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataSourceCredential
     */
    select?: DataSourceCredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataSourceCredential
     */
    omit?: DataSourceCredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataSourceCredentialInclude<ExtArgs> | null
    where?: DataSourceCredentialWhereInput
  }

  /**
   * DataSource without action
   */
  export type DataSourceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataSource
     */
    select?: DataSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataSource
     */
    omit?: DataSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataSourceInclude<ExtArgs> | null
  }


  /**
   * Model DataSourceTask
   */

  export type AggregateDataSourceTask = {
    _count: DataSourceTaskCountAggregateOutputType | null
    _min: DataSourceTaskMinAggregateOutputType | null
    _max: DataSourceTaskMaxAggregateOutputType | null
  }

  export type DataSourceTaskMinAggregateOutputType = {
    id: string | null
    clientId: string | null
    instanceId: string | null
    name: string | null
    code: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DataSourceTaskMaxAggregateOutputType = {
    id: string | null
    clientId: string | null
    instanceId: string | null
    name: string | null
    code: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DataSourceTaskCountAggregateOutputType = {
    id: number
    clientId: number
    instanceId: number
    name: number
    code: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DataSourceTaskMinAggregateInputType = {
    id?: true
    clientId?: true
    instanceId?: true
    name?: true
    code?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DataSourceTaskMaxAggregateInputType = {
    id?: true
    clientId?: true
    instanceId?: true
    name?: true
    code?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DataSourceTaskCountAggregateInputType = {
    id?: true
    clientId?: true
    instanceId?: true
    name?: true
    code?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DataSourceTaskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DataSourceTask to aggregate.
     */
    where?: DataSourceTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataSourceTasks to fetch.
     */
    orderBy?: DataSourceTaskOrderByWithRelationInput | DataSourceTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DataSourceTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataSourceTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataSourceTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DataSourceTasks
    **/
    _count?: true | DataSourceTaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DataSourceTaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DataSourceTaskMaxAggregateInputType
  }

  export type GetDataSourceTaskAggregateType<T extends DataSourceTaskAggregateArgs> = {
        [P in keyof T & keyof AggregateDataSourceTask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDataSourceTask[P]>
      : GetScalarType<T[P], AggregateDataSourceTask[P]>
  }




  export type DataSourceTaskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DataSourceTaskWhereInput
    orderBy?: DataSourceTaskOrderByWithAggregationInput | DataSourceTaskOrderByWithAggregationInput[]
    by: DataSourceTaskScalarFieldEnum[] | DataSourceTaskScalarFieldEnum
    having?: DataSourceTaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DataSourceTaskCountAggregateInputType | true
    _min?: DataSourceTaskMinAggregateInputType
    _max?: DataSourceTaskMaxAggregateInputType
  }

  export type DataSourceTaskGroupByOutputType = {
    id: string
    clientId: string
    instanceId: string
    name: string
    code: string
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    _count: DataSourceTaskCountAggregateOutputType | null
    _min: DataSourceTaskMinAggregateOutputType | null
    _max: DataSourceTaskMaxAggregateOutputType | null
  }

  type GetDataSourceTaskGroupByPayload<T extends DataSourceTaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DataSourceTaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DataSourceTaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DataSourceTaskGroupByOutputType[P]>
            : GetScalarType<T[P], DataSourceTaskGroupByOutputType[P]>
        }
      >
    >


  export type DataSourceTaskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    instanceId?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["dataSourceTask"]>



  export type DataSourceTaskSelectScalar = {
    id?: boolean
    clientId?: boolean
    instanceId?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DataSourceTaskOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "clientId" | "instanceId" | "name" | "code" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["dataSourceTask"]>

  export type $DataSourceTaskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DataSourceTask"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clientId: string
      instanceId: string
      name: string
      code: string
      description: string | null
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["dataSourceTask"]>
    composites: {}
  }

  type DataSourceTaskGetPayload<S extends boolean | null | undefined | DataSourceTaskDefaultArgs> = $Result.GetResult<Prisma.$DataSourceTaskPayload, S>

  type DataSourceTaskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DataSourceTaskFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DataSourceTaskCountAggregateInputType | true
    }

  export interface DataSourceTaskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DataSourceTask'], meta: { name: 'DataSourceTask' } }
    /**
     * Find zero or one DataSourceTask that matches the filter.
     * @param {DataSourceTaskFindUniqueArgs} args - Arguments to find a DataSourceTask
     * @example
     * // Get one DataSourceTask
     * const dataSourceTask = await prisma.dataSourceTask.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DataSourceTaskFindUniqueArgs>(args: SelectSubset<T, DataSourceTaskFindUniqueArgs<ExtArgs>>): Prisma__DataSourceTaskClient<$Result.GetResult<Prisma.$DataSourceTaskPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one DataSourceTask that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DataSourceTaskFindUniqueOrThrowArgs} args - Arguments to find a DataSourceTask
     * @example
     * // Get one DataSourceTask
     * const dataSourceTask = await prisma.dataSourceTask.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DataSourceTaskFindUniqueOrThrowArgs>(args: SelectSubset<T, DataSourceTaskFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DataSourceTaskClient<$Result.GetResult<Prisma.$DataSourceTaskPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first DataSourceTask that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataSourceTaskFindFirstArgs} args - Arguments to find a DataSourceTask
     * @example
     * // Get one DataSourceTask
     * const dataSourceTask = await prisma.dataSourceTask.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DataSourceTaskFindFirstArgs>(args?: SelectSubset<T, DataSourceTaskFindFirstArgs<ExtArgs>>): Prisma__DataSourceTaskClient<$Result.GetResult<Prisma.$DataSourceTaskPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first DataSourceTask that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataSourceTaskFindFirstOrThrowArgs} args - Arguments to find a DataSourceTask
     * @example
     * // Get one DataSourceTask
     * const dataSourceTask = await prisma.dataSourceTask.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DataSourceTaskFindFirstOrThrowArgs>(args?: SelectSubset<T, DataSourceTaskFindFirstOrThrowArgs<ExtArgs>>): Prisma__DataSourceTaskClient<$Result.GetResult<Prisma.$DataSourceTaskPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more DataSourceTasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataSourceTaskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DataSourceTasks
     * const dataSourceTasks = await prisma.dataSourceTask.findMany()
     * 
     * // Get first 10 DataSourceTasks
     * const dataSourceTasks = await prisma.dataSourceTask.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dataSourceTaskWithIdOnly = await prisma.dataSourceTask.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DataSourceTaskFindManyArgs>(args?: SelectSubset<T, DataSourceTaskFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DataSourceTaskPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a DataSourceTask.
     * @param {DataSourceTaskCreateArgs} args - Arguments to create a DataSourceTask.
     * @example
     * // Create one DataSourceTask
     * const DataSourceTask = await prisma.dataSourceTask.create({
     *   data: {
     *     // ... data to create a DataSourceTask
     *   }
     * })
     * 
     */
    create<T extends DataSourceTaskCreateArgs>(args: SelectSubset<T, DataSourceTaskCreateArgs<ExtArgs>>): Prisma__DataSourceTaskClient<$Result.GetResult<Prisma.$DataSourceTaskPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many DataSourceTasks.
     * @param {DataSourceTaskCreateManyArgs} args - Arguments to create many DataSourceTasks.
     * @example
     * // Create many DataSourceTasks
     * const dataSourceTask = await prisma.dataSourceTask.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DataSourceTaskCreateManyArgs>(args?: SelectSubset<T, DataSourceTaskCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DataSourceTask.
     * @param {DataSourceTaskDeleteArgs} args - Arguments to delete one DataSourceTask.
     * @example
     * // Delete one DataSourceTask
     * const DataSourceTask = await prisma.dataSourceTask.delete({
     *   where: {
     *     // ... filter to delete one DataSourceTask
     *   }
     * })
     * 
     */
    delete<T extends DataSourceTaskDeleteArgs>(args: SelectSubset<T, DataSourceTaskDeleteArgs<ExtArgs>>): Prisma__DataSourceTaskClient<$Result.GetResult<Prisma.$DataSourceTaskPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one DataSourceTask.
     * @param {DataSourceTaskUpdateArgs} args - Arguments to update one DataSourceTask.
     * @example
     * // Update one DataSourceTask
     * const dataSourceTask = await prisma.dataSourceTask.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DataSourceTaskUpdateArgs>(args: SelectSubset<T, DataSourceTaskUpdateArgs<ExtArgs>>): Prisma__DataSourceTaskClient<$Result.GetResult<Prisma.$DataSourceTaskPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more DataSourceTasks.
     * @param {DataSourceTaskDeleteManyArgs} args - Arguments to filter DataSourceTasks to delete.
     * @example
     * // Delete a few DataSourceTasks
     * const { count } = await prisma.dataSourceTask.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DataSourceTaskDeleteManyArgs>(args?: SelectSubset<T, DataSourceTaskDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DataSourceTasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataSourceTaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DataSourceTasks
     * const dataSourceTask = await prisma.dataSourceTask.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DataSourceTaskUpdateManyArgs>(args: SelectSubset<T, DataSourceTaskUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DataSourceTask.
     * @param {DataSourceTaskUpsertArgs} args - Arguments to update or create a DataSourceTask.
     * @example
     * // Update or create a DataSourceTask
     * const dataSourceTask = await prisma.dataSourceTask.upsert({
     *   create: {
     *     // ... data to create a DataSourceTask
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DataSourceTask we want to update
     *   }
     * })
     */
    upsert<T extends DataSourceTaskUpsertArgs>(args: SelectSubset<T, DataSourceTaskUpsertArgs<ExtArgs>>): Prisma__DataSourceTaskClient<$Result.GetResult<Prisma.$DataSourceTaskPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more DataSourceTasks that matches the filter.
     * @param {DataSourceTaskFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const dataSourceTask = await prisma.dataSourceTask.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: DataSourceTaskFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a DataSourceTask.
     * @param {DataSourceTaskAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const dataSourceTask = await prisma.dataSourceTask.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: DataSourceTaskAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of DataSourceTasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataSourceTaskCountArgs} args - Arguments to filter DataSourceTasks to count.
     * @example
     * // Count the number of DataSourceTasks
     * const count = await prisma.dataSourceTask.count({
     *   where: {
     *     // ... the filter for the DataSourceTasks we want to count
     *   }
     * })
    **/
    count<T extends DataSourceTaskCountArgs>(
      args?: Subset<T, DataSourceTaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DataSourceTaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DataSourceTask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataSourceTaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DataSourceTaskAggregateArgs>(args: Subset<T, DataSourceTaskAggregateArgs>): Prisma.PrismaPromise<GetDataSourceTaskAggregateType<T>>

    /**
     * Group by DataSourceTask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataSourceTaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DataSourceTaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DataSourceTaskGroupByArgs['orderBy'] }
        : { orderBy?: DataSourceTaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DataSourceTaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDataSourceTaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DataSourceTask model
   */
  readonly fields: DataSourceTaskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DataSourceTask.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DataSourceTaskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DataSourceTask model
   */ 
  interface DataSourceTaskFieldRefs {
    readonly id: FieldRef<"DataSourceTask", 'String'>
    readonly clientId: FieldRef<"DataSourceTask", 'String'>
    readonly instanceId: FieldRef<"DataSourceTask", 'String'>
    readonly name: FieldRef<"DataSourceTask", 'String'>
    readonly code: FieldRef<"DataSourceTask", 'String'>
    readonly description: FieldRef<"DataSourceTask", 'String'>
    readonly createdAt: FieldRef<"DataSourceTask", 'DateTime'>
    readonly updatedAt: FieldRef<"DataSourceTask", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DataSourceTask findUnique
   */
  export type DataSourceTaskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataSourceTask
     */
    select?: DataSourceTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataSourceTask
     */
    omit?: DataSourceTaskOmit<ExtArgs> | null
    /**
     * Filter, which DataSourceTask to fetch.
     */
    where: DataSourceTaskWhereUniqueInput
  }

  /**
   * DataSourceTask findUniqueOrThrow
   */
  export type DataSourceTaskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataSourceTask
     */
    select?: DataSourceTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataSourceTask
     */
    omit?: DataSourceTaskOmit<ExtArgs> | null
    /**
     * Filter, which DataSourceTask to fetch.
     */
    where: DataSourceTaskWhereUniqueInput
  }

  /**
   * DataSourceTask findFirst
   */
  export type DataSourceTaskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataSourceTask
     */
    select?: DataSourceTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataSourceTask
     */
    omit?: DataSourceTaskOmit<ExtArgs> | null
    /**
     * Filter, which DataSourceTask to fetch.
     */
    where?: DataSourceTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataSourceTasks to fetch.
     */
    orderBy?: DataSourceTaskOrderByWithRelationInput | DataSourceTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DataSourceTasks.
     */
    cursor?: DataSourceTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataSourceTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataSourceTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DataSourceTasks.
     */
    distinct?: DataSourceTaskScalarFieldEnum | DataSourceTaskScalarFieldEnum[]
  }

  /**
   * DataSourceTask findFirstOrThrow
   */
  export type DataSourceTaskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataSourceTask
     */
    select?: DataSourceTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataSourceTask
     */
    omit?: DataSourceTaskOmit<ExtArgs> | null
    /**
     * Filter, which DataSourceTask to fetch.
     */
    where?: DataSourceTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataSourceTasks to fetch.
     */
    orderBy?: DataSourceTaskOrderByWithRelationInput | DataSourceTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DataSourceTasks.
     */
    cursor?: DataSourceTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataSourceTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataSourceTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DataSourceTasks.
     */
    distinct?: DataSourceTaskScalarFieldEnum | DataSourceTaskScalarFieldEnum[]
  }

  /**
   * DataSourceTask findMany
   */
  export type DataSourceTaskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataSourceTask
     */
    select?: DataSourceTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataSourceTask
     */
    omit?: DataSourceTaskOmit<ExtArgs> | null
    /**
     * Filter, which DataSourceTasks to fetch.
     */
    where?: DataSourceTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataSourceTasks to fetch.
     */
    orderBy?: DataSourceTaskOrderByWithRelationInput | DataSourceTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DataSourceTasks.
     */
    cursor?: DataSourceTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataSourceTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataSourceTasks.
     */
    skip?: number
    distinct?: DataSourceTaskScalarFieldEnum | DataSourceTaskScalarFieldEnum[]
  }

  /**
   * DataSourceTask create
   */
  export type DataSourceTaskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataSourceTask
     */
    select?: DataSourceTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataSourceTask
     */
    omit?: DataSourceTaskOmit<ExtArgs> | null
    /**
     * The data needed to create a DataSourceTask.
     */
    data: XOR<DataSourceTaskCreateInput, DataSourceTaskUncheckedCreateInput>
  }

  /**
   * DataSourceTask createMany
   */
  export type DataSourceTaskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DataSourceTasks.
     */
    data: DataSourceTaskCreateManyInput | DataSourceTaskCreateManyInput[]
  }

  /**
   * DataSourceTask update
   */
  export type DataSourceTaskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataSourceTask
     */
    select?: DataSourceTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataSourceTask
     */
    omit?: DataSourceTaskOmit<ExtArgs> | null
    /**
     * The data needed to update a DataSourceTask.
     */
    data: XOR<DataSourceTaskUpdateInput, DataSourceTaskUncheckedUpdateInput>
    /**
     * Choose, which DataSourceTask to update.
     */
    where: DataSourceTaskWhereUniqueInput
  }

  /**
   * DataSourceTask updateMany
   */
  export type DataSourceTaskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DataSourceTasks.
     */
    data: XOR<DataSourceTaskUpdateManyMutationInput, DataSourceTaskUncheckedUpdateManyInput>
    /**
     * Filter which DataSourceTasks to update
     */
    where?: DataSourceTaskWhereInput
    /**
     * Limit how many DataSourceTasks to update.
     */
    limit?: number
  }

  /**
   * DataSourceTask upsert
   */
  export type DataSourceTaskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataSourceTask
     */
    select?: DataSourceTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataSourceTask
     */
    omit?: DataSourceTaskOmit<ExtArgs> | null
    /**
     * The filter to search for the DataSourceTask to update in case it exists.
     */
    where: DataSourceTaskWhereUniqueInput
    /**
     * In case the DataSourceTask found by the `where` argument doesn't exist, create a new DataSourceTask with this data.
     */
    create: XOR<DataSourceTaskCreateInput, DataSourceTaskUncheckedCreateInput>
    /**
     * In case the DataSourceTask was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DataSourceTaskUpdateInput, DataSourceTaskUncheckedUpdateInput>
  }

  /**
   * DataSourceTask delete
   */
  export type DataSourceTaskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataSourceTask
     */
    select?: DataSourceTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataSourceTask
     */
    omit?: DataSourceTaskOmit<ExtArgs> | null
    /**
     * Filter which DataSourceTask to delete.
     */
    where: DataSourceTaskWhereUniqueInput
  }

  /**
   * DataSourceTask deleteMany
   */
  export type DataSourceTaskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DataSourceTasks to delete
     */
    where?: DataSourceTaskWhereInput
    /**
     * Limit how many DataSourceTasks to delete.
     */
    limit?: number
  }

  /**
   * DataSourceTask findRaw
   */
  export type DataSourceTaskFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * DataSourceTask aggregateRaw
   */
  export type DataSourceTaskAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * DataSourceTask without action
   */
  export type DataSourceTaskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataSourceTask
     */
    select?: DataSourceTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataSourceTask
     */
    omit?: DataSourceTaskOmit<ExtArgs> | null
  }


  /**
   * Model DataSourceLoader
   */

  export type AggregateDataSourceLoader = {
    _count: DataSourceLoaderCountAggregateOutputType | null
    _min: DataSourceLoaderMinAggregateOutputType | null
    _max: DataSourceLoaderMaxAggregateOutputType | null
  }

  export type DataSourceLoaderMinAggregateOutputType = {
    id: string | null
    clientId: string | null
    instanceId: string | null
    name: string | null
    code: string | null
    loaderType: $Enums.DataSourceLoaderType | null
    sourceTable: string | null
    planningElementId: string | null
    planningElementType: string | null
    versionId: string | null
    createElementIfNotFound: boolean | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DataSourceLoaderMaxAggregateOutputType = {
    id: string | null
    clientId: string | null
    instanceId: string | null
    name: string | null
    code: string | null
    loaderType: $Enums.DataSourceLoaderType | null
    sourceTable: string | null
    planningElementId: string | null
    planningElementType: string | null
    versionId: string | null
    createElementIfNotFound: boolean | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DataSourceLoaderCountAggregateOutputType = {
    id: number
    clientId: number
    instanceId: number
    name: number
    code: number
    loaderType: number
    sourceTable: number
    planningTable: number
    planningElementId: number
    planningElementType: number
    versionId: number
    createElementIfNotFound: number
    settingsOptions: number
    columnMappings: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DataSourceLoaderMinAggregateInputType = {
    id?: true
    clientId?: true
    instanceId?: true
    name?: true
    code?: true
    loaderType?: true
    sourceTable?: true
    planningElementId?: true
    planningElementType?: true
    versionId?: true
    createElementIfNotFound?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DataSourceLoaderMaxAggregateInputType = {
    id?: true
    clientId?: true
    instanceId?: true
    name?: true
    code?: true
    loaderType?: true
    sourceTable?: true
    planningElementId?: true
    planningElementType?: true
    versionId?: true
    createElementIfNotFound?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DataSourceLoaderCountAggregateInputType = {
    id?: true
    clientId?: true
    instanceId?: true
    name?: true
    code?: true
    loaderType?: true
    sourceTable?: true
    planningTable?: true
    planningElementId?: true
    planningElementType?: true
    versionId?: true
    createElementIfNotFound?: true
    settingsOptions?: true
    columnMappings?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DataSourceLoaderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DataSourceLoader to aggregate.
     */
    where?: DataSourceLoaderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataSourceLoaders to fetch.
     */
    orderBy?: DataSourceLoaderOrderByWithRelationInput | DataSourceLoaderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DataSourceLoaderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataSourceLoaders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataSourceLoaders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DataSourceLoaders
    **/
    _count?: true | DataSourceLoaderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DataSourceLoaderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DataSourceLoaderMaxAggregateInputType
  }

  export type GetDataSourceLoaderAggregateType<T extends DataSourceLoaderAggregateArgs> = {
        [P in keyof T & keyof AggregateDataSourceLoader]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDataSourceLoader[P]>
      : GetScalarType<T[P], AggregateDataSourceLoader[P]>
  }




  export type DataSourceLoaderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DataSourceLoaderWhereInput
    orderBy?: DataSourceLoaderOrderByWithAggregationInput | DataSourceLoaderOrderByWithAggregationInput[]
    by: DataSourceLoaderScalarFieldEnum[] | DataSourceLoaderScalarFieldEnum
    having?: DataSourceLoaderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DataSourceLoaderCountAggregateInputType | true
    _min?: DataSourceLoaderMinAggregateInputType
    _max?: DataSourceLoaderMaxAggregateInputType
  }

  export type DataSourceLoaderGroupByOutputType = {
    id: string
    clientId: string
    instanceId: string
    name: string
    code: string
    loaderType: $Enums.DataSourceLoaderType
    sourceTable: string | null
    planningTable: string[]
    planningElementId: string
    planningElementType: string
    versionId: string
    createElementIfNotFound: boolean | null
    settingsOptions: JsonValue | null
    columnMappings: JsonValue | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    _count: DataSourceLoaderCountAggregateOutputType | null
    _min: DataSourceLoaderMinAggregateOutputType | null
    _max: DataSourceLoaderMaxAggregateOutputType | null
  }

  type GetDataSourceLoaderGroupByPayload<T extends DataSourceLoaderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DataSourceLoaderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DataSourceLoaderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DataSourceLoaderGroupByOutputType[P]>
            : GetScalarType<T[P], DataSourceLoaderGroupByOutputType[P]>
        }
      >
    >


  export type DataSourceLoaderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    instanceId?: boolean
    name?: boolean
    code?: boolean
    loaderType?: boolean
    sourceTable?: boolean
    planningTable?: boolean
    planningElementId?: boolean
    planningElementType?: boolean
    versionId?: boolean
    createElementIfNotFound?: boolean
    settingsOptions?: boolean
    columnMappings?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["dataSourceLoader"]>



  export type DataSourceLoaderSelectScalar = {
    id?: boolean
    clientId?: boolean
    instanceId?: boolean
    name?: boolean
    code?: boolean
    loaderType?: boolean
    sourceTable?: boolean
    planningTable?: boolean
    planningElementId?: boolean
    planningElementType?: boolean
    versionId?: boolean
    createElementIfNotFound?: boolean
    settingsOptions?: boolean
    columnMappings?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DataSourceLoaderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "clientId" | "instanceId" | "name" | "code" | "loaderType" | "sourceTable" | "planningTable" | "planningElementId" | "planningElementType" | "versionId" | "createElementIfNotFound" | "settingsOptions" | "columnMappings" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["dataSourceLoader"]>

  export type $DataSourceLoaderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DataSourceLoader"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clientId: string
      instanceId: string
      name: string
      code: string
      loaderType: $Enums.DataSourceLoaderType
      sourceTable: string | null
      planningTable: string[]
      planningElementId: string
      planningElementType: string
      versionId: string
      createElementIfNotFound: boolean | null
      settingsOptions: Prisma.JsonValue | null
      columnMappings: Prisma.JsonValue | null
      description: string | null
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["dataSourceLoader"]>
    composites: {}
  }

  type DataSourceLoaderGetPayload<S extends boolean | null | undefined | DataSourceLoaderDefaultArgs> = $Result.GetResult<Prisma.$DataSourceLoaderPayload, S>

  type DataSourceLoaderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DataSourceLoaderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DataSourceLoaderCountAggregateInputType | true
    }

  export interface DataSourceLoaderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DataSourceLoader'], meta: { name: 'DataSourceLoader' } }
    /**
     * Find zero or one DataSourceLoader that matches the filter.
     * @param {DataSourceLoaderFindUniqueArgs} args - Arguments to find a DataSourceLoader
     * @example
     * // Get one DataSourceLoader
     * const dataSourceLoader = await prisma.dataSourceLoader.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DataSourceLoaderFindUniqueArgs>(args: SelectSubset<T, DataSourceLoaderFindUniqueArgs<ExtArgs>>): Prisma__DataSourceLoaderClient<$Result.GetResult<Prisma.$DataSourceLoaderPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one DataSourceLoader that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DataSourceLoaderFindUniqueOrThrowArgs} args - Arguments to find a DataSourceLoader
     * @example
     * // Get one DataSourceLoader
     * const dataSourceLoader = await prisma.dataSourceLoader.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DataSourceLoaderFindUniqueOrThrowArgs>(args: SelectSubset<T, DataSourceLoaderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DataSourceLoaderClient<$Result.GetResult<Prisma.$DataSourceLoaderPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first DataSourceLoader that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataSourceLoaderFindFirstArgs} args - Arguments to find a DataSourceLoader
     * @example
     * // Get one DataSourceLoader
     * const dataSourceLoader = await prisma.dataSourceLoader.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DataSourceLoaderFindFirstArgs>(args?: SelectSubset<T, DataSourceLoaderFindFirstArgs<ExtArgs>>): Prisma__DataSourceLoaderClient<$Result.GetResult<Prisma.$DataSourceLoaderPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first DataSourceLoader that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataSourceLoaderFindFirstOrThrowArgs} args - Arguments to find a DataSourceLoader
     * @example
     * // Get one DataSourceLoader
     * const dataSourceLoader = await prisma.dataSourceLoader.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DataSourceLoaderFindFirstOrThrowArgs>(args?: SelectSubset<T, DataSourceLoaderFindFirstOrThrowArgs<ExtArgs>>): Prisma__DataSourceLoaderClient<$Result.GetResult<Prisma.$DataSourceLoaderPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more DataSourceLoaders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataSourceLoaderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DataSourceLoaders
     * const dataSourceLoaders = await prisma.dataSourceLoader.findMany()
     * 
     * // Get first 10 DataSourceLoaders
     * const dataSourceLoaders = await prisma.dataSourceLoader.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dataSourceLoaderWithIdOnly = await prisma.dataSourceLoader.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DataSourceLoaderFindManyArgs>(args?: SelectSubset<T, DataSourceLoaderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DataSourceLoaderPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a DataSourceLoader.
     * @param {DataSourceLoaderCreateArgs} args - Arguments to create a DataSourceLoader.
     * @example
     * // Create one DataSourceLoader
     * const DataSourceLoader = await prisma.dataSourceLoader.create({
     *   data: {
     *     // ... data to create a DataSourceLoader
     *   }
     * })
     * 
     */
    create<T extends DataSourceLoaderCreateArgs>(args: SelectSubset<T, DataSourceLoaderCreateArgs<ExtArgs>>): Prisma__DataSourceLoaderClient<$Result.GetResult<Prisma.$DataSourceLoaderPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many DataSourceLoaders.
     * @param {DataSourceLoaderCreateManyArgs} args - Arguments to create many DataSourceLoaders.
     * @example
     * // Create many DataSourceLoaders
     * const dataSourceLoader = await prisma.dataSourceLoader.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DataSourceLoaderCreateManyArgs>(args?: SelectSubset<T, DataSourceLoaderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DataSourceLoader.
     * @param {DataSourceLoaderDeleteArgs} args - Arguments to delete one DataSourceLoader.
     * @example
     * // Delete one DataSourceLoader
     * const DataSourceLoader = await prisma.dataSourceLoader.delete({
     *   where: {
     *     // ... filter to delete one DataSourceLoader
     *   }
     * })
     * 
     */
    delete<T extends DataSourceLoaderDeleteArgs>(args: SelectSubset<T, DataSourceLoaderDeleteArgs<ExtArgs>>): Prisma__DataSourceLoaderClient<$Result.GetResult<Prisma.$DataSourceLoaderPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one DataSourceLoader.
     * @param {DataSourceLoaderUpdateArgs} args - Arguments to update one DataSourceLoader.
     * @example
     * // Update one DataSourceLoader
     * const dataSourceLoader = await prisma.dataSourceLoader.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DataSourceLoaderUpdateArgs>(args: SelectSubset<T, DataSourceLoaderUpdateArgs<ExtArgs>>): Prisma__DataSourceLoaderClient<$Result.GetResult<Prisma.$DataSourceLoaderPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more DataSourceLoaders.
     * @param {DataSourceLoaderDeleteManyArgs} args - Arguments to filter DataSourceLoaders to delete.
     * @example
     * // Delete a few DataSourceLoaders
     * const { count } = await prisma.dataSourceLoader.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DataSourceLoaderDeleteManyArgs>(args?: SelectSubset<T, DataSourceLoaderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DataSourceLoaders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataSourceLoaderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DataSourceLoaders
     * const dataSourceLoader = await prisma.dataSourceLoader.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DataSourceLoaderUpdateManyArgs>(args: SelectSubset<T, DataSourceLoaderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DataSourceLoader.
     * @param {DataSourceLoaderUpsertArgs} args - Arguments to update or create a DataSourceLoader.
     * @example
     * // Update or create a DataSourceLoader
     * const dataSourceLoader = await prisma.dataSourceLoader.upsert({
     *   create: {
     *     // ... data to create a DataSourceLoader
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DataSourceLoader we want to update
     *   }
     * })
     */
    upsert<T extends DataSourceLoaderUpsertArgs>(args: SelectSubset<T, DataSourceLoaderUpsertArgs<ExtArgs>>): Prisma__DataSourceLoaderClient<$Result.GetResult<Prisma.$DataSourceLoaderPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more DataSourceLoaders that matches the filter.
     * @param {DataSourceLoaderFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const dataSourceLoader = await prisma.dataSourceLoader.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: DataSourceLoaderFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a DataSourceLoader.
     * @param {DataSourceLoaderAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const dataSourceLoader = await prisma.dataSourceLoader.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: DataSourceLoaderAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of DataSourceLoaders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataSourceLoaderCountArgs} args - Arguments to filter DataSourceLoaders to count.
     * @example
     * // Count the number of DataSourceLoaders
     * const count = await prisma.dataSourceLoader.count({
     *   where: {
     *     // ... the filter for the DataSourceLoaders we want to count
     *   }
     * })
    **/
    count<T extends DataSourceLoaderCountArgs>(
      args?: Subset<T, DataSourceLoaderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DataSourceLoaderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DataSourceLoader.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataSourceLoaderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DataSourceLoaderAggregateArgs>(args: Subset<T, DataSourceLoaderAggregateArgs>): Prisma.PrismaPromise<GetDataSourceLoaderAggregateType<T>>

    /**
     * Group by DataSourceLoader.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataSourceLoaderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DataSourceLoaderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DataSourceLoaderGroupByArgs['orderBy'] }
        : { orderBy?: DataSourceLoaderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DataSourceLoaderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDataSourceLoaderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DataSourceLoader model
   */
  readonly fields: DataSourceLoaderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DataSourceLoader.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DataSourceLoaderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DataSourceLoader model
   */ 
  interface DataSourceLoaderFieldRefs {
    readonly id: FieldRef<"DataSourceLoader", 'String'>
    readonly clientId: FieldRef<"DataSourceLoader", 'String'>
    readonly instanceId: FieldRef<"DataSourceLoader", 'String'>
    readonly name: FieldRef<"DataSourceLoader", 'String'>
    readonly code: FieldRef<"DataSourceLoader", 'String'>
    readonly loaderType: FieldRef<"DataSourceLoader", 'DataSourceLoaderType'>
    readonly sourceTable: FieldRef<"DataSourceLoader", 'String'>
    readonly planningTable: FieldRef<"DataSourceLoader", 'String[]'>
    readonly planningElementId: FieldRef<"DataSourceLoader", 'String'>
    readonly planningElementType: FieldRef<"DataSourceLoader", 'String'>
    readonly versionId: FieldRef<"DataSourceLoader", 'String'>
    readonly createElementIfNotFound: FieldRef<"DataSourceLoader", 'Boolean'>
    readonly settingsOptions: FieldRef<"DataSourceLoader", 'Json'>
    readonly columnMappings: FieldRef<"DataSourceLoader", 'Json'>
    readonly description: FieldRef<"DataSourceLoader", 'String'>
    readonly createdAt: FieldRef<"DataSourceLoader", 'DateTime'>
    readonly updatedAt: FieldRef<"DataSourceLoader", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DataSourceLoader findUnique
   */
  export type DataSourceLoaderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataSourceLoader
     */
    select?: DataSourceLoaderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataSourceLoader
     */
    omit?: DataSourceLoaderOmit<ExtArgs> | null
    /**
     * Filter, which DataSourceLoader to fetch.
     */
    where: DataSourceLoaderWhereUniqueInput
  }

  /**
   * DataSourceLoader findUniqueOrThrow
   */
  export type DataSourceLoaderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataSourceLoader
     */
    select?: DataSourceLoaderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataSourceLoader
     */
    omit?: DataSourceLoaderOmit<ExtArgs> | null
    /**
     * Filter, which DataSourceLoader to fetch.
     */
    where: DataSourceLoaderWhereUniqueInput
  }

  /**
   * DataSourceLoader findFirst
   */
  export type DataSourceLoaderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataSourceLoader
     */
    select?: DataSourceLoaderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataSourceLoader
     */
    omit?: DataSourceLoaderOmit<ExtArgs> | null
    /**
     * Filter, which DataSourceLoader to fetch.
     */
    where?: DataSourceLoaderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataSourceLoaders to fetch.
     */
    orderBy?: DataSourceLoaderOrderByWithRelationInput | DataSourceLoaderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DataSourceLoaders.
     */
    cursor?: DataSourceLoaderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataSourceLoaders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataSourceLoaders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DataSourceLoaders.
     */
    distinct?: DataSourceLoaderScalarFieldEnum | DataSourceLoaderScalarFieldEnum[]
  }

  /**
   * DataSourceLoader findFirstOrThrow
   */
  export type DataSourceLoaderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataSourceLoader
     */
    select?: DataSourceLoaderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataSourceLoader
     */
    omit?: DataSourceLoaderOmit<ExtArgs> | null
    /**
     * Filter, which DataSourceLoader to fetch.
     */
    where?: DataSourceLoaderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataSourceLoaders to fetch.
     */
    orderBy?: DataSourceLoaderOrderByWithRelationInput | DataSourceLoaderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DataSourceLoaders.
     */
    cursor?: DataSourceLoaderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataSourceLoaders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataSourceLoaders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DataSourceLoaders.
     */
    distinct?: DataSourceLoaderScalarFieldEnum | DataSourceLoaderScalarFieldEnum[]
  }

  /**
   * DataSourceLoader findMany
   */
  export type DataSourceLoaderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataSourceLoader
     */
    select?: DataSourceLoaderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataSourceLoader
     */
    omit?: DataSourceLoaderOmit<ExtArgs> | null
    /**
     * Filter, which DataSourceLoaders to fetch.
     */
    where?: DataSourceLoaderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataSourceLoaders to fetch.
     */
    orderBy?: DataSourceLoaderOrderByWithRelationInput | DataSourceLoaderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DataSourceLoaders.
     */
    cursor?: DataSourceLoaderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataSourceLoaders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataSourceLoaders.
     */
    skip?: number
    distinct?: DataSourceLoaderScalarFieldEnum | DataSourceLoaderScalarFieldEnum[]
  }

  /**
   * DataSourceLoader create
   */
  export type DataSourceLoaderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataSourceLoader
     */
    select?: DataSourceLoaderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataSourceLoader
     */
    omit?: DataSourceLoaderOmit<ExtArgs> | null
    /**
     * The data needed to create a DataSourceLoader.
     */
    data: XOR<DataSourceLoaderCreateInput, DataSourceLoaderUncheckedCreateInput>
  }

  /**
   * DataSourceLoader createMany
   */
  export type DataSourceLoaderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DataSourceLoaders.
     */
    data: DataSourceLoaderCreateManyInput | DataSourceLoaderCreateManyInput[]
  }

  /**
   * DataSourceLoader update
   */
  export type DataSourceLoaderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataSourceLoader
     */
    select?: DataSourceLoaderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataSourceLoader
     */
    omit?: DataSourceLoaderOmit<ExtArgs> | null
    /**
     * The data needed to update a DataSourceLoader.
     */
    data: XOR<DataSourceLoaderUpdateInput, DataSourceLoaderUncheckedUpdateInput>
    /**
     * Choose, which DataSourceLoader to update.
     */
    where: DataSourceLoaderWhereUniqueInput
  }

  /**
   * DataSourceLoader updateMany
   */
  export type DataSourceLoaderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DataSourceLoaders.
     */
    data: XOR<DataSourceLoaderUpdateManyMutationInput, DataSourceLoaderUncheckedUpdateManyInput>
    /**
     * Filter which DataSourceLoaders to update
     */
    where?: DataSourceLoaderWhereInput
    /**
     * Limit how many DataSourceLoaders to update.
     */
    limit?: number
  }

  /**
   * DataSourceLoader upsert
   */
  export type DataSourceLoaderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataSourceLoader
     */
    select?: DataSourceLoaderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataSourceLoader
     */
    omit?: DataSourceLoaderOmit<ExtArgs> | null
    /**
     * The filter to search for the DataSourceLoader to update in case it exists.
     */
    where: DataSourceLoaderWhereUniqueInput
    /**
     * In case the DataSourceLoader found by the `where` argument doesn't exist, create a new DataSourceLoader with this data.
     */
    create: XOR<DataSourceLoaderCreateInput, DataSourceLoaderUncheckedCreateInput>
    /**
     * In case the DataSourceLoader was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DataSourceLoaderUpdateInput, DataSourceLoaderUncheckedUpdateInput>
  }

  /**
   * DataSourceLoader delete
   */
  export type DataSourceLoaderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataSourceLoader
     */
    select?: DataSourceLoaderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataSourceLoader
     */
    omit?: DataSourceLoaderOmit<ExtArgs> | null
    /**
     * Filter which DataSourceLoader to delete.
     */
    where: DataSourceLoaderWhereUniqueInput
  }

  /**
   * DataSourceLoader deleteMany
   */
  export type DataSourceLoaderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DataSourceLoaders to delete
     */
    where?: DataSourceLoaderWhereInput
    /**
     * Limit how many DataSourceLoaders to delete.
     */
    limit?: number
  }

  /**
   * DataSourceLoader findRaw
   */
  export type DataSourceLoaderFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * DataSourceLoader aggregateRaw
   */
  export type DataSourceLoaderAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * DataSourceLoader without action
   */
  export type DataSourceLoaderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataSourceLoader
     */
    select?: DataSourceLoaderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataSourceLoader
     */
    omit?: DataSourceLoaderOmit<ExtArgs> | null
  }


  /**
   * Model DataSourceCredential
   */

  export type AggregateDataSourceCredential = {
    _count: DataSourceCredentialCountAggregateOutputType | null
    _min: DataSourceCredentialMinAggregateOutputType | null
    _max: DataSourceCredentialMaxAggregateOutputType | null
  }

  export type DataSourceCredentialMinAggregateOutputType = {
    id: string | null
    clientId: string | null
    instanceId: string | null
    name: string | null
    code: string | null
    description: string | null
    type: $Enums.DatasourceCredentialAuthType | null
    credentialId: string | null
    credentialKey: string | null
    credentialSecret: string | null
    credentialToken: string | null
    credentialTokenSecret: string | null
    credentialHostname: string | null
    credentialUsername: string | null
    fingerprint: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DataSourceCredentialMaxAggregateOutputType = {
    id: string | null
    clientId: string | null
    instanceId: string | null
    name: string | null
    code: string | null
    description: string | null
    type: $Enums.DatasourceCredentialAuthType | null
    credentialId: string | null
    credentialKey: string | null
    credentialSecret: string | null
    credentialToken: string | null
    credentialTokenSecret: string | null
    credentialHostname: string | null
    credentialUsername: string | null
    fingerprint: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DataSourceCredentialCountAggregateOutputType = {
    id: number
    clientId: number
    instanceId: number
    name: number
    code: number
    description: number
    type: number
    credentialId: number
    credentialKey: number
    credentialSecret: number
    credentialToken: number
    credentialTokenSecret: number
    credentialHostname: number
    credentialUsername: number
    fingerprint: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DataSourceCredentialMinAggregateInputType = {
    id?: true
    clientId?: true
    instanceId?: true
    name?: true
    code?: true
    description?: true
    type?: true
    credentialId?: true
    credentialKey?: true
    credentialSecret?: true
    credentialToken?: true
    credentialTokenSecret?: true
    credentialHostname?: true
    credentialUsername?: true
    fingerprint?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DataSourceCredentialMaxAggregateInputType = {
    id?: true
    clientId?: true
    instanceId?: true
    name?: true
    code?: true
    description?: true
    type?: true
    credentialId?: true
    credentialKey?: true
    credentialSecret?: true
    credentialToken?: true
    credentialTokenSecret?: true
    credentialHostname?: true
    credentialUsername?: true
    fingerprint?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DataSourceCredentialCountAggregateInputType = {
    id?: true
    clientId?: true
    instanceId?: true
    name?: true
    code?: true
    description?: true
    type?: true
    credentialId?: true
    credentialKey?: true
    credentialSecret?: true
    credentialToken?: true
    credentialTokenSecret?: true
    credentialHostname?: true
    credentialUsername?: true
    fingerprint?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DataSourceCredentialAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DataSourceCredential to aggregate.
     */
    where?: DataSourceCredentialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataSourceCredentials to fetch.
     */
    orderBy?: DataSourceCredentialOrderByWithRelationInput | DataSourceCredentialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DataSourceCredentialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataSourceCredentials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataSourceCredentials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DataSourceCredentials
    **/
    _count?: true | DataSourceCredentialCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DataSourceCredentialMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DataSourceCredentialMaxAggregateInputType
  }

  export type GetDataSourceCredentialAggregateType<T extends DataSourceCredentialAggregateArgs> = {
        [P in keyof T & keyof AggregateDataSourceCredential]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDataSourceCredential[P]>
      : GetScalarType<T[P], AggregateDataSourceCredential[P]>
  }




  export type DataSourceCredentialGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DataSourceCredentialWhereInput
    orderBy?: DataSourceCredentialOrderByWithAggregationInput | DataSourceCredentialOrderByWithAggregationInput[]
    by: DataSourceCredentialScalarFieldEnum[] | DataSourceCredentialScalarFieldEnum
    having?: DataSourceCredentialScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DataSourceCredentialCountAggregateInputType | true
    _min?: DataSourceCredentialMinAggregateInputType
    _max?: DataSourceCredentialMaxAggregateInputType
  }

  export type DataSourceCredentialGroupByOutputType = {
    id: string
    clientId: string
    instanceId: string
    name: string
    code: string
    description: string | null
    type: $Enums.DatasourceCredentialAuthType
    credentialId: string | null
    credentialKey: string | null
    credentialSecret: string | null
    credentialToken: string | null
    credentialTokenSecret: string | null
    credentialHostname: string | null
    credentialUsername: string | null
    fingerprint: string | null
    createdAt: Date | null
    updatedAt: Date | null
    _count: DataSourceCredentialCountAggregateOutputType | null
    _min: DataSourceCredentialMinAggregateOutputType | null
    _max: DataSourceCredentialMaxAggregateOutputType | null
  }

  type GetDataSourceCredentialGroupByPayload<T extends DataSourceCredentialGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DataSourceCredentialGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DataSourceCredentialGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DataSourceCredentialGroupByOutputType[P]>
            : GetScalarType<T[P], DataSourceCredentialGroupByOutputType[P]>
        }
      >
    >


  export type DataSourceCredentialSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    instanceId?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    type?: boolean
    credentialId?: boolean
    credentialKey?: boolean
    credentialSecret?: boolean
    credentialToken?: boolean
    credentialTokenSecret?: boolean
    credentialHostname?: boolean
    credentialUsername?: boolean
    fingerprint?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    datasources?: boolean | DataSourceCredential$datasourcesArgs<ExtArgs>
    _count?: boolean | DataSourceCredentialCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dataSourceCredential"]>



  export type DataSourceCredentialSelectScalar = {
    id?: boolean
    clientId?: boolean
    instanceId?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    type?: boolean
    credentialId?: boolean
    credentialKey?: boolean
    credentialSecret?: boolean
    credentialToken?: boolean
    credentialTokenSecret?: boolean
    credentialHostname?: boolean
    credentialUsername?: boolean
    fingerprint?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DataSourceCredentialOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "clientId" | "instanceId" | "name" | "code" | "description" | "type" | "credentialId" | "credentialKey" | "credentialSecret" | "credentialToken" | "credentialTokenSecret" | "credentialHostname" | "credentialUsername" | "fingerprint" | "createdAt" | "updatedAt", ExtArgs["result"]["dataSourceCredential"]>
  export type DataSourceCredentialInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    datasources?: boolean | DataSourceCredential$datasourcesArgs<ExtArgs>
    _count?: boolean | DataSourceCredentialCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $DataSourceCredentialPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DataSourceCredential"
    objects: {
      datasources: Prisma.$DataSourcePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clientId: string
      instanceId: string
      name: string
      code: string
      description: string | null
      type: $Enums.DatasourceCredentialAuthType
      credentialId: string | null
      credentialKey: string | null
      credentialSecret: string | null
      credentialToken: string | null
      credentialTokenSecret: string | null
      credentialHostname: string | null
      credentialUsername: string | null
      fingerprint: string | null
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["dataSourceCredential"]>
    composites: {}
  }

  type DataSourceCredentialGetPayload<S extends boolean | null | undefined | DataSourceCredentialDefaultArgs> = $Result.GetResult<Prisma.$DataSourceCredentialPayload, S>

  type DataSourceCredentialCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DataSourceCredentialFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DataSourceCredentialCountAggregateInputType | true
    }

  export interface DataSourceCredentialDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DataSourceCredential'], meta: { name: 'DataSourceCredential' } }
    /**
     * Find zero or one DataSourceCredential that matches the filter.
     * @param {DataSourceCredentialFindUniqueArgs} args - Arguments to find a DataSourceCredential
     * @example
     * // Get one DataSourceCredential
     * const dataSourceCredential = await prisma.dataSourceCredential.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DataSourceCredentialFindUniqueArgs>(args: SelectSubset<T, DataSourceCredentialFindUniqueArgs<ExtArgs>>): Prisma__DataSourceCredentialClient<$Result.GetResult<Prisma.$DataSourceCredentialPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one DataSourceCredential that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DataSourceCredentialFindUniqueOrThrowArgs} args - Arguments to find a DataSourceCredential
     * @example
     * // Get one DataSourceCredential
     * const dataSourceCredential = await prisma.dataSourceCredential.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DataSourceCredentialFindUniqueOrThrowArgs>(args: SelectSubset<T, DataSourceCredentialFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DataSourceCredentialClient<$Result.GetResult<Prisma.$DataSourceCredentialPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first DataSourceCredential that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataSourceCredentialFindFirstArgs} args - Arguments to find a DataSourceCredential
     * @example
     * // Get one DataSourceCredential
     * const dataSourceCredential = await prisma.dataSourceCredential.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DataSourceCredentialFindFirstArgs>(args?: SelectSubset<T, DataSourceCredentialFindFirstArgs<ExtArgs>>): Prisma__DataSourceCredentialClient<$Result.GetResult<Prisma.$DataSourceCredentialPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first DataSourceCredential that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataSourceCredentialFindFirstOrThrowArgs} args - Arguments to find a DataSourceCredential
     * @example
     * // Get one DataSourceCredential
     * const dataSourceCredential = await prisma.dataSourceCredential.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DataSourceCredentialFindFirstOrThrowArgs>(args?: SelectSubset<T, DataSourceCredentialFindFirstOrThrowArgs<ExtArgs>>): Prisma__DataSourceCredentialClient<$Result.GetResult<Prisma.$DataSourceCredentialPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more DataSourceCredentials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataSourceCredentialFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DataSourceCredentials
     * const dataSourceCredentials = await prisma.dataSourceCredential.findMany()
     * 
     * // Get first 10 DataSourceCredentials
     * const dataSourceCredentials = await prisma.dataSourceCredential.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dataSourceCredentialWithIdOnly = await prisma.dataSourceCredential.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DataSourceCredentialFindManyArgs>(args?: SelectSubset<T, DataSourceCredentialFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DataSourceCredentialPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a DataSourceCredential.
     * @param {DataSourceCredentialCreateArgs} args - Arguments to create a DataSourceCredential.
     * @example
     * // Create one DataSourceCredential
     * const DataSourceCredential = await prisma.dataSourceCredential.create({
     *   data: {
     *     // ... data to create a DataSourceCredential
     *   }
     * })
     * 
     */
    create<T extends DataSourceCredentialCreateArgs>(args: SelectSubset<T, DataSourceCredentialCreateArgs<ExtArgs>>): Prisma__DataSourceCredentialClient<$Result.GetResult<Prisma.$DataSourceCredentialPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many DataSourceCredentials.
     * @param {DataSourceCredentialCreateManyArgs} args - Arguments to create many DataSourceCredentials.
     * @example
     * // Create many DataSourceCredentials
     * const dataSourceCredential = await prisma.dataSourceCredential.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DataSourceCredentialCreateManyArgs>(args?: SelectSubset<T, DataSourceCredentialCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DataSourceCredential.
     * @param {DataSourceCredentialDeleteArgs} args - Arguments to delete one DataSourceCredential.
     * @example
     * // Delete one DataSourceCredential
     * const DataSourceCredential = await prisma.dataSourceCredential.delete({
     *   where: {
     *     // ... filter to delete one DataSourceCredential
     *   }
     * })
     * 
     */
    delete<T extends DataSourceCredentialDeleteArgs>(args: SelectSubset<T, DataSourceCredentialDeleteArgs<ExtArgs>>): Prisma__DataSourceCredentialClient<$Result.GetResult<Prisma.$DataSourceCredentialPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one DataSourceCredential.
     * @param {DataSourceCredentialUpdateArgs} args - Arguments to update one DataSourceCredential.
     * @example
     * // Update one DataSourceCredential
     * const dataSourceCredential = await prisma.dataSourceCredential.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DataSourceCredentialUpdateArgs>(args: SelectSubset<T, DataSourceCredentialUpdateArgs<ExtArgs>>): Prisma__DataSourceCredentialClient<$Result.GetResult<Prisma.$DataSourceCredentialPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more DataSourceCredentials.
     * @param {DataSourceCredentialDeleteManyArgs} args - Arguments to filter DataSourceCredentials to delete.
     * @example
     * // Delete a few DataSourceCredentials
     * const { count } = await prisma.dataSourceCredential.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DataSourceCredentialDeleteManyArgs>(args?: SelectSubset<T, DataSourceCredentialDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DataSourceCredentials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataSourceCredentialUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DataSourceCredentials
     * const dataSourceCredential = await prisma.dataSourceCredential.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DataSourceCredentialUpdateManyArgs>(args: SelectSubset<T, DataSourceCredentialUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DataSourceCredential.
     * @param {DataSourceCredentialUpsertArgs} args - Arguments to update or create a DataSourceCredential.
     * @example
     * // Update or create a DataSourceCredential
     * const dataSourceCredential = await prisma.dataSourceCredential.upsert({
     *   create: {
     *     // ... data to create a DataSourceCredential
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DataSourceCredential we want to update
     *   }
     * })
     */
    upsert<T extends DataSourceCredentialUpsertArgs>(args: SelectSubset<T, DataSourceCredentialUpsertArgs<ExtArgs>>): Prisma__DataSourceCredentialClient<$Result.GetResult<Prisma.$DataSourceCredentialPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more DataSourceCredentials that matches the filter.
     * @param {DataSourceCredentialFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const dataSourceCredential = await prisma.dataSourceCredential.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: DataSourceCredentialFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a DataSourceCredential.
     * @param {DataSourceCredentialAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const dataSourceCredential = await prisma.dataSourceCredential.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: DataSourceCredentialAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of DataSourceCredentials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataSourceCredentialCountArgs} args - Arguments to filter DataSourceCredentials to count.
     * @example
     * // Count the number of DataSourceCredentials
     * const count = await prisma.dataSourceCredential.count({
     *   where: {
     *     // ... the filter for the DataSourceCredentials we want to count
     *   }
     * })
    **/
    count<T extends DataSourceCredentialCountArgs>(
      args?: Subset<T, DataSourceCredentialCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DataSourceCredentialCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DataSourceCredential.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataSourceCredentialAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DataSourceCredentialAggregateArgs>(args: Subset<T, DataSourceCredentialAggregateArgs>): Prisma.PrismaPromise<GetDataSourceCredentialAggregateType<T>>

    /**
     * Group by DataSourceCredential.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataSourceCredentialGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DataSourceCredentialGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DataSourceCredentialGroupByArgs['orderBy'] }
        : { orderBy?: DataSourceCredentialGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DataSourceCredentialGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDataSourceCredentialGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DataSourceCredential model
   */
  readonly fields: DataSourceCredentialFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DataSourceCredential.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DataSourceCredentialClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    datasources<T extends DataSourceCredential$datasourcesArgs<ExtArgs> = {}>(args?: Subset<T, DataSourceCredential$datasourcesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DataSourcePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DataSourceCredential model
   */ 
  interface DataSourceCredentialFieldRefs {
    readonly id: FieldRef<"DataSourceCredential", 'String'>
    readonly clientId: FieldRef<"DataSourceCredential", 'String'>
    readonly instanceId: FieldRef<"DataSourceCredential", 'String'>
    readonly name: FieldRef<"DataSourceCredential", 'String'>
    readonly code: FieldRef<"DataSourceCredential", 'String'>
    readonly description: FieldRef<"DataSourceCredential", 'String'>
    readonly type: FieldRef<"DataSourceCredential", 'DatasourceCredentialAuthType'>
    readonly credentialId: FieldRef<"DataSourceCredential", 'String'>
    readonly credentialKey: FieldRef<"DataSourceCredential", 'String'>
    readonly credentialSecret: FieldRef<"DataSourceCredential", 'String'>
    readonly credentialToken: FieldRef<"DataSourceCredential", 'String'>
    readonly credentialTokenSecret: FieldRef<"DataSourceCredential", 'String'>
    readonly credentialHostname: FieldRef<"DataSourceCredential", 'String'>
    readonly credentialUsername: FieldRef<"DataSourceCredential", 'String'>
    readonly fingerprint: FieldRef<"DataSourceCredential", 'String'>
    readonly createdAt: FieldRef<"DataSourceCredential", 'DateTime'>
    readonly updatedAt: FieldRef<"DataSourceCredential", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DataSourceCredential findUnique
   */
  export type DataSourceCredentialFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataSourceCredential
     */
    select?: DataSourceCredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataSourceCredential
     */
    omit?: DataSourceCredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataSourceCredentialInclude<ExtArgs> | null
    /**
     * Filter, which DataSourceCredential to fetch.
     */
    where: DataSourceCredentialWhereUniqueInput
  }

  /**
   * DataSourceCredential findUniqueOrThrow
   */
  export type DataSourceCredentialFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataSourceCredential
     */
    select?: DataSourceCredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataSourceCredential
     */
    omit?: DataSourceCredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataSourceCredentialInclude<ExtArgs> | null
    /**
     * Filter, which DataSourceCredential to fetch.
     */
    where: DataSourceCredentialWhereUniqueInput
  }

  /**
   * DataSourceCredential findFirst
   */
  export type DataSourceCredentialFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataSourceCredential
     */
    select?: DataSourceCredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataSourceCredential
     */
    omit?: DataSourceCredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataSourceCredentialInclude<ExtArgs> | null
    /**
     * Filter, which DataSourceCredential to fetch.
     */
    where?: DataSourceCredentialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataSourceCredentials to fetch.
     */
    orderBy?: DataSourceCredentialOrderByWithRelationInput | DataSourceCredentialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DataSourceCredentials.
     */
    cursor?: DataSourceCredentialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataSourceCredentials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataSourceCredentials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DataSourceCredentials.
     */
    distinct?: DataSourceCredentialScalarFieldEnum | DataSourceCredentialScalarFieldEnum[]
  }

  /**
   * DataSourceCredential findFirstOrThrow
   */
  export type DataSourceCredentialFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataSourceCredential
     */
    select?: DataSourceCredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataSourceCredential
     */
    omit?: DataSourceCredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataSourceCredentialInclude<ExtArgs> | null
    /**
     * Filter, which DataSourceCredential to fetch.
     */
    where?: DataSourceCredentialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataSourceCredentials to fetch.
     */
    orderBy?: DataSourceCredentialOrderByWithRelationInput | DataSourceCredentialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DataSourceCredentials.
     */
    cursor?: DataSourceCredentialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataSourceCredentials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataSourceCredentials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DataSourceCredentials.
     */
    distinct?: DataSourceCredentialScalarFieldEnum | DataSourceCredentialScalarFieldEnum[]
  }

  /**
   * DataSourceCredential findMany
   */
  export type DataSourceCredentialFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataSourceCredential
     */
    select?: DataSourceCredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataSourceCredential
     */
    omit?: DataSourceCredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataSourceCredentialInclude<ExtArgs> | null
    /**
     * Filter, which DataSourceCredentials to fetch.
     */
    where?: DataSourceCredentialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataSourceCredentials to fetch.
     */
    orderBy?: DataSourceCredentialOrderByWithRelationInput | DataSourceCredentialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DataSourceCredentials.
     */
    cursor?: DataSourceCredentialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataSourceCredentials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataSourceCredentials.
     */
    skip?: number
    distinct?: DataSourceCredentialScalarFieldEnum | DataSourceCredentialScalarFieldEnum[]
  }

  /**
   * DataSourceCredential create
   */
  export type DataSourceCredentialCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataSourceCredential
     */
    select?: DataSourceCredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataSourceCredential
     */
    omit?: DataSourceCredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataSourceCredentialInclude<ExtArgs> | null
    /**
     * The data needed to create a DataSourceCredential.
     */
    data: XOR<DataSourceCredentialCreateInput, DataSourceCredentialUncheckedCreateInput>
  }

  /**
   * DataSourceCredential createMany
   */
  export type DataSourceCredentialCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DataSourceCredentials.
     */
    data: DataSourceCredentialCreateManyInput | DataSourceCredentialCreateManyInput[]
  }

  /**
   * DataSourceCredential update
   */
  export type DataSourceCredentialUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataSourceCredential
     */
    select?: DataSourceCredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataSourceCredential
     */
    omit?: DataSourceCredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataSourceCredentialInclude<ExtArgs> | null
    /**
     * The data needed to update a DataSourceCredential.
     */
    data: XOR<DataSourceCredentialUpdateInput, DataSourceCredentialUncheckedUpdateInput>
    /**
     * Choose, which DataSourceCredential to update.
     */
    where: DataSourceCredentialWhereUniqueInput
  }

  /**
   * DataSourceCredential updateMany
   */
  export type DataSourceCredentialUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DataSourceCredentials.
     */
    data: XOR<DataSourceCredentialUpdateManyMutationInput, DataSourceCredentialUncheckedUpdateManyInput>
    /**
     * Filter which DataSourceCredentials to update
     */
    where?: DataSourceCredentialWhereInput
    /**
     * Limit how many DataSourceCredentials to update.
     */
    limit?: number
  }

  /**
   * DataSourceCredential upsert
   */
  export type DataSourceCredentialUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataSourceCredential
     */
    select?: DataSourceCredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataSourceCredential
     */
    omit?: DataSourceCredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataSourceCredentialInclude<ExtArgs> | null
    /**
     * The filter to search for the DataSourceCredential to update in case it exists.
     */
    where: DataSourceCredentialWhereUniqueInput
    /**
     * In case the DataSourceCredential found by the `where` argument doesn't exist, create a new DataSourceCredential with this data.
     */
    create: XOR<DataSourceCredentialCreateInput, DataSourceCredentialUncheckedCreateInput>
    /**
     * In case the DataSourceCredential was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DataSourceCredentialUpdateInput, DataSourceCredentialUncheckedUpdateInput>
  }

  /**
   * DataSourceCredential delete
   */
  export type DataSourceCredentialDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataSourceCredential
     */
    select?: DataSourceCredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataSourceCredential
     */
    omit?: DataSourceCredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataSourceCredentialInclude<ExtArgs> | null
    /**
     * Filter which DataSourceCredential to delete.
     */
    where: DataSourceCredentialWhereUniqueInput
  }

  /**
   * DataSourceCredential deleteMany
   */
  export type DataSourceCredentialDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DataSourceCredentials to delete
     */
    where?: DataSourceCredentialWhereInput
    /**
     * Limit how many DataSourceCredentials to delete.
     */
    limit?: number
  }

  /**
   * DataSourceCredential findRaw
   */
  export type DataSourceCredentialFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * DataSourceCredential aggregateRaw
   */
  export type DataSourceCredentialAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * DataSourceCredential.datasources
   */
  export type DataSourceCredential$datasourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataSource
     */
    select?: DataSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataSource
     */
    omit?: DataSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataSourceInclude<ExtArgs> | null
    where?: DataSourceWhereInput
    orderBy?: DataSourceOrderByWithRelationInput | DataSourceOrderByWithRelationInput[]
    cursor?: DataSourceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DataSourceScalarFieldEnum | DataSourceScalarFieldEnum[]
  }

  /**
   * DataSourceCredential without action
   */
  export type DataSourceCredentialDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataSourceCredential
     */
    select?: DataSourceCredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataSourceCredential
     */
    omit?: DataSourceCredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataSourceCredentialInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const ConfigScalarFieldEnum: {
    id: 'id',
    defaultIsoCurrencyId: 'defaultIsoCurrencyId',
    defaultCurrencyId: 'defaultCurrencyId',
    defaultTopLevelName: 'defaultTopLevelName',
    defaultTopLevelDescription: 'defaultTopLevelDescription',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ConfigScalarFieldEnum = (typeof ConfigScalarFieldEnum)[keyof typeof ConfigScalarFieldEnum]


  export const CountryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    iso_3166_2_code: 'iso_3166_2_code',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CountryScalarFieldEnum = (typeof CountryScalarFieldEnum)[keyof typeof CountryScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    firstName: 'firstName',
    lastName: 'lastName',
    email: 'email',
    authProviderId: 'authProviderId',
    role: 'role',
    countryId: 'countryId',
    permissions: 'permissions',
    clientId: 'clientId',
    defaultInstance: 'defaultInstance',
    selectedInstance: 'selectedInstance',
    lastLogin: 'lastLogin',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ClientScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    status: 'status',
    countryId: 'countryId',
    contactId: 'contactId',
    lastLogin: 'lastLogin',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ClientScalarFieldEnum = (typeof ClientScalarFieldEnum)[keyof typeof ClientScalarFieldEnum]


  export const PermissionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    clientId: 'clientId',
    actions: 'actions',
    subjects: 'subjects',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PermissionScalarFieldEnum = (typeof PermissionScalarFieldEnum)[keyof typeof PermissionScalarFieldEnum]


  export const InstanceScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    clientId: 'clientId',
    description: 'description',
    status: 'status',
    userIds: 'userIds',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InstanceScalarFieldEnum = (typeof InstanceScalarFieldEnum)[keyof typeof InstanceScalarFieldEnum]


  export const VersionScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    begin: 'begin',
    end: 'end',
    startOfPlan: 'startOfPlan',
    description: 'description',
    isDefault: 'isDefault',
    isActuals: 'isActuals',
    status: 'status',
    clientId: 'clientId',
    instanceId: 'instanceId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VersionScalarFieldEnum = (typeof VersionScalarFieldEnum)[keyof typeof VersionScalarFieldEnum]


  export const CurrencyIsoCodeScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CurrencyIsoCodeScalarFieldEnum = (typeof CurrencyIsoCodeScalarFieldEnum)[keyof typeof CurrencyIsoCodeScalarFieldEnum]


  export const CurrencyScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    currencyIsoCodeId: 'currencyIsoCodeId',
    assignedLevels: 'assignedLevels',
    isDefault: 'isDefault',
    clientId: 'clientId',
    instanceId: 'instanceId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CurrencyScalarFieldEnum = (typeof CurrencyScalarFieldEnum)[keyof typeof CurrencyScalarFieldEnum]


  export const LevelScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    isRoot: 'isRoot',
    description: 'description',
    parentId: 'parentId',
    clientId: 'clientId',
    instanceId: 'instanceId',
    currencyId: 'currencyId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LevelScalarFieldEnum = (typeof LevelScalarFieldEnum)[keyof typeof LevelScalarFieldEnum]


  export const LevelAttributeAndValueScalarFieldEnum: {
    id: 'id',
    levelId: 'levelId',
    clientId: 'clientId',
    instanceId: 'instanceId',
    attributeId: 'attributeId',
    attributeValueId: 'attributeValueId',
    levelCode: 'levelCode',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LevelAttributeAndValueScalarFieldEnum = (typeof LevelAttributeAndValueScalarFieldEnum)[keyof typeof LevelAttributeAndValueScalarFieldEnum]


  export const LevelAttributeValueScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    attributeId: 'attributeId',
    parentId: 'parentId',
    clientId: 'clientId',
    instanceId: 'instanceId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LevelAttributeValueScalarFieldEnum = (typeof LevelAttributeValueScalarFieldEnum)[keyof typeof LevelAttributeValueScalarFieldEnum]


  export const LevelAttributeScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    description: 'description',
    clientId: 'clientId',
    instanceId: 'instanceId',
    attributeValueDefault: 'attributeValueDefault',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LevelAttributeScalarFieldEnum = (typeof LevelAttributeScalarFieldEnum)[keyof typeof LevelAttributeScalarFieldEnum]


  export const AccountAttributeScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    description: 'description',
    attributeValueDefault: 'attributeValueDefault',
    clientId: 'clientId',
    instanceId: 'instanceId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AccountAttributeScalarFieldEnum = (typeof AccountAttributeScalarFieldEnum)[keyof typeof AccountAttributeScalarFieldEnum]


  export const AccountAttributeValueScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    attributeId: 'attributeId',
    parentId: 'parentId',
    clientId: 'clientId',
    instanceId: 'instanceId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AccountAttributeValueScalarFieldEnum = (typeof AccountAttributeValueScalarFieldEnum)[keyof typeof AccountAttributeValueScalarFieldEnum]


  export const AccountAttributeAndValueScalarFieldEnum: {
    id: 'id',
    accountId: 'accountId',
    clientId: 'clientId',
    instanceId: 'instanceId',
    attributeId: 'attributeId',
    attributeValueId: 'attributeValueId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AccountAttributeAndValueScalarFieldEnum = (typeof AccountAttributeAndValueScalarFieldEnum)[keyof typeof AccountAttributeAndValueScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    isRoot: 'isRoot',
    isModelRoot: 'isModelRoot',
    accountType: 'accountType',
    accountTypeTag: 'accountTypeTag',
    group: 'group',
    plannedBy: 'plannedBy',
    actualsBy: 'actualsBy',
    displayAs: 'displayAs',
    containsSalaryInfo: 'containsSalaryInfo',
    description: 'description',
    instanceId: 'instanceId',
    clientId: 'clientId',
    parentId: 'parentId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const DimensionScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    description: 'description',
    dimensionValueDefault: 'dimensionValueDefault',
    clientId: 'clientId',
    instanceId: 'instanceId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DimensionScalarFieldEnum = (typeof DimensionScalarFieldEnum)[keyof typeof DimensionScalarFieldEnum]


  export const DimensionValueScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    parentId: 'parentId',
    clientId: 'clientId',
    instanceId: 'instanceId',
    dimensionId: 'dimensionId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DimensionValueScalarFieldEnum = (typeof DimensionValueScalarFieldEnum)[keyof typeof DimensionValueScalarFieldEnum]


  export const DimensionValueAttributeScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    description: 'description',
    clientId: 'clientId',
    instanceId: 'instanceId',
    updatedAt: 'updatedAt',
    createdAt: 'createdAt'
  };

  export type DimensionValueAttributeScalarFieldEnum = (typeof DimensionValueAttributeScalarFieldEnum)[keyof typeof DimensionValueAttributeScalarFieldEnum]


  export const DimensionValueAttributeValueScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    attributeId: 'attributeId',
    clientId: 'clientId',
    parentId: 'parentId',
    instanceId: 'instanceId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DimensionValueAttributeValueScalarFieldEnum = (typeof DimensionValueAttributeValueScalarFieldEnum)[keyof typeof DimensionValueAttributeValueScalarFieldEnum]


  export const DimensionValueAttributeAndValueScalarFieldEnum: {
    id: 'id',
    clientId: 'clientId',
    instanceId: 'instanceId',
    attributeId: 'attributeId',
    attributeValueId: 'attributeValueId',
    dimensionValueId: 'dimensionValueId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DimensionValueAttributeAndValueScalarFieldEnum = (typeof DimensionValueAttributeAndValueScalarFieldEnum)[keyof typeof DimensionValueAttributeAndValueScalarFieldEnum]


  export const ModelScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    description: 'description',
    dimensionality: 'dimensionality',
    status: 'status',
    isDefault: 'isDefault',
    instanceId: 'instanceId',
    clientId: 'clientId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    rootAccountId: 'rootAccountId'
  };

  export type ModelScalarFieldEnum = (typeof ModelScalarFieldEnum)[keyof typeof ModelScalarFieldEnum]


  export const ModelAccountStructureScalarFieldEnum: {
    id: 'id',
    instanceId: 'instanceId',
    isRoot: 'isRoot',
    clientId: 'clientId',
    parentId: 'parentId',
    modelId: 'modelId',
    accountId: 'accountId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ModelAccountStructureScalarFieldEnum = (typeof ModelAccountStructureScalarFieldEnum)[keyof typeof ModelAccountStructureScalarFieldEnum]


  export const ModelDataScalarFieldEnum: {
    id: 'id',
    clientId: 'clientId',
    instanceId: 'instanceId',
    modelId: 'modelId',
    versionId: 'versionId',
    levelId: 'levelId',
    accountId: 'accountId',
    timespan: 'timespan',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ModelDataScalarFieldEnum = (typeof ModelDataScalarFieldEnum)[keyof typeof ModelDataScalarFieldEnum]


  export const ModelDataCalculationsScalarFieldEnum: {
    id: 'id',
    clientId: 'clientId',
    instanceId: 'instanceId',
    modelId: 'modelId',
    versionId: 'versionId',
    levelId: 'levelId',
    accountId: 'accountId',
    modelAccountId: 'modelAccountId',
    calculations: 'calculations',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ModelDataCalculationsScalarFieldEnum = (typeof ModelDataCalculationsScalarFieldEnum)[keyof typeof ModelDataCalculationsScalarFieldEnum]


  export const TableScalarFieldEnum: {
    id: 'id',
    clientId: 'clientId',
    instanceId: 'instanceId',
    name: 'name',
    code: 'code',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    status: 'status'
  };

  export type TableScalarFieldEnum = (typeof TableScalarFieldEnum)[keyof typeof TableScalarFieldEnum]


  export const TableDataScalarFieldEnum: {
    id: 'id',
    clientId: 'clientId',
    instanceId: 'instanceId',
    tableId: 'tableId',
    rowKey: 'rowKey',
    versionId: 'versionId',
    levelId: 'levelId',
    data: 'data',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TableDataScalarFieldEnum = (typeof TableDataScalarFieldEnum)[keyof typeof TableDataScalarFieldEnum]


  export const DataSourceScalarFieldEnum: {
    id: 'id',
    clientId: 'clientId',
    instanceId: 'instanceId',
    name: 'name',
    code: 'code',
    credentialId: 'credentialId',
    description: 'description',
    type: 'type',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DataSourceScalarFieldEnum = (typeof DataSourceScalarFieldEnum)[keyof typeof DataSourceScalarFieldEnum]


  export const DataSourceTaskScalarFieldEnum: {
    id: 'id',
    clientId: 'clientId',
    instanceId: 'instanceId',
    name: 'name',
    code: 'code',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DataSourceTaskScalarFieldEnum = (typeof DataSourceTaskScalarFieldEnum)[keyof typeof DataSourceTaskScalarFieldEnum]


  export const DataSourceLoaderScalarFieldEnum: {
    id: 'id',
    clientId: 'clientId',
    instanceId: 'instanceId',
    name: 'name',
    code: 'code',
    loaderType: 'loaderType',
    sourceTable: 'sourceTable',
    planningTable: 'planningTable',
    planningElementId: 'planningElementId',
    planningElementType: 'planningElementType',
    versionId: 'versionId',
    createElementIfNotFound: 'createElementIfNotFound',
    settingsOptions: 'settingsOptions',
    columnMappings: 'columnMappings',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DataSourceLoaderScalarFieldEnum = (typeof DataSourceLoaderScalarFieldEnum)[keyof typeof DataSourceLoaderScalarFieldEnum]


  export const DataSourceCredentialScalarFieldEnum: {
    id: 'id',
    clientId: 'clientId',
    instanceId: 'instanceId',
    name: 'name',
    code: 'code',
    description: 'description',
    type: 'type',
    credentialId: 'credentialId',
    credentialKey: 'credentialKey',
    credentialSecret: 'credentialSecret',
    credentialToken: 'credentialToken',
    credentialTokenSecret: 'credentialTokenSecret',
    credentialHostname: 'credentialHostname',
    credentialUsername: 'credentialUsername',
    fingerprint: 'fingerprint',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DataSourceCredentialScalarFieldEnum = (typeof DataSourceCredentialScalarFieldEnum)[keyof typeof DataSourceCredentialScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'userRole'
   */
  export type EnumuserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'userRole'>
    


  /**
   * Reference to a field of type 'userRole[]'
   */
  export type ListEnumuserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'userRole[]'>
    


  /**
   * Reference to a field of type 'clientStatus'
   */
  export type EnumclientStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'clientStatus'>
    


  /**
   * Reference to a field of type 'clientStatus[]'
   */
  export type ListEnumclientStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'clientStatus[]'>
    


  /**
   * Reference to a field of type 'instanceStatus'
   */
  export type EnuminstanceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'instanceStatus'>
    


  /**
   * Reference to a field of type 'instanceStatus[]'
   */
  export type ListEnuminstanceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'instanceStatus[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'versionStatus'
   */
  export type EnumversionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'versionStatus'>
    


  /**
   * Reference to a field of type 'versionStatus[]'
   */
  export type ListEnumversionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'versionStatus[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'YesNo'
   */
  export type EnumYesNoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'YesNo'>
    


  /**
   * Reference to a field of type 'YesNo[]'
   */
  export type ListEnumYesNoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'YesNo[]'>
    


  /**
   * Reference to a field of type 'AccountType'
   */
  export type EnumAccountTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccountType'>
    


  /**
   * Reference to a field of type 'AccountType[]'
   */
  export type ListEnumAccountTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccountType[]'>
    


  /**
   * Reference to a field of type 'AccountTypeTag'
   */
  export type EnumAccountTypeTagFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccountTypeTag'>
    


  /**
   * Reference to a field of type 'AccountTypeTag[]'
   */
  export type ListEnumAccountTypeTagFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccountTypeTag[]'>
    


  /**
   * Reference to a field of type 'ActPlanBy'
   */
  export type EnumActPlanByFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ActPlanBy'>
    


  /**
   * Reference to a field of type 'ActPlanBy[]'
   */
  export type ListEnumActPlanByFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ActPlanBy[]'>
    


  /**
   * Reference to a field of type 'ActActualsBy'
   */
  export type EnumActActualsByFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ActActualsBy'>
    


  /**
   * Reference to a field of type 'ActActualsBy[]'
   */
  export type ListEnumActActualsByFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ActActualsBy[]'>
    


  /**
   * Reference to a field of type 'ActDisplayAs'
   */
  export type EnumActDisplayAsFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ActDisplayAs'>
    


  /**
   * Reference to a field of type 'ActDisplayAs[]'
   */
  export type ListEnumActDisplayAsFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ActDisplayAs[]'>
    


  /**
   * Reference to a field of type 'ModelStatus'
   */
  export type EnumModelStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ModelStatus'>
    


  /**
   * Reference to a field of type 'ModelStatus[]'
   */
  export type ListEnumModelStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ModelStatus[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'DataSourceType'
   */
  export type EnumDataSourceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DataSourceType'>
    


  /**
   * Reference to a field of type 'DataSourceType[]'
   */
  export type ListEnumDataSourceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DataSourceType[]'>
    


  /**
   * Reference to a field of type 'DataSourceLoaderType'
   */
  export type EnumDataSourceLoaderTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DataSourceLoaderType'>
    


  /**
   * Reference to a field of type 'DataSourceLoaderType[]'
   */
  export type ListEnumDataSourceLoaderTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DataSourceLoaderType[]'>
    


  /**
   * Reference to a field of type 'DatasourceCredentialAuthType'
   */
  export type EnumDatasourceCredentialAuthTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DatasourceCredentialAuthType'>
    


  /**
   * Reference to a field of type 'DatasourceCredentialAuthType[]'
   */
  export type ListEnumDatasourceCredentialAuthTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DatasourceCredentialAuthType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'TableColumnType'
   */
  export type EnumTableColumnTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TableColumnType'>
    


  /**
   * Reference to a field of type 'TableColumnType[]'
   */
  export type ListEnumTableColumnTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TableColumnType[]'>
    
  /**
   * Deep Input Types
   */


  export type ConfigWhereInput = {
    AND?: ConfigWhereInput | ConfigWhereInput[]
    OR?: ConfigWhereInput[]
    NOT?: ConfigWhereInput | ConfigWhereInput[]
    id?: StringFilter<"Config"> | string
    defaultIsoCurrencyId?: StringFilter<"Config"> | string
    defaultCurrencyId?: StringFilter<"Config"> | string
    defaultTopLevelName?: StringFilter<"Config"> | string
    defaultTopLevelDescription?: StringFilter<"Config"> | string
    createdAt?: DateTimeNullableFilter<"Config"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Config"> | Date | string | null
    defaultIsoCurrency?: XOR<CurrencyIsoCodeScalarRelationFilter, CurrencyIsoCodeWhereInput>
    defaultCurrency?: XOR<CurrencyScalarRelationFilter, CurrencyWhereInput>
  }

  export type ConfigOrderByWithRelationInput = {
    id?: SortOrder
    defaultIsoCurrencyId?: SortOrder
    defaultCurrencyId?: SortOrder
    defaultTopLevelName?: SortOrder
    defaultTopLevelDescription?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    defaultIsoCurrency?: CurrencyIsoCodeOrderByWithRelationInput
    defaultCurrency?: CurrencyOrderByWithRelationInput
  }

  export type ConfigWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ConfigWhereInput | ConfigWhereInput[]
    OR?: ConfigWhereInput[]
    NOT?: ConfigWhereInput | ConfigWhereInput[]
    defaultIsoCurrencyId?: StringFilter<"Config"> | string
    defaultCurrencyId?: StringFilter<"Config"> | string
    defaultTopLevelName?: StringFilter<"Config"> | string
    defaultTopLevelDescription?: StringFilter<"Config"> | string
    createdAt?: DateTimeNullableFilter<"Config"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Config"> | Date | string | null
    defaultIsoCurrency?: XOR<CurrencyIsoCodeScalarRelationFilter, CurrencyIsoCodeWhereInput>
    defaultCurrency?: XOR<CurrencyScalarRelationFilter, CurrencyWhereInput>
  }, "id">

  export type ConfigOrderByWithAggregationInput = {
    id?: SortOrder
    defaultIsoCurrencyId?: SortOrder
    defaultCurrencyId?: SortOrder
    defaultTopLevelName?: SortOrder
    defaultTopLevelDescription?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ConfigCountOrderByAggregateInput
    _max?: ConfigMaxOrderByAggregateInput
    _min?: ConfigMinOrderByAggregateInput
  }

  export type ConfigScalarWhereWithAggregatesInput = {
    AND?: ConfigScalarWhereWithAggregatesInput | ConfigScalarWhereWithAggregatesInput[]
    OR?: ConfigScalarWhereWithAggregatesInput[]
    NOT?: ConfigScalarWhereWithAggregatesInput | ConfigScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Config"> | string
    defaultIsoCurrencyId?: StringWithAggregatesFilter<"Config"> | string
    defaultCurrencyId?: StringWithAggregatesFilter<"Config"> | string
    defaultTopLevelName?: StringWithAggregatesFilter<"Config"> | string
    defaultTopLevelDescription?: StringWithAggregatesFilter<"Config"> | string
    createdAt?: DateTimeNullableWithAggregatesFilter<"Config"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Config"> | Date | string | null
  }

  export type CountryWhereInput = {
    AND?: CountryWhereInput | CountryWhereInput[]
    OR?: CountryWhereInput[]
    NOT?: CountryWhereInput | CountryWhereInput[]
    id?: StringFilter<"Country"> | string
    name?: StringFilter<"Country"> | string
    iso_3166_2_code?: StringFilter<"Country"> | string
    createdAt?: DateTimeNullableFilter<"Country"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Country"> | Date | string | null
    Client?: ClientListRelationFilter
    User?: UserListRelationFilter
  }

  export type CountryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    iso_3166_2_code?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Client?: ClientOrderByRelationAggregateInput
    User?: UserOrderByRelationAggregateInput
  }

  export type CountryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    iso_3166_2_code?: string
    AND?: CountryWhereInput | CountryWhereInput[]
    OR?: CountryWhereInput[]
    NOT?: CountryWhereInput | CountryWhereInput[]
    name?: StringFilter<"Country"> | string
    createdAt?: DateTimeNullableFilter<"Country"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Country"> | Date | string | null
    Client?: ClientListRelationFilter
    User?: UserListRelationFilter
  }, "id" | "iso_3166_2_code">

  export type CountryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    iso_3166_2_code?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CountryCountOrderByAggregateInput
    _max?: CountryMaxOrderByAggregateInput
    _min?: CountryMinOrderByAggregateInput
  }

  export type CountryScalarWhereWithAggregatesInput = {
    AND?: CountryScalarWhereWithAggregatesInput | CountryScalarWhereWithAggregatesInput[]
    OR?: CountryScalarWhereWithAggregatesInput[]
    NOT?: CountryScalarWhereWithAggregatesInput | CountryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Country"> | string
    name?: StringWithAggregatesFilter<"Country"> | string
    iso_3166_2_code?: StringWithAggregatesFilter<"Country"> | string
    createdAt?: DateTimeNullableWithAggregatesFilter<"Country"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Country"> | Date | string | null
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    authProviderId?: StringFilter<"User"> | string
    role?: EnumuserRoleFilter<"User"> | $Enums.userRole
    countryId?: StringNullableFilter<"User"> | string | null
    permissions?: StringNullableListFilter<"User">
    clientId?: StringFilter<"User"> | string
    defaultInstance?: StringFilter<"User"> | string
    selectedInstance?: StringNullableFilter<"User"> | string | null
    lastLogin?: DateTimeFilter<"User"> | Date | string
    createdAt?: DateTimeNullableFilter<"User"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    country?: XOR<CountryNullableScalarRelationFilter, CountryWhereInput> | null
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    authProviderId?: SortOrder
    role?: SortOrder
    countryId?: SortOrder
    permissions?: SortOrder
    clientId?: SortOrder
    defaultInstance?: SortOrder
    selectedInstance?: SortOrder
    lastLogin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    country?: CountryOrderByWithRelationInput
    client?: ClientOrderByWithRelationInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    authProviderId?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    role?: EnumuserRoleFilter<"User"> | $Enums.userRole
    countryId?: StringNullableFilter<"User"> | string | null
    permissions?: StringNullableListFilter<"User">
    clientId?: StringFilter<"User"> | string
    defaultInstance?: StringFilter<"User"> | string
    selectedInstance?: StringNullableFilter<"User"> | string | null
    lastLogin?: DateTimeFilter<"User"> | Date | string
    createdAt?: DateTimeNullableFilter<"User"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    country?: XOR<CountryNullableScalarRelationFilter, CountryWhereInput> | null
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
  }, "id" | "email" | "authProviderId">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    authProviderId?: SortOrder
    role?: SortOrder
    countryId?: SortOrder
    permissions?: SortOrder
    clientId?: SortOrder
    defaultInstance?: SortOrder
    selectedInstance?: SortOrder
    lastLogin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    firstName?: StringWithAggregatesFilter<"User"> | string
    lastName?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    authProviderId?: StringWithAggregatesFilter<"User"> | string
    role?: EnumuserRoleWithAggregatesFilter<"User"> | $Enums.userRole
    countryId?: StringNullableWithAggregatesFilter<"User"> | string | null
    permissions?: StringNullableListFilter<"User">
    clientId?: StringWithAggregatesFilter<"User"> | string
    defaultInstance?: StringWithAggregatesFilter<"User"> | string
    selectedInstance?: StringNullableWithAggregatesFilter<"User"> | string | null
    lastLogin?: DateTimeWithAggregatesFilter<"User"> | Date | string
    createdAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
  }

  export type ClientWhereInput = {
    AND?: ClientWhereInput | ClientWhereInput[]
    OR?: ClientWhereInput[]
    NOT?: ClientWhereInput | ClientWhereInput[]
    id?: StringFilter<"Client"> | string
    name?: StringFilter<"Client"> | string
    code?: StringFilter<"Client"> | string
    status?: EnumclientStatusFilter<"Client"> | $Enums.clientStatus
    address?: XOR<AddressTypeNullableCompositeFilter, addressTypeObjectEqualityInput> | null
    countryId?: StringNullableFilter<"Client"> | string | null
    contactId?: StringNullableFilter<"Client"> | string | null
    lastLogin?: DateTimeFilter<"Client"> | Date | string
    createdAt?: DateTimeNullableFilter<"Client"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Client"> | Date | string | null
    country?: XOR<CountryNullableScalarRelationFilter, CountryWhereInput> | null
    users?: UserListRelationFilter
    instances?: InstanceListRelationFilter
    Permission?: PermissionListRelationFilter
  }

  export type ClientOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    status?: SortOrder
    address?: addressTypeOrderByInput
    countryId?: SortOrder
    contactId?: SortOrder
    lastLogin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    country?: CountryOrderByWithRelationInput
    users?: UserOrderByRelationAggregateInput
    instances?: InstanceOrderByRelationAggregateInput
    Permission?: PermissionOrderByRelationAggregateInput
  }

  export type ClientWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    code?: string
    AND?: ClientWhereInput | ClientWhereInput[]
    OR?: ClientWhereInput[]
    NOT?: ClientWhereInput | ClientWhereInput[]
    status?: EnumclientStatusFilter<"Client"> | $Enums.clientStatus
    address?: XOR<AddressTypeNullableCompositeFilter, addressTypeObjectEqualityInput> | null
    countryId?: StringNullableFilter<"Client"> | string | null
    contactId?: StringNullableFilter<"Client"> | string | null
    lastLogin?: DateTimeFilter<"Client"> | Date | string
    createdAt?: DateTimeNullableFilter<"Client"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Client"> | Date | string | null
    country?: XOR<CountryNullableScalarRelationFilter, CountryWhereInput> | null
    users?: UserListRelationFilter
    instances?: InstanceListRelationFilter
    Permission?: PermissionListRelationFilter
  }, "id" | "name" | "code">

  export type ClientOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    status?: SortOrder
    countryId?: SortOrder
    contactId?: SortOrder
    lastLogin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ClientCountOrderByAggregateInput
    _max?: ClientMaxOrderByAggregateInput
    _min?: ClientMinOrderByAggregateInput
  }

  export type ClientScalarWhereWithAggregatesInput = {
    AND?: ClientScalarWhereWithAggregatesInput | ClientScalarWhereWithAggregatesInput[]
    OR?: ClientScalarWhereWithAggregatesInput[]
    NOT?: ClientScalarWhereWithAggregatesInput | ClientScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Client"> | string
    name?: StringWithAggregatesFilter<"Client"> | string
    code?: StringWithAggregatesFilter<"Client"> | string
    status?: EnumclientStatusWithAggregatesFilter<"Client"> | $Enums.clientStatus
    countryId?: StringNullableWithAggregatesFilter<"Client"> | string | null
    contactId?: StringNullableWithAggregatesFilter<"Client"> | string | null
    lastLogin?: DateTimeWithAggregatesFilter<"Client"> | Date | string
    createdAt?: DateTimeNullableWithAggregatesFilter<"Client"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Client"> | Date | string | null
  }

  export type PermissionWhereInput = {
    AND?: PermissionWhereInput | PermissionWhereInput[]
    OR?: PermissionWhereInput[]
    NOT?: PermissionWhereInput | PermissionWhereInput[]
    id?: StringFilter<"Permission"> | string
    name?: StringFilter<"Permission"> | string
    code?: StringFilter<"Permission"> | string
    clientId?: StringFilter<"Permission"> | string
    actions?: StringNullableListFilter<"Permission">
    subjects?: StringNullableListFilter<"Permission">
    description?: StringNullableFilter<"Permission"> | string | null
    createdAt?: DateTimeNullableFilter<"Permission"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Permission"> | Date | string | null
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
  }

  export type PermissionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    clientId?: SortOrder
    actions?: SortOrder
    subjects?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    client?: ClientOrderByWithRelationInput
  }

  export type PermissionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    code?: string
    AND?: PermissionWhereInput | PermissionWhereInput[]
    OR?: PermissionWhereInput[]
    NOT?: PermissionWhereInput | PermissionWhereInput[]
    clientId?: StringFilter<"Permission"> | string
    actions?: StringNullableListFilter<"Permission">
    subjects?: StringNullableListFilter<"Permission">
    description?: StringNullableFilter<"Permission"> | string | null
    createdAt?: DateTimeNullableFilter<"Permission"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Permission"> | Date | string | null
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
  }, "id" | "name" | "code">

  export type PermissionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    clientId?: SortOrder
    actions?: SortOrder
    subjects?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PermissionCountOrderByAggregateInput
    _max?: PermissionMaxOrderByAggregateInput
    _min?: PermissionMinOrderByAggregateInput
  }

  export type PermissionScalarWhereWithAggregatesInput = {
    AND?: PermissionScalarWhereWithAggregatesInput | PermissionScalarWhereWithAggregatesInput[]
    OR?: PermissionScalarWhereWithAggregatesInput[]
    NOT?: PermissionScalarWhereWithAggregatesInput | PermissionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Permission"> | string
    name?: StringWithAggregatesFilter<"Permission"> | string
    code?: StringWithAggregatesFilter<"Permission"> | string
    clientId?: StringWithAggregatesFilter<"Permission"> | string
    actions?: StringNullableListFilter<"Permission">
    subjects?: StringNullableListFilter<"Permission">
    description?: StringNullableWithAggregatesFilter<"Permission"> | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"Permission"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Permission"> | Date | string | null
  }

  export type InstanceWhereInput = {
    AND?: InstanceWhereInput | InstanceWhereInput[]
    OR?: InstanceWhereInput[]
    NOT?: InstanceWhereInput | InstanceWhereInput[]
    id?: StringFilter<"Instance"> | string
    code?: StringFilter<"Instance"> | string
    name?: StringFilter<"Instance"> | string
    clientId?: StringFilter<"Instance"> | string
    description?: StringNullableFilter<"Instance"> | string | null
    status?: EnuminstanceStatusFilter<"Instance"> | $Enums.instanceStatus
    userIds?: StringNullableListFilter<"Instance">
    createdAt?: DateTimeNullableFilter<"Instance"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Instance"> | Date | string | null
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
    levels?: LevelListRelationFilter
    versions?: VersionListRelationFilter
    currencies?: CurrencyListRelationFilter
    accounts?: AccountListRelationFilter
    models?: ModelListRelationFilter
    dimensions?: DimensionListRelationFilter
    dimensionValues?: DimensionValueListRelationFilter
    levelAttributes?: LevelAttributeListRelationFilter
    dimensionValueAttributes?: DimensionValueAttributeListRelationFilter
    accountAttributes?: AccountAttributeListRelationFilter
    levelAttValues?: LevelAttributeValueListRelationFilter
    accountAttValues?: AccountAttributeValueListRelationFilter
    dimensionValueAttributeValues?: DimensionValueAttributeValueListRelationFilter
    modelData?: ModelDataListRelationFilter
    modelDataCalculations?: ModelDataCalculationsListRelationFilter
    modelAccounts?: ModelAccountStructureListRelationFilter
    tables?: TableListRelationFilter
    tableData?: TableDataListRelationFilter
  }

  export type InstanceOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    clientId?: SortOrder
    description?: SortOrder
    status?: SortOrder
    userIds?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    client?: ClientOrderByWithRelationInput
    levels?: LevelOrderByRelationAggregateInput
    versions?: VersionOrderByRelationAggregateInput
    currencies?: CurrencyOrderByRelationAggregateInput
    accounts?: AccountOrderByRelationAggregateInput
    models?: ModelOrderByRelationAggregateInput
    dimensions?: DimensionOrderByRelationAggregateInput
    dimensionValues?: DimensionValueOrderByRelationAggregateInput
    levelAttributes?: LevelAttributeOrderByRelationAggregateInput
    dimensionValueAttributes?: DimensionValueAttributeOrderByRelationAggregateInput
    accountAttributes?: AccountAttributeOrderByRelationAggregateInput
    levelAttValues?: LevelAttributeValueOrderByRelationAggregateInput
    accountAttValues?: AccountAttributeValueOrderByRelationAggregateInput
    dimensionValueAttributeValues?: DimensionValueAttributeValueOrderByRelationAggregateInput
    modelData?: ModelDataOrderByRelationAggregateInput
    modelDataCalculations?: ModelDataCalculationsOrderByRelationAggregateInput
    modelAccounts?: ModelAccountStructureOrderByRelationAggregateInput
    tables?: TableOrderByRelationAggregateInput
    tableData?: TableDataOrderByRelationAggregateInput
  }

  export type InstanceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    clientId_code?: InstanceClientIdCodeCompoundUniqueInput
    AND?: InstanceWhereInput | InstanceWhereInput[]
    OR?: InstanceWhereInput[]
    NOT?: InstanceWhereInput | InstanceWhereInput[]
    code?: StringFilter<"Instance"> | string
    name?: StringFilter<"Instance"> | string
    clientId?: StringFilter<"Instance"> | string
    description?: StringNullableFilter<"Instance"> | string | null
    status?: EnuminstanceStatusFilter<"Instance"> | $Enums.instanceStatus
    userIds?: StringNullableListFilter<"Instance">
    createdAt?: DateTimeNullableFilter<"Instance"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Instance"> | Date | string | null
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
    levels?: LevelListRelationFilter
    versions?: VersionListRelationFilter
    currencies?: CurrencyListRelationFilter
    accounts?: AccountListRelationFilter
    models?: ModelListRelationFilter
    dimensions?: DimensionListRelationFilter
    dimensionValues?: DimensionValueListRelationFilter
    levelAttributes?: LevelAttributeListRelationFilter
    dimensionValueAttributes?: DimensionValueAttributeListRelationFilter
    accountAttributes?: AccountAttributeListRelationFilter
    levelAttValues?: LevelAttributeValueListRelationFilter
    accountAttValues?: AccountAttributeValueListRelationFilter
    dimensionValueAttributeValues?: DimensionValueAttributeValueListRelationFilter
    modelData?: ModelDataListRelationFilter
    modelDataCalculations?: ModelDataCalculationsListRelationFilter
    modelAccounts?: ModelAccountStructureListRelationFilter
    tables?: TableListRelationFilter
    tableData?: TableDataListRelationFilter
  }, "id" | "clientId_code">

  export type InstanceOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    clientId?: SortOrder
    description?: SortOrder
    status?: SortOrder
    userIds?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InstanceCountOrderByAggregateInput
    _max?: InstanceMaxOrderByAggregateInput
    _min?: InstanceMinOrderByAggregateInput
  }

  export type InstanceScalarWhereWithAggregatesInput = {
    AND?: InstanceScalarWhereWithAggregatesInput | InstanceScalarWhereWithAggregatesInput[]
    OR?: InstanceScalarWhereWithAggregatesInput[]
    NOT?: InstanceScalarWhereWithAggregatesInput | InstanceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Instance"> | string
    code?: StringWithAggregatesFilter<"Instance"> | string
    name?: StringWithAggregatesFilter<"Instance"> | string
    clientId?: StringWithAggregatesFilter<"Instance"> | string
    description?: StringNullableWithAggregatesFilter<"Instance"> | string | null
    status?: EnuminstanceStatusWithAggregatesFilter<"Instance"> | $Enums.instanceStatus
    userIds?: StringNullableListFilter<"Instance">
    createdAt?: DateTimeNullableWithAggregatesFilter<"Instance"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Instance"> | Date | string | null
  }

  export type VersionWhereInput = {
    AND?: VersionWhereInput | VersionWhereInput[]
    OR?: VersionWhereInput[]
    NOT?: VersionWhereInput | VersionWhereInput[]
    id?: StringFilter<"Version"> | string
    code?: StringFilter<"Version"> | string
    name?: StringFilter<"Version"> | string
    begin?: DateTimeFilter<"Version"> | Date | string
    end?: DateTimeFilter<"Version"> | Date | string
    startOfPlan?: DateTimeFilter<"Version"> | Date | string
    description?: StringNullableFilter<"Version"> | string | null
    isDefault?: BoolFilter<"Version"> | boolean
    isActuals?: BoolFilter<"Version"> | boolean
    status?: EnumversionStatusFilter<"Version"> | $Enums.versionStatus
    clientId?: StringFilter<"Version"> | string
    instanceId?: StringFilter<"Version"> | string
    createdAt?: DateTimeNullableFilter<"Version"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Version"> | Date | string | null
    instance?: XOR<InstanceScalarRelationFilter, InstanceWhereInput>
    modelData?: ModelDataListRelationFilter
    modelDataCalculations?: ModelDataCalculationsListRelationFilter
  }

  export type VersionOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    begin?: SortOrder
    end?: SortOrder
    startOfPlan?: SortOrder
    description?: SortOrder
    isDefault?: SortOrder
    isActuals?: SortOrder
    status?: SortOrder
    clientId?: SortOrder
    instanceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    instance?: InstanceOrderByWithRelationInput
    modelData?: ModelDataOrderByRelationAggregateInput
    modelDataCalculations?: ModelDataCalculationsOrderByRelationAggregateInput
  }

  export type VersionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    clientId_code_instanceId?: VersionClientIdCodeInstanceIdCompoundUniqueInput
    AND?: VersionWhereInput | VersionWhereInput[]
    OR?: VersionWhereInput[]
    NOT?: VersionWhereInput | VersionWhereInput[]
    code?: StringFilter<"Version"> | string
    name?: StringFilter<"Version"> | string
    begin?: DateTimeFilter<"Version"> | Date | string
    end?: DateTimeFilter<"Version"> | Date | string
    startOfPlan?: DateTimeFilter<"Version"> | Date | string
    description?: StringNullableFilter<"Version"> | string | null
    isDefault?: BoolFilter<"Version"> | boolean
    isActuals?: BoolFilter<"Version"> | boolean
    status?: EnumversionStatusFilter<"Version"> | $Enums.versionStatus
    clientId?: StringFilter<"Version"> | string
    instanceId?: StringFilter<"Version"> | string
    createdAt?: DateTimeNullableFilter<"Version"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Version"> | Date | string | null
    instance?: XOR<InstanceScalarRelationFilter, InstanceWhereInput>
    modelData?: ModelDataListRelationFilter
    modelDataCalculations?: ModelDataCalculationsListRelationFilter
  }, "id" | "clientId_code_instanceId">

  export type VersionOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    begin?: SortOrder
    end?: SortOrder
    startOfPlan?: SortOrder
    description?: SortOrder
    isDefault?: SortOrder
    isActuals?: SortOrder
    status?: SortOrder
    clientId?: SortOrder
    instanceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VersionCountOrderByAggregateInput
    _max?: VersionMaxOrderByAggregateInput
    _min?: VersionMinOrderByAggregateInput
  }

  export type VersionScalarWhereWithAggregatesInput = {
    AND?: VersionScalarWhereWithAggregatesInput | VersionScalarWhereWithAggregatesInput[]
    OR?: VersionScalarWhereWithAggregatesInput[]
    NOT?: VersionScalarWhereWithAggregatesInput | VersionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Version"> | string
    code?: StringWithAggregatesFilter<"Version"> | string
    name?: StringWithAggregatesFilter<"Version"> | string
    begin?: DateTimeWithAggregatesFilter<"Version"> | Date | string
    end?: DateTimeWithAggregatesFilter<"Version"> | Date | string
    startOfPlan?: DateTimeWithAggregatesFilter<"Version"> | Date | string
    description?: StringNullableWithAggregatesFilter<"Version"> | string | null
    isDefault?: BoolWithAggregatesFilter<"Version"> | boolean
    isActuals?: BoolWithAggregatesFilter<"Version"> | boolean
    status?: EnumversionStatusWithAggregatesFilter<"Version"> | $Enums.versionStatus
    clientId?: StringWithAggregatesFilter<"Version"> | string
    instanceId?: StringWithAggregatesFilter<"Version"> | string
    createdAt?: DateTimeNullableWithAggregatesFilter<"Version"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Version"> | Date | string | null
  }

  export type CurrencyIsoCodeWhereInput = {
    AND?: CurrencyIsoCodeWhereInput | CurrencyIsoCodeWhereInput[]
    OR?: CurrencyIsoCodeWhereInput[]
    NOT?: CurrencyIsoCodeWhereInput | CurrencyIsoCodeWhereInput[]
    id?: StringFilter<"CurrencyIsoCode"> | string
    code?: StringFilter<"CurrencyIsoCode"> | string
    name?: StringFilter<"CurrencyIsoCode"> | string
    createdAt?: DateTimeNullableFilter<"CurrencyIsoCode"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"CurrencyIsoCode"> | Date | string | null
    currencies?: CurrencyListRelationFilter
    config?: ConfigListRelationFilter
  }

  export type CurrencyIsoCodeOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    currencies?: CurrencyOrderByRelationAggregateInput
    config?: ConfigOrderByRelationAggregateInput
  }

  export type CurrencyIsoCodeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: CurrencyIsoCodeWhereInput | CurrencyIsoCodeWhereInput[]
    OR?: CurrencyIsoCodeWhereInput[]
    NOT?: CurrencyIsoCodeWhereInput | CurrencyIsoCodeWhereInput[]
    name?: StringFilter<"CurrencyIsoCode"> | string
    createdAt?: DateTimeNullableFilter<"CurrencyIsoCode"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"CurrencyIsoCode"> | Date | string | null
    currencies?: CurrencyListRelationFilter
    config?: ConfigListRelationFilter
  }, "id" | "code">

  export type CurrencyIsoCodeOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CurrencyIsoCodeCountOrderByAggregateInput
    _max?: CurrencyIsoCodeMaxOrderByAggregateInput
    _min?: CurrencyIsoCodeMinOrderByAggregateInput
  }

  export type CurrencyIsoCodeScalarWhereWithAggregatesInput = {
    AND?: CurrencyIsoCodeScalarWhereWithAggregatesInput | CurrencyIsoCodeScalarWhereWithAggregatesInput[]
    OR?: CurrencyIsoCodeScalarWhereWithAggregatesInput[]
    NOT?: CurrencyIsoCodeScalarWhereWithAggregatesInput | CurrencyIsoCodeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CurrencyIsoCode"> | string
    code?: StringWithAggregatesFilter<"CurrencyIsoCode"> | string
    name?: StringWithAggregatesFilter<"CurrencyIsoCode"> | string
    createdAt?: DateTimeNullableWithAggregatesFilter<"CurrencyIsoCode"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"CurrencyIsoCode"> | Date | string | null
  }

  export type CurrencyWhereInput = {
    AND?: CurrencyWhereInput | CurrencyWhereInput[]
    OR?: CurrencyWhereInput[]
    NOT?: CurrencyWhereInput | CurrencyWhereInput[]
    id?: StringFilter<"Currency"> | string
    name?: StringFilter<"Currency"> | string
    code?: StringFilter<"Currency"> | string
    currencyIsoCodeId?: StringFilter<"Currency"> | string
    assignedLevels?: IntFilter<"Currency"> | number
    isDefault?: EnumYesNoFilter<"Currency"> | $Enums.YesNo
    clientId?: StringFilter<"Currency"> | string
    instanceId?: StringFilter<"Currency"> | string
    createdAt?: DateTimeNullableFilter<"Currency"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Currency"> | Date | string | null
    currencyIsoCode?: XOR<CurrencyIsoCodeScalarRelationFilter, CurrencyIsoCodeWhereInput>
    instance?: XOR<InstanceScalarRelationFilter, InstanceWhereInput>
    levels?: LevelListRelationFilter
    defaults?: ConfigListRelationFilter
  }

  export type CurrencyOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    currencyIsoCodeId?: SortOrder
    assignedLevels?: SortOrder
    isDefault?: SortOrder
    clientId?: SortOrder
    instanceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    currencyIsoCode?: CurrencyIsoCodeOrderByWithRelationInput
    instance?: InstanceOrderByWithRelationInput
    levels?: LevelOrderByRelationAggregateInput
    defaults?: ConfigOrderByRelationAggregateInput
  }

  export type CurrencyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    clientId_instanceId_currencyIsoCodeId_code?: CurrencyClientIdInstanceIdCurrencyIsoCodeIdCodeCompoundUniqueInput
    AND?: CurrencyWhereInput | CurrencyWhereInput[]
    OR?: CurrencyWhereInput[]
    NOT?: CurrencyWhereInput | CurrencyWhereInput[]
    name?: StringFilter<"Currency"> | string
    code?: StringFilter<"Currency"> | string
    currencyIsoCodeId?: StringFilter<"Currency"> | string
    assignedLevels?: IntFilter<"Currency"> | number
    isDefault?: EnumYesNoFilter<"Currency"> | $Enums.YesNo
    clientId?: StringFilter<"Currency"> | string
    instanceId?: StringFilter<"Currency"> | string
    createdAt?: DateTimeNullableFilter<"Currency"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Currency"> | Date | string | null
    currencyIsoCode?: XOR<CurrencyIsoCodeScalarRelationFilter, CurrencyIsoCodeWhereInput>
    instance?: XOR<InstanceScalarRelationFilter, InstanceWhereInput>
    levels?: LevelListRelationFilter
    defaults?: ConfigListRelationFilter
  }, "id" | "clientId_instanceId_currencyIsoCodeId_code">

  export type CurrencyOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    currencyIsoCodeId?: SortOrder
    assignedLevels?: SortOrder
    isDefault?: SortOrder
    clientId?: SortOrder
    instanceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CurrencyCountOrderByAggregateInput
    _avg?: CurrencyAvgOrderByAggregateInput
    _max?: CurrencyMaxOrderByAggregateInput
    _min?: CurrencyMinOrderByAggregateInput
    _sum?: CurrencySumOrderByAggregateInput
  }

  export type CurrencyScalarWhereWithAggregatesInput = {
    AND?: CurrencyScalarWhereWithAggregatesInput | CurrencyScalarWhereWithAggregatesInput[]
    OR?: CurrencyScalarWhereWithAggregatesInput[]
    NOT?: CurrencyScalarWhereWithAggregatesInput | CurrencyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Currency"> | string
    name?: StringWithAggregatesFilter<"Currency"> | string
    code?: StringWithAggregatesFilter<"Currency"> | string
    currencyIsoCodeId?: StringWithAggregatesFilter<"Currency"> | string
    assignedLevels?: IntWithAggregatesFilter<"Currency"> | number
    isDefault?: EnumYesNoWithAggregatesFilter<"Currency"> | $Enums.YesNo
    clientId?: StringWithAggregatesFilter<"Currency"> | string
    instanceId?: StringWithAggregatesFilter<"Currency"> | string
    createdAt?: DateTimeNullableWithAggregatesFilter<"Currency"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Currency"> | Date | string | null
  }

  export type LevelWhereInput = {
    AND?: LevelWhereInput | LevelWhereInput[]
    OR?: LevelWhereInput[]
    NOT?: LevelWhereInput | LevelWhereInput[]
    id?: StringFilter<"Level"> | string
    code?: StringFilter<"Level"> | string
    name?: StringFilter<"Level"> | string
    isRoot?: BoolFilter<"Level"> | boolean
    description?: StringNullableFilter<"Level"> | string | null
    parentId?: StringNullableFilter<"Level"> | string | null
    clientId?: StringFilter<"Level"> | string
    instanceId?: StringFilter<"Level"> | string
    currencyId?: StringFilter<"Level"> | string
    createdAt?: DateTimeNullableFilter<"Level"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Level"> | Date | string | null
    AttributeAndValues?: LevelAttributeAndValueListRelationFilter
    parent?: XOR<LevelNullableScalarRelationFilter, LevelWhereInput> | null
    instance?: XOR<InstanceScalarRelationFilter, InstanceWhereInput>
    currency?: XOR<CurrencyScalarRelationFilter, CurrencyWhereInput>
    childLevels?: LevelListRelationFilter
    modelData?: ModelDataListRelationFilter
    modeldataCalculations?: ModelDataCalculationsListRelationFilter
  }

  export type LevelOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    isRoot?: SortOrder
    description?: SortOrder
    parentId?: SortOrder
    clientId?: SortOrder
    instanceId?: SortOrder
    currencyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    AttributeAndValues?: LevelAttributeAndValueOrderByRelationAggregateInput
    parent?: LevelOrderByWithRelationInput
    instance?: InstanceOrderByWithRelationInput
    currency?: CurrencyOrderByWithRelationInput
    childLevels?: LevelOrderByRelationAggregateInput
    modelData?: ModelDataOrderByRelationAggregateInput
    modeldataCalculations?: ModelDataCalculationsOrderByRelationAggregateInput
  }

  export type LevelWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    uniqueCode?: LevelUniqueCodeCompoundUniqueInput
    AND?: LevelWhereInput | LevelWhereInput[]
    OR?: LevelWhereInput[]
    NOT?: LevelWhereInput | LevelWhereInput[]
    code?: StringFilter<"Level"> | string
    name?: StringFilter<"Level"> | string
    isRoot?: BoolFilter<"Level"> | boolean
    description?: StringNullableFilter<"Level"> | string | null
    parentId?: StringNullableFilter<"Level"> | string | null
    clientId?: StringFilter<"Level"> | string
    instanceId?: StringFilter<"Level"> | string
    currencyId?: StringFilter<"Level"> | string
    createdAt?: DateTimeNullableFilter<"Level"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Level"> | Date | string | null
    AttributeAndValues?: LevelAttributeAndValueListRelationFilter
    parent?: XOR<LevelNullableScalarRelationFilter, LevelWhereInput> | null
    instance?: XOR<InstanceScalarRelationFilter, InstanceWhereInput>
    currency?: XOR<CurrencyScalarRelationFilter, CurrencyWhereInput>
    childLevels?: LevelListRelationFilter
    modelData?: ModelDataListRelationFilter
    modeldataCalculations?: ModelDataCalculationsListRelationFilter
  }, "id" | "uniqueCode">

  export type LevelOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    isRoot?: SortOrder
    description?: SortOrder
    parentId?: SortOrder
    clientId?: SortOrder
    instanceId?: SortOrder
    currencyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LevelCountOrderByAggregateInput
    _max?: LevelMaxOrderByAggregateInput
    _min?: LevelMinOrderByAggregateInput
  }

  export type LevelScalarWhereWithAggregatesInput = {
    AND?: LevelScalarWhereWithAggregatesInput | LevelScalarWhereWithAggregatesInput[]
    OR?: LevelScalarWhereWithAggregatesInput[]
    NOT?: LevelScalarWhereWithAggregatesInput | LevelScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Level"> | string
    code?: StringWithAggregatesFilter<"Level"> | string
    name?: StringWithAggregatesFilter<"Level"> | string
    isRoot?: BoolWithAggregatesFilter<"Level"> | boolean
    description?: StringNullableWithAggregatesFilter<"Level"> | string | null
    parentId?: StringNullableWithAggregatesFilter<"Level"> | string | null
    clientId?: StringWithAggregatesFilter<"Level"> | string
    instanceId?: StringWithAggregatesFilter<"Level"> | string
    currencyId?: StringWithAggregatesFilter<"Level"> | string
    createdAt?: DateTimeNullableWithAggregatesFilter<"Level"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Level"> | Date | string | null
  }

  export type LevelAttributeAndValueWhereInput = {
    AND?: LevelAttributeAndValueWhereInput | LevelAttributeAndValueWhereInput[]
    OR?: LevelAttributeAndValueWhereInput[]
    NOT?: LevelAttributeAndValueWhereInput | LevelAttributeAndValueWhereInput[]
    id?: StringFilter<"LevelAttributeAndValue"> | string
    levelId?: StringFilter<"LevelAttributeAndValue"> | string
    clientId?: StringFilter<"LevelAttributeAndValue"> | string
    instanceId?: StringFilter<"LevelAttributeAndValue"> | string
    attributeId?: StringFilter<"LevelAttributeAndValue"> | string
    attributeValueId?: StringFilter<"LevelAttributeAndValue"> | string
    levelCode?: StringFilter<"LevelAttributeAndValue"> | string
    createdAt?: DateTimeNullableFilter<"LevelAttributeAndValue"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"LevelAttributeAndValue"> | Date | string | null
    level?: XOR<LevelNullableScalarRelationFilter, LevelWhereInput> | null
    attribute?: XOR<LevelAttributeNullableScalarRelationFilter, LevelAttributeWhereInput> | null
    attributeValue?: XOR<LevelAttributeValueNullableScalarRelationFilter, LevelAttributeValueWhereInput> | null
  }

  export type LevelAttributeAndValueOrderByWithRelationInput = {
    id?: SortOrder
    levelId?: SortOrder
    clientId?: SortOrder
    instanceId?: SortOrder
    attributeId?: SortOrder
    attributeValueId?: SortOrder
    levelCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    level?: LevelOrderByWithRelationInput
    attribute?: LevelAttributeOrderByWithRelationInput
    attributeValue?: LevelAttributeValueOrderByWithRelationInput
  }

  export type LevelAttributeAndValueWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LevelAttributeAndValueWhereInput | LevelAttributeAndValueWhereInput[]
    OR?: LevelAttributeAndValueWhereInput[]
    NOT?: LevelAttributeAndValueWhereInput | LevelAttributeAndValueWhereInput[]
    levelId?: StringFilter<"LevelAttributeAndValue"> | string
    clientId?: StringFilter<"LevelAttributeAndValue"> | string
    instanceId?: StringFilter<"LevelAttributeAndValue"> | string
    attributeId?: StringFilter<"LevelAttributeAndValue"> | string
    attributeValueId?: StringFilter<"LevelAttributeAndValue"> | string
    levelCode?: StringFilter<"LevelAttributeAndValue"> | string
    createdAt?: DateTimeNullableFilter<"LevelAttributeAndValue"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"LevelAttributeAndValue"> | Date | string | null
    level?: XOR<LevelNullableScalarRelationFilter, LevelWhereInput> | null
    attribute?: XOR<LevelAttributeNullableScalarRelationFilter, LevelAttributeWhereInput> | null
    attributeValue?: XOR<LevelAttributeValueNullableScalarRelationFilter, LevelAttributeValueWhereInput> | null
  }, "id">

  export type LevelAttributeAndValueOrderByWithAggregationInput = {
    id?: SortOrder
    levelId?: SortOrder
    clientId?: SortOrder
    instanceId?: SortOrder
    attributeId?: SortOrder
    attributeValueId?: SortOrder
    levelCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LevelAttributeAndValueCountOrderByAggregateInput
    _max?: LevelAttributeAndValueMaxOrderByAggregateInput
    _min?: LevelAttributeAndValueMinOrderByAggregateInput
  }

  export type LevelAttributeAndValueScalarWhereWithAggregatesInput = {
    AND?: LevelAttributeAndValueScalarWhereWithAggregatesInput | LevelAttributeAndValueScalarWhereWithAggregatesInput[]
    OR?: LevelAttributeAndValueScalarWhereWithAggregatesInput[]
    NOT?: LevelAttributeAndValueScalarWhereWithAggregatesInput | LevelAttributeAndValueScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LevelAttributeAndValue"> | string
    levelId?: StringWithAggregatesFilter<"LevelAttributeAndValue"> | string
    clientId?: StringWithAggregatesFilter<"LevelAttributeAndValue"> | string
    instanceId?: StringWithAggregatesFilter<"LevelAttributeAndValue"> | string
    attributeId?: StringWithAggregatesFilter<"LevelAttributeAndValue"> | string
    attributeValueId?: StringWithAggregatesFilter<"LevelAttributeAndValue"> | string
    levelCode?: StringWithAggregatesFilter<"LevelAttributeAndValue"> | string
    createdAt?: DateTimeNullableWithAggregatesFilter<"LevelAttributeAndValue"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"LevelAttributeAndValue"> | Date | string | null
  }

  export type LevelAttributeValueWhereInput = {
    AND?: LevelAttributeValueWhereInput | LevelAttributeValueWhereInput[]
    OR?: LevelAttributeValueWhereInput[]
    NOT?: LevelAttributeValueWhereInput | LevelAttributeValueWhereInput[]
    id?: StringFilter<"LevelAttributeValue"> | string
    code?: StringFilter<"LevelAttributeValue"> | string
    name?: StringFilter<"LevelAttributeValue"> | string
    attributeId?: StringFilter<"LevelAttributeValue"> | string
    parentId?: StringNullableFilter<"LevelAttributeValue"> | string | null
    clientId?: StringFilter<"LevelAttributeValue"> | string
    instanceId?: StringFilter<"LevelAttributeValue"> | string
    createdAt?: DateTimeNullableFilter<"LevelAttributeValue"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"LevelAttributeValue"> | Date | string | null
    parent?: XOR<LevelAttributeValueNullableScalarRelationFilter, LevelAttributeValueWhereInput> | null
    childAttributeValues?: LevelAttributeValueListRelationFilter
    instance?: XOR<InstanceScalarRelationFilter, InstanceWhereInput>
    levelAttribute?: XOR<LevelAttributeScalarRelationFilter, LevelAttributeWhereInput>
    levelAttributeAndValues?: LevelAttributeAndValueListRelationFilter
  }

  export type LevelAttributeValueOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    attributeId?: SortOrder
    parentId?: SortOrder
    clientId?: SortOrder
    instanceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    parent?: LevelAttributeValueOrderByWithRelationInput
    childAttributeValues?: LevelAttributeValueOrderByRelationAggregateInput
    instance?: InstanceOrderByWithRelationInput
    levelAttribute?: LevelAttributeOrderByWithRelationInput
    levelAttributeAndValues?: LevelAttributeAndValueOrderByRelationAggregateInput
  }

  export type LevelAttributeValueWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    clientId_code_instanceId_attributeId?: LevelAttributeValueClientIdCodeInstanceIdAttributeIdCompoundUniqueInput
    AND?: LevelAttributeValueWhereInput | LevelAttributeValueWhereInput[]
    OR?: LevelAttributeValueWhereInput[]
    NOT?: LevelAttributeValueWhereInput | LevelAttributeValueWhereInput[]
    code?: StringFilter<"LevelAttributeValue"> | string
    name?: StringFilter<"LevelAttributeValue"> | string
    attributeId?: StringFilter<"LevelAttributeValue"> | string
    parentId?: StringNullableFilter<"LevelAttributeValue"> | string | null
    clientId?: StringFilter<"LevelAttributeValue"> | string
    instanceId?: StringFilter<"LevelAttributeValue"> | string
    createdAt?: DateTimeNullableFilter<"LevelAttributeValue"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"LevelAttributeValue"> | Date | string | null
    parent?: XOR<LevelAttributeValueNullableScalarRelationFilter, LevelAttributeValueWhereInput> | null
    childAttributeValues?: LevelAttributeValueListRelationFilter
    instance?: XOR<InstanceScalarRelationFilter, InstanceWhereInput>
    levelAttribute?: XOR<LevelAttributeScalarRelationFilter, LevelAttributeWhereInput>
    levelAttributeAndValues?: LevelAttributeAndValueListRelationFilter
  }, "id" | "clientId_code_instanceId_attributeId">

  export type LevelAttributeValueOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    attributeId?: SortOrder
    parentId?: SortOrder
    clientId?: SortOrder
    instanceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LevelAttributeValueCountOrderByAggregateInput
    _max?: LevelAttributeValueMaxOrderByAggregateInput
    _min?: LevelAttributeValueMinOrderByAggregateInput
  }

  export type LevelAttributeValueScalarWhereWithAggregatesInput = {
    AND?: LevelAttributeValueScalarWhereWithAggregatesInput | LevelAttributeValueScalarWhereWithAggregatesInput[]
    OR?: LevelAttributeValueScalarWhereWithAggregatesInput[]
    NOT?: LevelAttributeValueScalarWhereWithAggregatesInput | LevelAttributeValueScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LevelAttributeValue"> | string
    code?: StringWithAggregatesFilter<"LevelAttributeValue"> | string
    name?: StringWithAggregatesFilter<"LevelAttributeValue"> | string
    attributeId?: StringWithAggregatesFilter<"LevelAttributeValue"> | string
    parentId?: StringNullableWithAggregatesFilter<"LevelAttributeValue"> | string | null
    clientId?: StringWithAggregatesFilter<"LevelAttributeValue"> | string
    instanceId?: StringWithAggregatesFilter<"LevelAttributeValue"> | string
    createdAt?: DateTimeNullableWithAggregatesFilter<"LevelAttributeValue"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"LevelAttributeValue"> | Date | string | null
  }

  export type LevelAttributeWhereInput = {
    AND?: LevelAttributeWhereInput | LevelAttributeWhereInput[]
    OR?: LevelAttributeWhereInput[]
    NOT?: LevelAttributeWhereInput | LevelAttributeWhereInput[]
    id?: StringFilter<"LevelAttribute"> | string
    code?: StringFilter<"LevelAttribute"> | string
    name?: StringFilter<"LevelAttribute"> | string
    description?: StringNullableFilter<"LevelAttribute"> | string | null
    clientId?: StringFilter<"LevelAttribute"> | string
    instanceId?: StringFilter<"LevelAttribute"> | string
    attributeValueDefault?: StringNullableFilter<"LevelAttribute"> | string | null
    createdAt?: DateTimeNullableFilter<"LevelAttribute"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"LevelAttribute"> | Date | string | null
    instance?: XOR<InstanceScalarRelationFilter, InstanceWhereInput>
    levelAttributeValues?: LevelAttributeValueListRelationFilter
    levelAttributeAndValues?: LevelAttributeAndValueListRelationFilter
  }

  export type LevelAttributeOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    clientId?: SortOrder
    instanceId?: SortOrder
    attributeValueDefault?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    instance?: InstanceOrderByWithRelationInput
    levelAttributeValues?: LevelAttributeValueOrderByRelationAggregateInput
    levelAttributeAndValues?: LevelAttributeAndValueOrderByRelationAggregateInput
  }

  export type LevelAttributeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    clientId_code_instanceId?: LevelAttributeClientIdCodeInstanceIdCompoundUniqueInput
    AND?: LevelAttributeWhereInput | LevelAttributeWhereInput[]
    OR?: LevelAttributeWhereInput[]
    NOT?: LevelAttributeWhereInput | LevelAttributeWhereInput[]
    code?: StringFilter<"LevelAttribute"> | string
    name?: StringFilter<"LevelAttribute"> | string
    description?: StringNullableFilter<"LevelAttribute"> | string | null
    clientId?: StringFilter<"LevelAttribute"> | string
    instanceId?: StringFilter<"LevelAttribute"> | string
    attributeValueDefault?: StringNullableFilter<"LevelAttribute"> | string | null
    createdAt?: DateTimeNullableFilter<"LevelAttribute"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"LevelAttribute"> | Date | string | null
    instance?: XOR<InstanceScalarRelationFilter, InstanceWhereInput>
    levelAttributeValues?: LevelAttributeValueListRelationFilter
    levelAttributeAndValues?: LevelAttributeAndValueListRelationFilter
  }, "id" | "clientId_code_instanceId">

  export type LevelAttributeOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    clientId?: SortOrder
    instanceId?: SortOrder
    attributeValueDefault?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LevelAttributeCountOrderByAggregateInput
    _max?: LevelAttributeMaxOrderByAggregateInput
    _min?: LevelAttributeMinOrderByAggregateInput
  }

  export type LevelAttributeScalarWhereWithAggregatesInput = {
    AND?: LevelAttributeScalarWhereWithAggregatesInput | LevelAttributeScalarWhereWithAggregatesInput[]
    OR?: LevelAttributeScalarWhereWithAggregatesInput[]
    NOT?: LevelAttributeScalarWhereWithAggregatesInput | LevelAttributeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LevelAttribute"> | string
    code?: StringWithAggregatesFilter<"LevelAttribute"> | string
    name?: StringWithAggregatesFilter<"LevelAttribute"> | string
    description?: StringNullableWithAggregatesFilter<"LevelAttribute"> | string | null
    clientId?: StringWithAggregatesFilter<"LevelAttribute"> | string
    instanceId?: StringWithAggregatesFilter<"LevelAttribute"> | string
    attributeValueDefault?: StringNullableWithAggregatesFilter<"LevelAttribute"> | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"LevelAttribute"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"LevelAttribute"> | Date | string | null
  }

  export type AccountAttributeWhereInput = {
    AND?: AccountAttributeWhereInput | AccountAttributeWhereInput[]
    OR?: AccountAttributeWhereInput[]
    NOT?: AccountAttributeWhereInput | AccountAttributeWhereInput[]
    id?: StringFilter<"AccountAttribute"> | string
    code?: StringFilter<"AccountAttribute"> | string
    name?: StringFilter<"AccountAttribute"> | string
    description?: StringNullableFilter<"AccountAttribute"> | string | null
    attributeValueDefault?: StringNullableFilter<"AccountAttribute"> | string | null
    clientId?: StringFilter<"AccountAttribute"> | string
    instanceId?: StringFilter<"AccountAttribute"> | string
    createdAt?: DateTimeNullableFilter<"AccountAttribute"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"AccountAttribute"> | Date | string | null
    instance?: XOR<InstanceScalarRelationFilter, InstanceWhereInput>
    accountAttributeValues?: AccountAttributeValueListRelationFilter
    AttributeAndValues?: AccountAttributeAndValueListRelationFilter
  }

  export type AccountAttributeOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    attributeValueDefault?: SortOrder
    clientId?: SortOrder
    instanceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    instance?: InstanceOrderByWithRelationInput
    accountAttributeValues?: AccountAttributeValueOrderByRelationAggregateInput
    AttributeAndValues?: AccountAttributeAndValueOrderByRelationAggregateInput
  }

  export type AccountAttributeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    clientId_code_instanceId?: AccountAttributeClientIdCodeInstanceIdCompoundUniqueInput
    AND?: AccountAttributeWhereInput | AccountAttributeWhereInput[]
    OR?: AccountAttributeWhereInput[]
    NOT?: AccountAttributeWhereInput | AccountAttributeWhereInput[]
    code?: StringFilter<"AccountAttribute"> | string
    name?: StringFilter<"AccountAttribute"> | string
    description?: StringNullableFilter<"AccountAttribute"> | string | null
    attributeValueDefault?: StringNullableFilter<"AccountAttribute"> | string | null
    clientId?: StringFilter<"AccountAttribute"> | string
    instanceId?: StringFilter<"AccountAttribute"> | string
    createdAt?: DateTimeNullableFilter<"AccountAttribute"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"AccountAttribute"> | Date | string | null
    instance?: XOR<InstanceScalarRelationFilter, InstanceWhereInput>
    accountAttributeValues?: AccountAttributeValueListRelationFilter
    AttributeAndValues?: AccountAttributeAndValueListRelationFilter
  }, "id" | "clientId_code_instanceId">

  export type AccountAttributeOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    attributeValueDefault?: SortOrder
    clientId?: SortOrder
    instanceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AccountAttributeCountOrderByAggregateInput
    _max?: AccountAttributeMaxOrderByAggregateInput
    _min?: AccountAttributeMinOrderByAggregateInput
  }

  export type AccountAttributeScalarWhereWithAggregatesInput = {
    AND?: AccountAttributeScalarWhereWithAggregatesInput | AccountAttributeScalarWhereWithAggregatesInput[]
    OR?: AccountAttributeScalarWhereWithAggregatesInput[]
    NOT?: AccountAttributeScalarWhereWithAggregatesInput | AccountAttributeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AccountAttribute"> | string
    code?: StringWithAggregatesFilter<"AccountAttribute"> | string
    name?: StringWithAggregatesFilter<"AccountAttribute"> | string
    description?: StringNullableWithAggregatesFilter<"AccountAttribute"> | string | null
    attributeValueDefault?: StringNullableWithAggregatesFilter<"AccountAttribute"> | string | null
    clientId?: StringWithAggregatesFilter<"AccountAttribute"> | string
    instanceId?: StringWithAggregatesFilter<"AccountAttribute"> | string
    createdAt?: DateTimeNullableWithAggregatesFilter<"AccountAttribute"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"AccountAttribute"> | Date | string | null
  }

  export type AccountAttributeValueWhereInput = {
    AND?: AccountAttributeValueWhereInput | AccountAttributeValueWhereInput[]
    OR?: AccountAttributeValueWhereInput[]
    NOT?: AccountAttributeValueWhereInput | AccountAttributeValueWhereInput[]
    id?: StringFilter<"AccountAttributeValue"> | string
    code?: StringFilter<"AccountAttributeValue"> | string
    name?: StringFilter<"AccountAttributeValue"> | string
    attributeId?: StringFilter<"AccountAttributeValue"> | string
    parentId?: StringNullableFilter<"AccountAttributeValue"> | string | null
    clientId?: StringFilter<"AccountAttributeValue"> | string
    instanceId?: StringFilter<"AccountAttributeValue"> | string
    createdAt?: DateTimeNullableFilter<"AccountAttributeValue"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"AccountAttributeValue"> | Date | string | null
    parent?: XOR<AccountAttributeValueNullableScalarRelationFilter, AccountAttributeValueWhereInput> | null
    childAttributeValues?: AccountAttributeValueListRelationFilter
    accountAttribute?: XOR<AccountAttributeScalarRelationFilter, AccountAttributeWhereInput>
    instance?: XOR<InstanceScalarRelationFilter, InstanceWhereInput>
    AttributeAndValues?: AccountAttributeAndValueListRelationFilter
  }

  export type AccountAttributeValueOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    attributeId?: SortOrder
    parentId?: SortOrder
    clientId?: SortOrder
    instanceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    parent?: AccountAttributeValueOrderByWithRelationInput
    childAttributeValues?: AccountAttributeValueOrderByRelationAggregateInput
    accountAttribute?: AccountAttributeOrderByWithRelationInput
    instance?: InstanceOrderByWithRelationInput
    AttributeAndValues?: AccountAttributeAndValueOrderByRelationAggregateInput
  }

  export type AccountAttributeValueWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    clientId_code_instanceId_attributeId?: AccountAttributeValueClientIdCodeInstanceIdAttributeIdCompoundUniqueInput
    AND?: AccountAttributeValueWhereInput | AccountAttributeValueWhereInput[]
    OR?: AccountAttributeValueWhereInput[]
    NOT?: AccountAttributeValueWhereInput | AccountAttributeValueWhereInput[]
    code?: StringFilter<"AccountAttributeValue"> | string
    name?: StringFilter<"AccountAttributeValue"> | string
    attributeId?: StringFilter<"AccountAttributeValue"> | string
    parentId?: StringNullableFilter<"AccountAttributeValue"> | string | null
    clientId?: StringFilter<"AccountAttributeValue"> | string
    instanceId?: StringFilter<"AccountAttributeValue"> | string
    createdAt?: DateTimeNullableFilter<"AccountAttributeValue"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"AccountAttributeValue"> | Date | string | null
    parent?: XOR<AccountAttributeValueNullableScalarRelationFilter, AccountAttributeValueWhereInput> | null
    childAttributeValues?: AccountAttributeValueListRelationFilter
    accountAttribute?: XOR<AccountAttributeScalarRelationFilter, AccountAttributeWhereInput>
    instance?: XOR<InstanceScalarRelationFilter, InstanceWhereInput>
    AttributeAndValues?: AccountAttributeAndValueListRelationFilter
  }, "id" | "clientId_code_instanceId_attributeId">

  export type AccountAttributeValueOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    attributeId?: SortOrder
    parentId?: SortOrder
    clientId?: SortOrder
    instanceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AccountAttributeValueCountOrderByAggregateInput
    _max?: AccountAttributeValueMaxOrderByAggregateInput
    _min?: AccountAttributeValueMinOrderByAggregateInput
  }

  export type AccountAttributeValueScalarWhereWithAggregatesInput = {
    AND?: AccountAttributeValueScalarWhereWithAggregatesInput | AccountAttributeValueScalarWhereWithAggregatesInput[]
    OR?: AccountAttributeValueScalarWhereWithAggregatesInput[]
    NOT?: AccountAttributeValueScalarWhereWithAggregatesInput | AccountAttributeValueScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AccountAttributeValue"> | string
    code?: StringWithAggregatesFilter<"AccountAttributeValue"> | string
    name?: StringWithAggregatesFilter<"AccountAttributeValue"> | string
    attributeId?: StringWithAggregatesFilter<"AccountAttributeValue"> | string
    parentId?: StringNullableWithAggregatesFilter<"AccountAttributeValue"> | string | null
    clientId?: StringWithAggregatesFilter<"AccountAttributeValue"> | string
    instanceId?: StringWithAggregatesFilter<"AccountAttributeValue"> | string
    createdAt?: DateTimeNullableWithAggregatesFilter<"AccountAttributeValue"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"AccountAttributeValue"> | Date | string | null
  }

  export type AccountAttributeAndValueWhereInput = {
    AND?: AccountAttributeAndValueWhereInput | AccountAttributeAndValueWhereInput[]
    OR?: AccountAttributeAndValueWhereInput[]
    NOT?: AccountAttributeAndValueWhereInput | AccountAttributeAndValueWhereInput[]
    id?: StringFilter<"AccountAttributeAndValue"> | string
    accountId?: StringFilter<"AccountAttributeAndValue"> | string
    clientId?: StringFilter<"AccountAttributeAndValue"> | string
    instanceId?: StringFilter<"AccountAttributeAndValue"> | string
    attributeId?: StringFilter<"AccountAttributeAndValue"> | string
    attributeValueId?: StringFilter<"AccountAttributeAndValue"> | string
    createdAt?: DateTimeNullableFilter<"AccountAttributeAndValue"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"AccountAttributeAndValue"> | Date | string | null
    account?: XOR<AccountNullableScalarRelationFilter, AccountWhereInput> | null
    attribute?: XOR<AccountAttributeNullableScalarRelationFilter, AccountAttributeWhereInput> | null
    attributeValue?: XOR<AccountAttributeValueNullableScalarRelationFilter, AccountAttributeValueWhereInput> | null
  }

  export type AccountAttributeAndValueOrderByWithRelationInput = {
    id?: SortOrder
    accountId?: SortOrder
    clientId?: SortOrder
    instanceId?: SortOrder
    attributeId?: SortOrder
    attributeValueId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    account?: AccountOrderByWithRelationInput
    attribute?: AccountAttributeOrderByWithRelationInput
    attributeValue?: AccountAttributeValueOrderByWithRelationInput
  }

  export type AccountAttributeAndValueWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AccountAttributeAndValueWhereInput | AccountAttributeAndValueWhereInput[]
    OR?: AccountAttributeAndValueWhereInput[]
    NOT?: AccountAttributeAndValueWhereInput | AccountAttributeAndValueWhereInput[]
    accountId?: StringFilter<"AccountAttributeAndValue"> | string
    clientId?: StringFilter<"AccountAttributeAndValue"> | string
    instanceId?: StringFilter<"AccountAttributeAndValue"> | string
    attributeId?: StringFilter<"AccountAttributeAndValue"> | string
    attributeValueId?: StringFilter<"AccountAttributeAndValue"> | string
    createdAt?: DateTimeNullableFilter<"AccountAttributeAndValue"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"AccountAttributeAndValue"> | Date | string | null
    account?: XOR<AccountNullableScalarRelationFilter, AccountWhereInput> | null
    attribute?: XOR<AccountAttributeNullableScalarRelationFilter, AccountAttributeWhereInput> | null
    attributeValue?: XOR<AccountAttributeValueNullableScalarRelationFilter, AccountAttributeValueWhereInput> | null
  }, "id">

  export type AccountAttributeAndValueOrderByWithAggregationInput = {
    id?: SortOrder
    accountId?: SortOrder
    clientId?: SortOrder
    instanceId?: SortOrder
    attributeId?: SortOrder
    attributeValueId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AccountAttributeAndValueCountOrderByAggregateInput
    _max?: AccountAttributeAndValueMaxOrderByAggregateInput
    _min?: AccountAttributeAndValueMinOrderByAggregateInput
  }

  export type AccountAttributeAndValueScalarWhereWithAggregatesInput = {
    AND?: AccountAttributeAndValueScalarWhereWithAggregatesInput | AccountAttributeAndValueScalarWhereWithAggregatesInput[]
    OR?: AccountAttributeAndValueScalarWhereWithAggregatesInput[]
    NOT?: AccountAttributeAndValueScalarWhereWithAggregatesInput | AccountAttributeAndValueScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AccountAttributeAndValue"> | string
    accountId?: StringWithAggregatesFilter<"AccountAttributeAndValue"> | string
    clientId?: StringWithAggregatesFilter<"AccountAttributeAndValue"> | string
    instanceId?: StringWithAggregatesFilter<"AccountAttributeAndValue"> | string
    attributeId?: StringWithAggregatesFilter<"AccountAttributeAndValue"> | string
    attributeValueId?: StringWithAggregatesFilter<"AccountAttributeAndValue"> | string
    createdAt?: DateTimeNullableWithAggregatesFilter<"AccountAttributeAndValue"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"AccountAttributeAndValue"> | Date | string | null
  }

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: StringFilter<"Account"> | string
    code?: StringFilter<"Account"> | string
    name?: StringFilter<"Account"> | string
    isRoot?: BoolFilter<"Account"> | boolean
    isModelRoot?: BoolFilter<"Account"> | boolean
    accountType?: EnumAccountTypeFilter<"Account"> | $Enums.AccountType
    accountTypeTag?: EnumAccountTypeTagFilter<"Account"> | $Enums.AccountTypeTag
    group?: EnumYesNoFilter<"Account"> | $Enums.YesNo
    plannedBy?: EnumActPlanByNullableFilter<"Account"> | $Enums.ActPlanBy | null
    actualsBy?: EnumActActualsByNullableFilter<"Account"> | $Enums.ActActualsBy | null
    displayAs?: EnumActDisplayAsFilter<"Account"> | $Enums.ActDisplayAs
    containsSalaryInfo?: EnumYesNoFilter<"Account"> | $Enums.YesNo
    description?: StringNullableFilter<"Account"> | string | null
    instanceId?: StringFilter<"Account"> | string
    clientId?: StringFilter<"Account"> | string
    parentId?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    instance?: XOR<InstanceScalarRelationFilter, InstanceWhereInput>
    parent?: XOR<AccountNullableScalarRelationFilter, AccountWhereInput> | null
    childAccounts?: AccountListRelationFilter
    AttributeAndValues?: AccountAttributeAndValueListRelationFilter
    modelAccounts?: ModelAccountStructureListRelationFilter
    modelData?: ModelDataListRelationFilter
    modeldataCalculations?: ModelDataCalculationsListRelationFilter
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    isRoot?: SortOrder
    isModelRoot?: SortOrder
    accountType?: SortOrder
    accountTypeTag?: SortOrder
    group?: SortOrder
    plannedBy?: SortOrder
    actualsBy?: SortOrder
    displayAs?: SortOrder
    containsSalaryInfo?: SortOrder
    description?: SortOrder
    instanceId?: SortOrder
    clientId?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    instance?: InstanceOrderByWithRelationInput
    parent?: AccountOrderByWithRelationInput
    childAccounts?: AccountOrderByRelationAggregateInput
    AttributeAndValues?: AccountAttributeAndValueOrderByRelationAggregateInput
    modelAccounts?: ModelAccountStructureOrderByRelationAggregateInput
    modelData?: ModelDataOrderByRelationAggregateInput
    modeldataCalculations?: ModelDataCalculationsOrderByRelationAggregateInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    clientId_code_instanceId?: AccountClientIdCodeInstanceIdCompoundUniqueInput
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    code?: StringFilter<"Account"> | string
    name?: StringFilter<"Account"> | string
    isRoot?: BoolFilter<"Account"> | boolean
    isModelRoot?: BoolFilter<"Account"> | boolean
    accountType?: EnumAccountTypeFilter<"Account"> | $Enums.AccountType
    accountTypeTag?: EnumAccountTypeTagFilter<"Account"> | $Enums.AccountTypeTag
    group?: EnumYesNoFilter<"Account"> | $Enums.YesNo
    plannedBy?: EnumActPlanByNullableFilter<"Account"> | $Enums.ActPlanBy | null
    actualsBy?: EnumActActualsByNullableFilter<"Account"> | $Enums.ActActualsBy | null
    displayAs?: EnumActDisplayAsFilter<"Account"> | $Enums.ActDisplayAs
    containsSalaryInfo?: EnumYesNoFilter<"Account"> | $Enums.YesNo
    description?: StringNullableFilter<"Account"> | string | null
    instanceId?: StringFilter<"Account"> | string
    clientId?: StringFilter<"Account"> | string
    parentId?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    instance?: XOR<InstanceScalarRelationFilter, InstanceWhereInput>
    parent?: XOR<AccountNullableScalarRelationFilter, AccountWhereInput> | null
    childAccounts?: AccountListRelationFilter
    AttributeAndValues?: AccountAttributeAndValueListRelationFilter
    modelAccounts?: ModelAccountStructureListRelationFilter
    modelData?: ModelDataListRelationFilter
    modeldataCalculations?: ModelDataCalculationsListRelationFilter
  }, "id" | "clientId_code_instanceId">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    isRoot?: SortOrder
    isModelRoot?: SortOrder
    accountType?: SortOrder
    accountTypeTag?: SortOrder
    group?: SortOrder
    plannedBy?: SortOrder
    actualsBy?: SortOrder
    displayAs?: SortOrder
    containsSalaryInfo?: SortOrder
    description?: SortOrder
    instanceId?: SortOrder
    clientId?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AccountCountOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Account"> | string
    code?: StringWithAggregatesFilter<"Account"> | string
    name?: StringWithAggregatesFilter<"Account"> | string
    isRoot?: BoolWithAggregatesFilter<"Account"> | boolean
    isModelRoot?: BoolWithAggregatesFilter<"Account"> | boolean
    accountType?: EnumAccountTypeWithAggregatesFilter<"Account"> | $Enums.AccountType
    accountTypeTag?: EnumAccountTypeTagWithAggregatesFilter<"Account"> | $Enums.AccountTypeTag
    group?: EnumYesNoWithAggregatesFilter<"Account"> | $Enums.YesNo
    plannedBy?: EnumActPlanByNullableWithAggregatesFilter<"Account"> | $Enums.ActPlanBy | null
    actualsBy?: EnumActActualsByNullableWithAggregatesFilter<"Account"> | $Enums.ActActualsBy | null
    displayAs?: EnumActDisplayAsWithAggregatesFilter<"Account"> | $Enums.ActDisplayAs
    containsSalaryInfo?: EnumYesNoWithAggregatesFilter<"Account"> | $Enums.YesNo
    description?: StringNullableWithAggregatesFilter<"Account"> | string | null
    instanceId?: StringWithAggregatesFilter<"Account"> | string
    clientId?: StringWithAggregatesFilter<"Account"> | string
    parentId?: StringNullableWithAggregatesFilter<"Account"> | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"Account"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Account"> | Date | string | null
  }

  export type DimensionWhereInput = {
    AND?: DimensionWhereInput | DimensionWhereInput[]
    OR?: DimensionWhereInput[]
    NOT?: DimensionWhereInput | DimensionWhereInput[]
    id?: StringFilter<"Dimension"> | string
    code?: StringFilter<"Dimension"> | string
    name?: StringFilter<"Dimension"> | string
    description?: StringNullableFilter<"Dimension"> | string | null
    dimensionValueDefault?: StringNullableFilter<"Dimension"> | string | null
    clientId?: StringFilter<"Dimension"> | string
    instanceId?: StringFilter<"Dimension"> | string
    createdAt?: DateTimeNullableFilter<"Dimension"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Dimension"> | Date | string | null
    instance?: XOR<InstanceScalarRelationFilter, InstanceWhereInput>
    dimensionValues?: DimensionValueListRelationFilter
  }

  export type DimensionOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    dimensionValueDefault?: SortOrder
    clientId?: SortOrder
    instanceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    instance?: InstanceOrderByWithRelationInput
    dimensionValues?: DimensionValueOrderByRelationAggregateInput
  }

  export type DimensionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    clientId_code_instanceId?: DimensionClientIdCodeInstanceIdCompoundUniqueInput
    AND?: DimensionWhereInput | DimensionWhereInput[]
    OR?: DimensionWhereInput[]
    NOT?: DimensionWhereInput | DimensionWhereInput[]
    code?: StringFilter<"Dimension"> | string
    name?: StringFilter<"Dimension"> | string
    description?: StringNullableFilter<"Dimension"> | string | null
    dimensionValueDefault?: StringNullableFilter<"Dimension"> | string | null
    clientId?: StringFilter<"Dimension"> | string
    instanceId?: StringFilter<"Dimension"> | string
    createdAt?: DateTimeNullableFilter<"Dimension"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Dimension"> | Date | string | null
    instance?: XOR<InstanceScalarRelationFilter, InstanceWhereInput>
    dimensionValues?: DimensionValueListRelationFilter
  }, "id" | "clientId_code_instanceId">

  export type DimensionOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    dimensionValueDefault?: SortOrder
    clientId?: SortOrder
    instanceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DimensionCountOrderByAggregateInput
    _max?: DimensionMaxOrderByAggregateInput
    _min?: DimensionMinOrderByAggregateInput
  }

  export type DimensionScalarWhereWithAggregatesInput = {
    AND?: DimensionScalarWhereWithAggregatesInput | DimensionScalarWhereWithAggregatesInput[]
    OR?: DimensionScalarWhereWithAggregatesInput[]
    NOT?: DimensionScalarWhereWithAggregatesInput | DimensionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Dimension"> | string
    code?: StringWithAggregatesFilter<"Dimension"> | string
    name?: StringWithAggregatesFilter<"Dimension"> | string
    description?: StringNullableWithAggregatesFilter<"Dimension"> | string | null
    dimensionValueDefault?: StringNullableWithAggregatesFilter<"Dimension"> | string | null
    clientId?: StringWithAggregatesFilter<"Dimension"> | string
    instanceId?: StringWithAggregatesFilter<"Dimension"> | string
    createdAt?: DateTimeNullableWithAggregatesFilter<"Dimension"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Dimension"> | Date | string | null
  }

  export type DimensionValueWhereInput = {
    AND?: DimensionValueWhereInput | DimensionValueWhereInput[]
    OR?: DimensionValueWhereInput[]
    NOT?: DimensionValueWhereInput | DimensionValueWhereInput[]
    id?: StringFilter<"DimensionValue"> | string
    code?: StringFilter<"DimensionValue"> | string
    name?: StringFilter<"DimensionValue"> | string
    parentId?: StringNullableFilter<"DimensionValue"> | string | null
    clientId?: StringFilter<"DimensionValue"> | string
    instanceId?: StringFilter<"DimensionValue"> | string
    dimensionId?: StringFilter<"DimensionValue"> | string
    createdAt?: DateTimeNullableFilter<"DimensionValue"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"DimensionValue"> | Date | string | null
    parent?: XOR<DimensionValueNullableScalarRelationFilter, DimensionValueWhereInput> | null
    childDimensionValues?: DimensionValueListRelationFilter
    AttributeAndValues?: DimensionValueAttributeAndValueListRelationFilter
    instance?: XOR<InstanceScalarRelationFilter, InstanceWhereInput>
    dimension?: XOR<DimensionScalarRelationFilter, DimensionWhereInput>
  }

  export type DimensionValueOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    parentId?: SortOrder
    clientId?: SortOrder
    instanceId?: SortOrder
    dimensionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    parent?: DimensionValueOrderByWithRelationInput
    childDimensionValues?: DimensionValueOrderByRelationAggregateInput
    AttributeAndValues?: DimensionValueAttributeAndValueOrderByRelationAggregateInput
    instance?: InstanceOrderByWithRelationInput
    dimension?: DimensionOrderByWithRelationInput
  }

  export type DimensionValueWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    clientId_code_instanceId_dimensionId?: DimensionValueClientIdCodeInstanceIdDimensionIdCompoundUniqueInput
    AND?: DimensionValueWhereInput | DimensionValueWhereInput[]
    OR?: DimensionValueWhereInput[]
    NOT?: DimensionValueWhereInput | DimensionValueWhereInput[]
    code?: StringFilter<"DimensionValue"> | string
    name?: StringFilter<"DimensionValue"> | string
    parentId?: StringNullableFilter<"DimensionValue"> | string | null
    clientId?: StringFilter<"DimensionValue"> | string
    instanceId?: StringFilter<"DimensionValue"> | string
    dimensionId?: StringFilter<"DimensionValue"> | string
    createdAt?: DateTimeNullableFilter<"DimensionValue"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"DimensionValue"> | Date | string | null
    parent?: XOR<DimensionValueNullableScalarRelationFilter, DimensionValueWhereInput> | null
    childDimensionValues?: DimensionValueListRelationFilter
    AttributeAndValues?: DimensionValueAttributeAndValueListRelationFilter
    instance?: XOR<InstanceScalarRelationFilter, InstanceWhereInput>
    dimension?: XOR<DimensionScalarRelationFilter, DimensionWhereInput>
  }, "id" | "clientId_code_instanceId_dimensionId">

  export type DimensionValueOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    parentId?: SortOrder
    clientId?: SortOrder
    instanceId?: SortOrder
    dimensionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DimensionValueCountOrderByAggregateInput
    _max?: DimensionValueMaxOrderByAggregateInput
    _min?: DimensionValueMinOrderByAggregateInput
  }

  export type DimensionValueScalarWhereWithAggregatesInput = {
    AND?: DimensionValueScalarWhereWithAggregatesInput | DimensionValueScalarWhereWithAggregatesInput[]
    OR?: DimensionValueScalarWhereWithAggregatesInput[]
    NOT?: DimensionValueScalarWhereWithAggregatesInput | DimensionValueScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DimensionValue"> | string
    code?: StringWithAggregatesFilter<"DimensionValue"> | string
    name?: StringWithAggregatesFilter<"DimensionValue"> | string
    parentId?: StringNullableWithAggregatesFilter<"DimensionValue"> | string | null
    clientId?: StringWithAggregatesFilter<"DimensionValue"> | string
    instanceId?: StringWithAggregatesFilter<"DimensionValue"> | string
    dimensionId?: StringWithAggregatesFilter<"DimensionValue"> | string
    createdAt?: DateTimeNullableWithAggregatesFilter<"DimensionValue"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"DimensionValue"> | Date | string | null
  }

  export type DimensionValueAttributeWhereInput = {
    AND?: DimensionValueAttributeWhereInput | DimensionValueAttributeWhereInput[]
    OR?: DimensionValueAttributeWhereInput[]
    NOT?: DimensionValueAttributeWhereInput | DimensionValueAttributeWhereInput[]
    id?: StringFilter<"DimensionValueAttribute"> | string
    code?: StringFilter<"DimensionValueAttribute"> | string
    name?: StringFilter<"DimensionValueAttribute"> | string
    description?: StringNullableFilter<"DimensionValueAttribute"> | string | null
    clientId?: StringFilter<"DimensionValueAttribute"> | string
    instanceId?: StringFilter<"DimensionValueAttribute"> | string
    updatedAt?: DateTimeNullableFilter<"DimensionValueAttribute"> | Date | string | null
    createdAt?: DateTimeNullableFilter<"DimensionValueAttribute"> | Date | string | null
    instance?: XOR<InstanceScalarRelationFilter, InstanceWhereInput>
    AttributeValues?: DimensionValueAttributeValueListRelationFilter
    AttributeAndValues?: DimensionValueAttributeAndValueListRelationFilter
  }

  export type DimensionValueAttributeOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    clientId?: SortOrder
    instanceId?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    instance?: InstanceOrderByWithRelationInput
    AttributeValues?: DimensionValueAttributeValueOrderByRelationAggregateInput
    AttributeAndValues?: DimensionValueAttributeAndValueOrderByRelationAggregateInput
  }

  export type DimensionValueAttributeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    clientId_code_instanceId?: DimensionValueAttributeClientIdCodeInstanceIdCompoundUniqueInput
    AND?: DimensionValueAttributeWhereInput | DimensionValueAttributeWhereInput[]
    OR?: DimensionValueAttributeWhereInput[]
    NOT?: DimensionValueAttributeWhereInput | DimensionValueAttributeWhereInput[]
    code?: StringFilter<"DimensionValueAttribute"> | string
    name?: StringFilter<"DimensionValueAttribute"> | string
    description?: StringNullableFilter<"DimensionValueAttribute"> | string | null
    clientId?: StringFilter<"DimensionValueAttribute"> | string
    instanceId?: StringFilter<"DimensionValueAttribute"> | string
    updatedAt?: DateTimeNullableFilter<"DimensionValueAttribute"> | Date | string | null
    createdAt?: DateTimeNullableFilter<"DimensionValueAttribute"> | Date | string | null
    instance?: XOR<InstanceScalarRelationFilter, InstanceWhereInput>
    AttributeValues?: DimensionValueAttributeValueListRelationFilter
    AttributeAndValues?: DimensionValueAttributeAndValueListRelationFilter
  }, "id" | "clientId_code_instanceId">

  export type DimensionValueAttributeOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    clientId?: SortOrder
    instanceId?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    _count?: DimensionValueAttributeCountOrderByAggregateInput
    _max?: DimensionValueAttributeMaxOrderByAggregateInput
    _min?: DimensionValueAttributeMinOrderByAggregateInput
  }

  export type DimensionValueAttributeScalarWhereWithAggregatesInput = {
    AND?: DimensionValueAttributeScalarWhereWithAggregatesInput | DimensionValueAttributeScalarWhereWithAggregatesInput[]
    OR?: DimensionValueAttributeScalarWhereWithAggregatesInput[]
    NOT?: DimensionValueAttributeScalarWhereWithAggregatesInput | DimensionValueAttributeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DimensionValueAttribute"> | string
    code?: StringWithAggregatesFilter<"DimensionValueAttribute"> | string
    name?: StringWithAggregatesFilter<"DimensionValueAttribute"> | string
    description?: StringNullableWithAggregatesFilter<"DimensionValueAttribute"> | string | null
    clientId?: StringWithAggregatesFilter<"DimensionValueAttribute"> | string
    instanceId?: StringWithAggregatesFilter<"DimensionValueAttribute"> | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"DimensionValueAttribute"> | Date | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"DimensionValueAttribute"> | Date | string | null
  }

  export type DimensionValueAttributeValueWhereInput = {
    AND?: DimensionValueAttributeValueWhereInput | DimensionValueAttributeValueWhereInput[]
    OR?: DimensionValueAttributeValueWhereInput[]
    NOT?: DimensionValueAttributeValueWhereInput | DimensionValueAttributeValueWhereInput[]
    id?: StringFilter<"DimensionValueAttributeValue"> | string
    code?: StringFilter<"DimensionValueAttributeValue"> | string
    name?: StringFilter<"DimensionValueAttributeValue"> | string
    attributeId?: StringFilter<"DimensionValueAttributeValue"> | string
    clientId?: StringFilter<"DimensionValueAttributeValue"> | string
    parentId?: StringNullableFilter<"DimensionValueAttributeValue"> | string | null
    instanceId?: StringFilter<"DimensionValueAttributeValue"> | string
    createdAt?: DateTimeNullableFilter<"DimensionValueAttributeValue"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"DimensionValueAttributeValue"> | Date | string | null
    instance?: XOR<InstanceScalarRelationFilter, InstanceWhereInput>
    parent?: XOR<DimensionValueAttributeValueNullableScalarRelationFilter, DimensionValueAttributeValueWhereInput> | null
    childAttributeValues?: DimensionValueAttributeValueListRelationFilter
    dimensionValueAttribute?: XOR<DimensionValueAttributeScalarRelationFilter, DimensionValueAttributeWhereInput>
    dimensionAttributeAndValues?: DimensionValueAttributeAndValueListRelationFilter
  }

  export type DimensionValueAttributeValueOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    attributeId?: SortOrder
    clientId?: SortOrder
    parentId?: SortOrder
    instanceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    instance?: InstanceOrderByWithRelationInput
    parent?: DimensionValueAttributeValueOrderByWithRelationInput
    childAttributeValues?: DimensionValueAttributeValueOrderByRelationAggregateInput
    dimensionValueAttribute?: DimensionValueAttributeOrderByWithRelationInput
    dimensionAttributeAndValues?: DimensionValueAttributeAndValueOrderByRelationAggregateInput
  }

  export type DimensionValueAttributeValueWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    clientId_code_instanceId_attributeId?: DimensionValueAttributeValueClientIdCodeInstanceIdAttributeIdCompoundUniqueInput
    AND?: DimensionValueAttributeValueWhereInput | DimensionValueAttributeValueWhereInput[]
    OR?: DimensionValueAttributeValueWhereInput[]
    NOT?: DimensionValueAttributeValueWhereInput | DimensionValueAttributeValueWhereInput[]
    code?: StringFilter<"DimensionValueAttributeValue"> | string
    name?: StringFilter<"DimensionValueAttributeValue"> | string
    attributeId?: StringFilter<"DimensionValueAttributeValue"> | string
    clientId?: StringFilter<"DimensionValueAttributeValue"> | string
    parentId?: StringNullableFilter<"DimensionValueAttributeValue"> | string | null
    instanceId?: StringFilter<"DimensionValueAttributeValue"> | string
    createdAt?: DateTimeNullableFilter<"DimensionValueAttributeValue"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"DimensionValueAttributeValue"> | Date | string | null
    instance?: XOR<InstanceScalarRelationFilter, InstanceWhereInput>
    parent?: XOR<DimensionValueAttributeValueNullableScalarRelationFilter, DimensionValueAttributeValueWhereInput> | null
    childAttributeValues?: DimensionValueAttributeValueListRelationFilter
    dimensionValueAttribute?: XOR<DimensionValueAttributeScalarRelationFilter, DimensionValueAttributeWhereInput>
    dimensionAttributeAndValues?: DimensionValueAttributeAndValueListRelationFilter
  }, "id" | "clientId_code_instanceId_attributeId">

  export type DimensionValueAttributeValueOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    attributeId?: SortOrder
    clientId?: SortOrder
    parentId?: SortOrder
    instanceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DimensionValueAttributeValueCountOrderByAggregateInput
    _max?: DimensionValueAttributeValueMaxOrderByAggregateInput
    _min?: DimensionValueAttributeValueMinOrderByAggregateInput
  }

  export type DimensionValueAttributeValueScalarWhereWithAggregatesInput = {
    AND?: DimensionValueAttributeValueScalarWhereWithAggregatesInput | DimensionValueAttributeValueScalarWhereWithAggregatesInput[]
    OR?: DimensionValueAttributeValueScalarWhereWithAggregatesInput[]
    NOT?: DimensionValueAttributeValueScalarWhereWithAggregatesInput | DimensionValueAttributeValueScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DimensionValueAttributeValue"> | string
    code?: StringWithAggregatesFilter<"DimensionValueAttributeValue"> | string
    name?: StringWithAggregatesFilter<"DimensionValueAttributeValue"> | string
    attributeId?: StringWithAggregatesFilter<"DimensionValueAttributeValue"> | string
    clientId?: StringWithAggregatesFilter<"DimensionValueAttributeValue"> | string
    parentId?: StringNullableWithAggregatesFilter<"DimensionValueAttributeValue"> | string | null
    instanceId?: StringWithAggregatesFilter<"DimensionValueAttributeValue"> | string
    createdAt?: DateTimeNullableWithAggregatesFilter<"DimensionValueAttributeValue"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"DimensionValueAttributeValue"> | Date | string | null
  }

  export type DimensionValueAttributeAndValueWhereInput = {
    AND?: DimensionValueAttributeAndValueWhereInput | DimensionValueAttributeAndValueWhereInput[]
    OR?: DimensionValueAttributeAndValueWhereInput[]
    NOT?: DimensionValueAttributeAndValueWhereInput | DimensionValueAttributeAndValueWhereInput[]
    id?: StringFilter<"DimensionValueAttributeAndValue"> | string
    clientId?: StringFilter<"DimensionValueAttributeAndValue"> | string
    instanceId?: StringFilter<"DimensionValueAttributeAndValue"> | string
    attributeId?: StringFilter<"DimensionValueAttributeAndValue"> | string
    attributeValueId?: StringFilter<"DimensionValueAttributeAndValue"> | string
    dimensionValueId?: StringFilter<"DimensionValueAttributeAndValue"> | string
    createdAt?: DateTimeNullableFilter<"DimensionValueAttributeAndValue"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"DimensionValueAttributeAndValue"> | Date | string | null
    dimensionValue?: XOR<DimensionValueNullableScalarRelationFilter, DimensionValueWhereInput> | null
    attribute?: XOR<DimensionValueAttributeNullableScalarRelationFilter, DimensionValueAttributeWhereInput> | null
    attributeValue?: XOR<DimensionValueAttributeValueNullableScalarRelationFilter, DimensionValueAttributeValueWhereInput> | null
  }

  export type DimensionValueAttributeAndValueOrderByWithRelationInput = {
    id?: SortOrder
    clientId?: SortOrder
    instanceId?: SortOrder
    attributeId?: SortOrder
    attributeValueId?: SortOrder
    dimensionValueId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    dimensionValue?: DimensionValueOrderByWithRelationInput
    attribute?: DimensionValueAttributeOrderByWithRelationInput
    attributeValue?: DimensionValueAttributeValueOrderByWithRelationInput
  }

  export type DimensionValueAttributeAndValueWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DimensionValueAttributeAndValueWhereInput | DimensionValueAttributeAndValueWhereInput[]
    OR?: DimensionValueAttributeAndValueWhereInput[]
    NOT?: DimensionValueAttributeAndValueWhereInput | DimensionValueAttributeAndValueWhereInput[]
    clientId?: StringFilter<"DimensionValueAttributeAndValue"> | string
    instanceId?: StringFilter<"DimensionValueAttributeAndValue"> | string
    attributeId?: StringFilter<"DimensionValueAttributeAndValue"> | string
    attributeValueId?: StringFilter<"DimensionValueAttributeAndValue"> | string
    dimensionValueId?: StringFilter<"DimensionValueAttributeAndValue"> | string
    createdAt?: DateTimeNullableFilter<"DimensionValueAttributeAndValue"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"DimensionValueAttributeAndValue"> | Date | string | null
    dimensionValue?: XOR<DimensionValueNullableScalarRelationFilter, DimensionValueWhereInput> | null
    attribute?: XOR<DimensionValueAttributeNullableScalarRelationFilter, DimensionValueAttributeWhereInput> | null
    attributeValue?: XOR<DimensionValueAttributeValueNullableScalarRelationFilter, DimensionValueAttributeValueWhereInput> | null
  }, "id">

  export type DimensionValueAttributeAndValueOrderByWithAggregationInput = {
    id?: SortOrder
    clientId?: SortOrder
    instanceId?: SortOrder
    attributeId?: SortOrder
    attributeValueId?: SortOrder
    dimensionValueId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DimensionValueAttributeAndValueCountOrderByAggregateInput
    _max?: DimensionValueAttributeAndValueMaxOrderByAggregateInput
    _min?: DimensionValueAttributeAndValueMinOrderByAggregateInput
  }

  export type DimensionValueAttributeAndValueScalarWhereWithAggregatesInput = {
    AND?: DimensionValueAttributeAndValueScalarWhereWithAggregatesInput | DimensionValueAttributeAndValueScalarWhereWithAggregatesInput[]
    OR?: DimensionValueAttributeAndValueScalarWhereWithAggregatesInput[]
    NOT?: DimensionValueAttributeAndValueScalarWhereWithAggregatesInput | DimensionValueAttributeAndValueScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DimensionValueAttributeAndValue"> | string
    clientId?: StringWithAggregatesFilter<"DimensionValueAttributeAndValue"> | string
    instanceId?: StringWithAggregatesFilter<"DimensionValueAttributeAndValue"> | string
    attributeId?: StringWithAggregatesFilter<"DimensionValueAttributeAndValue"> | string
    attributeValueId?: StringWithAggregatesFilter<"DimensionValueAttributeAndValue"> | string
    dimensionValueId?: StringWithAggregatesFilter<"DimensionValueAttributeAndValue"> | string
    createdAt?: DateTimeNullableWithAggregatesFilter<"DimensionValueAttributeAndValue"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"DimensionValueAttributeAndValue"> | Date | string | null
  }

  export type ModelWhereInput = {
    AND?: ModelWhereInput | ModelWhereInput[]
    OR?: ModelWhereInput[]
    NOT?: ModelWhereInput | ModelWhereInput[]
    id?: StringFilter<"Model"> | string
    code?: StringFilter<"Model"> | string
    name?: StringFilter<"Model"> | string
    description?: StringNullableFilter<"Model"> | string | null
    dimensionality?: StringNullableListFilter<"Model">
    status?: EnumModelStatusFilter<"Model"> | $Enums.ModelStatus
    isDefault?: BoolFilter<"Model"> | boolean
    instanceId?: StringFilter<"Model"> | string
    clientId?: StringFilter<"Model"> | string
    createdAt?: DateTimeNullableFilter<"Model"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Model"> | Date | string | null
    rootAccountId?: StringFilter<"Model"> | string
    instance?: XOR<InstanceScalarRelationFilter, InstanceWhereInput>
    modelData?: ModelDataListRelationFilter
    modelAccounts?: ModelAccountStructureListRelationFilter
    modelDataCalculations?: ModelDataCalculationsListRelationFilter
  }

  export type ModelOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    dimensionality?: SortOrder
    status?: SortOrder
    isDefault?: SortOrder
    instanceId?: SortOrder
    clientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    rootAccountId?: SortOrder
    instance?: InstanceOrderByWithRelationInput
    modelData?: ModelDataOrderByRelationAggregateInput
    modelAccounts?: ModelAccountStructureOrderByRelationAggregateInput
    modelDataCalculations?: ModelDataCalculationsOrderByRelationAggregateInput
  }

  export type ModelWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    clientId_instanceId_code?: ModelClientIdInstanceIdCodeCompoundUniqueInput
    AND?: ModelWhereInput | ModelWhereInput[]
    OR?: ModelWhereInput[]
    NOT?: ModelWhereInput | ModelWhereInput[]
    code?: StringFilter<"Model"> | string
    name?: StringFilter<"Model"> | string
    description?: StringNullableFilter<"Model"> | string | null
    dimensionality?: StringNullableListFilter<"Model">
    status?: EnumModelStatusFilter<"Model"> | $Enums.ModelStatus
    isDefault?: BoolFilter<"Model"> | boolean
    instanceId?: StringFilter<"Model"> | string
    clientId?: StringFilter<"Model"> | string
    createdAt?: DateTimeNullableFilter<"Model"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Model"> | Date | string | null
    rootAccountId?: StringFilter<"Model"> | string
    instance?: XOR<InstanceScalarRelationFilter, InstanceWhereInput>
    modelData?: ModelDataListRelationFilter
    modelAccounts?: ModelAccountStructureListRelationFilter
    modelDataCalculations?: ModelDataCalculationsListRelationFilter
  }, "id" | "clientId_instanceId_code">

  export type ModelOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    dimensionality?: SortOrder
    status?: SortOrder
    isDefault?: SortOrder
    instanceId?: SortOrder
    clientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    rootAccountId?: SortOrder
    _count?: ModelCountOrderByAggregateInput
    _max?: ModelMaxOrderByAggregateInput
    _min?: ModelMinOrderByAggregateInput
  }

  export type ModelScalarWhereWithAggregatesInput = {
    AND?: ModelScalarWhereWithAggregatesInput | ModelScalarWhereWithAggregatesInput[]
    OR?: ModelScalarWhereWithAggregatesInput[]
    NOT?: ModelScalarWhereWithAggregatesInput | ModelScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Model"> | string
    code?: StringWithAggregatesFilter<"Model"> | string
    name?: StringWithAggregatesFilter<"Model"> | string
    description?: StringNullableWithAggregatesFilter<"Model"> | string | null
    dimensionality?: StringNullableListFilter<"Model">
    status?: EnumModelStatusWithAggregatesFilter<"Model"> | $Enums.ModelStatus
    isDefault?: BoolWithAggregatesFilter<"Model"> | boolean
    instanceId?: StringWithAggregatesFilter<"Model"> | string
    clientId?: StringWithAggregatesFilter<"Model"> | string
    createdAt?: DateTimeNullableWithAggregatesFilter<"Model"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Model"> | Date | string | null
    rootAccountId?: StringWithAggregatesFilter<"Model"> | string
  }

  export type ModelAccountStructureWhereInput = {
    AND?: ModelAccountStructureWhereInput | ModelAccountStructureWhereInput[]
    OR?: ModelAccountStructureWhereInput[]
    NOT?: ModelAccountStructureWhereInput | ModelAccountStructureWhereInput[]
    id?: StringFilter<"ModelAccountStructure"> | string
    instanceId?: StringFilter<"ModelAccountStructure"> | string
    isRoot?: BoolFilter<"ModelAccountStructure"> | boolean
    clientId?: StringFilter<"ModelAccountStructure"> | string
    parentId?: StringNullableFilter<"ModelAccountStructure"> | string | null
    modelId?: StringFilter<"ModelAccountStructure"> | string
    accountId?: StringFilter<"ModelAccountStructure"> | string
    createdAt?: DateTimeNullableFilter<"ModelAccountStructure"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"ModelAccountStructure"> | Date | string | null
    instance?: XOR<InstanceScalarRelationFilter, InstanceWhereInput>
    model?: XOR<ModelScalarRelationFilter, ModelWhereInput>
    account?: XOR<AccountScalarRelationFilter, AccountWhereInput>
    modeldataCalculations?: ModelDataCalculationsListRelationFilter
    parentAccount?: XOR<ModelAccountStructureNullableScalarRelationFilter, ModelAccountStructureWhereInput> | null
    childAccounts?: ModelAccountStructureListRelationFilter
  }

  export type ModelAccountStructureOrderByWithRelationInput = {
    id?: SortOrder
    instanceId?: SortOrder
    isRoot?: SortOrder
    clientId?: SortOrder
    parentId?: SortOrder
    modelId?: SortOrder
    accountId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    instance?: InstanceOrderByWithRelationInput
    model?: ModelOrderByWithRelationInput
    account?: AccountOrderByWithRelationInput
    modeldataCalculations?: ModelDataCalculationsOrderByRelationAggregateInput
    parentAccount?: ModelAccountStructureOrderByWithRelationInput
    childAccounts?: ModelAccountStructureOrderByRelationAggregateInput
  }

  export type ModelAccountStructureWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ModelAccountStructureWhereInput | ModelAccountStructureWhereInput[]
    OR?: ModelAccountStructureWhereInput[]
    NOT?: ModelAccountStructureWhereInput | ModelAccountStructureWhereInput[]
    instanceId?: StringFilter<"ModelAccountStructure"> | string
    isRoot?: BoolFilter<"ModelAccountStructure"> | boolean
    clientId?: StringFilter<"ModelAccountStructure"> | string
    parentId?: StringNullableFilter<"ModelAccountStructure"> | string | null
    modelId?: StringFilter<"ModelAccountStructure"> | string
    accountId?: StringFilter<"ModelAccountStructure"> | string
    createdAt?: DateTimeNullableFilter<"ModelAccountStructure"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"ModelAccountStructure"> | Date | string | null
    instance?: XOR<InstanceScalarRelationFilter, InstanceWhereInput>
    model?: XOR<ModelScalarRelationFilter, ModelWhereInput>
    account?: XOR<AccountScalarRelationFilter, AccountWhereInput>
    modeldataCalculations?: ModelDataCalculationsListRelationFilter
    parentAccount?: XOR<ModelAccountStructureNullableScalarRelationFilter, ModelAccountStructureWhereInput> | null
    childAccounts?: ModelAccountStructureListRelationFilter
  }, "id">

  export type ModelAccountStructureOrderByWithAggregationInput = {
    id?: SortOrder
    instanceId?: SortOrder
    isRoot?: SortOrder
    clientId?: SortOrder
    parentId?: SortOrder
    modelId?: SortOrder
    accountId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ModelAccountStructureCountOrderByAggregateInput
    _max?: ModelAccountStructureMaxOrderByAggregateInput
    _min?: ModelAccountStructureMinOrderByAggregateInput
  }

  export type ModelAccountStructureScalarWhereWithAggregatesInput = {
    AND?: ModelAccountStructureScalarWhereWithAggregatesInput | ModelAccountStructureScalarWhereWithAggregatesInput[]
    OR?: ModelAccountStructureScalarWhereWithAggregatesInput[]
    NOT?: ModelAccountStructureScalarWhereWithAggregatesInput | ModelAccountStructureScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ModelAccountStructure"> | string
    instanceId?: StringWithAggregatesFilter<"ModelAccountStructure"> | string
    isRoot?: BoolWithAggregatesFilter<"ModelAccountStructure"> | boolean
    clientId?: StringWithAggregatesFilter<"ModelAccountStructure"> | string
    parentId?: StringNullableWithAggregatesFilter<"ModelAccountStructure"> | string | null
    modelId?: StringWithAggregatesFilter<"ModelAccountStructure"> | string
    accountId?: StringWithAggregatesFilter<"ModelAccountStructure"> | string
    createdAt?: DateTimeNullableWithAggregatesFilter<"ModelAccountStructure"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"ModelAccountStructure"> | Date | string | null
  }

  export type ModelDataWhereInput = {
    AND?: ModelDataWhereInput | ModelDataWhereInput[]
    OR?: ModelDataWhereInput[]
    NOT?: ModelDataWhereInput | ModelDataWhereInput[]
    id?: StringFilter<"ModelData"> | string
    clientId?: StringFilter<"ModelData"> | string
    instanceId?: StringFilter<"ModelData"> | string
    modelId?: StringFilter<"ModelData"> | string
    versionId?: StringFilter<"ModelData"> | string
    levelId?: StringFilter<"ModelData"> | string
    accountId?: StringFilter<"ModelData"> | string
    dimensionality?: ModelDataDimensionalityCompositeListFilter | ModelDataDimensionalityObjectEqualityInput[]
    timespan?: JsonFilter<"ModelData">
    createdAt?: DateTimeNullableFilter<"ModelData"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"ModelData"> | Date | string | null
    model?: XOR<ModelScalarRelationFilter, ModelWhereInput>
    level?: XOR<LevelScalarRelationFilter, LevelWhereInput>
    account?: XOR<AccountScalarRelationFilter, AccountWhereInput>
    version?: XOR<VersionScalarRelationFilter, VersionWhereInput>
    instance?: XOR<InstanceScalarRelationFilter, InstanceWhereInput>
  }

  export type ModelDataOrderByWithRelationInput = {
    id?: SortOrder
    clientId?: SortOrder
    instanceId?: SortOrder
    modelId?: SortOrder
    versionId?: SortOrder
    levelId?: SortOrder
    accountId?: SortOrder
    dimensionality?: ModelDataDimensionalityOrderByCompositeAggregateInput
    timespan?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    model?: ModelOrderByWithRelationInput
    level?: LevelOrderByWithRelationInput
    account?: AccountOrderByWithRelationInput
    version?: VersionOrderByWithRelationInput
    instance?: InstanceOrderByWithRelationInput
  }

  export type ModelDataWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ModelDataWhereInput | ModelDataWhereInput[]
    OR?: ModelDataWhereInput[]
    NOT?: ModelDataWhereInput | ModelDataWhereInput[]
    clientId?: StringFilter<"ModelData"> | string
    instanceId?: StringFilter<"ModelData"> | string
    modelId?: StringFilter<"ModelData"> | string
    versionId?: StringFilter<"ModelData"> | string
    levelId?: StringFilter<"ModelData"> | string
    accountId?: StringFilter<"ModelData"> | string
    dimensionality?: ModelDataDimensionalityCompositeListFilter | ModelDataDimensionalityObjectEqualityInput[]
    timespan?: JsonFilter<"ModelData">
    createdAt?: DateTimeNullableFilter<"ModelData"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"ModelData"> | Date | string | null
    model?: XOR<ModelScalarRelationFilter, ModelWhereInput>
    level?: XOR<LevelScalarRelationFilter, LevelWhereInput>
    account?: XOR<AccountScalarRelationFilter, AccountWhereInput>
    version?: XOR<VersionScalarRelationFilter, VersionWhereInput>
    instance?: XOR<InstanceScalarRelationFilter, InstanceWhereInput>
  }, "id">

  export type ModelDataOrderByWithAggregationInput = {
    id?: SortOrder
    clientId?: SortOrder
    instanceId?: SortOrder
    modelId?: SortOrder
    versionId?: SortOrder
    levelId?: SortOrder
    accountId?: SortOrder
    timespan?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ModelDataCountOrderByAggregateInput
    _max?: ModelDataMaxOrderByAggregateInput
    _min?: ModelDataMinOrderByAggregateInput
  }

  export type ModelDataScalarWhereWithAggregatesInput = {
    AND?: ModelDataScalarWhereWithAggregatesInput | ModelDataScalarWhereWithAggregatesInput[]
    OR?: ModelDataScalarWhereWithAggregatesInput[]
    NOT?: ModelDataScalarWhereWithAggregatesInput | ModelDataScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ModelData"> | string
    clientId?: StringWithAggregatesFilter<"ModelData"> | string
    instanceId?: StringWithAggregatesFilter<"ModelData"> | string
    modelId?: StringWithAggregatesFilter<"ModelData"> | string
    versionId?: StringWithAggregatesFilter<"ModelData"> | string
    levelId?: StringWithAggregatesFilter<"ModelData"> | string
    accountId?: StringWithAggregatesFilter<"ModelData"> | string
    timespan?: JsonWithAggregatesFilter<"ModelData">
    createdAt?: DateTimeNullableWithAggregatesFilter<"ModelData"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"ModelData"> | Date | string | null
  }

  export type ModelDataCalculationsWhereInput = {
    AND?: ModelDataCalculationsWhereInput | ModelDataCalculationsWhereInput[]
    OR?: ModelDataCalculationsWhereInput[]
    NOT?: ModelDataCalculationsWhereInput | ModelDataCalculationsWhereInput[]
    id?: StringFilter<"ModelDataCalculations"> | string
    clientId?: StringFilter<"ModelDataCalculations"> | string
    instanceId?: StringFilter<"ModelDataCalculations"> | string
    modelId?: StringFilter<"ModelDataCalculations"> | string
    versionId?: StringFilter<"ModelDataCalculations"> | string
    levelId?: StringFilter<"ModelDataCalculations"> | string
    accountId?: StringFilter<"ModelDataCalculations"> | string
    modelAccountId?: StringFilter<"ModelDataCalculations"> | string
    calculations?: JsonFilter<"ModelDataCalculations">
    createdAt?: DateTimeNullableFilter<"ModelDataCalculations"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"ModelDataCalculations"> | Date | string | null
    model?: XOR<ModelScalarRelationFilter, ModelWhereInput>
    level?: XOR<LevelScalarRelationFilter, LevelWhereInput>
    account?: XOR<AccountScalarRelationFilter, AccountWhereInput>
    version?: XOR<VersionScalarRelationFilter, VersionWhereInput>
    instance?: XOR<InstanceScalarRelationFilter, InstanceWhereInput>
    modelAccount?: XOR<ModelAccountStructureScalarRelationFilter, ModelAccountStructureWhereInput>
  }

  export type ModelDataCalculationsOrderByWithRelationInput = {
    id?: SortOrder
    clientId?: SortOrder
    instanceId?: SortOrder
    modelId?: SortOrder
    versionId?: SortOrder
    levelId?: SortOrder
    accountId?: SortOrder
    modelAccountId?: SortOrder
    calculations?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    model?: ModelOrderByWithRelationInput
    level?: LevelOrderByWithRelationInput
    account?: AccountOrderByWithRelationInput
    version?: VersionOrderByWithRelationInput
    instance?: InstanceOrderByWithRelationInput
    modelAccount?: ModelAccountStructureOrderByWithRelationInput
  }

  export type ModelDataCalculationsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ModelDataCalculationsWhereInput | ModelDataCalculationsWhereInput[]
    OR?: ModelDataCalculationsWhereInput[]
    NOT?: ModelDataCalculationsWhereInput | ModelDataCalculationsWhereInput[]
    clientId?: StringFilter<"ModelDataCalculations"> | string
    instanceId?: StringFilter<"ModelDataCalculations"> | string
    modelId?: StringFilter<"ModelDataCalculations"> | string
    versionId?: StringFilter<"ModelDataCalculations"> | string
    levelId?: StringFilter<"ModelDataCalculations"> | string
    accountId?: StringFilter<"ModelDataCalculations"> | string
    modelAccountId?: StringFilter<"ModelDataCalculations"> | string
    calculations?: JsonFilter<"ModelDataCalculations">
    createdAt?: DateTimeNullableFilter<"ModelDataCalculations"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"ModelDataCalculations"> | Date | string | null
    model?: XOR<ModelScalarRelationFilter, ModelWhereInput>
    level?: XOR<LevelScalarRelationFilter, LevelWhereInput>
    account?: XOR<AccountScalarRelationFilter, AccountWhereInput>
    version?: XOR<VersionScalarRelationFilter, VersionWhereInput>
    instance?: XOR<InstanceScalarRelationFilter, InstanceWhereInput>
    modelAccount?: XOR<ModelAccountStructureScalarRelationFilter, ModelAccountStructureWhereInput>
  }, "id">

  export type ModelDataCalculationsOrderByWithAggregationInput = {
    id?: SortOrder
    clientId?: SortOrder
    instanceId?: SortOrder
    modelId?: SortOrder
    versionId?: SortOrder
    levelId?: SortOrder
    accountId?: SortOrder
    modelAccountId?: SortOrder
    calculations?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ModelDataCalculationsCountOrderByAggregateInput
    _max?: ModelDataCalculationsMaxOrderByAggregateInput
    _min?: ModelDataCalculationsMinOrderByAggregateInput
  }

  export type ModelDataCalculationsScalarWhereWithAggregatesInput = {
    AND?: ModelDataCalculationsScalarWhereWithAggregatesInput | ModelDataCalculationsScalarWhereWithAggregatesInput[]
    OR?: ModelDataCalculationsScalarWhereWithAggregatesInput[]
    NOT?: ModelDataCalculationsScalarWhereWithAggregatesInput | ModelDataCalculationsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ModelDataCalculations"> | string
    clientId?: StringWithAggregatesFilter<"ModelDataCalculations"> | string
    instanceId?: StringWithAggregatesFilter<"ModelDataCalculations"> | string
    modelId?: StringWithAggregatesFilter<"ModelDataCalculations"> | string
    versionId?: StringWithAggregatesFilter<"ModelDataCalculations"> | string
    levelId?: StringWithAggregatesFilter<"ModelDataCalculations"> | string
    accountId?: StringWithAggregatesFilter<"ModelDataCalculations"> | string
    modelAccountId?: StringWithAggregatesFilter<"ModelDataCalculations"> | string
    calculations?: JsonWithAggregatesFilter<"ModelDataCalculations">
    createdAt?: DateTimeNullableWithAggregatesFilter<"ModelDataCalculations"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"ModelDataCalculations"> | Date | string | null
  }

  export type TableWhereInput = {
    AND?: TableWhereInput | TableWhereInput[]
    OR?: TableWhereInput[]
    NOT?: TableWhereInput | TableWhereInput[]
    id?: StringFilter<"Table"> | string
    clientId?: StringFilter<"Table"> | string
    instanceId?: StringFilter<"Table"> | string
    name?: StringFilter<"Table"> | string
    code?: StringFilter<"Table"> | string
    description?: StringNullableFilter<"Table"> | string | null
    createdAt?: DateTimeNullableFilter<"Table"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Table"> | Date | string | null
    status?: EnumModelStatusFilter<"Table"> | $Enums.ModelStatus
    columnDefinitions?: TableColumnDefinitionCompositeListFilter | TableColumnDefinitionObjectEqualityInput[]
    instance?: XOR<InstanceScalarRelationFilter, InstanceWhereInput>
    tableData?: TableDataListRelationFilter
  }

  export type TableOrderByWithRelationInput = {
    id?: SortOrder
    clientId?: SortOrder
    instanceId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    columnDefinitions?: TableColumnDefinitionOrderByCompositeAggregateInput
    instance?: InstanceOrderByWithRelationInput
    tableData?: TableDataOrderByRelationAggregateInput
  }

  export type TableWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    clientId_instanceId_code?: TableClientIdInstanceIdCodeCompoundUniqueInput
    AND?: TableWhereInput | TableWhereInput[]
    OR?: TableWhereInput[]
    NOT?: TableWhereInput | TableWhereInput[]
    clientId?: StringFilter<"Table"> | string
    instanceId?: StringFilter<"Table"> | string
    name?: StringFilter<"Table"> | string
    code?: StringFilter<"Table"> | string
    description?: StringNullableFilter<"Table"> | string | null
    createdAt?: DateTimeNullableFilter<"Table"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Table"> | Date | string | null
    status?: EnumModelStatusFilter<"Table"> | $Enums.ModelStatus
    columnDefinitions?: TableColumnDefinitionCompositeListFilter | TableColumnDefinitionObjectEqualityInput[]
    instance?: XOR<InstanceScalarRelationFilter, InstanceWhereInput>
    tableData?: TableDataListRelationFilter
  }, "id" | "clientId_instanceId_code">

  export type TableOrderByWithAggregationInput = {
    id?: SortOrder
    clientId?: SortOrder
    instanceId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    _count?: TableCountOrderByAggregateInput
    _max?: TableMaxOrderByAggregateInput
    _min?: TableMinOrderByAggregateInput
  }

  export type TableScalarWhereWithAggregatesInput = {
    AND?: TableScalarWhereWithAggregatesInput | TableScalarWhereWithAggregatesInput[]
    OR?: TableScalarWhereWithAggregatesInput[]
    NOT?: TableScalarWhereWithAggregatesInput | TableScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Table"> | string
    clientId?: StringWithAggregatesFilter<"Table"> | string
    instanceId?: StringWithAggregatesFilter<"Table"> | string
    name?: StringWithAggregatesFilter<"Table"> | string
    code?: StringWithAggregatesFilter<"Table"> | string
    description?: StringNullableWithAggregatesFilter<"Table"> | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"Table"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Table"> | Date | string | null
    status?: EnumModelStatusWithAggregatesFilter<"Table"> | $Enums.ModelStatus
  }

  export type TableDataWhereInput = {
    AND?: TableDataWhereInput | TableDataWhereInput[]
    OR?: TableDataWhereInput[]
    NOT?: TableDataWhereInput | TableDataWhereInput[]
    id?: StringFilter<"TableData"> | string
    clientId?: StringFilter<"TableData"> | string
    instanceId?: StringFilter<"TableData"> | string
    tableId?: StringFilter<"TableData"> | string
    rowKey?: StringFilter<"TableData"> | string
    versionId?: StringFilter<"TableData"> | string
    levelId?: StringFilter<"TableData"> | string
    data?: JsonFilter<"TableData">
    createdAt?: DateTimeNullableFilter<"TableData"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"TableData"> | Date | string | null
    table?: XOR<TableScalarRelationFilter, TableWhereInput>
    instance?: XOR<InstanceScalarRelationFilter, InstanceWhereInput>
  }

  export type TableDataOrderByWithRelationInput = {
    id?: SortOrder
    clientId?: SortOrder
    instanceId?: SortOrder
    tableId?: SortOrder
    rowKey?: SortOrder
    versionId?: SortOrder
    levelId?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    table?: TableOrderByWithRelationInput
    instance?: InstanceOrderByWithRelationInput
  }

  export type TableDataWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    rowKey?: string
    AND?: TableDataWhereInput | TableDataWhereInput[]
    OR?: TableDataWhereInput[]
    NOT?: TableDataWhereInput | TableDataWhereInput[]
    clientId?: StringFilter<"TableData"> | string
    instanceId?: StringFilter<"TableData"> | string
    tableId?: StringFilter<"TableData"> | string
    versionId?: StringFilter<"TableData"> | string
    levelId?: StringFilter<"TableData"> | string
    data?: JsonFilter<"TableData">
    createdAt?: DateTimeNullableFilter<"TableData"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"TableData"> | Date | string | null
    table?: XOR<TableScalarRelationFilter, TableWhereInput>
    instance?: XOR<InstanceScalarRelationFilter, InstanceWhereInput>
  }, "id" | "rowKey">

  export type TableDataOrderByWithAggregationInput = {
    id?: SortOrder
    clientId?: SortOrder
    instanceId?: SortOrder
    tableId?: SortOrder
    rowKey?: SortOrder
    versionId?: SortOrder
    levelId?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TableDataCountOrderByAggregateInput
    _max?: TableDataMaxOrderByAggregateInput
    _min?: TableDataMinOrderByAggregateInput
  }

  export type TableDataScalarWhereWithAggregatesInput = {
    AND?: TableDataScalarWhereWithAggregatesInput | TableDataScalarWhereWithAggregatesInput[]
    OR?: TableDataScalarWhereWithAggregatesInput[]
    NOT?: TableDataScalarWhereWithAggregatesInput | TableDataScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TableData"> | string
    clientId?: StringWithAggregatesFilter<"TableData"> | string
    instanceId?: StringWithAggregatesFilter<"TableData"> | string
    tableId?: StringWithAggregatesFilter<"TableData"> | string
    rowKey?: StringWithAggregatesFilter<"TableData"> | string
    versionId?: StringWithAggregatesFilter<"TableData"> | string
    levelId?: StringWithAggregatesFilter<"TableData"> | string
    data?: JsonWithAggregatesFilter<"TableData">
    createdAt?: DateTimeNullableWithAggregatesFilter<"TableData"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"TableData"> | Date | string | null
  }

  export type DataSourceWhereInput = {
    AND?: DataSourceWhereInput | DataSourceWhereInput[]
    OR?: DataSourceWhereInput[]
    NOT?: DataSourceWhereInput | DataSourceWhereInput[]
    id?: StringFilter<"DataSource"> | string
    clientId?: StringFilter<"DataSource"> | string
    instanceId?: StringFilter<"DataSource"> | string
    name?: StringFilter<"DataSource"> | string
    code?: StringFilter<"DataSource"> | string
    credentialId?: StringNullableFilter<"DataSource"> | string | null
    description?: StringNullableFilter<"DataSource"> | string | null
    type?: EnumDataSourceTypeFilter<"DataSource"> | $Enums.DataSourceType
    createdAt?: DateTimeNullableFilter<"DataSource"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"DataSource"> | Date | string | null
    credential?: XOR<DataSourceCredentialNullableScalarRelationFilter, DataSourceCredentialWhereInput> | null
  }

  export type DataSourceOrderByWithRelationInput = {
    id?: SortOrder
    clientId?: SortOrder
    instanceId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    credentialId?: SortOrder
    description?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    credential?: DataSourceCredentialOrderByWithRelationInput
  }

  export type DataSourceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    clientId_instanceId_code?: DataSourceClientIdInstanceIdCodeCompoundUniqueInput
    AND?: DataSourceWhereInput | DataSourceWhereInput[]
    OR?: DataSourceWhereInput[]
    NOT?: DataSourceWhereInput | DataSourceWhereInput[]
    clientId?: StringFilter<"DataSource"> | string
    instanceId?: StringFilter<"DataSource"> | string
    name?: StringFilter<"DataSource"> | string
    code?: StringFilter<"DataSource"> | string
    credentialId?: StringNullableFilter<"DataSource"> | string | null
    description?: StringNullableFilter<"DataSource"> | string | null
    type?: EnumDataSourceTypeFilter<"DataSource"> | $Enums.DataSourceType
    createdAt?: DateTimeNullableFilter<"DataSource"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"DataSource"> | Date | string | null
    credential?: XOR<DataSourceCredentialNullableScalarRelationFilter, DataSourceCredentialWhereInput> | null
  }, "id" | "clientId_instanceId_code">

  export type DataSourceOrderByWithAggregationInput = {
    id?: SortOrder
    clientId?: SortOrder
    instanceId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    credentialId?: SortOrder
    description?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DataSourceCountOrderByAggregateInput
    _max?: DataSourceMaxOrderByAggregateInput
    _min?: DataSourceMinOrderByAggregateInput
  }

  export type DataSourceScalarWhereWithAggregatesInput = {
    AND?: DataSourceScalarWhereWithAggregatesInput | DataSourceScalarWhereWithAggregatesInput[]
    OR?: DataSourceScalarWhereWithAggregatesInput[]
    NOT?: DataSourceScalarWhereWithAggregatesInput | DataSourceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DataSource"> | string
    clientId?: StringWithAggregatesFilter<"DataSource"> | string
    instanceId?: StringWithAggregatesFilter<"DataSource"> | string
    name?: StringWithAggregatesFilter<"DataSource"> | string
    code?: StringWithAggregatesFilter<"DataSource"> | string
    credentialId?: StringNullableWithAggregatesFilter<"DataSource"> | string | null
    description?: StringNullableWithAggregatesFilter<"DataSource"> | string | null
    type?: EnumDataSourceTypeWithAggregatesFilter<"DataSource"> | $Enums.DataSourceType
    createdAt?: DateTimeNullableWithAggregatesFilter<"DataSource"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"DataSource"> | Date | string | null
  }

  export type DataSourceTaskWhereInput = {
    AND?: DataSourceTaskWhereInput | DataSourceTaskWhereInput[]
    OR?: DataSourceTaskWhereInput[]
    NOT?: DataSourceTaskWhereInput | DataSourceTaskWhereInput[]
    id?: StringFilter<"DataSourceTask"> | string
    clientId?: StringFilter<"DataSourceTask"> | string
    instanceId?: StringFilter<"DataSourceTask"> | string
    name?: StringFilter<"DataSourceTask"> | string
    code?: StringFilter<"DataSourceTask"> | string
    description?: StringNullableFilter<"DataSourceTask"> | string | null
    createdAt?: DateTimeNullableFilter<"DataSourceTask"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"DataSourceTask"> | Date | string | null
  }

  export type DataSourceTaskOrderByWithRelationInput = {
    id?: SortOrder
    clientId?: SortOrder
    instanceId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DataSourceTaskWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    clientId_instanceId_code?: DataSourceTaskClientIdInstanceIdCodeCompoundUniqueInput
    AND?: DataSourceTaskWhereInput | DataSourceTaskWhereInput[]
    OR?: DataSourceTaskWhereInput[]
    NOT?: DataSourceTaskWhereInput | DataSourceTaskWhereInput[]
    clientId?: StringFilter<"DataSourceTask"> | string
    instanceId?: StringFilter<"DataSourceTask"> | string
    name?: StringFilter<"DataSourceTask"> | string
    code?: StringFilter<"DataSourceTask"> | string
    description?: StringNullableFilter<"DataSourceTask"> | string | null
    createdAt?: DateTimeNullableFilter<"DataSourceTask"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"DataSourceTask"> | Date | string | null
  }, "id" | "clientId_instanceId_code">

  export type DataSourceTaskOrderByWithAggregationInput = {
    id?: SortOrder
    clientId?: SortOrder
    instanceId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DataSourceTaskCountOrderByAggregateInput
    _max?: DataSourceTaskMaxOrderByAggregateInput
    _min?: DataSourceTaskMinOrderByAggregateInput
  }

  export type DataSourceTaskScalarWhereWithAggregatesInput = {
    AND?: DataSourceTaskScalarWhereWithAggregatesInput | DataSourceTaskScalarWhereWithAggregatesInput[]
    OR?: DataSourceTaskScalarWhereWithAggregatesInput[]
    NOT?: DataSourceTaskScalarWhereWithAggregatesInput | DataSourceTaskScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DataSourceTask"> | string
    clientId?: StringWithAggregatesFilter<"DataSourceTask"> | string
    instanceId?: StringWithAggregatesFilter<"DataSourceTask"> | string
    name?: StringWithAggregatesFilter<"DataSourceTask"> | string
    code?: StringWithAggregatesFilter<"DataSourceTask"> | string
    description?: StringNullableWithAggregatesFilter<"DataSourceTask"> | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"DataSourceTask"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"DataSourceTask"> | Date | string | null
  }

  export type DataSourceLoaderWhereInput = {
    AND?: DataSourceLoaderWhereInput | DataSourceLoaderWhereInput[]
    OR?: DataSourceLoaderWhereInput[]
    NOT?: DataSourceLoaderWhereInput | DataSourceLoaderWhereInput[]
    id?: StringFilter<"DataSourceLoader"> | string
    clientId?: StringFilter<"DataSourceLoader"> | string
    instanceId?: StringFilter<"DataSourceLoader"> | string
    name?: StringFilter<"DataSourceLoader"> | string
    code?: StringFilter<"DataSourceLoader"> | string
    loaderType?: EnumDataSourceLoaderTypeFilter<"DataSourceLoader"> | $Enums.DataSourceLoaderType
    sourceTable?: StringNullableFilter<"DataSourceLoader"> | string | null
    planningTable?: StringNullableListFilter<"DataSourceLoader">
    planningElementId?: StringFilter<"DataSourceLoader"> | string
    planningElementType?: StringFilter<"DataSourceLoader"> | string
    versionId?: StringFilter<"DataSourceLoader"> | string
    createElementIfNotFound?: BoolNullableFilter<"DataSourceLoader"> | boolean | null
    settingsOptions?: JsonNullableFilter<"DataSourceLoader">
    columnMappings?: JsonNullableFilter<"DataSourceLoader">
    description?: StringNullableFilter<"DataSourceLoader"> | string | null
    createdAt?: DateTimeNullableFilter<"DataSourceLoader"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"DataSourceLoader"> | Date | string | null
  }

  export type DataSourceLoaderOrderByWithRelationInput = {
    id?: SortOrder
    clientId?: SortOrder
    instanceId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    loaderType?: SortOrder
    sourceTable?: SortOrder
    planningTable?: SortOrder
    planningElementId?: SortOrder
    planningElementType?: SortOrder
    versionId?: SortOrder
    createElementIfNotFound?: SortOrder
    settingsOptions?: SortOrder
    columnMappings?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DataSourceLoaderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    clientId_instanceId_code?: DataSourceLoaderClientIdInstanceIdCodeCompoundUniqueInput
    AND?: DataSourceLoaderWhereInput | DataSourceLoaderWhereInput[]
    OR?: DataSourceLoaderWhereInput[]
    NOT?: DataSourceLoaderWhereInput | DataSourceLoaderWhereInput[]
    clientId?: StringFilter<"DataSourceLoader"> | string
    instanceId?: StringFilter<"DataSourceLoader"> | string
    name?: StringFilter<"DataSourceLoader"> | string
    code?: StringFilter<"DataSourceLoader"> | string
    loaderType?: EnumDataSourceLoaderTypeFilter<"DataSourceLoader"> | $Enums.DataSourceLoaderType
    sourceTable?: StringNullableFilter<"DataSourceLoader"> | string | null
    planningTable?: StringNullableListFilter<"DataSourceLoader">
    planningElementId?: StringFilter<"DataSourceLoader"> | string
    planningElementType?: StringFilter<"DataSourceLoader"> | string
    versionId?: StringFilter<"DataSourceLoader"> | string
    createElementIfNotFound?: BoolNullableFilter<"DataSourceLoader"> | boolean | null
    settingsOptions?: JsonNullableFilter<"DataSourceLoader">
    columnMappings?: JsonNullableFilter<"DataSourceLoader">
    description?: StringNullableFilter<"DataSourceLoader"> | string | null
    createdAt?: DateTimeNullableFilter<"DataSourceLoader"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"DataSourceLoader"> | Date | string | null
  }, "id" | "clientId_instanceId_code">

  export type DataSourceLoaderOrderByWithAggregationInput = {
    id?: SortOrder
    clientId?: SortOrder
    instanceId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    loaderType?: SortOrder
    sourceTable?: SortOrder
    planningTable?: SortOrder
    planningElementId?: SortOrder
    planningElementType?: SortOrder
    versionId?: SortOrder
    createElementIfNotFound?: SortOrder
    settingsOptions?: SortOrder
    columnMappings?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DataSourceLoaderCountOrderByAggregateInput
    _max?: DataSourceLoaderMaxOrderByAggregateInput
    _min?: DataSourceLoaderMinOrderByAggregateInput
  }

  export type DataSourceLoaderScalarWhereWithAggregatesInput = {
    AND?: DataSourceLoaderScalarWhereWithAggregatesInput | DataSourceLoaderScalarWhereWithAggregatesInput[]
    OR?: DataSourceLoaderScalarWhereWithAggregatesInput[]
    NOT?: DataSourceLoaderScalarWhereWithAggregatesInput | DataSourceLoaderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DataSourceLoader"> | string
    clientId?: StringWithAggregatesFilter<"DataSourceLoader"> | string
    instanceId?: StringWithAggregatesFilter<"DataSourceLoader"> | string
    name?: StringWithAggregatesFilter<"DataSourceLoader"> | string
    code?: StringWithAggregatesFilter<"DataSourceLoader"> | string
    loaderType?: EnumDataSourceLoaderTypeWithAggregatesFilter<"DataSourceLoader"> | $Enums.DataSourceLoaderType
    sourceTable?: StringNullableWithAggregatesFilter<"DataSourceLoader"> | string | null
    planningTable?: StringNullableListFilter<"DataSourceLoader">
    planningElementId?: StringWithAggregatesFilter<"DataSourceLoader"> | string
    planningElementType?: StringWithAggregatesFilter<"DataSourceLoader"> | string
    versionId?: StringWithAggregatesFilter<"DataSourceLoader"> | string
    createElementIfNotFound?: BoolNullableWithAggregatesFilter<"DataSourceLoader"> | boolean | null
    settingsOptions?: JsonNullableWithAggregatesFilter<"DataSourceLoader">
    columnMappings?: JsonNullableWithAggregatesFilter<"DataSourceLoader">
    description?: StringNullableWithAggregatesFilter<"DataSourceLoader"> | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"DataSourceLoader"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"DataSourceLoader"> | Date | string | null
  }

  export type DataSourceCredentialWhereInput = {
    AND?: DataSourceCredentialWhereInput | DataSourceCredentialWhereInput[]
    OR?: DataSourceCredentialWhereInput[]
    NOT?: DataSourceCredentialWhereInput | DataSourceCredentialWhereInput[]
    id?: StringFilter<"DataSourceCredential"> | string
    clientId?: StringFilter<"DataSourceCredential"> | string
    instanceId?: StringFilter<"DataSourceCredential"> | string
    name?: StringFilter<"DataSourceCredential"> | string
    code?: StringFilter<"DataSourceCredential"> | string
    description?: StringNullableFilter<"DataSourceCredential"> | string | null
    type?: EnumDatasourceCredentialAuthTypeFilter<"DataSourceCredential"> | $Enums.DatasourceCredentialAuthType
    credentialId?: StringNullableFilter<"DataSourceCredential"> | string | null
    credentialKey?: StringNullableFilter<"DataSourceCredential"> | string | null
    credentialSecret?: StringNullableFilter<"DataSourceCredential"> | string | null
    credentialToken?: StringNullableFilter<"DataSourceCredential"> | string | null
    credentialTokenSecret?: StringNullableFilter<"DataSourceCredential"> | string | null
    credentialHostname?: StringNullableFilter<"DataSourceCredential"> | string | null
    credentialUsername?: StringNullableFilter<"DataSourceCredential"> | string | null
    fingerprint?: StringNullableFilter<"DataSourceCredential"> | string | null
    createdAt?: DateTimeNullableFilter<"DataSourceCredential"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"DataSourceCredential"> | Date | string | null
    datasources?: DataSourceListRelationFilter
  }

  export type DataSourceCredentialOrderByWithRelationInput = {
    id?: SortOrder
    clientId?: SortOrder
    instanceId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    type?: SortOrder
    credentialId?: SortOrder
    credentialKey?: SortOrder
    credentialSecret?: SortOrder
    credentialToken?: SortOrder
    credentialTokenSecret?: SortOrder
    credentialHostname?: SortOrder
    credentialUsername?: SortOrder
    fingerprint?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    datasources?: DataSourceOrderByRelationAggregateInput
  }

  export type DataSourceCredentialWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    clientId_instanceId_code?: DataSourceCredentialClientIdInstanceIdCodeCompoundUniqueInput
    AND?: DataSourceCredentialWhereInput | DataSourceCredentialWhereInput[]
    OR?: DataSourceCredentialWhereInput[]
    NOT?: DataSourceCredentialWhereInput | DataSourceCredentialWhereInput[]
    clientId?: StringFilter<"DataSourceCredential"> | string
    instanceId?: StringFilter<"DataSourceCredential"> | string
    name?: StringFilter<"DataSourceCredential"> | string
    code?: StringFilter<"DataSourceCredential"> | string
    description?: StringNullableFilter<"DataSourceCredential"> | string | null
    type?: EnumDatasourceCredentialAuthTypeFilter<"DataSourceCredential"> | $Enums.DatasourceCredentialAuthType
    credentialId?: StringNullableFilter<"DataSourceCredential"> | string | null
    credentialKey?: StringNullableFilter<"DataSourceCredential"> | string | null
    credentialSecret?: StringNullableFilter<"DataSourceCredential"> | string | null
    credentialToken?: StringNullableFilter<"DataSourceCredential"> | string | null
    credentialTokenSecret?: StringNullableFilter<"DataSourceCredential"> | string | null
    credentialHostname?: StringNullableFilter<"DataSourceCredential"> | string | null
    credentialUsername?: StringNullableFilter<"DataSourceCredential"> | string | null
    fingerprint?: StringNullableFilter<"DataSourceCredential"> | string | null
    createdAt?: DateTimeNullableFilter<"DataSourceCredential"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"DataSourceCredential"> | Date | string | null
    datasources?: DataSourceListRelationFilter
  }, "id" | "clientId_instanceId_code">

  export type DataSourceCredentialOrderByWithAggregationInput = {
    id?: SortOrder
    clientId?: SortOrder
    instanceId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    type?: SortOrder
    credentialId?: SortOrder
    credentialKey?: SortOrder
    credentialSecret?: SortOrder
    credentialToken?: SortOrder
    credentialTokenSecret?: SortOrder
    credentialHostname?: SortOrder
    credentialUsername?: SortOrder
    fingerprint?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DataSourceCredentialCountOrderByAggregateInput
    _max?: DataSourceCredentialMaxOrderByAggregateInput
    _min?: DataSourceCredentialMinOrderByAggregateInput
  }

  export type DataSourceCredentialScalarWhereWithAggregatesInput = {
    AND?: DataSourceCredentialScalarWhereWithAggregatesInput | DataSourceCredentialScalarWhereWithAggregatesInput[]
    OR?: DataSourceCredentialScalarWhereWithAggregatesInput[]
    NOT?: DataSourceCredentialScalarWhereWithAggregatesInput | DataSourceCredentialScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DataSourceCredential"> | string
    clientId?: StringWithAggregatesFilter<"DataSourceCredential"> | string
    instanceId?: StringWithAggregatesFilter<"DataSourceCredential"> | string
    name?: StringWithAggregatesFilter<"DataSourceCredential"> | string
    code?: StringWithAggregatesFilter<"DataSourceCredential"> | string
    description?: StringNullableWithAggregatesFilter<"DataSourceCredential"> | string | null
    type?: EnumDatasourceCredentialAuthTypeWithAggregatesFilter<"DataSourceCredential"> | $Enums.DatasourceCredentialAuthType
    credentialId?: StringNullableWithAggregatesFilter<"DataSourceCredential"> | string | null
    credentialKey?: StringNullableWithAggregatesFilter<"DataSourceCredential"> | string | null
    credentialSecret?: StringNullableWithAggregatesFilter<"DataSourceCredential"> | string | null
    credentialToken?: StringNullableWithAggregatesFilter<"DataSourceCredential"> | string | null
    credentialTokenSecret?: StringNullableWithAggregatesFilter<"DataSourceCredential"> | string | null
    credentialHostname?: StringNullableWithAggregatesFilter<"DataSourceCredential"> | string | null
    credentialUsername?: StringNullableWithAggregatesFilter<"DataSourceCredential"> | string | null
    fingerprint?: StringNullableWithAggregatesFilter<"DataSourceCredential"> | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"DataSourceCredential"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"DataSourceCredential"> | Date | string | null
  }

  export type ConfigCreateInput = {
    id?: string
    defaultTopLevelName: string
    defaultTopLevelDescription: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    defaultIsoCurrency: CurrencyIsoCodeCreateNestedOneWithoutConfigInput
    defaultCurrency: CurrencyCreateNestedOneWithoutDefaultsInput
  }

  export type ConfigUncheckedCreateInput = {
    id?: string
    defaultIsoCurrencyId: string
    defaultCurrencyId: string
    defaultTopLevelName: string
    defaultTopLevelDescription: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ConfigUpdateInput = {
    defaultTopLevelName?: StringFieldUpdateOperationsInput | string
    defaultTopLevelDescription?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    defaultIsoCurrency?: CurrencyIsoCodeUpdateOneRequiredWithoutConfigNestedInput
    defaultCurrency?: CurrencyUpdateOneRequiredWithoutDefaultsNestedInput
  }

  export type ConfigUncheckedUpdateInput = {
    defaultIsoCurrencyId?: StringFieldUpdateOperationsInput | string
    defaultCurrencyId?: StringFieldUpdateOperationsInput | string
    defaultTopLevelName?: StringFieldUpdateOperationsInput | string
    defaultTopLevelDescription?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ConfigCreateManyInput = {
    id?: string
    defaultIsoCurrencyId: string
    defaultCurrencyId: string
    defaultTopLevelName: string
    defaultTopLevelDescription: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ConfigUpdateManyMutationInput = {
    defaultTopLevelName?: StringFieldUpdateOperationsInput | string
    defaultTopLevelDescription?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ConfigUncheckedUpdateManyInput = {
    defaultIsoCurrencyId?: StringFieldUpdateOperationsInput | string
    defaultCurrencyId?: StringFieldUpdateOperationsInput | string
    defaultTopLevelName?: StringFieldUpdateOperationsInput | string
    defaultTopLevelDescription?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CountryCreateInput = {
    id?: string
    name: string
    iso_3166_2_code: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    Client?: ClientCreateNestedManyWithoutCountryInput
    User?: UserCreateNestedManyWithoutCountryInput
  }

  export type CountryUncheckedCreateInput = {
    id?: string
    name: string
    iso_3166_2_code: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    Client?: ClientUncheckedCreateNestedManyWithoutCountryInput
    User?: UserUncheckedCreateNestedManyWithoutCountryInput
  }

  export type CountryUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    iso_3166_2_code?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Client?: ClientUpdateManyWithoutCountryNestedInput
    User?: UserUpdateManyWithoutCountryNestedInput
  }

  export type CountryUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    iso_3166_2_code?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Client?: ClientUncheckedUpdateManyWithoutCountryNestedInput
    User?: UserUncheckedUpdateManyWithoutCountryNestedInput
  }

  export type CountryCreateManyInput = {
    id?: string
    name: string
    iso_3166_2_code: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type CountryUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    iso_3166_2_code?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CountryUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    iso_3166_2_code?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserCreateInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    authProviderId: string
    role?: $Enums.userRole
    permissions?: UserCreatepermissionsInput | string[]
    defaultInstance: string
    selectedInstance?: string | null
    lastLogin?: Date | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    country?: CountryCreateNestedOneWithoutUserInput
    client: ClientCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    authProviderId: string
    role?: $Enums.userRole
    countryId?: string | null
    permissions?: UserCreatepermissionsInput | string[]
    clientId: string
    defaultInstance: string
    selectedInstance?: string | null
    lastLogin?: Date | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type UserUpdateInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    authProviderId?: StringFieldUpdateOperationsInput | string
    role?: EnumuserRoleFieldUpdateOperationsInput | $Enums.userRole
    permissions?: UserUpdatepermissionsInput | string[]
    defaultInstance?: StringFieldUpdateOperationsInput | string
    selectedInstance?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: CountryUpdateOneWithoutUserNestedInput
    client?: ClientUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    authProviderId?: StringFieldUpdateOperationsInput | string
    role?: EnumuserRoleFieldUpdateOperationsInput | $Enums.userRole
    countryId?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: UserUpdatepermissionsInput | string[]
    clientId?: StringFieldUpdateOperationsInput | string
    defaultInstance?: StringFieldUpdateOperationsInput | string
    selectedInstance?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserCreateManyInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    authProviderId: string
    role?: $Enums.userRole
    countryId?: string | null
    permissions?: UserCreatepermissionsInput | string[]
    clientId: string
    defaultInstance: string
    selectedInstance?: string | null
    lastLogin?: Date | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type UserUpdateManyMutationInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    authProviderId?: StringFieldUpdateOperationsInput | string
    role?: EnumuserRoleFieldUpdateOperationsInput | $Enums.userRole
    permissions?: UserUpdatepermissionsInput | string[]
    defaultInstance?: StringFieldUpdateOperationsInput | string
    selectedInstance?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    authProviderId?: StringFieldUpdateOperationsInput | string
    role?: EnumuserRoleFieldUpdateOperationsInput | $Enums.userRole
    countryId?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: UserUpdatepermissionsInput | string[]
    clientId?: StringFieldUpdateOperationsInput | string
    defaultInstance?: StringFieldUpdateOperationsInput | string
    selectedInstance?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ClientCreateInput = {
    id?: string
    name: string
    code: string
    status?: $Enums.clientStatus
    address?: XOR<addressTypeNullableCreateEnvelopeInput, addressTypeCreateInput> | null
    contactId?: string | null
    lastLogin?: Date | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    country?: CountryCreateNestedOneWithoutClientInput
    users?: UserCreateNestedManyWithoutClientInput
    instances?: InstanceCreateNestedManyWithoutClientInput
    Permission?: PermissionCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateInput = {
    id?: string
    name: string
    code: string
    status?: $Enums.clientStatus
    address?: XOR<addressTypeNullableCreateEnvelopeInput, addressTypeCreateInput> | null
    countryId?: string | null
    contactId?: string | null
    lastLogin?: Date | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    users?: UserUncheckedCreateNestedManyWithoutClientInput
    instances?: InstanceUncheckedCreateNestedManyWithoutClientInput
    Permission?: PermissionUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumclientStatusFieldUpdateOperationsInput | $Enums.clientStatus
    address?: XOR<addressTypeNullableUpdateEnvelopeInput, addressTypeCreateInput> | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: CountryUpdateOneWithoutClientNestedInput
    users?: UserUpdateManyWithoutClientNestedInput
    instances?: InstanceUpdateManyWithoutClientNestedInput
    Permission?: PermissionUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumclientStatusFieldUpdateOperationsInput | $Enums.clientStatus
    address?: XOR<addressTypeNullableUpdateEnvelopeInput, addressTypeCreateInput> | null
    countryId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: UserUncheckedUpdateManyWithoutClientNestedInput
    instances?: InstanceUncheckedUpdateManyWithoutClientNestedInput
    Permission?: PermissionUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ClientCreateManyInput = {
    id?: string
    name: string
    code: string
    status?: $Enums.clientStatus
    address?: XOR<addressTypeNullableCreateEnvelopeInput, addressTypeCreateInput> | null
    countryId?: string | null
    contactId?: string | null
    lastLogin?: Date | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ClientUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumclientStatusFieldUpdateOperationsInput | $Enums.clientStatus
    address?: XOR<addressTypeNullableUpdateEnvelopeInput, addressTypeCreateInput> | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ClientUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumclientStatusFieldUpdateOperationsInput | $Enums.clientStatus
    address?: XOR<addressTypeNullableUpdateEnvelopeInput, addressTypeCreateInput> | null
    countryId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PermissionCreateInput = {
    id?: string
    name: string
    code: string
    actions?: PermissionCreateactionsInput | string[]
    subjects?: PermissionCreatesubjectsInput | string[]
    description?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    client: ClientCreateNestedOneWithoutPermissionInput
  }

  export type PermissionUncheckedCreateInput = {
    id?: string
    name: string
    code: string
    clientId: string
    actions?: PermissionCreateactionsInput | string[]
    subjects?: PermissionCreatesubjectsInput | string[]
    description?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type PermissionUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    actions?: PermissionUpdateactionsInput | string[]
    subjects?: PermissionUpdatesubjectsInput | string[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    client?: ClientUpdateOneRequiredWithoutPermissionNestedInput
  }

  export type PermissionUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    actions?: PermissionUpdateactionsInput | string[]
    subjects?: PermissionUpdatesubjectsInput | string[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PermissionCreateManyInput = {
    id?: string
    name: string
    code: string
    clientId: string
    actions?: PermissionCreateactionsInput | string[]
    subjects?: PermissionCreatesubjectsInput | string[]
    description?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type PermissionUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    actions?: PermissionUpdateactionsInput | string[]
    subjects?: PermissionUpdatesubjectsInput | string[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PermissionUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    actions?: PermissionUpdateactionsInput | string[]
    subjects?: PermissionUpdatesubjectsInput | string[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InstanceCreateInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    status?: $Enums.instanceStatus
    userIds?: InstanceCreateuserIdsInput | string[]
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    client: ClientCreateNestedOneWithoutInstancesInput
    levels?: LevelCreateNestedManyWithoutInstanceInput
    versions?: VersionCreateNestedManyWithoutInstanceInput
    currencies?: CurrencyCreateNestedManyWithoutInstanceInput
    accounts?: AccountCreateNestedManyWithoutInstanceInput
    models?: ModelCreateNestedManyWithoutInstanceInput
    dimensions?: DimensionCreateNestedManyWithoutInstanceInput
    dimensionValues?: DimensionValueCreateNestedManyWithoutInstanceInput
    levelAttributes?: LevelAttributeCreateNestedManyWithoutInstanceInput
    dimensionValueAttributes?: DimensionValueAttributeCreateNestedManyWithoutInstanceInput
    accountAttributes?: AccountAttributeCreateNestedManyWithoutInstanceInput
    levelAttValues?: LevelAttributeValueCreateNestedManyWithoutInstanceInput
    accountAttValues?: AccountAttributeValueCreateNestedManyWithoutInstanceInput
    dimensionValueAttributeValues?: DimensionValueAttributeValueCreateNestedManyWithoutInstanceInput
    modelData?: ModelDataCreateNestedManyWithoutInstanceInput
    modelDataCalculations?: ModelDataCalculationsCreateNestedManyWithoutInstanceInput
    modelAccounts?: ModelAccountStructureCreateNestedManyWithoutInstanceInput
    tables?: TableCreateNestedManyWithoutInstanceInput
    tableData?: TableDataCreateNestedManyWithoutInstanceInput
  }

  export type InstanceUncheckedCreateInput = {
    id?: string
    code: string
    name: string
    clientId: string
    description?: string | null
    status?: $Enums.instanceStatus
    userIds?: InstanceCreateuserIdsInput | string[]
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    levels?: LevelUncheckedCreateNestedManyWithoutInstanceInput
    versions?: VersionUncheckedCreateNestedManyWithoutInstanceInput
    currencies?: CurrencyUncheckedCreateNestedManyWithoutInstanceInput
    accounts?: AccountUncheckedCreateNestedManyWithoutInstanceInput
    models?: ModelUncheckedCreateNestedManyWithoutInstanceInput
    dimensions?: DimensionUncheckedCreateNestedManyWithoutInstanceInput
    dimensionValues?: DimensionValueUncheckedCreateNestedManyWithoutInstanceInput
    levelAttributes?: LevelAttributeUncheckedCreateNestedManyWithoutInstanceInput
    dimensionValueAttributes?: DimensionValueAttributeUncheckedCreateNestedManyWithoutInstanceInput
    accountAttributes?: AccountAttributeUncheckedCreateNestedManyWithoutInstanceInput
    levelAttValues?: LevelAttributeValueUncheckedCreateNestedManyWithoutInstanceInput
    accountAttValues?: AccountAttributeValueUncheckedCreateNestedManyWithoutInstanceInput
    dimensionValueAttributeValues?: DimensionValueAttributeValueUncheckedCreateNestedManyWithoutInstanceInput
    modelData?: ModelDataUncheckedCreateNestedManyWithoutInstanceInput
    modelDataCalculations?: ModelDataCalculationsUncheckedCreateNestedManyWithoutInstanceInput
    modelAccounts?: ModelAccountStructureUncheckedCreateNestedManyWithoutInstanceInput
    tables?: TableUncheckedCreateNestedManyWithoutInstanceInput
    tableData?: TableDataUncheckedCreateNestedManyWithoutInstanceInput
  }

  export type InstanceUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnuminstanceStatusFieldUpdateOperationsInput | $Enums.instanceStatus
    userIds?: InstanceUpdateuserIdsInput | string[]
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    client?: ClientUpdateOneRequiredWithoutInstancesNestedInput
    levels?: LevelUpdateManyWithoutInstanceNestedInput
    versions?: VersionUpdateManyWithoutInstanceNestedInput
    currencies?: CurrencyUpdateManyWithoutInstanceNestedInput
    accounts?: AccountUpdateManyWithoutInstanceNestedInput
    models?: ModelUpdateManyWithoutInstanceNestedInput
    dimensions?: DimensionUpdateManyWithoutInstanceNestedInput
    dimensionValues?: DimensionValueUpdateManyWithoutInstanceNestedInput
    levelAttributes?: LevelAttributeUpdateManyWithoutInstanceNestedInput
    dimensionValueAttributes?: DimensionValueAttributeUpdateManyWithoutInstanceNestedInput
    accountAttributes?: AccountAttributeUpdateManyWithoutInstanceNestedInput
    levelAttValues?: LevelAttributeValueUpdateManyWithoutInstanceNestedInput
    accountAttValues?: AccountAttributeValueUpdateManyWithoutInstanceNestedInput
    dimensionValueAttributeValues?: DimensionValueAttributeValueUpdateManyWithoutInstanceNestedInput
    modelData?: ModelDataUpdateManyWithoutInstanceNestedInput
    modelDataCalculations?: ModelDataCalculationsUpdateManyWithoutInstanceNestedInput
    modelAccounts?: ModelAccountStructureUpdateManyWithoutInstanceNestedInput
    tables?: TableUpdateManyWithoutInstanceNestedInput
    tableData?: TableDataUpdateManyWithoutInstanceNestedInput
  }

  export type InstanceUncheckedUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnuminstanceStatusFieldUpdateOperationsInput | $Enums.instanceStatus
    userIds?: InstanceUpdateuserIdsInput | string[]
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    levels?: LevelUncheckedUpdateManyWithoutInstanceNestedInput
    versions?: VersionUncheckedUpdateManyWithoutInstanceNestedInput
    currencies?: CurrencyUncheckedUpdateManyWithoutInstanceNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutInstanceNestedInput
    models?: ModelUncheckedUpdateManyWithoutInstanceNestedInput
    dimensions?: DimensionUncheckedUpdateManyWithoutInstanceNestedInput
    dimensionValues?: DimensionValueUncheckedUpdateManyWithoutInstanceNestedInput
    levelAttributes?: LevelAttributeUncheckedUpdateManyWithoutInstanceNestedInput
    dimensionValueAttributes?: DimensionValueAttributeUncheckedUpdateManyWithoutInstanceNestedInput
    accountAttributes?: AccountAttributeUncheckedUpdateManyWithoutInstanceNestedInput
    levelAttValues?: LevelAttributeValueUncheckedUpdateManyWithoutInstanceNestedInput
    accountAttValues?: AccountAttributeValueUncheckedUpdateManyWithoutInstanceNestedInput
    dimensionValueAttributeValues?: DimensionValueAttributeValueUncheckedUpdateManyWithoutInstanceNestedInput
    modelData?: ModelDataUncheckedUpdateManyWithoutInstanceNestedInput
    modelDataCalculations?: ModelDataCalculationsUncheckedUpdateManyWithoutInstanceNestedInput
    modelAccounts?: ModelAccountStructureUncheckedUpdateManyWithoutInstanceNestedInput
    tables?: TableUncheckedUpdateManyWithoutInstanceNestedInput
    tableData?: TableDataUncheckedUpdateManyWithoutInstanceNestedInput
  }

  export type InstanceCreateManyInput = {
    id?: string
    code: string
    name: string
    clientId: string
    description?: string | null
    status?: $Enums.instanceStatus
    userIds?: InstanceCreateuserIdsInput | string[]
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type InstanceUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnuminstanceStatusFieldUpdateOperationsInput | $Enums.instanceStatus
    userIds?: InstanceUpdateuserIdsInput | string[]
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InstanceUncheckedUpdateManyInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnuminstanceStatusFieldUpdateOperationsInput | $Enums.instanceStatus
    userIds?: InstanceUpdateuserIdsInput | string[]
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VersionCreateInput = {
    id?: string
    code: string
    name: string
    begin: Date | string
    end: Date | string
    startOfPlan: Date | string
    description?: string | null
    isDefault?: boolean
    isActuals?: boolean
    status?: $Enums.versionStatus
    clientId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    instance: InstanceCreateNestedOneWithoutVersionsInput
    modelData?: ModelDataCreateNestedManyWithoutVersionInput
    modelDataCalculations?: ModelDataCalculationsCreateNestedManyWithoutVersionInput
  }

  export type VersionUncheckedCreateInput = {
    id?: string
    code: string
    name: string
    begin: Date | string
    end: Date | string
    startOfPlan: Date | string
    description?: string | null
    isDefault?: boolean
    isActuals?: boolean
    status?: $Enums.versionStatus
    clientId: string
    instanceId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    modelData?: ModelDataUncheckedCreateNestedManyWithoutVersionInput
    modelDataCalculations?: ModelDataCalculationsUncheckedCreateNestedManyWithoutVersionInput
  }

  export type VersionUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    begin?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    startOfPlan?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isActuals?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumversionStatusFieldUpdateOperationsInput | $Enums.versionStatus
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instance?: InstanceUpdateOneRequiredWithoutVersionsNestedInput
    modelData?: ModelDataUpdateManyWithoutVersionNestedInput
    modelDataCalculations?: ModelDataCalculationsUpdateManyWithoutVersionNestedInput
  }

  export type VersionUncheckedUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    begin?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    startOfPlan?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isActuals?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumversionStatusFieldUpdateOperationsInput | $Enums.versionStatus
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modelData?: ModelDataUncheckedUpdateManyWithoutVersionNestedInput
    modelDataCalculations?: ModelDataCalculationsUncheckedUpdateManyWithoutVersionNestedInput
  }

  export type VersionCreateManyInput = {
    id?: string
    code: string
    name: string
    begin: Date | string
    end: Date | string
    startOfPlan: Date | string
    description?: string | null
    isDefault?: boolean
    isActuals?: boolean
    status?: $Enums.versionStatus
    clientId: string
    instanceId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type VersionUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    begin?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    startOfPlan?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isActuals?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumversionStatusFieldUpdateOperationsInput | $Enums.versionStatus
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VersionUncheckedUpdateManyInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    begin?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    startOfPlan?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isActuals?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumversionStatusFieldUpdateOperationsInput | $Enums.versionStatus
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CurrencyIsoCodeCreateInput = {
    id?: string
    code: string
    name: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    currencies?: CurrencyCreateNestedManyWithoutCurrencyIsoCodeInput
    config?: ConfigCreateNestedManyWithoutDefaultIsoCurrencyInput
  }

  export type CurrencyIsoCodeUncheckedCreateInput = {
    id?: string
    code: string
    name: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    currencies?: CurrencyUncheckedCreateNestedManyWithoutCurrencyIsoCodeInput
    config?: ConfigUncheckedCreateNestedManyWithoutDefaultIsoCurrencyInput
  }

  export type CurrencyIsoCodeUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currencies?: CurrencyUpdateManyWithoutCurrencyIsoCodeNestedInput
    config?: ConfigUpdateManyWithoutDefaultIsoCurrencyNestedInput
  }

  export type CurrencyIsoCodeUncheckedUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currencies?: CurrencyUncheckedUpdateManyWithoutCurrencyIsoCodeNestedInput
    config?: ConfigUncheckedUpdateManyWithoutDefaultIsoCurrencyNestedInput
  }

  export type CurrencyIsoCodeCreateManyInput = {
    id?: string
    code: string
    name: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type CurrencyIsoCodeUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CurrencyIsoCodeUncheckedUpdateManyInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CurrencyCreateInput = {
    id?: string
    name: string
    code: string
    assignedLevels: number
    isDefault?: $Enums.YesNo
    clientId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    currencyIsoCode: CurrencyIsoCodeCreateNestedOneWithoutCurrenciesInput
    instance: InstanceCreateNestedOneWithoutCurrenciesInput
    levels?: LevelCreateNestedManyWithoutCurrencyInput
    defaults?: ConfigCreateNestedManyWithoutDefaultCurrencyInput
  }

  export type CurrencyUncheckedCreateInput = {
    id?: string
    name: string
    code: string
    currencyIsoCodeId: string
    assignedLevels: number
    isDefault?: $Enums.YesNo
    clientId: string
    instanceId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    levels?: LevelUncheckedCreateNestedManyWithoutCurrencyInput
    defaults?: ConfigUncheckedCreateNestedManyWithoutDefaultCurrencyInput
  }

  export type CurrencyUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    assignedLevels?: IntFieldUpdateOperationsInput | number
    isDefault?: EnumYesNoFieldUpdateOperationsInput | $Enums.YesNo
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currencyIsoCode?: CurrencyIsoCodeUpdateOneRequiredWithoutCurrenciesNestedInput
    instance?: InstanceUpdateOneRequiredWithoutCurrenciesNestedInput
    levels?: LevelUpdateManyWithoutCurrencyNestedInput
    defaults?: ConfigUpdateManyWithoutDefaultCurrencyNestedInput
  }

  export type CurrencyUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    currencyIsoCodeId?: StringFieldUpdateOperationsInput | string
    assignedLevels?: IntFieldUpdateOperationsInput | number
    isDefault?: EnumYesNoFieldUpdateOperationsInput | $Enums.YesNo
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    levels?: LevelUncheckedUpdateManyWithoutCurrencyNestedInput
    defaults?: ConfigUncheckedUpdateManyWithoutDefaultCurrencyNestedInput
  }

  export type CurrencyCreateManyInput = {
    id?: string
    name: string
    code: string
    currencyIsoCodeId: string
    assignedLevels: number
    isDefault?: $Enums.YesNo
    clientId: string
    instanceId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type CurrencyUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    assignedLevels?: IntFieldUpdateOperationsInput | number
    isDefault?: EnumYesNoFieldUpdateOperationsInput | $Enums.YesNo
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CurrencyUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    currencyIsoCodeId?: StringFieldUpdateOperationsInput | string
    assignedLevels?: IntFieldUpdateOperationsInput | number
    isDefault?: EnumYesNoFieldUpdateOperationsInput | $Enums.YesNo
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LevelCreateInput = {
    id?: string
    code: string
    name: string
    isRoot?: boolean
    description?: string | null
    clientId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    AttributeAndValues?: LevelAttributeAndValueCreateNestedManyWithoutLevelInput
    parent?: LevelCreateNestedOneWithoutChildLevelsInput
    instance: InstanceCreateNestedOneWithoutLevelsInput
    currency: CurrencyCreateNestedOneWithoutLevelsInput
    childLevels?: LevelCreateNestedManyWithoutParentInput
    modelData?: ModelDataCreateNestedManyWithoutLevelInput
    modeldataCalculations?: ModelDataCalculationsCreateNestedManyWithoutLevelInput
  }

  export type LevelUncheckedCreateInput = {
    id?: string
    code: string
    name: string
    isRoot?: boolean
    description?: string | null
    parentId?: string | null
    clientId: string
    instanceId: string
    currencyId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    AttributeAndValues?: LevelAttributeAndValueUncheckedCreateNestedManyWithoutLevelInput
    childLevels?: LevelUncheckedCreateNestedManyWithoutParentInput
    modelData?: ModelDataUncheckedCreateNestedManyWithoutLevelInput
    modeldataCalculations?: ModelDataCalculationsUncheckedCreateNestedManyWithoutLevelInput
  }

  export type LevelUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isRoot?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    AttributeAndValues?: LevelAttributeAndValueUpdateManyWithoutLevelNestedInput
    parent?: LevelUpdateOneWithoutChildLevelsNestedInput
    instance?: InstanceUpdateOneRequiredWithoutLevelsNestedInput
    currency?: CurrencyUpdateOneRequiredWithoutLevelsNestedInput
    childLevels?: LevelUpdateManyWithoutParentNestedInput
    modelData?: ModelDataUpdateManyWithoutLevelNestedInput
    modeldataCalculations?: ModelDataCalculationsUpdateManyWithoutLevelNestedInput
  }

  export type LevelUncheckedUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isRoot?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    currencyId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    AttributeAndValues?: LevelAttributeAndValueUncheckedUpdateManyWithoutLevelNestedInput
    childLevels?: LevelUncheckedUpdateManyWithoutParentNestedInput
    modelData?: ModelDataUncheckedUpdateManyWithoutLevelNestedInput
    modeldataCalculations?: ModelDataCalculationsUncheckedUpdateManyWithoutLevelNestedInput
  }

  export type LevelCreateManyInput = {
    id?: string
    code: string
    name: string
    isRoot?: boolean
    description?: string | null
    parentId?: string | null
    clientId: string
    instanceId: string
    currencyId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type LevelUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isRoot?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LevelUncheckedUpdateManyInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isRoot?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    currencyId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LevelAttributeAndValueCreateInput = {
    id?: string
    clientId: string
    instanceId: string
    levelCode: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    level?: LevelCreateNestedOneWithoutAttributeAndValuesInput
    attribute?: LevelAttributeCreateNestedOneWithoutLevelAttributeAndValuesInput
    attributeValue?: LevelAttributeValueCreateNestedOneWithoutLevelAttributeAndValuesInput
  }

  export type LevelAttributeAndValueUncheckedCreateInput = {
    id?: string
    levelId: string
    clientId: string
    instanceId: string
    attributeId: string
    attributeValueId: string
    levelCode: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type LevelAttributeAndValueUpdateInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    levelCode?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    level?: LevelUpdateOneWithoutAttributeAndValuesNestedInput
    attribute?: LevelAttributeUpdateOneWithoutLevelAttributeAndValuesNestedInput
    attributeValue?: LevelAttributeValueUpdateOneWithoutLevelAttributeAndValuesNestedInput
  }

  export type LevelAttributeAndValueUncheckedUpdateInput = {
    levelId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    attributeId?: StringFieldUpdateOperationsInput | string
    attributeValueId?: StringFieldUpdateOperationsInput | string
    levelCode?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LevelAttributeAndValueCreateManyInput = {
    id?: string
    levelId: string
    clientId: string
    instanceId: string
    attributeId: string
    attributeValueId: string
    levelCode: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type LevelAttributeAndValueUpdateManyMutationInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    levelCode?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LevelAttributeAndValueUncheckedUpdateManyInput = {
    levelId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    attributeId?: StringFieldUpdateOperationsInput | string
    attributeValueId?: StringFieldUpdateOperationsInput | string
    levelCode?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LevelAttributeValueCreateInput = {
    id?: string
    code: string
    name: string
    clientId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    parent?: LevelAttributeValueCreateNestedOneWithoutChildAttributeValuesInput
    childAttributeValues?: LevelAttributeValueCreateNestedManyWithoutParentInput
    instance: InstanceCreateNestedOneWithoutLevelAttValuesInput
    levelAttribute: LevelAttributeCreateNestedOneWithoutLevelAttributeValuesInput
    levelAttributeAndValues?: LevelAttributeAndValueCreateNestedManyWithoutAttributeValueInput
  }

  export type LevelAttributeValueUncheckedCreateInput = {
    id?: string
    code: string
    name: string
    attributeId: string
    parentId?: string | null
    clientId: string
    instanceId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    childAttributeValues?: LevelAttributeValueUncheckedCreateNestedManyWithoutParentInput
    levelAttributeAndValues?: LevelAttributeAndValueUncheckedCreateNestedManyWithoutAttributeValueInput
  }

  export type LevelAttributeValueUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parent?: LevelAttributeValueUpdateOneWithoutChildAttributeValuesNestedInput
    childAttributeValues?: LevelAttributeValueUpdateManyWithoutParentNestedInput
    instance?: InstanceUpdateOneRequiredWithoutLevelAttValuesNestedInput
    levelAttribute?: LevelAttributeUpdateOneRequiredWithoutLevelAttributeValuesNestedInput
    levelAttributeAndValues?: LevelAttributeAndValueUpdateManyWithoutAttributeValueNestedInput
  }

  export type LevelAttributeValueUncheckedUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    attributeId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    childAttributeValues?: LevelAttributeValueUncheckedUpdateManyWithoutParentNestedInput
    levelAttributeAndValues?: LevelAttributeAndValueUncheckedUpdateManyWithoutAttributeValueNestedInput
  }

  export type LevelAttributeValueCreateManyInput = {
    id?: string
    code: string
    name: string
    attributeId: string
    parentId?: string | null
    clientId: string
    instanceId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type LevelAttributeValueUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LevelAttributeValueUncheckedUpdateManyInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    attributeId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LevelAttributeCreateInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    clientId: string
    attributeValueDefault?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    instance: InstanceCreateNestedOneWithoutLevelAttributesInput
    levelAttributeValues?: LevelAttributeValueCreateNestedManyWithoutLevelAttributeInput
    levelAttributeAndValues?: LevelAttributeAndValueCreateNestedManyWithoutAttributeInput
  }

  export type LevelAttributeUncheckedCreateInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    clientId: string
    instanceId: string
    attributeValueDefault?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    levelAttributeValues?: LevelAttributeValueUncheckedCreateNestedManyWithoutLevelAttributeInput
    levelAttributeAndValues?: LevelAttributeAndValueUncheckedCreateNestedManyWithoutAttributeInput
  }

  export type LevelAttributeUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    attributeValueDefault?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instance?: InstanceUpdateOneRequiredWithoutLevelAttributesNestedInput
    levelAttributeValues?: LevelAttributeValueUpdateManyWithoutLevelAttributeNestedInput
    levelAttributeAndValues?: LevelAttributeAndValueUpdateManyWithoutAttributeNestedInput
  }

  export type LevelAttributeUncheckedUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    attributeValueDefault?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    levelAttributeValues?: LevelAttributeValueUncheckedUpdateManyWithoutLevelAttributeNestedInput
    levelAttributeAndValues?: LevelAttributeAndValueUncheckedUpdateManyWithoutAttributeNestedInput
  }

  export type LevelAttributeCreateManyInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    clientId: string
    instanceId: string
    attributeValueDefault?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type LevelAttributeUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    attributeValueDefault?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LevelAttributeUncheckedUpdateManyInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    attributeValueDefault?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AccountAttributeCreateInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    attributeValueDefault?: string | null
    clientId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    instance: InstanceCreateNestedOneWithoutAccountAttributesInput
    accountAttributeValues?: AccountAttributeValueCreateNestedManyWithoutAccountAttributeInput
    AttributeAndValues?: AccountAttributeAndValueCreateNestedManyWithoutAttributeInput
  }

  export type AccountAttributeUncheckedCreateInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    attributeValueDefault?: string | null
    clientId: string
    instanceId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    accountAttributeValues?: AccountAttributeValueUncheckedCreateNestedManyWithoutAccountAttributeInput
    AttributeAndValues?: AccountAttributeAndValueUncheckedCreateNestedManyWithoutAttributeInput
  }

  export type AccountAttributeUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    attributeValueDefault?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instance?: InstanceUpdateOneRequiredWithoutAccountAttributesNestedInput
    accountAttributeValues?: AccountAttributeValueUpdateManyWithoutAccountAttributeNestedInput
    AttributeAndValues?: AccountAttributeAndValueUpdateManyWithoutAttributeNestedInput
  }

  export type AccountAttributeUncheckedUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    attributeValueDefault?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountAttributeValues?: AccountAttributeValueUncheckedUpdateManyWithoutAccountAttributeNestedInput
    AttributeAndValues?: AccountAttributeAndValueUncheckedUpdateManyWithoutAttributeNestedInput
  }

  export type AccountAttributeCreateManyInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    attributeValueDefault?: string | null
    clientId: string
    instanceId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type AccountAttributeUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    attributeValueDefault?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AccountAttributeUncheckedUpdateManyInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    attributeValueDefault?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AccountAttributeValueCreateInput = {
    id?: string
    code: string
    name: string
    clientId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    parent?: AccountAttributeValueCreateNestedOneWithoutChildAttributeValuesInput
    childAttributeValues?: AccountAttributeValueCreateNestedManyWithoutParentInput
    accountAttribute: AccountAttributeCreateNestedOneWithoutAccountAttributeValuesInput
    instance: InstanceCreateNestedOneWithoutAccountAttValuesInput
    AttributeAndValues?: AccountAttributeAndValueCreateNestedManyWithoutAttributeValueInput
  }

  export type AccountAttributeValueUncheckedCreateInput = {
    id?: string
    code: string
    name: string
    attributeId: string
    parentId?: string | null
    clientId: string
    instanceId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    childAttributeValues?: AccountAttributeValueUncheckedCreateNestedManyWithoutParentInput
    AttributeAndValues?: AccountAttributeAndValueUncheckedCreateNestedManyWithoutAttributeValueInput
  }

  export type AccountAttributeValueUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parent?: AccountAttributeValueUpdateOneWithoutChildAttributeValuesNestedInput
    childAttributeValues?: AccountAttributeValueUpdateManyWithoutParentNestedInput
    accountAttribute?: AccountAttributeUpdateOneRequiredWithoutAccountAttributeValuesNestedInput
    instance?: InstanceUpdateOneRequiredWithoutAccountAttValuesNestedInput
    AttributeAndValues?: AccountAttributeAndValueUpdateManyWithoutAttributeValueNestedInput
  }

  export type AccountAttributeValueUncheckedUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    attributeId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    childAttributeValues?: AccountAttributeValueUncheckedUpdateManyWithoutParentNestedInput
    AttributeAndValues?: AccountAttributeAndValueUncheckedUpdateManyWithoutAttributeValueNestedInput
  }

  export type AccountAttributeValueCreateManyInput = {
    id?: string
    code: string
    name: string
    attributeId: string
    parentId?: string | null
    clientId: string
    instanceId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type AccountAttributeValueUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AccountAttributeValueUncheckedUpdateManyInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    attributeId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AccountAttributeAndValueCreateInput = {
    id?: string
    clientId: string
    instanceId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    account?: AccountCreateNestedOneWithoutAttributeAndValuesInput
    attribute?: AccountAttributeCreateNestedOneWithoutAttributeAndValuesInput
    attributeValue?: AccountAttributeValueCreateNestedOneWithoutAttributeAndValuesInput
  }

  export type AccountAttributeAndValueUncheckedCreateInput = {
    id?: string
    accountId: string
    clientId: string
    instanceId: string
    attributeId: string
    attributeValueId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type AccountAttributeAndValueUpdateInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account?: AccountUpdateOneWithoutAttributeAndValuesNestedInput
    attribute?: AccountAttributeUpdateOneWithoutAttributeAndValuesNestedInput
    attributeValue?: AccountAttributeValueUpdateOneWithoutAttributeAndValuesNestedInput
  }

  export type AccountAttributeAndValueUncheckedUpdateInput = {
    accountId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    attributeId?: StringFieldUpdateOperationsInput | string
    attributeValueId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AccountAttributeAndValueCreateManyInput = {
    id?: string
    accountId: string
    clientId: string
    instanceId: string
    attributeId: string
    attributeValueId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type AccountAttributeAndValueUpdateManyMutationInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AccountAttributeAndValueUncheckedUpdateManyInput = {
    accountId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    attributeId?: StringFieldUpdateOperationsInput | string
    attributeValueId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AccountCreateInput = {
    id?: string
    code: string
    name: string
    isRoot?: boolean
    isModelRoot?: boolean
    accountType: $Enums.AccountType
    accountTypeTag: $Enums.AccountTypeTag
    group?: $Enums.YesNo
    plannedBy?: $Enums.ActPlanBy | null
    actualsBy?: $Enums.ActActualsBy | null
    displayAs?: $Enums.ActDisplayAs
    containsSalaryInfo?: $Enums.YesNo
    description?: string | null
    clientId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    instance: InstanceCreateNestedOneWithoutAccountsInput
    parent?: AccountCreateNestedOneWithoutChildAccountsInput
    childAccounts?: AccountCreateNestedManyWithoutParentInput
    AttributeAndValues?: AccountAttributeAndValueCreateNestedManyWithoutAccountInput
    modelAccounts?: ModelAccountStructureCreateNestedManyWithoutAccountInput
    modelData?: ModelDataCreateNestedManyWithoutAccountInput
    modeldataCalculations?: ModelDataCalculationsCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    code: string
    name: string
    isRoot?: boolean
    isModelRoot?: boolean
    accountType: $Enums.AccountType
    accountTypeTag: $Enums.AccountTypeTag
    group?: $Enums.YesNo
    plannedBy?: $Enums.ActPlanBy | null
    actualsBy?: $Enums.ActActualsBy | null
    displayAs?: $Enums.ActDisplayAs
    containsSalaryInfo?: $Enums.YesNo
    description?: string | null
    instanceId: string
    clientId: string
    parentId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    childAccounts?: AccountUncheckedCreateNestedManyWithoutParentInput
    AttributeAndValues?: AccountAttributeAndValueUncheckedCreateNestedManyWithoutAccountInput
    modelAccounts?: ModelAccountStructureUncheckedCreateNestedManyWithoutAccountInput
    modelData?: ModelDataUncheckedCreateNestedManyWithoutAccountInput
    modeldataCalculations?: ModelDataCalculationsUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isRoot?: BoolFieldUpdateOperationsInput | boolean
    isModelRoot?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    accountTypeTag?: EnumAccountTypeTagFieldUpdateOperationsInput | $Enums.AccountTypeTag
    group?: EnumYesNoFieldUpdateOperationsInput | $Enums.YesNo
    plannedBy?: NullableEnumActPlanByFieldUpdateOperationsInput | $Enums.ActPlanBy | null
    actualsBy?: NullableEnumActActualsByFieldUpdateOperationsInput | $Enums.ActActualsBy | null
    displayAs?: EnumActDisplayAsFieldUpdateOperationsInput | $Enums.ActDisplayAs
    containsSalaryInfo?: EnumYesNoFieldUpdateOperationsInput | $Enums.YesNo
    description?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instance?: InstanceUpdateOneRequiredWithoutAccountsNestedInput
    parent?: AccountUpdateOneWithoutChildAccountsNestedInput
    childAccounts?: AccountUpdateManyWithoutParentNestedInput
    AttributeAndValues?: AccountAttributeAndValueUpdateManyWithoutAccountNestedInput
    modelAccounts?: ModelAccountStructureUpdateManyWithoutAccountNestedInput
    modelData?: ModelDataUpdateManyWithoutAccountNestedInput
    modeldataCalculations?: ModelDataCalculationsUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isRoot?: BoolFieldUpdateOperationsInput | boolean
    isModelRoot?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    accountTypeTag?: EnumAccountTypeTagFieldUpdateOperationsInput | $Enums.AccountTypeTag
    group?: EnumYesNoFieldUpdateOperationsInput | $Enums.YesNo
    plannedBy?: NullableEnumActPlanByFieldUpdateOperationsInput | $Enums.ActPlanBy | null
    actualsBy?: NullableEnumActActualsByFieldUpdateOperationsInput | $Enums.ActActualsBy | null
    displayAs?: EnumActDisplayAsFieldUpdateOperationsInput | $Enums.ActDisplayAs
    containsSalaryInfo?: EnumYesNoFieldUpdateOperationsInput | $Enums.YesNo
    description?: NullableStringFieldUpdateOperationsInput | string | null
    instanceId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    childAccounts?: AccountUncheckedUpdateManyWithoutParentNestedInput
    AttributeAndValues?: AccountAttributeAndValueUncheckedUpdateManyWithoutAccountNestedInput
    modelAccounts?: ModelAccountStructureUncheckedUpdateManyWithoutAccountNestedInput
    modelData?: ModelDataUncheckedUpdateManyWithoutAccountNestedInput
    modeldataCalculations?: ModelDataCalculationsUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type AccountCreateManyInput = {
    id?: string
    code: string
    name: string
    isRoot?: boolean
    isModelRoot?: boolean
    accountType: $Enums.AccountType
    accountTypeTag: $Enums.AccountTypeTag
    group?: $Enums.YesNo
    plannedBy?: $Enums.ActPlanBy | null
    actualsBy?: $Enums.ActActualsBy | null
    displayAs?: $Enums.ActDisplayAs
    containsSalaryInfo?: $Enums.YesNo
    description?: string | null
    instanceId: string
    clientId: string
    parentId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type AccountUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isRoot?: BoolFieldUpdateOperationsInput | boolean
    isModelRoot?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    accountTypeTag?: EnumAccountTypeTagFieldUpdateOperationsInput | $Enums.AccountTypeTag
    group?: EnumYesNoFieldUpdateOperationsInput | $Enums.YesNo
    plannedBy?: NullableEnumActPlanByFieldUpdateOperationsInput | $Enums.ActPlanBy | null
    actualsBy?: NullableEnumActActualsByFieldUpdateOperationsInput | $Enums.ActActualsBy | null
    displayAs?: EnumActDisplayAsFieldUpdateOperationsInput | $Enums.ActDisplayAs
    containsSalaryInfo?: EnumYesNoFieldUpdateOperationsInput | $Enums.YesNo
    description?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AccountUncheckedUpdateManyInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isRoot?: BoolFieldUpdateOperationsInput | boolean
    isModelRoot?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    accountTypeTag?: EnumAccountTypeTagFieldUpdateOperationsInput | $Enums.AccountTypeTag
    group?: EnumYesNoFieldUpdateOperationsInput | $Enums.YesNo
    plannedBy?: NullableEnumActPlanByFieldUpdateOperationsInput | $Enums.ActPlanBy | null
    actualsBy?: NullableEnumActActualsByFieldUpdateOperationsInput | $Enums.ActActualsBy | null
    displayAs?: EnumActDisplayAsFieldUpdateOperationsInput | $Enums.ActDisplayAs
    containsSalaryInfo?: EnumYesNoFieldUpdateOperationsInput | $Enums.YesNo
    description?: NullableStringFieldUpdateOperationsInput | string | null
    instanceId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DimensionCreateInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    dimensionValueDefault?: string | null
    clientId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    instance: InstanceCreateNestedOneWithoutDimensionsInput
    dimensionValues?: DimensionValueCreateNestedManyWithoutDimensionInput
  }

  export type DimensionUncheckedCreateInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    dimensionValueDefault?: string | null
    clientId: string
    instanceId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    dimensionValues?: DimensionValueUncheckedCreateNestedManyWithoutDimensionInput
  }

  export type DimensionUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dimensionValueDefault?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instance?: InstanceUpdateOneRequiredWithoutDimensionsNestedInput
    dimensionValues?: DimensionValueUpdateManyWithoutDimensionNestedInput
  }

  export type DimensionUncheckedUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dimensionValueDefault?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dimensionValues?: DimensionValueUncheckedUpdateManyWithoutDimensionNestedInput
  }

  export type DimensionCreateManyInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    dimensionValueDefault?: string | null
    clientId: string
    instanceId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type DimensionUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dimensionValueDefault?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DimensionUncheckedUpdateManyInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dimensionValueDefault?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DimensionValueCreateInput = {
    id?: string
    code: string
    name: string
    clientId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    parent?: DimensionValueCreateNestedOneWithoutChildDimensionValuesInput
    childDimensionValues?: DimensionValueCreateNestedManyWithoutParentInput
    AttributeAndValues?: DimensionValueAttributeAndValueCreateNestedManyWithoutDimensionValueInput
    instance: InstanceCreateNestedOneWithoutDimensionValuesInput
    dimension: DimensionCreateNestedOneWithoutDimensionValuesInput
  }

  export type DimensionValueUncheckedCreateInput = {
    id?: string
    code: string
    name: string
    parentId?: string | null
    clientId: string
    instanceId: string
    dimensionId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    childDimensionValues?: DimensionValueUncheckedCreateNestedManyWithoutParentInput
    AttributeAndValues?: DimensionValueAttributeAndValueUncheckedCreateNestedManyWithoutDimensionValueInput
  }

  export type DimensionValueUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parent?: DimensionValueUpdateOneWithoutChildDimensionValuesNestedInput
    childDimensionValues?: DimensionValueUpdateManyWithoutParentNestedInput
    AttributeAndValues?: DimensionValueAttributeAndValueUpdateManyWithoutDimensionValueNestedInput
    instance?: InstanceUpdateOneRequiredWithoutDimensionValuesNestedInput
    dimension?: DimensionUpdateOneRequiredWithoutDimensionValuesNestedInput
  }

  export type DimensionValueUncheckedUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    dimensionId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    childDimensionValues?: DimensionValueUncheckedUpdateManyWithoutParentNestedInput
    AttributeAndValues?: DimensionValueAttributeAndValueUncheckedUpdateManyWithoutDimensionValueNestedInput
  }

  export type DimensionValueCreateManyInput = {
    id?: string
    code: string
    name: string
    parentId?: string | null
    clientId: string
    instanceId: string
    dimensionId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type DimensionValueUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DimensionValueUncheckedUpdateManyInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    dimensionId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DimensionValueAttributeCreateInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    clientId: string
    updatedAt?: Date | string | null
    createdAt?: Date | string | null
    instance: InstanceCreateNestedOneWithoutDimensionValueAttributesInput
    AttributeValues?: DimensionValueAttributeValueCreateNestedManyWithoutDimensionValueAttributeInput
    AttributeAndValues?: DimensionValueAttributeAndValueCreateNestedManyWithoutAttributeInput
  }

  export type DimensionValueAttributeUncheckedCreateInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    clientId: string
    instanceId: string
    updatedAt?: Date | string | null
    createdAt?: Date | string | null
    AttributeValues?: DimensionValueAttributeValueUncheckedCreateNestedManyWithoutDimensionValueAttributeInput
    AttributeAndValues?: DimensionValueAttributeAndValueUncheckedCreateNestedManyWithoutAttributeInput
  }

  export type DimensionValueAttributeUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instance?: InstanceUpdateOneRequiredWithoutDimensionValueAttributesNestedInput
    AttributeValues?: DimensionValueAttributeValueUpdateManyWithoutDimensionValueAttributeNestedInput
    AttributeAndValues?: DimensionValueAttributeAndValueUpdateManyWithoutAttributeNestedInput
  }

  export type DimensionValueAttributeUncheckedUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    AttributeValues?: DimensionValueAttributeValueUncheckedUpdateManyWithoutDimensionValueAttributeNestedInput
    AttributeAndValues?: DimensionValueAttributeAndValueUncheckedUpdateManyWithoutAttributeNestedInput
  }

  export type DimensionValueAttributeCreateManyInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    clientId: string
    instanceId: string
    updatedAt?: Date | string | null
    createdAt?: Date | string | null
  }

  export type DimensionValueAttributeUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DimensionValueAttributeUncheckedUpdateManyInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DimensionValueAttributeValueCreateInput = {
    id?: string
    code: string
    name: string
    clientId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    instance: InstanceCreateNestedOneWithoutDimensionValueAttributeValuesInput
    parent?: DimensionValueAttributeValueCreateNestedOneWithoutChildAttributeValuesInput
    childAttributeValues?: DimensionValueAttributeValueCreateNestedManyWithoutParentInput
    dimensionValueAttribute: DimensionValueAttributeCreateNestedOneWithoutAttributeValuesInput
    dimensionAttributeAndValues?: DimensionValueAttributeAndValueCreateNestedManyWithoutAttributeValueInput
  }

  export type DimensionValueAttributeValueUncheckedCreateInput = {
    id?: string
    code: string
    name: string
    attributeId: string
    clientId: string
    parentId?: string | null
    instanceId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    childAttributeValues?: DimensionValueAttributeValueUncheckedCreateNestedManyWithoutParentInput
    dimensionAttributeAndValues?: DimensionValueAttributeAndValueUncheckedCreateNestedManyWithoutAttributeValueInput
  }

  export type DimensionValueAttributeValueUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instance?: InstanceUpdateOneRequiredWithoutDimensionValueAttributeValuesNestedInput
    parent?: DimensionValueAttributeValueUpdateOneWithoutChildAttributeValuesNestedInput
    childAttributeValues?: DimensionValueAttributeValueUpdateManyWithoutParentNestedInput
    dimensionValueAttribute?: DimensionValueAttributeUpdateOneRequiredWithoutAttributeValuesNestedInput
    dimensionAttributeAndValues?: DimensionValueAttributeAndValueUpdateManyWithoutAttributeValueNestedInput
  }

  export type DimensionValueAttributeValueUncheckedUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    attributeId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    instanceId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    childAttributeValues?: DimensionValueAttributeValueUncheckedUpdateManyWithoutParentNestedInput
    dimensionAttributeAndValues?: DimensionValueAttributeAndValueUncheckedUpdateManyWithoutAttributeValueNestedInput
  }

  export type DimensionValueAttributeValueCreateManyInput = {
    id?: string
    code: string
    name: string
    attributeId: string
    clientId: string
    parentId?: string | null
    instanceId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type DimensionValueAttributeValueUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DimensionValueAttributeValueUncheckedUpdateManyInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    attributeId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    instanceId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DimensionValueAttributeAndValueCreateInput = {
    id?: string
    clientId: string
    instanceId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    dimensionValue?: DimensionValueCreateNestedOneWithoutAttributeAndValuesInput
    attribute?: DimensionValueAttributeCreateNestedOneWithoutAttributeAndValuesInput
    attributeValue?: DimensionValueAttributeValueCreateNestedOneWithoutDimensionAttributeAndValuesInput
  }

  export type DimensionValueAttributeAndValueUncheckedCreateInput = {
    id?: string
    clientId: string
    instanceId: string
    attributeId: string
    attributeValueId: string
    dimensionValueId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type DimensionValueAttributeAndValueUpdateInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dimensionValue?: DimensionValueUpdateOneWithoutAttributeAndValuesNestedInput
    attribute?: DimensionValueAttributeUpdateOneWithoutAttributeAndValuesNestedInput
    attributeValue?: DimensionValueAttributeValueUpdateOneWithoutDimensionAttributeAndValuesNestedInput
  }

  export type DimensionValueAttributeAndValueUncheckedUpdateInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    attributeId?: StringFieldUpdateOperationsInput | string
    attributeValueId?: StringFieldUpdateOperationsInput | string
    dimensionValueId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DimensionValueAttributeAndValueCreateManyInput = {
    id?: string
    clientId: string
    instanceId: string
    attributeId: string
    attributeValueId: string
    dimensionValueId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type DimensionValueAttributeAndValueUpdateManyMutationInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DimensionValueAttributeAndValueUncheckedUpdateManyInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    attributeId?: StringFieldUpdateOperationsInput | string
    attributeValueId?: StringFieldUpdateOperationsInput | string
    dimensionValueId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ModelCreateInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    dimensionality?: ModelCreatedimensionalityInput | string[]
    status?: $Enums.ModelStatus
    isDefault?: boolean
    clientId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    rootAccountId: string
    instance: InstanceCreateNestedOneWithoutModelsInput
    modelData?: ModelDataCreateNestedManyWithoutModelInput
    modelAccounts?: ModelAccountStructureCreateNestedManyWithoutModelInput
    modelDataCalculations?: ModelDataCalculationsCreateNestedManyWithoutModelInput
  }

  export type ModelUncheckedCreateInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    dimensionality?: ModelCreatedimensionalityInput | string[]
    status?: $Enums.ModelStatus
    isDefault?: boolean
    instanceId: string
    clientId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    rootAccountId: string
    modelData?: ModelDataUncheckedCreateNestedManyWithoutModelInput
    modelAccounts?: ModelAccountStructureUncheckedCreateNestedManyWithoutModelInput
    modelDataCalculations?: ModelDataCalculationsUncheckedCreateNestedManyWithoutModelInput
  }

  export type ModelUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dimensionality?: ModelUpdatedimensionalityInput | string[]
    status?: EnumModelStatusFieldUpdateOperationsInput | $Enums.ModelStatus
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rootAccountId?: StringFieldUpdateOperationsInput | string
    instance?: InstanceUpdateOneRequiredWithoutModelsNestedInput
    modelData?: ModelDataUpdateManyWithoutModelNestedInput
    modelAccounts?: ModelAccountStructureUpdateManyWithoutModelNestedInput
    modelDataCalculations?: ModelDataCalculationsUpdateManyWithoutModelNestedInput
  }

  export type ModelUncheckedUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dimensionality?: ModelUpdatedimensionalityInput | string[]
    status?: EnumModelStatusFieldUpdateOperationsInput | $Enums.ModelStatus
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    instanceId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rootAccountId?: StringFieldUpdateOperationsInput | string
    modelData?: ModelDataUncheckedUpdateManyWithoutModelNestedInput
    modelAccounts?: ModelAccountStructureUncheckedUpdateManyWithoutModelNestedInput
    modelDataCalculations?: ModelDataCalculationsUncheckedUpdateManyWithoutModelNestedInput
  }

  export type ModelCreateManyInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    dimensionality?: ModelCreatedimensionalityInput | string[]
    status?: $Enums.ModelStatus
    isDefault?: boolean
    instanceId: string
    clientId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    rootAccountId: string
  }

  export type ModelUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dimensionality?: ModelUpdatedimensionalityInput | string[]
    status?: EnumModelStatusFieldUpdateOperationsInput | $Enums.ModelStatus
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rootAccountId?: StringFieldUpdateOperationsInput | string
  }

  export type ModelUncheckedUpdateManyInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dimensionality?: ModelUpdatedimensionalityInput | string[]
    status?: EnumModelStatusFieldUpdateOperationsInput | $Enums.ModelStatus
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    instanceId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rootAccountId?: StringFieldUpdateOperationsInput | string
  }

  export type ModelAccountStructureCreateInput = {
    id?: string
    isRoot?: boolean
    clientId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    instance: InstanceCreateNestedOneWithoutModelAccountsInput
    model: ModelCreateNestedOneWithoutModelAccountsInput
    account: AccountCreateNestedOneWithoutModelAccountsInput
    modeldataCalculations?: ModelDataCalculationsCreateNestedManyWithoutModelAccountInput
    parentAccount?: ModelAccountStructureCreateNestedOneWithoutChildAccountsInput
    childAccounts?: ModelAccountStructureCreateNestedManyWithoutParentAccountInput
  }

  export type ModelAccountStructureUncheckedCreateInput = {
    id?: string
    instanceId: string
    isRoot?: boolean
    clientId: string
    parentId?: string | null
    modelId: string
    accountId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    modeldataCalculations?: ModelDataCalculationsUncheckedCreateNestedManyWithoutModelAccountInput
    childAccounts?: ModelAccountStructureUncheckedCreateNestedManyWithoutParentAccountInput
  }

  export type ModelAccountStructureUpdateInput = {
    isRoot?: BoolFieldUpdateOperationsInput | boolean
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instance?: InstanceUpdateOneRequiredWithoutModelAccountsNestedInput
    model?: ModelUpdateOneRequiredWithoutModelAccountsNestedInput
    account?: AccountUpdateOneRequiredWithoutModelAccountsNestedInput
    modeldataCalculations?: ModelDataCalculationsUpdateManyWithoutModelAccountNestedInput
    parentAccount?: ModelAccountStructureUpdateOneWithoutChildAccountsNestedInput
    childAccounts?: ModelAccountStructureUpdateManyWithoutParentAccountNestedInput
  }

  export type ModelAccountStructureUncheckedUpdateInput = {
    instanceId?: StringFieldUpdateOperationsInput | string
    isRoot?: BoolFieldUpdateOperationsInput | boolean
    clientId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    modelId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modeldataCalculations?: ModelDataCalculationsUncheckedUpdateManyWithoutModelAccountNestedInput
    childAccounts?: ModelAccountStructureUncheckedUpdateManyWithoutParentAccountNestedInput
  }

  export type ModelAccountStructureCreateManyInput = {
    id?: string
    instanceId: string
    isRoot?: boolean
    clientId: string
    parentId?: string | null
    modelId: string
    accountId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ModelAccountStructureUpdateManyMutationInput = {
    isRoot?: BoolFieldUpdateOperationsInput | boolean
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ModelAccountStructureUncheckedUpdateManyInput = {
    instanceId?: StringFieldUpdateOperationsInput | string
    isRoot?: BoolFieldUpdateOperationsInput | boolean
    clientId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    modelId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ModelDataCreateInput = {
    id?: string
    clientId: string
    dimensionality?: XOR<ModelDataDimensionalityListCreateEnvelopeInput, ModelDataDimensionalityCreateInput> | ModelDataDimensionalityCreateInput[]
    timespan: InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    model: ModelCreateNestedOneWithoutModelDataInput
    level: LevelCreateNestedOneWithoutModelDataInput
    account: AccountCreateNestedOneWithoutModelDataInput
    version: VersionCreateNestedOneWithoutModelDataInput
    instance: InstanceCreateNestedOneWithoutModelDataInput
  }

  export type ModelDataUncheckedCreateInput = {
    id?: string
    clientId: string
    instanceId: string
    modelId: string
    versionId: string
    levelId: string
    accountId: string
    dimensionality?: XOR<ModelDataDimensionalityListCreateEnvelopeInput, ModelDataDimensionalityCreateInput> | ModelDataDimensionalityCreateInput[]
    timespan: InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ModelDataUpdateInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    dimensionality?: XOR<ModelDataDimensionalityListUpdateEnvelopeInput, ModelDataDimensionalityCreateInput> | ModelDataDimensionalityCreateInput[]
    timespan?: InputJsonValue | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    model?: ModelUpdateOneRequiredWithoutModelDataNestedInput
    level?: LevelUpdateOneRequiredWithoutModelDataNestedInput
    account?: AccountUpdateOneRequiredWithoutModelDataNestedInput
    version?: VersionUpdateOneRequiredWithoutModelDataNestedInput
    instance?: InstanceUpdateOneRequiredWithoutModelDataNestedInput
  }

  export type ModelDataUncheckedUpdateInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    modelId?: StringFieldUpdateOperationsInput | string
    versionId?: StringFieldUpdateOperationsInput | string
    levelId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    dimensionality?: XOR<ModelDataDimensionalityListUpdateEnvelopeInput, ModelDataDimensionalityCreateInput> | ModelDataDimensionalityCreateInput[]
    timespan?: InputJsonValue | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ModelDataCreateManyInput = {
    id?: string
    clientId: string
    instanceId: string
    modelId: string
    versionId: string
    levelId: string
    accountId: string
    dimensionality?: XOR<ModelDataDimensionalityListCreateEnvelopeInput, ModelDataDimensionalityCreateInput> | ModelDataDimensionalityCreateInput[]
    timespan: InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ModelDataUpdateManyMutationInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    dimensionality?: XOR<ModelDataDimensionalityListUpdateEnvelopeInput, ModelDataDimensionalityCreateInput> | ModelDataDimensionalityCreateInput[]
    timespan?: InputJsonValue | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ModelDataUncheckedUpdateManyInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    modelId?: StringFieldUpdateOperationsInput | string
    versionId?: StringFieldUpdateOperationsInput | string
    levelId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    dimensionality?: XOR<ModelDataDimensionalityListUpdateEnvelopeInput, ModelDataDimensionalityCreateInput> | ModelDataDimensionalityCreateInput[]
    timespan?: InputJsonValue | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ModelDataCalculationsCreateInput = {
    id?: string
    clientId: string
    calculations: InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    model: ModelCreateNestedOneWithoutModelDataCalculationsInput
    level: LevelCreateNestedOneWithoutModeldataCalculationsInput
    account: AccountCreateNestedOneWithoutModeldataCalculationsInput
    version: VersionCreateNestedOneWithoutModelDataCalculationsInput
    instance: InstanceCreateNestedOneWithoutModelDataCalculationsInput
    modelAccount: ModelAccountStructureCreateNestedOneWithoutModeldataCalculationsInput
  }

  export type ModelDataCalculationsUncheckedCreateInput = {
    id?: string
    clientId: string
    instanceId: string
    modelId: string
    versionId: string
    levelId: string
    accountId: string
    modelAccountId: string
    calculations: InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ModelDataCalculationsUpdateInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    calculations?: InputJsonValue | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    model?: ModelUpdateOneRequiredWithoutModelDataCalculationsNestedInput
    level?: LevelUpdateOneRequiredWithoutModeldataCalculationsNestedInput
    account?: AccountUpdateOneRequiredWithoutModeldataCalculationsNestedInput
    version?: VersionUpdateOneRequiredWithoutModelDataCalculationsNestedInput
    instance?: InstanceUpdateOneRequiredWithoutModelDataCalculationsNestedInput
    modelAccount?: ModelAccountStructureUpdateOneRequiredWithoutModeldataCalculationsNestedInput
  }

  export type ModelDataCalculationsUncheckedUpdateInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    modelId?: StringFieldUpdateOperationsInput | string
    versionId?: StringFieldUpdateOperationsInput | string
    levelId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    modelAccountId?: StringFieldUpdateOperationsInput | string
    calculations?: InputJsonValue | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ModelDataCalculationsCreateManyInput = {
    id?: string
    clientId: string
    instanceId: string
    modelId: string
    versionId: string
    levelId: string
    accountId: string
    modelAccountId: string
    calculations: InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ModelDataCalculationsUpdateManyMutationInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    calculations?: InputJsonValue | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ModelDataCalculationsUncheckedUpdateManyInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    modelId?: StringFieldUpdateOperationsInput | string
    versionId?: StringFieldUpdateOperationsInput | string
    levelId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    modelAccountId?: StringFieldUpdateOperationsInput | string
    calculations?: InputJsonValue | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TableCreateInput = {
    id?: string
    clientId: string
    name: string
    code: string
    description?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    status: $Enums.ModelStatus
    columnDefinitions?: XOR<TableColumnDefinitionListCreateEnvelopeInput, TableColumnDefinitionCreateInput> | TableColumnDefinitionCreateInput[]
    instance: InstanceCreateNestedOneWithoutTablesInput
    tableData?: TableDataCreateNestedManyWithoutTableInput
  }

  export type TableUncheckedCreateInput = {
    id?: string
    clientId: string
    instanceId: string
    name: string
    code: string
    description?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    status: $Enums.ModelStatus
    columnDefinitions?: XOR<TableColumnDefinitionListCreateEnvelopeInput, TableColumnDefinitionCreateInput> | TableColumnDefinitionCreateInput[]
    tableData?: TableDataUncheckedCreateNestedManyWithoutTableInput
  }

  export type TableUpdateInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumModelStatusFieldUpdateOperationsInput | $Enums.ModelStatus
    columnDefinitions?: XOR<TableColumnDefinitionListUpdateEnvelopeInput, TableColumnDefinitionCreateInput> | TableColumnDefinitionCreateInput[]
    instance?: InstanceUpdateOneRequiredWithoutTablesNestedInput
    tableData?: TableDataUpdateManyWithoutTableNestedInput
  }

  export type TableUncheckedUpdateInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumModelStatusFieldUpdateOperationsInput | $Enums.ModelStatus
    columnDefinitions?: XOR<TableColumnDefinitionListUpdateEnvelopeInput, TableColumnDefinitionCreateInput> | TableColumnDefinitionCreateInput[]
    tableData?: TableDataUncheckedUpdateManyWithoutTableNestedInput
  }

  export type TableCreateManyInput = {
    id?: string
    clientId: string
    instanceId: string
    name: string
    code: string
    description?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    status: $Enums.ModelStatus
    columnDefinitions?: XOR<TableColumnDefinitionListCreateEnvelopeInput, TableColumnDefinitionCreateInput> | TableColumnDefinitionCreateInput[]
  }

  export type TableUpdateManyMutationInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumModelStatusFieldUpdateOperationsInput | $Enums.ModelStatus
    columnDefinitions?: XOR<TableColumnDefinitionListUpdateEnvelopeInput, TableColumnDefinitionCreateInput> | TableColumnDefinitionCreateInput[]
  }

  export type TableUncheckedUpdateManyInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumModelStatusFieldUpdateOperationsInput | $Enums.ModelStatus
    columnDefinitions?: XOR<TableColumnDefinitionListUpdateEnvelopeInput, TableColumnDefinitionCreateInput> | TableColumnDefinitionCreateInput[]
  }

  export type TableDataCreateInput = {
    id?: string
    clientId: string
    rowKey: string
    versionId: string
    levelId: string
    data: InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    table: TableCreateNestedOneWithoutTableDataInput
    instance: InstanceCreateNestedOneWithoutTableDataInput
  }

  export type TableDataUncheckedCreateInput = {
    id?: string
    clientId: string
    instanceId: string
    tableId: string
    rowKey: string
    versionId: string
    levelId: string
    data: InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type TableDataUpdateInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    rowKey?: StringFieldUpdateOperationsInput | string
    versionId?: StringFieldUpdateOperationsInput | string
    levelId?: StringFieldUpdateOperationsInput | string
    data?: InputJsonValue | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    table?: TableUpdateOneRequiredWithoutTableDataNestedInput
    instance?: InstanceUpdateOneRequiredWithoutTableDataNestedInput
  }

  export type TableDataUncheckedUpdateInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    tableId?: StringFieldUpdateOperationsInput | string
    rowKey?: StringFieldUpdateOperationsInput | string
    versionId?: StringFieldUpdateOperationsInput | string
    levelId?: StringFieldUpdateOperationsInput | string
    data?: InputJsonValue | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TableDataCreateManyInput = {
    id?: string
    clientId: string
    instanceId: string
    tableId: string
    rowKey: string
    versionId: string
    levelId: string
    data: InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type TableDataUpdateManyMutationInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    rowKey?: StringFieldUpdateOperationsInput | string
    versionId?: StringFieldUpdateOperationsInput | string
    levelId?: StringFieldUpdateOperationsInput | string
    data?: InputJsonValue | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TableDataUncheckedUpdateManyInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    tableId?: StringFieldUpdateOperationsInput | string
    rowKey?: StringFieldUpdateOperationsInput | string
    versionId?: StringFieldUpdateOperationsInput | string
    levelId?: StringFieldUpdateOperationsInput | string
    data?: InputJsonValue | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DataSourceCreateInput = {
    id?: string
    clientId: string
    instanceId: string
    name: string
    code: string
    description?: string | null
    type: $Enums.DataSourceType
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    credential?: DataSourceCredentialCreateNestedOneWithoutDatasourcesInput
  }

  export type DataSourceUncheckedCreateInput = {
    id?: string
    clientId: string
    instanceId: string
    name: string
    code: string
    credentialId?: string | null
    description?: string | null
    type: $Enums.DataSourceType
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type DataSourceUpdateInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumDataSourceTypeFieldUpdateOperationsInput | $Enums.DataSourceType
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    credential?: DataSourceCredentialUpdateOneWithoutDatasourcesNestedInput
  }

  export type DataSourceUncheckedUpdateInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    credentialId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumDataSourceTypeFieldUpdateOperationsInput | $Enums.DataSourceType
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DataSourceCreateManyInput = {
    id?: string
    clientId: string
    instanceId: string
    name: string
    code: string
    credentialId?: string | null
    description?: string | null
    type: $Enums.DataSourceType
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type DataSourceUpdateManyMutationInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumDataSourceTypeFieldUpdateOperationsInput | $Enums.DataSourceType
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DataSourceUncheckedUpdateManyInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    credentialId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumDataSourceTypeFieldUpdateOperationsInput | $Enums.DataSourceType
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DataSourceTaskCreateInput = {
    id?: string
    clientId: string
    instanceId: string
    name: string
    code: string
    description?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type DataSourceTaskUncheckedCreateInput = {
    id?: string
    clientId: string
    instanceId: string
    name: string
    code: string
    description?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type DataSourceTaskUpdateInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DataSourceTaskUncheckedUpdateInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DataSourceTaskCreateManyInput = {
    id?: string
    clientId: string
    instanceId: string
    name: string
    code: string
    description?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type DataSourceTaskUpdateManyMutationInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DataSourceTaskUncheckedUpdateManyInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DataSourceLoaderCreateInput = {
    id?: string
    clientId: string
    instanceId: string
    name: string
    code: string
    loaderType: $Enums.DataSourceLoaderType
    sourceTable?: string | null
    planningTable?: DataSourceLoaderCreateplanningTableInput | string[]
    planningElementId: string
    planningElementType: string
    versionId: string
    createElementIfNotFound?: boolean | null
    settingsOptions?: InputJsonValue | null
    columnMappings?: InputJsonValue | null
    description?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type DataSourceLoaderUncheckedCreateInput = {
    id?: string
    clientId: string
    instanceId: string
    name: string
    code: string
    loaderType: $Enums.DataSourceLoaderType
    sourceTable?: string | null
    planningTable?: DataSourceLoaderCreateplanningTableInput | string[]
    planningElementId: string
    planningElementType: string
    versionId: string
    createElementIfNotFound?: boolean | null
    settingsOptions?: InputJsonValue | null
    columnMappings?: InputJsonValue | null
    description?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type DataSourceLoaderUpdateInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    loaderType?: EnumDataSourceLoaderTypeFieldUpdateOperationsInput | $Enums.DataSourceLoaderType
    sourceTable?: NullableStringFieldUpdateOperationsInput | string | null
    planningTable?: DataSourceLoaderUpdateplanningTableInput | string[]
    planningElementId?: StringFieldUpdateOperationsInput | string
    planningElementType?: StringFieldUpdateOperationsInput | string
    versionId?: StringFieldUpdateOperationsInput | string
    createElementIfNotFound?: NullableBoolFieldUpdateOperationsInput | boolean | null
    settingsOptions?: InputJsonValue | InputJsonValue | null
    columnMappings?: InputJsonValue | InputJsonValue | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DataSourceLoaderUncheckedUpdateInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    loaderType?: EnumDataSourceLoaderTypeFieldUpdateOperationsInput | $Enums.DataSourceLoaderType
    sourceTable?: NullableStringFieldUpdateOperationsInput | string | null
    planningTable?: DataSourceLoaderUpdateplanningTableInput | string[]
    planningElementId?: StringFieldUpdateOperationsInput | string
    planningElementType?: StringFieldUpdateOperationsInput | string
    versionId?: StringFieldUpdateOperationsInput | string
    createElementIfNotFound?: NullableBoolFieldUpdateOperationsInput | boolean | null
    settingsOptions?: InputJsonValue | InputJsonValue | null
    columnMappings?: InputJsonValue | InputJsonValue | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DataSourceLoaderCreateManyInput = {
    id?: string
    clientId: string
    instanceId: string
    name: string
    code: string
    loaderType: $Enums.DataSourceLoaderType
    sourceTable?: string | null
    planningTable?: DataSourceLoaderCreateplanningTableInput | string[]
    planningElementId: string
    planningElementType: string
    versionId: string
    createElementIfNotFound?: boolean | null
    settingsOptions?: InputJsonValue | null
    columnMappings?: InputJsonValue | null
    description?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type DataSourceLoaderUpdateManyMutationInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    loaderType?: EnumDataSourceLoaderTypeFieldUpdateOperationsInput | $Enums.DataSourceLoaderType
    sourceTable?: NullableStringFieldUpdateOperationsInput | string | null
    planningTable?: DataSourceLoaderUpdateplanningTableInput | string[]
    planningElementId?: StringFieldUpdateOperationsInput | string
    planningElementType?: StringFieldUpdateOperationsInput | string
    versionId?: StringFieldUpdateOperationsInput | string
    createElementIfNotFound?: NullableBoolFieldUpdateOperationsInput | boolean | null
    settingsOptions?: InputJsonValue | InputJsonValue | null
    columnMappings?: InputJsonValue | InputJsonValue | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DataSourceLoaderUncheckedUpdateManyInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    loaderType?: EnumDataSourceLoaderTypeFieldUpdateOperationsInput | $Enums.DataSourceLoaderType
    sourceTable?: NullableStringFieldUpdateOperationsInput | string | null
    planningTable?: DataSourceLoaderUpdateplanningTableInput | string[]
    planningElementId?: StringFieldUpdateOperationsInput | string
    planningElementType?: StringFieldUpdateOperationsInput | string
    versionId?: StringFieldUpdateOperationsInput | string
    createElementIfNotFound?: NullableBoolFieldUpdateOperationsInput | boolean | null
    settingsOptions?: InputJsonValue | InputJsonValue | null
    columnMappings?: InputJsonValue | InputJsonValue | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DataSourceCredentialCreateInput = {
    id?: string
    clientId: string
    instanceId: string
    name: string
    code: string
    description?: string | null
    type: $Enums.DatasourceCredentialAuthType
    credentialId?: string | null
    credentialKey?: string | null
    credentialSecret?: string | null
    credentialToken?: string | null
    credentialTokenSecret?: string | null
    credentialHostname?: string | null
    credentialUsername?: string | null
    fingerprint?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    datasources?: DataSourceCreateNestedManyWithoutCredentialInput
  }

  export type DataSourceCredentialUncheckedCreateInput = {
    id?: string
    clientId: string
    instanceId: string
    name: string
    code: string
    description?: string | null
    type: $Enums.DatasourceCredentialAuthType
    credentialId?: string | null
    credentialKey?: string | null
    credentialSecret?: string | null
    credentialToken?: string | null
    credentialTokenSecret?: string | null
    credentialHostname?: string | null
    credentialUsername?: string | null
    fingerprint?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    datasources?: DataSourceUncheckedCreateNestedManyWithoutCredentialInput
  }

  export type DataSourceCredentialUpdateInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumDatasourceCredentialAuthTypeFieldUpdateOperationsInput | $Enums.DatasourceCredentialAuthType
    credentialId?: NullableStringFieldUpdateOperationsInput | string | null
    credentialKey?: NullableStringFieldUpdateOperationsInput | string | null
    credentialSecret?: NullableStringFieldUpdateOperationsInput | string | null
    credentialToken?: NullableStringFieldUpdateOperationsInput | string | null
    credentialTokenSecret?: NullableStringFieldUpdateOperationsInput | string | null
    credentialHostname?: NullableStringFieldUpdateOperationsInput | string | null
    credentialUsername?: NullableStringFieldUpdateOperationsInput | string | null
    fingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    datasources?: DataSourceUpdateManyWithoutCredentialNestedInput
  }

  export type DataSourceCredentialUncheckedUpdateInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumDatasourceCredentialAuthTypeFieldUpdateOperationsInput | $Enums.DatasourceCredentialAuthType
    credentialId?: NullableStringFieldUpdateOperationsInput | string | null
    credentialKey?: NullableStringFieldUpdateOperationsInput | string | null
    credentialSecret?: NullableStringFieldUpdateOperationsInput | string | null
    credentialToken?: NullableStringFieldUpdateOperationsInput | string | null
    credentialTokenSecret?: NullableStringFieldUpdateOperationsInput | string | null
    credentialHostname?: NullableStringFieldUpdateOperationsInput | string | null
    credentialUsername?: NullableStringFieldUpdateOperationsInput | string | null
    fingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    datasources?: DataSourceUncheckedUpdateManyWithoutCredentialNestedInput
  }

  export type DataSourceCredentialCreateManyInput = {
    id?: string
    clientId: string
    instanceId: string
    name: string
    code: string
    description?: string | null
    type: $Enums.DatasourceCredentialAuthType
    credentialId?: string | null
    credentialKey?: string | null
    credentialSecret?: string | null
    credentialToken?: string | null
    credentialTokenSecret?: string | null
    credentialHostname?: string | null
    credentialUsername?: string | null
    fingerprint?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type DataSourceCredentialUpdateManyMutationInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumDatasourceCredentialAuthTypeFieldUpdateOperationsInput | $Enums.DatasourceCredentialAuthType
    credentialId?: NullableStringFieldUpdateOperationsInput | string | null
    credentialKey?: NullableStringFieldUpdateOperationsInput | string | null
    credentialSecret?: NullableStringFieldUpdateOperationsInput | string | null
    credentialToken?: NullableStringFieldUpdateOperationsInput | string | null
    credentialTokenSecret?: NullableStringFieldUpdateOperationsInput | string | null
    credentialHostname?: NullableStringFieldUpdateOperationsInput | string | null
    credentialUsername?: NullableStringFieldUpdateOperationsInput | string | null
    fingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DataSourceCredentialUncheckedUpdateManyInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumDatasourceCredentialAuthTypeFieldUpdateOperationsInput | $Enums.DatasourceCredentialAuthType
    credentialId?: NullableStringFieldUpdateOperationsInput | string | null
    credentialKey?: NullableStringFieldUpdateOperationsInput | string | null
    credentialSecret?: NullableStringFieldUpdateOperationsInput | string | null
    credentialToken?: NullableStringFieldUpdateOperationsInput | string | null
    credentialTokenSecret?: NullableStringFieldUpdateOperationsInput | string | null
    credentialHostname?: NullableStringFieldUpdateOperationsInput | string | null
    credentialUsername?: NullableStringFieldUpdateOperationsInput | string | null
    fingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
    isSet?: boolean
  }

  export type CurrencyIsoCodeScalarRelationFilter = {
    is?: CurrencyIsoCodeWhereInput
    isNot?: CurrencyIsoCodeWhereInput
  }

  export type CurrencyScalarRelationFilter = {
    is?: CurrencyWhereInput
    isNot?: CurrencyWhereInput
  }

  export type ConfigCountOrderByAggregateInput = {
    id?: SortOrder
    defaultIsoCurrencyId?: SortOrder
    defaultCurrencyId?: SortOrder
    defaultTopLevelName?: SortOrder
    defaultTopLevelDescription?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConfigMaxOrderByAggregateInput = {
    id?: SortOrder
    defaultIsoCurrencyId?: SortOrder
    defaultCurrencyId?: SortOrder
    defaultTopLevelName?: SortOrder
    defaultTopLevelDescription?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConfigMinOrderByAggregateInput = {
    id?: SortOrder
    defaultIsoCurrencyId?: SortOrder
    defaultCurrencyId?: SortOrder
    defaultTopLevelName?: SortOrder
    defaultTopLevelDescription?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type ClientListRelationFilter = {
    every?: ClientWhereInput
    some?: ClientWhereInput
    none?: ClientWhereInput
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type ClientOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CountryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    iso_3166_2_code?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CountryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    iso_3166_2_code?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CountryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    iso_3166_2_code?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumuserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.userRole | EnumuserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.userRole[] | ListEnumuserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.userRole[] | ListEnumuserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumuserRoleFilter<$PrismaModel> | $Enums.userRole
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
    isSet?: boolean
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type CountryNullableScalarRelationFilter = {
    is?: CountryWhereInput | null
    isNot?: CountryWhereInput | null
  }

  export type ClientScalarRelationFilter = {
    is?: ClientWhereInput
    isNot?: ClientWhereInput
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    authProviderId?: SortOrder
    role?: SortOrder
    countryId?: SortOrder
    permissions?: SortOrder
    clientId?: SortOrder
    defaultInstance?: SortOrder
    selectedInstance?: SortOrder
    lastLogin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    authProviderId?: SortOrder
    role?: SortOrder
    countryId?: SortOrder
    clientId?: SortOrder
    defaultInstance?: SortOrder
    selectedInstance?: SortOrder
    lastLogin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    authProviderId?: SortOrder
    role?: SortOrder
    countryId?: SortOrder
    clientId?: SortOrder
    defaultInstance?: SortOrder
    selectedInstance?: SortOrder
    lastLogin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumuserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.userRole | EnumuserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.userRole[] | ListEnumuserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.userRole[] | ListEnumuserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumuserRoleWithAggregatesFilter<$PrismaModel> | $Enums.userRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumuserRoleFilter<$PrismaModel>
    _max?: NestedEnumuserRoleFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumclientStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.clientStatus | EnumclientStatusFieldRefInput<$PrismaModel>
    in?: $Enums.clientStatus[] | ListEnumclientStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.clientStatus[] | ListEnumclientStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumclientStatusFilter<$PrismaModel> | $Enums.clientStatus
  }

  export type AddressTypeNullableCompositeFilter = {
    equals?: addressTypeObjectEqualityInput | null
    is?: addressTypeWhereInput | null
    isNot?: addressTypeWhereInput | null
    isSet?: boolean
  }

  export type addressTypeObjectEqualityInput = {
    address1?: string | null
    address2?: string | null
    city?: string | null
    state?: string | null
  }

  export type InstanceListRelationFilter = {
    every?: InstanceWhereInput
    some?: InstanceWhereInput
    none?: InstanceWhereInput
  }

  export type PermissionListRelationFilter = {
    every?: PermissionWhereInput
    some?: PermissionWhereInput
    none?: PermissionWhereInput
  }

  export type addressTypeOrderByInput = {
    address1?: SortOrder
    address2?: SortOrder
    city?: SortOrder
    state?: SortOrder
  }

  export type InstanceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PermissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClientCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    status?: SortOrder
    countryId?: SortOrder
    contactId?: SortOrder
    lastLogin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    status?: SortOrder
    countryId?: SortOrder
    contactId?: SortOrder
    lastLogin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    status?: SortOrder
    countryId?: SortOrder
    contactId?: SortOrder
    lastLogin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumclientStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.clientStatus | EnumclientStatusFieldRefInput<$PrismaModel>
    in?: $Enums.clientStatus[] | ListEnumclientStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.clientStatus[] | ListEnumclientStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumclientStatusWithAggregatesFilter<$PrismaModel> | $Enums.clientStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumclientStatusFilter<$PrismaModel>
    _max?: NestedEnumclientStatusFilter<$PrismaModel>
  }

  export type PermissionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    clientId?: SortOrder
    actions?: SortOrder
    subjects?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PermissionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    clientId?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PermissionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    clientId?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnuminstanceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.instanceStatus | EnuminstanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.instanceStatus[] | ListEnuminstanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.instanceStatus[] | ListEnuminstanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnuminstanceStatusFilter<$PrismaModel> | $Enums.instanceStatus
  }

  export type LevelListRelationFilter = {
    every?: LevelWhereInput
    some?: LevelWhereInput
    none?: LevelWhereInput
  }

  export type VersionListRelationFilter = {
    every?: VersionWhereInput
    some?: VersionWhereInput
    none?: VersionWhereInput
  }

  export type CurrencyListRelationFilter = {
    every?: CurrencyWhereInput
    some?: CurrencyWhereInput
    none?: CurrencyWhereInput
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type ModelListRelationFilter = {
    every?: ModelWhereInput
    some?: ModelWhereInput
    none?: ModelWhereInput
  }

  export type DimensionListRelationFilter = {
    every?: DimensionWhereInput
    some?: DimensionWhereInput
    none?: DimensionWhereInput
  }

  export type DimensionValueListRelationFilter = {
    every?: DimensionValueWhereInput
    some?: DimensionValueWhereInput
    none?: DimensionValueWhereInput
  }

  export type LevelAttributeListRelationFilter = {
    every?: LevelAttributeWhereInput
    some?: LevelAttributeWhereInput
    none?: LevelAttributeWhereInput
  }

  export type DimensionValueAttributeListRelationFilter = {
    every?: DimensionValueAttributeWhereInput
    some?: DimensionValueAttributeWhereInput
    none?: DimensionValueAttributeWhereInput
  }

  export type AccountAttributeListRelationFilter = {
    every?: AccountAttributeWhereInput
    some?: AccountAttributeWhereInput
    none?: AccountAttributeWhereInput
  }

  export type LevelAttributeValueListRelationFilter = {
    every?: LevelAttributeValueWhereInput
    some?: LevelAttributeValueWhereInput
    none?: LevelAttributeValueWhereInput
  }

  export type AccountAttributeValueListRelationFilter = {
    every?: AccountAttributeValueWhereInput
    some?: AccountAttributeValueWhereInput
    none?: AccountAttributeValueWhereInput
  }

  export type DimensionValueAttributeValueListRelationFilter = {
    every?: DimensionValueAttributeValueWhereInput
    some?: DimensionValueAttributeValueWhereInput
    none?: DimensionValueAttributeValueWhereInput
  }

  export type ModelDataListRelationFilter = {
    every?: ModelDataWhereInput
    some?: ModelDataWhereInput
    none?: ModelDataWhereInput
  }

  export type ModelDataCalculationsListRelationFilter = {
    every?: ModelDataCalculationsWhereInput
    some?: ModelDataCalculationsWhereInput
    none?: ModelDataCalculationsWhereInput
  }

  export type ModelAccountStructureListRelationFilter = {
    every?: ModelAccountStructureWhereInput
    some?: ModelAccountStructureWhereInput
    none?: ModelAccountStructureWhereInput
  }

  export type TableListRelationFilter = {
    every?: TableWhereInput
    some?: TableWhereInput
    none?: TableWhereInput
  }

  export type TableDataListRelationFilter = {
    every?: TableDataWhereInput
    some?: TableDataWhereInput
    none?: TableDataWhereInput
  }

  export type LevelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VersionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CurrencyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ModelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DimensionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DimensionValueOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LevelAttributeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DimensionValueAttributeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccountAttributeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LevelAttributeValueOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccountAttributeValueOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DimensionValueAttributeValueOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ModelDataOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ModelDataCalculationsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ModelAccountStructureOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TableOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TableDataOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InstanceClientIdCodeCompoundUniqueInput = {
    clientId: string
    code: string
  }

  export type InstanceCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    clientId?: SortOrder
    description?: SortOrder
    status?: SortOrder
    userIds?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InstanceMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    clientId?: SortOrder
    description?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InstanceMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    clientId?: SortOrder
    description?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnuminstanceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.instanceStatus | EnuminstanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.instanceStatus[] | ListEnuminstanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.instanceStatus[] | ListEnuminstanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnuminstanceStatusWithAggregatesFilter<$PrismaModel> | $Enums.instanceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnuminstanceStatusFilter<$PrismaModel>
    _max?: NestedEnuminstanceStatusFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type EnumversionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.versionStatus | EnumversionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.versionStatus[] | ListEnumversionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.versionStatus[] | ListEnumversionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumversionStatusFilter<$PrismaModel> | $Enums.versionStatus
  }

  export type InstanceScalarRelationFilter = {
    is?: InstanceWhereInput
    isNot?: InstanceWhereInput
  }

  export type VersionClientIdCodeInstanceIdCompoundUniqueInput = {
    clientId: string
    code: string
    instanceId: string
  }

  export type VersionCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    begin?: SortOrder
    end?: SortOrder
    startOfPlan?: SortOrder
    description?: SortOrder
    isDefault?: SortOrder
    isActuals?: SortOrder
    status?: SortOrder
    clientId?: SortOrder
    instanceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VersionMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    begin?: SortOrder
    end?: SortOrder
    startOfPlan?: SortOrder
    description?: SortOrder
    isDefault?: SortOrder
    isActuals?: SortOrder
    status?: SortOrder
    clientId?: SortOrder
    instanceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VersionMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    begin?: SortOrder
    end?: SortOrder
    startOfPlan?: SortOrder
    description?: SortOrder
    isDefault?: SortOrder
    isActuals?: SortOrder
    status?: SortOrder
    clientId?: SortOrder
    instanceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumversionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.versionStatus | EnumversionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.versionStatus[] | ListEnumversionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.versionStatus[] | ListEnumversionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumversionStatusWithAggregatesFilter<$PrismaModel> | $Enums.versionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumversionStatusFilter<$PrismaModel>
    _max?: NestedEnumversionStatusFilter<$PrismaModel>
  }

  export type ConfigListRelationFilter = {
    every?: ConfigWhereInput
    some?: ConfigWhereInput
    none?: ConfigWhereInput
  }

  export type ConfigOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CurrencyIsoCodeCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CurrencyIsoCodeMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CurrencyIsoCodeMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type EnumYesNoFilter<$PrismaModel = never> = {
    equals?: $Enums.YesNo | EnumYesNoFieldRefInput<$PrismaModel>
    in?: $Enums.YesNo[] | ListEnumYesNoFieldRefInput<$PrismaModel>
    notIn?: $Enums.YesNo[] | ListEnumYesNoFieldRefInput<$PrismaModel>
    not?: NestedEnumYesNoFilter<$PrismaModel> | $Enums.YesNo
  }

  export type CurrencyClientIdInstanceIdCurrencyIsoCodeIdCodeCompoundUniqueInput = {
    clientId: string
    instanceId: string
    currencyIsoCodeId: string
    code: string
  }

  export type CurrencyCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    currencyIsoCodeId?: SortOrder
    assignedLevels?: SortOrder
    isDefault?: SortOrder
    clientId?: SortOrder
    instanceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CurrencyAvgOrderByAggregateInput = {
    assignedLevels?: SortOrder
  }

  export type CurrencyMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    currencyIsoCodeId?: SortOrder
    assignedLevels?: SortOrder
    isDefault?: SortOrder
    clientId?: SortOrder
    instanceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CurrencyMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    currencyIsoCodeId?: SortOrder
    assignedLevels?: SortOrder
    isDefault?: SortOrder
    clientId?: SortOrder
    instanceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CurrencySumOrderByAggregateInput = {
    assignedLevels?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumYesNoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.YesNo | EnumYesNoFieldRefInput<$PrismaModel>
    in?: $Enums.YesNo[] | ListEnumYesNoFieldRefInput<$PrismaModel>
    notIn?: $Enums.YesNo[] | ListEnumYesNoFieldRefInput<$PrismaModel>
    not?: NestedEnumYesNoWithAggregatesFilter<$PrismaModel> | $Enums.YesNo
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumYesNoFilter<$PrismaModel>
    _max?: NestedEnumYesNoFilter<$PrismaModel>
  }

  export type LevelAttributeAndValueListRelationFilter = {
    every?: LevelAttributeAndValueWhereInput
    some?: LevelAttributeAndValueWhereInput
    none?: LevelAttributeAndValueWhereInput
  }

  export type LevelNullableScalarRelationFilter = {
    is?: LevelWhereInput | null
    isNot?: LevelWhereInput | null
  }

  export type LevelAttributeAndValueOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LevelUniqueCodeCompoundUniqueInput = {
    clientId: string
    code: string
    instanceId: string
  }

  export type LevelCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    isRoot?: SortOrder
    description?: SortOrder
    parentId?: SortOrder
    clientId?: SortOrder
    instanceId?: SortOrder
    currencyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LevelMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    isRoot?: SortOrder
    description?: SortOrder
    parentId?: SortOrder
    clientId?: SortOrder
    instanceId?: SortOrder
    currencyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LevelMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    isRoot?: SortOrder
    description?: SortOrder
    parentId?: SortOrder
    clientId?: SortOrder
    instanceId?: SortOrder
    currencyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LevelAttributeNullableScalarRelationFilter = {
    is?: LevelAttributeWhereInput | null
    isNot?: LevelAttributeWhereInput | null
  }

  export type LevelAttributeValueNullableScalarRelationFilter = {
    is?: LevelAttributeValueWhereInput | null
    isNot?: LevelAttributeValueWhereInput | null
  }

  export type LevelAttributeAndValueCountOrderByAggregateInput = {
    id?: SortOrder
    levelId?: SortOrder
    clientId?: SortOrder
    instanceId?: SortOrder
    attributeId?: SortOrder
    attributeValueId?: SortOrder
    levelCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LevelAttributeAndValueMaxOrderByAggregateInput = {
    id?: SortOrder
    levelId?: SortOrder
    clientId?: SortOrder
    instanceId?: SortOrder
    attributeId?: SortOrder
    attributeValueId?: SortOrder
    levelCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LevelAttributeAndValueMinOrderByAggregateInput = {
    id?: SortOrder
    levelId?: SortOrder
    clientId?: SortOrder
    instanceId?: SortOrder
    attributeId?: SortOrder
    attributeValueId?: SortOrder
    levelCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LevelAttributeScalarRelationFilter = {
    is?: LevelAttributeWhereInput
    isNot?: LevelAttributeWhereInput
  }

  export type LevelAttributeValueClientIdCodeInstanceIdAttributeIdCompoundUniqueInput = {
    clientId: string
    code: string
    instanceId: string
    attributeId: string
  }

  export type LevelAttributeValueCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    attributeId?: SortOrder
    parentId?: SortOrder
    clientId?: SortOrder
    instanceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LevelAttributeValueMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    attributeId?: SortOrder
    parentId?: SortOrder
    clientId?: SortOrder
    instanceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LevelAttributeValueMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    attributeId?: SortOrder
    parentId?: SortOrder
    clientId?: SortOrder
    instanceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LevelAttributeClientIdCodeInstanceIdCompoundUniqueInput = {
    clientId: string
    code: string
    instanceId: string
  }

  export type LevelAttributeCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    clientId?: SortOrder
    instanceId?: SortOrder
    attributeValueDefault?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LevelAttributeMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    clientId?: SortOrder
    instanceId?: SortOrder
    attributeValueDefault?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LevelAttributeMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    clientId?: SortOrder
    instanceId?: SortOrder
    attributeValueDefault?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountAttributeAndValueListRelationFilter = {
    every?: AccountAttributeAndValueWhereInput
    some?: AccountAttributeAndValueWhereInput
    none?: AccountAttributeAndValueWhereInput
  }

  export type AccountAttributeAndValueOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccountAttributeClientIdCodeInstanceIdCompoundUniqueInput = {
    clientId: string
    code: string
    instanceId: string
  }

  export type AccountAttributeCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    attributeValueDefault?: SortOrder
    clientId?: SortOrder
    instanceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountAttributeMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    attributeValueDefault?: SortOrder
    clientId?: SortOrder
    instanceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountAttributeMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    attributeValueDefault?: SortOrder
    clientId?: SortOrder
    instanceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountAttributeValueNullableScalarRelationFilter = {
    is?: AccountAttributeValueWhereInput | null
    isNot?: AccountAttributeValueWhereInput | null
  }

  export type AccountAttributeScalarRelationFilter = {
    is?: AccountAttributeWhereInput
    isNot?: AccountAttributeWhereInput
  }

  export type AccountAttributeValueClientIdCodeInstanceIdAttributeIdCompoundUniqueInput = {
    clientId: string
    code: string
    instanceId: string
    attributeId: string
  }

  export type AccountAttributeValueCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    attributeId?: SortOrder
    parentId?: SortOrder
    clientId?: SortOrder
    instanceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountAttributeValueMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    attributeId?: SortOrder
    parentId?: SortOrder
    clientId?: SortOrder
    instanceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountAttributeValueMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    attributeId?: SortOrder
    parentId?: SortOrder
    clientId?: SortOrder
    instanceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountNullableScalarRelationFilter = {
    is?: AccountWhereInput | null
    isNot?: AccountWhereInput | null
  }

  export type AccountAttributeNullableScalarRelationFilter = {
    is?: AccountAttributeWhereInput | null
    isNot?: AccountAttributeWhereInput | null
  }

  export type AccountAttributeAndValueCountOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    clientId?: SortOrder
    instanceId?: SortOrder
    attributeId?: SortOrder
    attributeValueId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountAttributeAndValueMaxOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    clientId?: SortOrder
    instanceId?: SortOrder
    attributeId?: SortOrder
    attributeValueId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountAttributeAndValueMinOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    clientId?: SortOrder
    instanceId?: SortOrder
    attributeId?: SortOrder
    attributeValueId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumAccountTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountType | EnumAccountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountTypeFilter<$PrismaModel> | $Enums.AccountType
  }

  export type EnumAccountTypeTagFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountTypeTag | EnumAccountTypeTagFieldRefInput<$PrismaModel>
    in?: $Enums.AccountTypeTag[] | ListEnumAccountTypeTagFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountTypeTag[] | ListEnumAccountTypeTagFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountTypeTagFilter<$PrismaModel> | $Enums.AccountTypeTag
  }

  export type EnumActPlanByNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ActPlanBy | EnumActPlanByFieldRefInput<$PrismaModel> | null
    in?: $Enums.ActPlanBy[] | ListEnumActPlanByFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ActPlanBy[] | ListEnumActPlanByFieldRefInput<$PrismaModel> | null
    not?: NestedEnumActPlanByNullableFilter<$PrismaModel> | $Enums.ActPlanBy | null
    isSet?: boolean
  }

  export type EnumActActualsByNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ActActualsBy | EnumActActualsByFieldRefInput<$PrismaModel> | null
    in?: $Enums.ActActualsBy[] | ListEnumActActualsByFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ActActualsBy[] | ListEnumActActualsByFieldRefInput<$PrismaModel> | null
    not?: NestedEnumActActualsByNullableFilter<$PrismaModel> | $Enums.ActActualsBy | null
    isSet?: boolean
  }

  export type EnumActDisplayAsFilter<$PrismaModel = never> = {
    equals?: $Enums.ActDisplayAs | EnumActDisplayAsFieldRefInput<$PrismaModel>
    in?: $Enums.ActDisplayAs[] | ListEnumActDisplayAsFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActDisplayAs[] | ListEnumActDisplayAsFieldRefInput<$PrismaModel>
    not?: NestedEnumActDisplayAsFilter<$PrismaModel> | $Enums.ActDisplayAs
  }

  export type AccountClientIdCodeInstanceIdCompoundUniqueInput = {
    clientId: string
    code: string
    instanceId: string
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    isRoot?: SortOrder
    isModelRoot?: SortOrder
    accountType?: SortOrder
    accountTypeTag?: SortOrder
    group?: SortOrder
    plannedBy?: SortOrder
    actualsBy?: SortOrder
    displayAs?: SortOrder
    containsSalaryInfo?: SortOrder
    description?: SortOrder
    instanceId?: SortOrder
    clientId?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    isRoot?: SortOrder
    isModelRoot?: SortOrder
    accountType?: SortOrder
    accountTypeTag?: SortOrder
    group?: SortOrder
    plannedBy?: SortOrder
    actualsBy?: SortOrder
    displayAs?: SortOrder
    containsSalaryInfo?: SortOrder
    description?: SortOrder
    instanceId?: SortOrder
    clientId?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    isRoot?: SortOrder
    isModelRoot?: SortOrder
    accountType?: SortOrder
    accountTypeTag?: SortOrder
    group?: SortOrder
    plannedBy?: SortOrder
    actualsBy?: SortOrder
    displayAs?: SortOrder
    containsSalaryInfo?: SortOrder
    description?: SortOrder
    instanceId?: SortOrder
    clientId?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumAccountTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountType | EnumAccountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountTypeWithAggregatesFilter<$PrismaModel> | $Enums.AccountType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccountTypeFilter<$PrismaModel>
    _max?: NestedEnumAccountTypeFilter<$PrismaModel>
  }

  export type EnumAccountTypeTagWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountTypeTag | EnumAccountTypeTagFieldRefInput<$PrismaModel>
    in?: $Enums.AccountTypeTag[] | ListEnumAccountTypeTagFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountTypeTag[] | ListEnumAccountTypeTagFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountTypeTagWithAggregatesFilter<$PrismaModel> | $Enums.AccountTypeTag
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccountTypeTagFilter<$PrismaModel>
    _max?: NestedEnumAccountTypeTagFilter<$PrismaModel>
  }

  export type EnumActPlanByNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActPlanBy | EnumActPlanByFieldRefInput<$PrismaModel> | null
    in?: $Enums.ActPlanBy[] | ListEnumActPlanByFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ActPlanBy[] | ListEnumActPlanByFieldRefInput<$PrismaModel> | null
    not?: NestedEnumActPlanByNullableWithAggregatesFilter<$PrismaModel> | $Enums.ActPlanBy | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumActPlanByNullableFilter<$PrismaModel>
    _max?: NestedEnumActPlanByNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type EnumActActualsByNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActActualsBy | EnumActActualsByFieldRefInput<$PrismaModel> | null
    in?: $Enums.ActActualsBy[] | ListEnumActActualsByFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ActActualsBy[] | ListEnumActActualsByFieldRefInput<$PrismaModel> | null
    not?: NestedEnumActActualsByNullableWithAggregatesFilter<$PrismaModel> | $Enums.ActActualsBy | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumActActualsByNullableFilter<$PrismaModel>
    _max?: NestedEnumActActualsByNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type EnumActDisplayAsWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActDisplayAs | EnumActDisplayAsFieldRefInput<$PrismaModel>
    in?: $Enums.ActDisplayAs[] | ListEnumActDisplayAsFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActDisplayAs[] | ListEnumActDisplayAsFieldRefInput<$PrismaModel>
    not?: NestedEnumActDisplayAsWithAggregatesFilter<$PrismaModel> | $Enums.ActDisplayAs
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActDisplayAsFilter<$PrismaModel>
    _max?: NestedEnumActDisplayAsFilter<$PrismaModel>
  }

  export type DimensionClientIdCodeInstanceIdCompoundUniqueInput = {
    clientId: string
    code: string
    instanceId: string
  }

  export type DimensionCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    dimensionValueDefault?: SortOrder
    clientId?: SortOrder
    instanceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DimensionMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    dimensionValueDefault?: SortOrder
    clientId?: SortOrder
    instanceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DimensionMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    dimensionValueDefault?: SortOrder
    clientId?: SortOrder
    instanceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DimensionValueNullableScalarRelationFilter = {
    is?: DimensionValueWhereInput | null
    isNot?: DimensionValueWhereInput | null
  }

  export type DimensionValueAttributeAndValueListRelationFilter = {
    every?: DimensionValueAttributeAndValueWhereInput
    some?: DimensionValueAttributeAndValueWhereInput
    none?: DimensionValueAttributeAndValueWhereInput
  }

  export type DimensionScalarRelationFilter = {
    is?: DimensionWhereInput
    isNot?: DimensionWhereInput
  }

  export type DimensionValueAttributeAndValueOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DimensionValueClientIdCodeInstanceIdDimensionIdCompoundUniqueInput = {
    clientId: string
    code: string
    instanceId: string
    dimensionId: string
  }

  export type DimensionValueCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    parentId?: SortOrder
    clientId?: SortOrder
    instanceId?: SortOrder
    dimensionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DimensionValueMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    parentId?: SortOrder
    clientId?: SortOrder
    instanceId?: SortOrder
    dimensionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DimensionValueMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    parentId?: SortOrder
    clientId?: SortOrder
    instanceId?: SortOrder
    dimensionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DimensionValueAttributeClientIdCodeInstanceIdCompoundUniqueInput = {
    clientId: string
    code: string
    instanceId: string
  }

  export type DimensionValueAttributeCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    clientId?: SortOrder
    instanceId?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type DimensionValueAttributeMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    clientId?: SortOrder
    instanceId?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type DimensionValueAttributeMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    clientId?: SortOrder
    instanceId?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type DimensionValueAttributeValueNullableScalarRelationFilter = {
    is?: DimensionValueAttributeValueWhereInput | null
    isNot?: DimensionValueAttributeValueWhereInput | null
  }

  export type DimensionValueAttributeScalarRelationFilter = {
    is?: DimensionValueAttributeWhereInput
    isNot?: DimensionValueAttributeWhereInput
  }

  export type DimensionValueAttributeValueClientIdCodeInstanceIdAttributeIdCompoundUniqueInput = {
    clientId: string
    code: string
    instanceId: string
    attributeId: string
  }

  export type DimensionValueAttributeValueCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    attributeId?: SortOrder
    clientId?: SortOrder
    parentId?: SortOrder
    instanceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DimensionValueAttributeValueMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    attributeId?: SortOrder
    clientId?: SortOrder
    parentId?: SortOrder
    instanceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DimensionValueAttributeValueMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    attributeId?: SortOrder
    clientId?: SortOrder
    parentId?: SortOrder
    instanceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DimensionValueAttributeNullableScalarRelationFilter = {
    is?: DimensionValueAttributeWhereInput | null
    isNot?: DimensionValueAttributeWhereInput | null
  }

  export type DimensionValueAttributeAndValueCountOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    instanceId?: SortOrder
    attributeId?: SortOrder
    attributeValueId?: SortOrder
    dimensionValueId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DimensionValueAttributeAndValueMaxOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    instanceId?: SortOrder
    attributeId?: SortOrder
    attributeValueId?: SortOrder
    dimensionValueId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DimensionValueAttributeAndValueMinOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    instanceId?: SortOrder
    attributeId?: SortOrder
    attributeValueId?: SortOrder
    dimensionValueId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumModelStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ModelStatus | EnumModelStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ModelStatus[] | ListEnumModelStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ModelStatus[] | ListEnumModelStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumModelStatusFilter<$PrismaModel> | $Enums.ModelStatus
  }

  export type ModelClientIdInstanceIdCodeCompoundUniqueInput = {
    clientId: string
    instanceId: string
    code: string
  }

  export type ModelCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    dimensionality?: SortOrder
    status?: SortOrder
    isDefault?: SortOrder
    instanceId?: SortOrder
    clientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    rootAccountId?: SortOrder
  }

  export type ModelMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    isDefault?: SortOrder
    instanceId?: SortOrder
    clientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    rootAccountId?: SortOrder
  }

  export type ModelMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    isDefault?: SortOrder
    instanceId?: SortOrder
    clientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    rootAccountId?: SortOrder
  }

  export type EnumModelStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ModelStatus | EnumModelStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ModelStatus[] | ListEnumModelStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ModelStatus[] | ListEnumModelStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumModelStatusWithAggregatesFilter<$PrismaModel> | $Enums.ModelStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumModelStatusFilter<$PrismaModel>
    _max?: NestedEnumModelStatusFilter<$PrismaModel>
  }

  export type ModelScalarRelationFilter = {
    is?: ModelWhereInput
    isNot?: ModelWhereInput
  }

  export type AccountScalarRelationFilter = {
    is?: AccountWhereInput
    isNot?: AccountWhereInput
  }

  export type ModelAccountStructureNullableScalarRelationFilter = {
    is?: ModelAccountStructureWhereInput | null
    isNot?: ModelAccountStructureWhereInput | null
  }

  export type ModelAccountStructureCountOrderByAggregateInput = {
    id?: SortOrder
    instanceId?: SortOrder
    isRoot?: SortOrder
    clientId?: SortOrder
    parentId?: SortOrder
    modelId?: SortOrder
    accountId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ModelAccountStructureMaxOrderByAggregateInput = {
    id?: SortOrder
    instanceId?: SortOrder
    isRoot?: SortOrder
    clientId?: SortOrder
    parentId?: SortOrder
    modelId?: SortOrder
    accountId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ModelAccountStructureMinOrderByAggregateInput = {
    id?: SortOrder
    instanceId?: SortOrder
    isRoot?: SortOrder
    clientId?: SortOrder
    parentId?: SortOrder
    modelId?: SortOrder
    accountId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ModelDataDimensionalityCompositeListFilter = {
    equals?: ModelDataDimensionalityObjectEqualityInput[]
    every?: ModelDataDimensionalityWhereInput
    some?: ModelDataDimensionalityWhereInput
    none?: ModelDataDimensionalityWhereInput
    isEmpty?: boolean
    isSet?: boolean
  }

  export type ModelDataDimensionalityObjectEqualityInput = {
    dimensionId: string
    dimensionValueId: string
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
  }

  export type LevelScalarRelationFilter = {
    is?: LevelWhereInput
    isNot?: LevelWhereInput
  }

  export type VersionScalarRelationFilter = {
    is?: VersionWhereInput
    isNot?: VersionWhereInput
  }

  export type ModelDataDimensionalityOrderByCompositeAggregateInput = {
    _count?: SortOrder
  }

  export type ModelDataCountOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    instanceId?: SortOrder
    modelId?: SortOrder
    versionId?: SortOrder
    levelId?: SortOrder
    accountId?: SortOrder
    timespan?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ModelDataMaxOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    instanceId?: SortOrder
    modelId?: SortOrder
    versionId?: SortOrder
    levelId?: SortOrder
    accountId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ModelDataMinOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    instanceId?: SortOrder
    modelId?: SortOrder
    versionId?: SortOrder
    levelId?: SortOrder
    accountId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type ModelAccountStructureScalarRelationFilter = {
    is?: ModelAccountStructureWhereInput
    isNot?: ModelAccountStructureWhereInput
  }

  export type ModelDataCalculationsCountOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    instanceId?: SortOrder
    modelId?: SortOrder
    versionId?: SortOrder
    levelId?: SortOrder
    accountId?: SortOrder
    modelAccountId?: SortOrder
    calculations?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ModelDataCalculationsMaxOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    instanceId?: SortOrder
    modelId?: SortOrder
    versionId?: SortOrder
    levelId?: SortOrder
    accountId?: SortOrder
    modelAccountId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ModelDataCalculationsMinOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    instanceId?: SortOrder
    modelId?: SortOrder
    versionId?: SortOrder
    levelId?: SortOrder
    accountId?: SortOrder
    modelAccountId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TableColumnDefinitionCompositeListFilter = {
    equals?: TableColumnDefinitionObjectEqualityInput[]
    every?: TableColumnDefinitionWhereInput
    some?: TableColumnDefinitionWhereInput
    none?: TableColumnDefinitionWhereInput
    isEmpty?: boolean
    isSet?: boolean
  }

  export type TableColumnDefinitionObjectEqualityInput = {
    tableId: string
    name: string
    code: string
    type: $Enums.TableColumnType
    dimensionId?: string | null
  }

  export type TableColumnDefinitionOrderByCompositeAggregateInput = {
    _count?: SortOrder
  }

  export type TableClientIdInstanceIdCodeCompoundUniqueInput = {
    clientId: string
    instanceId: string
    code: string
  }

  export type TableCountOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    instanceId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type TableMaxOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    instanceId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type TableMinOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    instanceId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type TableScalarRelationFilter = {
    is?: TableWhereInput
    isNot?: TableWhereInput
  }

  export type TableDataCountOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    instanceId?: SortOrder
    tableId?: SortOrder
    rowKey?: SortOrder
    versionId?: SortOrder
    levelId?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TableDataMaxOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    instanceId?: SortOrder
    tableId?: SortOrder
    rowKey?: SortOrder
    versionId?: SortOrder
    levelId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TableDataMinOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    instanceId?: SortOrder
    tableId?: SortOrder
    rowKey?: SortOrder
    versionId?: SortOrder
    levelId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumDataSourceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DataSourceType | EnumDataSourceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DataSourceType[] | ListEnumDataSourceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DataSourceType[] | ListEnumDataSourceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDataSourceTypeFilter<$PrismaModel> | $Enums.DataSourceType
  }

  export type DataSourceCredentialNullableScalarRelationFilter = {
    is?: DataSourceCredentialWhereInput | null
    isNot?: DataSourceCredentialWhereInput | null
  }

  export type DataSourceClientIdInstanceIdCodeCompoundUniqueInput = {
    clientId: string
    instanceId: string
    code: string
  }

  export type DataSourceCountOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    instanceId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    credentialId?: SortOrder
    description?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DataSourceMaxOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    instanceId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    credentialId?: SortOrder
    description?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DataSourceMinOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    instanceId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    credentialId?: SortOrder
    description?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumDataSourceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DataSourceType | EnumDataSourceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DataSourceType[] | ListEnumDataSourceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DataSourceType[] | ListEnumDataSourceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDataSourceTypeWithAggregatesFilter<$PrismaModel> | $Enums.DataSourceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDataSourceTypeFilter<$PrismaModel>
    _max?: NestedEnumDataSourceTypeFilter<$PrismaModel>
  }

  export type DataSourceTaskClientIdInstanceIdCodeCompoundUniqueInput = {
    clientId: string
    instanceId: string
    code: string
  }

  export type DataSourceTaskCountOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    instanceId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DataSourceTaskMaxOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    instanceId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DataSourceTaskMinOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    instanceId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumDataSourceLoaderTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DataSourceLoaderType | EnumDataSourceLoaderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DataSourceLoaderType[] | ListEnumDataSourceLoaderTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DataSourceLoaderType[] | ListEnumDataSourceLoaderTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDataSourceLoaderTypeFilter<$PrismaModel> | $Enums.DataSourceLoaderType
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
    isSet?: boolean
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    isSet?: boolean
  }

  export type DataSourceLoaderClientIdInstanceIdCodeCompoundUniqueInput = {
    clientId: string
    instanceId: string
    code: string
  }

  export type DataSourceLoaderCountOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    instanceId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    loaderType?: SortOrder
    sourceTable?: SortOrder
    planningTable?: SortOrder
    planningElementId?: SortOrder
    planningElementType?: SortOrder
    versionId?: SortOrder
    createElementIfNotFound?: SortOrder
    settingsOptions?: SortOrder
    columnMappings?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DataSourceLoaderMaxOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    instanceId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    loaderType?: SortOrder
    sourceTable?: SortOrder
    planningElementId?: SortOrder
    planningElementType?: SortOrder
    versionId?: SortOrder
    createElementIfNotFound?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DataSourceLoaderMinOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    instanceId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    loaderType?: SortOrder
    sourceTable?: SortOrder
    planningElementId?: SortOrder
    planningElementType?: SortOrder
    versionId?: SortOrder
    createElementIfNotFound?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumDataSourceLoaderTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DataSourceLoaderType | EnumDataSourceLoaderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DataSourceLoaderType[] | ListEnumDataSourceLoaderTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DataSourceLoaderType[] | ListEnumDataSourceLoaderTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDataSourceLoaderTypeWithAggregatesFilter<$PrismaModel> | $Enums.DataSourceLoaderType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDataSourceLoaderTypeFilter<$PrismaModel>
    _max?: NestedEnumDataSourceLoaderTypeFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
    isSet?: boolean
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type EnumDatasourceCredentialAuthTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DatasourceCredentialAuthType | EnumDatasourceCredentialAuthTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DatasourceCredentialAuthType[] | ListEnumDatasourceCredentialAuthTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DatasourceCredentialAuthType[] | ListEnumDatasourceCredentialAuthTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDatasourceCredentialAuthTypeFilter<$PrismaModel> | $Enums.DatasourceCredentialAuthType
  }

  export type DataSourceListRelationFilter = {
    every?: DataSourceWhereInput
    some?: DataSourceWhereInput
    none?: DataSourceWhereInput
  }

  export type DataSourceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DataSourceCredentialClientIdInstanceIdCodeCompoundUniqueInput = {
    clientId: string
    instanceId: string
    code: string
  }

  export type DataSourceCredentialCountOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    instanceId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    type?: SortOrder
    credentialId?: SortOrder
    credentialKey?: SortOrder
    credentialSecret?: SortOrder
    credentialToken?: SortOrder
    credentialTokenSecret?: SortOrder
    credentialHostname?: SortOrder
    credentialUsername?: SortOrder
    fingerprint?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DataSourceCredentialMaxOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    instanceId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    type?: SortOrder
    credentialId?: SortOrder
    credentialKey?: SortOrder
    credentialSecret?: SortOrder
    credentialToken?: SortOrder
    credentialTokenSecret?: SortOrder
    credentialHostname?: SortOrder
    credentialUsername?: SortOrder
    fingerprint?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DataSourceCredentialMinOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    instanceId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    type?: SortOrder
    credentialId?: SortOrder
    credentialKey?: SortOrder
    credentialSecret?: SortOrder
    credentialToken?: SortOrder
    credentialTokenSecret?: SortOrder
    credentialHostname?: SortOrder
    credentialUsername?: SortOrder
    fingerprint?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumDatasourceCredentialAuthTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DatasourceCredentialAuthType | EnumDatasourceCredentialAuthTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DatasourceCredentialAuthType[] | ListEnumDatasourceCredentialAuthTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DatasourceCredentialAuthType[] | ListEnumDatasourceCredentialAuthTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDatasourceCredentialAuthTypeWithAggregatesFilter<$PrismaModel> | $Enums.DatasourceCredentialAuthType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDatasourceCredentialAuthTypeFilter<$PrismaModel>
    _max?: NestedEnumDatasourceCredentialAuthTypeFilter<$PrismaModel>
  }

  export type CurrencyIsoCodeCreateNestedOneWithoutConfigInput = {
    create?: XOR<CurrencyIsoCodeCreateWithoutConfigInput, CurrencyIsoCodeUncheckedCreateWithoutConfigInput>
    connectOrCreate?: CurrencyIsoCodeCreateOrConnectWithoutConfigInput
    connect?: CurrencyIsoCodeWhereUniqueInput
  }

  export type CurrencyCreateNestedOneWithoutDefaultsInput = {
    create?: XOR<CurrencyCreateWithoutDefaultsInput, CurrencyUncheckedCreateWithoutDefaultsInput>
    connectOrCreate?: CurrencyCreateOrConnectWithoutDefaultsInput
    connect?: CurrencyWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
    unset?: boolean
  }

  export type CurrencyIsoCodeUpdateOneRequiredWithoutConfigNestedInput = {
    create?: XOR<CurrencyIsoCodeCreateWithoutConfigInput, CurrencyIsoCodeUncheckedCreateWithoutConfigInput>
    connectOrCreate?: CurrencyIsoCodeCreateOrConnectWithoutConfigInput
    upsert?: CurrencyIsoCodeUpsertWithoutConfigInput
    connect?: CurrencyIsoCodeWhereUniqueInput
    update?: XOR<XOR<CurrencyIsoCodeUpdateToOneWithWhereWithoutConfigInput, CurrencyIsoCodeUpdateWithoutConfigInput>, CurrencyIsoCodeUncheckedUpdateWithoutConfigInput>
  }

  export type CurrencyUpdateOneRequiredWithoutDefaultsNestedInput = {
    create?: XOR<CurrencyCreateWithoutDefaultsInput, CurrencyUncheckedCreateWithoutDefaultsInput>
    connectOrCreate?: CurrencyCreateOrConnectWithoutDefaultsInput
    upsert?: CurrencyUpsertWithoutDefaultsInput
    connect?: CurrencyWhereUniqueInput
    update?: XOR<XOR<CurrencyUpdateToOneWithWhereWithoutDefaultsInput, CurrencyUpdateWithoutDefaultsInput>, CurrencyUncheckedUpdateWithoutDefaultsInput>
  }

  export type ClientCreateNestedManyWithoutCountryInput = {
    create?: XOR<ClientCreateWithoutCountryInput, ClientUncheckedCreateWithoutCountryInput> | ClientCreateWithoutCountryInput[] | ClientUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: ClientCreateOrConnectWithoutCountryInput | ClientCreateOrConnectWithoutCountryInput[]
    createMany?: ClientCreateManyCountryInputEnvelope
    connect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
  }

  export type UserCreateNestedManyWithoutCountryInput = {
    create?: XOR<UserCreateWithoutCountryInput, UserUncheckedCreateWithoutCountryInput> | UserCreateWithoutCountryInput[] | UserUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCountryInput | UserCreateOrConnectWithoutCountryInput[]
    createMany?: UserCreateManyCountryInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type ClientUncheckedCreateNestedManyWithoutCountryInput = {
    create?: XOR<ClientCreateWithoutCountryInput, ClientUncheckedCreateWithoutCountryInput> | ClientCreateWithoutCountryInput[] | ClientUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: ClientCreateOrConnectWithoutCountryInput | ClientCreateOrConnectWithoutCountryInput[]
    createMany?: ClientCreateManyCountryInputEnvelope
    connect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutCountryInput = {
    create?: XOR<UserCreateWithoutCountryInput, UserUncheckedCreateWithoutCountryInput> | UserCreateWithoutCountryInput[] | UserUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCountryInput | UserCreateOrConnectWithoutCountryInput[]
    createMany?: UserCreateManyCountryInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type ClientUpdateManyWithoutCountryNestedInput = {
    create?: XOR<ClientCreateWithoutCountryInput, ClientUncheckedCreateWithoutCountryInput> | ClientCreateWithoutCountryInput[] | ClientUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: ClientCreateOrConnectWithoutCountryInput | ClientCreateOrConnectWithoutCountryInput[]
    upsert?: ClientUpsertWithWhereUniqueWithoutCountryInput | ClientUpsertWithWhereUniqueWithoutCountryInput[]
    createMany?: ClientCreateManyCountryInputEnvelope
    set?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    disconnect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    delete?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    connect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    update?: ClientUpdateWithWhereUniqueWithoutCountryInput | ClientUpdateWithWhereUniqueWithoutCountryInput[]
    updateMany?: ClientUpdateManyWithWhereWithoutCountryInput | ClientUpdateManyWithWhereWithoutCountryInput[]
    deleteMany?: ClientScalarWhereInput | ClientScalarWhereInput[]
  }

  export type UserUpdateManyWithoutCountryNestedInput = {
    create?: XOR<UserCreateWithoutCountryInput, UserUncheckedCreateWithoutCountryInput> | UserCreateWithoutCountryInput[] | UserUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCountryInput | UserCreateOrConnectWithoutCountryInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutCountryInput | UserUpsertWithWhereUniqueWithoutCountryInput[]
    createMany?: UserCreateManyCountryInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutCountryInput | UserUpdateWithWhereUniqueWithoutCountryInput[]
    updateMany?: UserUpdateManyWithWhereWithoutCountryInput | UserUpdateManyWithWhereWithoutCountryInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type ClientUncheckedUpdateManyWithoutCountryNestedInput = {
    create?: XOR<ClientCreateWithoutCountryInput, ClientUncheckedCreateWithoutCountryInput> | ClientCreateWithoutCountryInput[] | ClientUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: ClientCreateOrConnectWithoutCountryInput | ClientCreateOrConnectWithoutCountryInput[]
    upsert?: ClientUpsertWithWhereUniqueWithoutCountryInput | ClientUpsertWithWhereUniqueWithoutCountryInput[]
    createMany?: ClientCreateManyCountryInputEnvelope
    set?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    disconnect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    delete?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    connect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    update?: ClientUpdateWithWhereUniqueWithoutCountryInput | ClientUpdateWithWhereUniqueWithoutCountryInput[]
    updateMany?: ClientUpdateManyWithWhereWithoutCountryInput | ClientUpdateManyWithWhereWithoutCountryInput[]
    deleteMany?: ClientScalarWhereInput | ClientScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutCountryNestedInput = {
    create?: XOR<UserCreateWithoutCountryInput, UserUncheckedCreateWithoutCountryInput> | UserCreateWithoutCountryInput[] | UserUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCountryInput | UserCreateOrConnectWithoutCountryInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutCountryInput | UserUpsertWithWhereUniqueWithoutCountryInput[]
    createMany?: UserCreateManyCountryInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutCountryInput | UserUpdateWithWhereUniqueWithoutCountryInput[]
    updateMany?: UserUpdateManyWithWhereWithoutCountryInput | UserUpdateManyWithWhereWithoutCountryInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserCreatepermissionsInput = {
    set: string[]
  }

  export type CountryCreateNestedOneWithoutUserInput = {
    create?: XOR<CountryCreateWithoutUserInput, CountryUncheckedCreateWithoutUserInput>
    connectOrCreate?: CountryCreateOrConnectWithoutUserInput
    connect?: CountryWhereUniqueInput
  }

  export type ClientCreateNestedOneWithoutUsersInput = {
    create?: XOR<ClientCreateWithoutUsersInput, ClientUncheckedCreateWithoutUsersInput>
    connectOrCreate?: ClientCreateOrConnectWithoutUsersInput
    connect?: ClientWhereUniqueInput
  }

  export type EnumuserRoleFieldUpdateOperationsInput = {
    set?: $Enums.userRole
  }

  export type UserUpdatepermissionsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
    unset?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type CountryUpdateOneWithoutUserNestedInput = {
    create?: XOR<CountryCreateWithoutUserInput, CountryUncheckedCreateWithoutUserInput>
    connectOrCreate?: CountryCreateOrConnectWithoutUserInput
    upsert?: CountryUpsertWithoutUserInput
    disconnect?: boolean
    delete?: CountryWhereInput | boolean
    connect?: CountryWhereUniqueInput
    update?: XOR<XOR<CountryUpdateToOneWithWhereWithoutUserInput, CountryUpdateWithoutUserInput>, CountryUncheckedUpdateWithoutUserInput>
  }

  export type ClientUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<ClientCreateWithoutUsersInput, ClientUncheckedCreateWithoutUsersInput>
    connectOrCreate?: ClientCreateOrConnectWithoutUsersInput
    upsert?: ClientUpsertWithoutUsersInput
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutUsersInput, ClientUpdateWithoutUsersInput>, ClientUncheckedUpdateWithoutUsersInput>
  }

  export type addressTypeNullableCreateEnvelopeInput = {
    set?: addressTypeCreateInput | null
  }

  export type addressTypeCreateInput = {
    address1?: string | null
    address2?: string | null
    city?: string | null
    state?: string | null
  }

  export type CountryCreateNestedOneWithoutClientInput = {
    create?: XOR<CountryCreateWithoutClientInput, CountryUncheckedCreateWithoutClientInput>
    connectOrCreate?: CountryCreateOrConnectWithoutClientInput
    connect?: CountryWhereUniqueInput
  }

  export type UserCreateNestedManyWithoutClientInput = {
    create?: XOR<UserCreateWithoutClientInput, UserUncheckedCreateWithoutClientInput> | UserCreateWithoutClientInput[] | UserUncheckedCreateWithoutClientInput[]
    connectOrCreate?: UserCreateOrConnectWithoutClientInput | UserCreateOrConnectWithoutClientInput[]
    createMany?: UserCreateManyClientInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type InstanceCreateNestedManyWithoutClientInput = {
    create?: XOR<InstanceCreateWithoutClientInput, InstanceUncheckedCreateWithoutClientInput> | InstanceCreateWithoutClientInput[] | InstanceUncheckedCreateWithoutClientInput[]
    connectOrCreate?: InstanceCreateOrConnectWithoutClientInput | InstanceCreateOrConnectWithoutClientInput[]
    createMany?: InstanceCreateManyClientInputEnvelope
    connect?: InstanceWhereUniqueInput | InstanceWhereUniqueInput[]
  }

  export type PermissionCreateNestedManyWithoutClientInput = {
    create?: XOR<PermissionCreateWithoutClientInput, PermissionUncheckedCreateWithoutClientInput> | PermissionCreateWithoutClientInput[] | PermissionUncheckedCreateWithoutClientInput[]
    connectOrCreate?: PermissionCreateOrConnectWithoutClientInput | PermissionCreateOrConnectWithoutClientInput[]
    createMany?: PermissionCreateManyClientInputEnvelope
    connect?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<UserCreateWithoutClientInput, UserUncheckedCreateWithoutClientInput> | UserCreateWithoutClientInput[] | UserUncheckedCreateWithoutClientInput[]
    connectOrCreate?: UserCreateOrConnectWithoutClientInput | UserCreateOrConnectWithoutClientInput[]
    createMany?: UserCreateManyClientInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type InstanceUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<InstanceCreateWithoutClientInput, InstanceUncheckedCreateWithoutClientInput> | InstanceCreateWithoutClientInput[] | InstanceUncheckedCreateWithoutClientInput[]
    connectOrCreate?: InstanceCreateOrConnectWithoutClientInput | InstanceCreateOrConnectWithoutClientInput[]
    createMany?: InstanceCreateManyClientInputEnvelope
    connect?: InstanceWhereUniqueInput | InstanceWhereUniqueInput[]
  }

  export type PermissionUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<PermissionCreateWithoutClientInput, PermissionUncheckedCreateWithoutClientInput> | PermissionCreateWithoutClientInput[] | PermissionUncheckedCreateWithoutClientInput[]
    connectOrCreate?: PermissionCreateOrConnectWithoutClientInput | PermissionCreateOrConnectWithoutClientInput[]
    createMany?: PermissionCreateManyClientInputEnvelope
    connect?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
  }

  export type EnumclientStatusFieldUpdateOperationsInput = {
    set?: $Enums.clientStatus
  }

  export type addressTypeNullableUpdateEnvelopeInput = {
    set?: addressTypeCreateInput | null
    upsert?: addressTypeUpsertInput
    unset?: boolean
  }

  export type CountryUpdateOneWithoutClientNestedInput = {
    create?: XOR<CountryCreateWithoutClientInput, CountryUncheckedCreateWithoutClientInput>
    connectOrCreate?: CountryCreateOrConnectWithoutClientInput
    upsert?: CountryUpsertWithoutClientInput
    disconnect?: boolean
    delete?: CountryWhereInput | boolean
    connect?: CountryWhereUniqueInput
    update?: XOR<XOR<CountryUpdateToOneWithWhereWithoutClientInput, CountryUpdateWithoutClientInput>, CountryUncheckedUpdateWithoutClientInput>
  }

  export type UserUpdateManyWithoutClientNestedInput = {
    create?: XOR<UserCreateWithoutClientInput, UserUncheckedCreateWithoutClientInput> | UserCreateWithoutClientInput[] | UserUncheckedCreateWithoutClientInput[]
    connectOrCreate?: UserCreateOrConnectWithoutClientInput | UserCreateOrConnectWithoutClientInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutClientInput | UserUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: UserCreateManyClientInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutClientInput | UserUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: UserUpdateManyWithWhereWithoutClientInput | UserUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type InstanceUpdateManyWithoutClientNestedInput = {
    create?: XOR<InstanceCreateWithoutClientInput, InstanceUncheckedCreateWithoutClientInput> | InstanceCreateWithoutClientInput[] | InstanceUncheckedCreateWithoutClientInput[]
    connectOrCreate?: InstanceCreateOrConnectWithoutClientInput | InstanceCreateOrConnectWithoutClientInput[]
    upsert?: InstanceUpsertWithWhereUniqueWithoutClientInput | InstanceUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: InstanceCreateManyClientInputEnvelope
    set?: InstanceWhereUniqueInput | InstanceWhereUniqueInput[]
    disconnect?: InstanceWhereUniqueInput | InstanceWhereUniqueInput[]
    delete?: InstanceWhereUniqueInput | InstanceWhereUniqueInput[]
    connect?: InstanceWhereUniqueInput | InstanceWhereUniqueInput[]
    update?: InstanceUpdateWithWhereUniqueWithoutClientInput | InstanceUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: InstanceUpdateManyWithWhereWithoutClientInput | InstanceUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: InstanceScalarWhereInput | InstanceScalarWhereInput[]
  }

  export type PermissionUpdateManyWithoutClientNestedInput = {
    create?: XOR<PermissionCreateWithoutClientInput, PermissionUncheckedCreateWithoutClientInput> | PermissionCreateWithoutClientInput[] | PermissionUncheckedCreateWithoutClientInput[]
    connectOrCreate?: PermissionCreateOrConnectWithoutClientInput | PermissionCreateOrConnectWithoutClientInput[]
    upsert?: PermissionUpsertWithWhereUniqueWithoutClientInput | PermissionUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: PermissionCreateManyClientInputEnvelope
    set?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    disconnect?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    delete?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    connect?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    update?: PermissionUpdateWithWhereUniqueWithoutClientInput | PermissionUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: PermissionUpdateManyWithWhereWithoutClientInput | PermissionUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: PermissionScalarWhereInput | PermissionScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<UserCreateWithoutClientInput, UserUncheckedCreateWithoutClientInput> | UserCreateWithoutClientInput[] | UserUncheckedCreateWithoutClientInput[]
    connectOrCreate?: UserCreateOrConnectWithoutClientInput | UserCreateOrConnectWithoutClientInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutClientInput | UserUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: UserCreateManyClientInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutClientInput | UserUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: UserUpdateManyWithWhereWithoutClientInput | UserUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type InstanceUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<InstanceCreateWithoutClientInput, InstanceUncheckedCreateWithoutClientInput> | InstanceCreateWithoutClientInput[] | InstanceUncheckedCreateWithoutClientInput[]
    connectOrCreate?: InstanceCreateOrConnectWithoutClientInput | InstanceCreateOrConnectWithoutClientInput[]
    upsert?: InstanceUpsertWithWhereUniqueWithoutClientInput | InstanceUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: InstanceCreateManyClientInputEnvelope
    set?: InstanceWhereUniqueInput | InstanceWhereUniqueInput[]
    disconnect?: InstanceWhereUniqueInput | InstanceWhereUniqueInput[]
    delete?: InstanceWhereUniqueInput | InstanceWhereUniqueInput[]
    connect?: InstanceWhereUniqueInput | InstanceWhereUniqueInput[]
    update?: InstanceUpdateWithWhereUniqueWithoutClientInput | InstanceUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: InstanceUpdateManyWithWhereWithoutClientInput | InstanceUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: InstanceScalarWhereInput | InstanceScalarWhereInput[]
  }

  export type PermissionUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<PermissionCreateWithoutClientInput, PermissionUncheckedCreateWithoutClientInput> | PermissionCreateWithoutClientInput[] | PermissionUncheckedCreateWithoutClientInput[]
    connectOrCreate?: PermissionCreateOrConnectWithoutClientInput | PermissionCreateOrConnectWithoutClientInput[]
    upsert?: PermissionUpsertWithWhereUniqueWithoutClientInput | PermissionUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: PermissionCreateManyClientInputEnvelope
    set?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    disconnect?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    delete?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    connect?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    update?: PermissionUpdateWithWhereUniqueWithoutClientInput | PermissionUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: PermissionUpdateManyWithWhereWithoutClientInput | PermissionUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: PermissionScalarWhereInput | PermissionScalarWhereInput[]
  }

  export type PermissionCreateactionsInput = {
    set: string[]
  }

  export type PermissionCreatesubjectsInput = {
    set: string[]
  }

  export type ClientCreateNestedOneWithoutPermissionInput = {
    create?: XOR<ClientCreateWithoutPermissionInput, ClientUncheckedCreateWithoutPermissionInput>
    connectOrCreate?: ClientCreateOrConnectWithoutPermissionInput
    connect?: ClientWhereUniqueInput
  }

  export type PermissionUpdateactionsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type PermissionUpdatesubjectsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ClientUpdateOneRequiredWithoutPermissionNestedInput = {
    create?: XOR<ClientCreateWithoutPermissionInput, ClientUncheckedCreateWithoutPermissionInput>
    connectOrCreate?: ClientCreateOrConnectWithoutPermissionInput
    upsert?: ClientUpsertWithoutPermissionInput
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutPermissionInput, ClientUpdateWithoutPermissionInput>, ClientUncheckedUpdateWithoutPermissionInput>
  }

  export type InstanceCreateuserIdsInput = {
    set: string[]
  }

  export type ClientCreateNestedOneWithoutInstancesInput = {
    create?: XOR<ClientCreateWithoutInstancesInput, ClientUncheckedCreateWithoutInstancesInput>
    connectOrCreate?: ClientCreateOrConnectWithoutInstancesInput
    connect?: ClientWhereUniqueInput
  }

  export type LevelCreateNestedManyWithoutInstanceInput = {
    create?: XOR<LevelCreateWithoutInstanceInput, LevelUncheckedCreateWithoutInstanceInput> | LevelCreateWithoutInstanceInput[] | LevelUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: LevelCreateOrConnectWithoutInstanceInput | LevelCreateOrConnectWithoutInstanceInput[]
    createMany?: LevelCreateManyInstanceInputEnvelope
    connect?: LevelWhereUniqueInput | LevelWhereUniqueInput[]
  }

  export type VersionCreateNestedManyWithoutInstanceInput = {
    create?: XOR<VersionCreateWithoutInstanceInput, VersionUncheckedCreateWithoutInstanceInput> | VersionCreateWithoutInstanceInput[] | VersionUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: VersionCreateOrConnectWithoutInstanceInput | VersionCreateOrConnectWithoutInstanceInput[]
    createMany?: VersionCreateManyInstanceInputEnvelope
    connect?: VersionWhereUniqueInput | VersionWhereUniqueInput[]
  }

  export type CurrencyCreateNestedManyWithoutInstanceInput = {
    create?: XOR<CurrencyCreateWithoutInstanceInput, CurrencyUncheckedCreateWithoutInstanceInput> | CurrencyCreateWithoutInstanceInput[] | CurrencyUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: CurrencyCreateOrConnectWithoutInstanceInput | CurrencyCreateOrConnectWithoutInstanceInput[]
    createMany?: CurrencyCreateManyInstanceInputEnvelope
    connect?: CurrencyWhereUniqueInput | CurrencyWhereUniqueInput[]
  }

  export type AccountCreateNestedManyWithoutInstanceInput = {
    create?: XOR<AccountCreateWithoutInstanceInput, AccountUncheckedCreateWithoutInstanceInput> | AccountCreateWithoutInstanceInput[] | AccountUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutInstanceInput | AccountCreateOrConnectWithoutInstanceInput[]
    createMany?: AccountCreateManyInstanceInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type ModelCreateNestedManyWithoutInstanceInput = {
    create?: XOR<ModelCreateWithoutInstanceInput, ModelUncheckedCreateWithoutInstanceInput> | ModelCreateWithoutInstanceInput[] | ModelUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: ModelCreateOrConnectWithoutInstanceInput | ModelCreateOrConnectWithoutInstanceInput[]
    createMany?: ModelCreateManyInstanceInputEnvelope
    connect?: ModelWhereUniqueInput | ModelWhereUniqueInput[]
  }

  export type DimensionCreateNestedManyWithoutInstanceInput = {
    create?: XOR<DimensionCreateWithoutInstanceInput, DimensionUncheckedCreateWithoutInstanceInput> | DimensionCreateWithoutInstanceInput[] | DimensionUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: DimensionCreateOrConnectWithoutInstanceInput | DimensionCreateOrConnectWithoutInstanceInput[]
    createMany?: DimensionCreateManyInstanceInputEnvelope
    connect?: DimensionWhereUniqueInput | DimensionWhereUniqueInput[]
  }

  export type DimensionValueCreateNestedManyWithoutInstanceInput = {
    create?: XOR<DimensionValueCreateWithoutInstanceInput, DimensionValueUncheckedCreateWithoutInstanceInput> | DimensionValueCreateWithoutInstanceInput[] | DimensionValueUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: DimensionValueCreateOrConnectWithoutInstanceInput | DimensionValueCreateOrConnectWithoutInstanceInput[]
    createMany?: DimensionValueCreateManyInstanceInputEnvelope
    connect?: DimensionValueWhereUniqueInput | DimensionValueWhereUniqueInput[]
  }

  export type LevelAttributeCreateNestedManyWithoutInstanceInput = {
    create?: XOR<LevelAttributeCreateWithoutInstanceInput, LevelAttributeUncheckedCreateWithoutInstanceInput> | LevelAttributeCreateWithoutInstanceInput[] | LevelAttributeUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: LevelAttributeCreateOrConnectWithoutInstanceInput | LevelAttributeCreateOrConnectWithoutInstanceInput[]
    createMany?: LevelAttributeCreateManyInstanceInputEnvelope
    connect?: LevelAttributeWhereUniqueInput | LevelAttributeWhereUniqueInput[]
  }

  export type DimensionValueAttributeCreateNestedManyWithoutInstanceInput = {
    create?: XOR<DimensionValueAttributeCreateWithoutInstanceInput, DimensionValueAttributeUncheckedCreateWithoutInstanceInput> | DimensionValueAttributeCreateWithoutInstanceInput[] | DimensionValueAttributeUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: DimensionValueAttributeCreateOrConnectWithoutInstanceInput | DimensionValueAttributeCreateOrConnectWithoutInstanceInput[]
    createMany?: DimensionValueAttributeCreateManyInstanceInputEnvelope
    connect?: DimensionValueAttributeWhereUniqueInput | DimensionValueAttributeWhereUniqueInput[]
  }

  export type AccountAttributeCreateNestedManyWithoutInstanceInput = {
    create?: XOR<AccountAttributeCreateWithoutInstanceInput, AccountAttributeUncheckedCreateWithoutInstanceInput> | AccountAttributeCreateWithoutInstanceInput[] | AccountAttributeUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: AccountAttributeCreateOrConnectWithoutInstanceInput | AccountAttributeCreateOrConnectWithoutInstanceInput[]
    createMany?: AccountAttributeCreateManyInstanceInputEnvelope
    connect?: AccountAttributeWhereUniqueInput | AccountAttributeWhereUniqueInput[]
  }

  export type LevelAttributeValueCreateNestedManyWithoutInstanceInput = {
    create?: XOR<LevelAttributeValueCreateWithoutInstanceInput, LevelAttributeValueUncheckedCreateWithoutInstanceInput> | LevelAttributeValueCreateWithoutInstanceInput[] | LevelAttributeValueUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: LevelAttributeValueCreateOrConnectWithoutInstanceInput | LevelAttributeValueCreateOrConnectWithoutInstanceInput[]
    createMany?: LevelAttributeValueCreateManyInstanceInputEnvelope
    connect?: LevelAttributeValueWhereUniqueInput | LevelAttributeValueWhereUniqueInput[]
  }

  export type AccountAttributeValueCreateNestedManyWithoutInstanceInput = {
    create?: XOR<AccountAttributeValueCreateWithoutInstanceInput, AccountAttributeValueUncheckedCreateWithoutInstanceInput> | AccountAttributeValueCreateWithoutInstanceInput[] | AccountAttributeValueUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: AccountAttributeValueCreateOrConnectWithoutInstanceInput | AccountAttributeValueCreateOrConnectWithoutInstanceInput[]
    createMany?: AccountAttributeValueCreateManyInstanceInputEnvelope
    connect?: AccountAttributeValueWhereUniqueInput | AccountAttributeValueWhereUniqueInput[]
  }

  export type DimensionValueAttributeValueCreateNestedManyWithoutInstanceInput = {
    create?: XOR<DimensionValueAttributeValueCreateWithoutInstanceInput, DimensionValueAttributeValueUncheckedCreateWithoutInstanceInput> | DimensionValueAttributeValueCreateWithoutInstanceInput[] | DimensionValueAttributeValueUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: DimensionValueAttributeValueCreateOrConnectWithoutInstanceInput | DimensionValueAttributeValueCreateOrConnectWithoutInstanceInput[]
    createMany?: DimensionValueAttributeValueCreateManyInstanceInputEnvelope
    connect?: DimensionValueAttributeValueWhereUniqueInput | DimensionValueAttributeValueWhereUniqueInput[]
  }

  export type ModelDataCreateNestedManyWithoutInstanceInput = {
    create?: XOR<ModelDataCreateWithoutInstanceInput, ModelDataUncheckedCreateWithoutInstanceInput> | ModelDataCreateWithoutInstanceInput[] | ModelDataUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: ModelDataCreateOrConnectWithoutInstanceInput | ModelDataCreateOrConnectWithoutInstanceInput[]
    createMany?: ModelDataCreateManyInstanceInputEnvelope
    connect?: ModelDataWhereUniqueInput | ModelDataWhereUniqueInput[]
  }

  export type ModelDataCalculationsCreateNestedManyWithoutInstanceInput = {
    create?: XOR<ModelDataCalculationsCreateWithoutInstanceInput, ModelDataCalculationsUncheckedCreateWithoutInstanceInput> | ModelDataCalculationsCreateWithoutInstanceInput[] | ModelDataCalculationsUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: ModelDataCalculationsCreateOrConnectWithoutInstanceInput | ModelDataCalculationsCreateOrConnectWithoutInstanceInput[]
    createMany?: ModelDataCalculationsCreateManyInstanceInputEnvelope
    connect?: ModelDataCalculationsWhereUniqueInput | ModelDataCalculationsWhereUniqueInput[]
  }

  export type ModelAccountStructureCreateNestedManyWithoutInstanceInput = {
    create?: XOR<ModelAccountStructureCreateWithoutInstanceInput, ModelAccountStructureUncheckedCreateWithoutInstanceInput> | ModelAccountStructureCreateWithoutInstanceInput[] | ModelAccountStructureUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: ModelAccountStructureCreateOrConnectWithoutInstanceInput | ModelAccountStructureCreateOrConnectWithoutInstanceInput[]
    createMany?: ModelAccountStructureCreateManyInstanceInputEnvelope
    connect?: ModelAccountStructureWhereUniqueInput | ModelAccountStructureWhereUniqueInput[]
  }

  export type TableCreateNestedManyWithoutInstanceInput = {
    create?: XOR<TableCreateWithoutInstanceInput, TableUncheckedCreateWithoutInstanceInput> | TableCreateWithoutInstanceInput[] | TableUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: TableCreateOrConnectWithoutInstanceInput | TableCreateOrConnectWithoutInstanceInput[]
    createMany?: TableCreateManyInstanceInputEnvelope
    connect?: TableWhereUniqueInput | TableWhereUniqueInput[]
  }

  export type TableDataCreateNestedManyWithoutInstanceInput = {
    create?: XOR<TableDataCreateWithoutInstanceInput, TableDataUncheckedCreateWithoutInstanceInput> | TableDataCreateWithoutInstanceInput[] | TableDataUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: TableDataCreateOrConnectWithoutInstanceInput | TableDataCreateOrConnectWithoutInstanceInput[]
    createMany?: TableDataCreateManyInstanceInputEnvelope
    connect?: TableDataWhereUniqueInput | TableDataWhereUniqueInput[]
  }

  export type LevelUncheckedCreateNestedManyWithoutInstanceInput = {
    create?: XOR<LevelCreateWithoutInstanceInput, LevelUncheckedCreateWithoutInstanceInput> | LevelCreateWithoutInstanceInput[] | LevelUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: LevelCreateOrConnectWithoutInstanceInput | LevelCreateOrConnectWithoutInstanceInput[]
    createMany?: LevelCreateManyInstanceInputEnvelope
    connect?: LevelWhereUniqueInput | LevelWhereUniqueInput[]
  }

  export type VersionUncheckedCreateNestedManyWithoutInstanceInput = {
    create?: XOR<VersionCreateWithoutInstanceInput, VersionUncheckedCreateWithoutInstanceInput> | VersionCreateWithoutInstanceInput[] | VersionUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: VersionCreateOrConnectWithoutInstanceInput | VersionCreateOrConnectWithoutInstanceInput[]
    createMany?: VersionCreateManyInstanceInputEnvelope
    connect?: VersionWhereUniqueInput | VersionWhereUniqueInput[]
  }

  export type CurrencyUncheckedCreateNestedManyWithoutInstanceInput = {
    create?: XOR<CurrencyCreateWithoutInstanceInput, CurrencyUncheckedCreateWithoutInstanceInput> | CurrencyCreateWithoutInstanceInput[] | CurrencyUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: CurrencyCreateOrConnectWithoutInstanceInput | CurrencyCreateOrConnectWithoutInstanceInput[]
    createMany?: CurrencyCreateManyInstanceInputEnvelope
    connect?: CurrencyWhereUniqueInput | CurrencyWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutInstanceInput = {
    create?: XOR<AccountCreateWithoutInstanceInput, AccountUncheckedCreateWithoutInstanceInput> | AccountCreateWithoutInstanceInput[] | AccountUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutInstanceInput | AccountCreateOrConnectWithoutInstanceInput[]
    createMany?: AccountCreateManyInstanceInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type ModelUncheckedCreateNestedManyWithoutInstanceInput = {
    create?: XOR<ModelCreateWithoutInstanceInput, ModelUncheckedCreateWithoutInstanceInput> | ModelCreateWithoutInstanceInput[] | ModelUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: ModelCreateOrConnectWithoutInstanceInput | ModelCreateOrConnectWithoutInstanceInput[]
    createMany?: ModelCreateManyInstanceInputEnvelope
    connect?: ModelWhereUniqueInput | ModelWhereUniqueInput[]
  }

  export type DimensionUncheckedCreateNestedManyWithoutInstanceInput = {
    create?: XOR<DimensionCreateWithoutInstanceInput, DimensionUncheckedCreateWithoutInstanceInput> | DimensionCreateWithoutInstanceInput[] | DimensionUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: DimensionCreateOrConnectWithoutInstanceInput | DimensionCreateOrConnectWithoutInstanceInput[]
    createMany?: DimensionCreateManyInstanceInputEnvelope
    connect?: DimensionWhereUniqueInput | DimensionWhereUniqueInput[]
  }

  export type DimensionValueUncheckedCreateNestedManyWithoutInstanceInput = {
    create?: XOR<DimensionValueCreateWithoutInstanceInput, DimensionValueUncheckedCreateWithoutInstanceInput> | DimensionValueCreateWithoutInstanceInput[] | DimensionValueUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: DimensionValueCreateOrConnectWithoutInstanceInput | DimensionValueCreateOrConnectWithoutInstanceInput[]
    createMany?: DimensionValueCreateManyInstanceInputEnvelope
    connect?: DimensionValueWhereUniqueInput | DimensionValueWhereUniqueInput[]
  }

  export type LevelAttributeUncheckedCreateNestedManyWithoutInstanceInput = {
    create?: XOR<LevelAttributeCreateWithoutInstanceInput, LevelAttributeUncheckedCreateWithoutInstanceInput> | LevelAttributeCreateWithoutInstanceInput[] | LevelAttributeUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: LevelAttributeCreateOrConnectWithoutInstanceInput | LevelAttributeCreateOrConnectWithoutInstanceInput[]
    createMany?: LevelAttributeCreateManyInstanceInputEnvelope
    connect?: LevelAttributeWhereUniqueInput | LevelAttributeWhereUniqueInput[]
  }

  export type DimensionValueAttributeUncheckedCreateNestedManyWithoutInstanceInput = {
    create?: XOR<DimensionValueAttributeCreateWithoutInstanceInput, DimensionValueAttributeUncheckedCreateWithoutInstanceInput> | DimensionValueAttributeCreateWithoutInstanceInput[] | DimensionValueAttributeUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: DimensionValueAttributeCreateOrConnectWithoutInstanceInput | DimensionValueAttributeCreateOrConnectWithoutInstanceInput[]
    createMany?: DimensionValueAttributeCreateManyInstanceInputEnvelope
    connect?: DimensionValueAttributeWhereUniqueInput | DimensionValueAttributeWhereUniqueInput[]
  }

  export type AccountAttributeUncheckedCreateNestedManyWithoutInstanceInput = {
    create?: XOR<AccountAttributeCreateWithoutInstanceInput, AccountAttributeUncheckedCreateWithoutInstanceInput> | AccountAttributeCreateWithoutInstanceInput[] | AccountAttributeUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: AccountAttributeCreateOrConnectWithoutInstanceInput | AccountAttributeCreateOrConnectWithoutInstanceInput[]
    createMany?: AccountAttributeCreateManyInstanceInputEnvelope
    connect?: AccountAttributeWhereUniqueInput | AccountAttributeWhereUniqueInput[]
  }

  export type LevelAttributeValueUncheckedCreateNestedManyWithoutInstanceInput = {
    create?: XOR<LevelAttributeValueCreateWithoutInstanceInput, LevelAttributeValueUncheckedCreateWithoutInstanceInput> | LevelAttributeValueCreateWithoutInstanceInput[] | LevelAttributeValueUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: LevelAttributeValueCreateOrConnectWithoutInstanceInput | LevelAttributeValueCreateOrConnectWithoutInstanceInput[]
    createMany?: LevelAttributeValueCreateManyInstanceInputEnvelope
    connect?: LevelAttributeValueWhereUniqueInput | LevelAttributeValueWhereUniqueInput[]
  }

  export type AccountAttributeValueUncheckedCreateNestedManyWithoutInstanceInput = {
    create?: XOR<AccountAttributeValueCreateWithoutInstanceInput, AccountAttributeValueUncheckedCreateWithoutInstanceInput> | AccountAttributeValueCreateWithoutInstanceInput[] | AccountAttributeValueUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: AccountAttributeValueCreateOrConnectWithoutInstanceInput | AccountAttributeValueCreateOrConnectWithoutInstanceInput[]
    createMany?: AccountAttributeValueCreateManyInstanceInputEnvelope
    connect?: AccountAttributeValueWhereUniqueInput | AccountAttributeValueWhereUniqueInput[]
  }

  export type DimensionValueAttributeValueUncheckedCreateNestedManyWithoutInstanceInput = {
    create?: XOR<DimensionValueAttributeValueCreateWithoutInstanceInput, DimensionValueAttributeValueUncheckedCreateWithoutInstanceInput> | DimensionValueAttributeValueCreateWithoutInstanceInput[] | DimensionValueAttributeValueUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: DimensionValueAttributeValueCreateOrConnectWithoutInstanceInput | DimensionValueAttributeValueCreateOrConnectWithoutInstanceInput[]
    createMany?: DimensionValueAttributeValueCreateManyInstanceInputEnvelope
    connect?: DimensionValueAttributeValueWhereUniqueInput | DimensionValueAttributeValueWhereUniqueInput[]
  }

  export type ModelDataUncheckedCreateNestedManyWithoutInstanceInput = {
    create?: XOR<ModelDataCreateWithoutInstanceInput, ModelDataUncheckedCreateWithoutInstanceInput> | ModelDataCreateWithoutInstanceInput[] | ModelDataUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: ModelDataCreateOrConnectWithoutInstanceInput | ModelDataCreateOrConnectWithoutInstanceInput[]
    createMany?: ModelDataCreateManyInstanceInputEnvelope
    connect?: ModelDataWhereUniqueInput | ModelDataWhereUniqueInput[]
  }

  export type ModelDataCalculationsUncheckedCreateNestedManyWithoutInstanceInput = {
    create?: XOR<ModelDataCalculationsCreateWithoutInstanceInput, ModelDataCalculationsUncheckedCreateWithoutInstanceInput> | ModelDataCalculationsCreateWithoutInstanceInput[] | ModelDataCalculationsUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: ModelDataCalculationsCreateOrConnectWithoutInstanceInput | ModelDataCalculationsCreateOrConnectWithoutInstanceInput[]
    createMany?: ModelDataCalculationsCreateManyInstanceInputEnvelope
    connect?: ModelDataCalculationsWhereUniqueInput | ModelDataCalculationsWhereUniqueInput[]
  }

  export type ModelAccountStructureUncheckedCreateNestedManyWithoutInstanceInput = {
    create?: XOR<ModelAccountStructureCreateWithoutInstanceInput, ModelAccountStructureUncheckedCreateWithoutInstanceInput> | ModelAccountStructureCreateWithoutInstanceInput[] | ModelAccountStructureUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: ModelAccountStructureCreateOrConnectWithoutInstanceInput | ModelAccountStructureCreateOrConnectWithoutInstanceInput[]
    createMany?: ModelAccountStructureCreateManyInstanceInputEnvelope
    connect?: ModelAccountStructureWhereUniqueInput | ModelAccountStructureWhereUniqueInput[]
  }

  export type TableUncheckedCreateNestedManyWithoutInstanceInput = {
    create?: XOR<TableCreateWithoutInstanceInput, TableUncheckedCreateWithoutInstanceInput> | TableCreateWithoutInstanceInput[] | TableUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: TableCreateOrConnectWithoutInstanceInput | TableCreateOrConnectWithoutInstanceInput[]
    createMany?: TableCreateManyInstanceInputEnvelope
    connect?: TableWhereUniqueInput | TableWhereUniqueInput[]
  }

  export type TableDataUncheckedCreateNestedManyWithoutInstanceInput = {
    create?: XOR<TableDataCreateWithoutInstanceInput, TableDataUncheckedCreateWithoutInstanceInput> | TableDataCreateWithoutInstanceInput[] | TableDataUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: TableDataCreateOrConnectWithoutInstanceInput | TableDataCreateOrConnectWithoutInstanceInput[]
    createMany?: TableDataCreateManyInstanceInputEnvelope
    connect?: TableDataWhereUniqueInput | TableDataWhereUniqueInput[]
  }

  export type EnuminstanceStatusFieldUpdateOperationsInput = {
    set?: $Enums.instanceStatus
  }

  export type InstanceUpdateuserIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ClientUpdateOneRequiredWithoutInstancesNestedInput = {
    create?: XOR<ClientCreateWithoutInstancesInput, ClientUncheckedCreateWithoutInstancesInput>
    connectOrCreate?: ClientCreateOrConnectWithoutInstancesInput
    upsert?: ClientUpsertWithoutInstancesInput
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutInstancesInput, ClientUpdateWithoutInstancesInput>, ClientUncheckedUpdateWithoutInstancesInput>
  }

  export type LevelUpdateManyWithoutInstanceNestedInput = {
    create?: XOR<LevelCreateWithoutInstanceInput, LevelUncheckedCreateWithoutInstanceInput> | LevelCreateWithoutInstanceInput[] | LevelUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: LevelCreateOrConnectWithoutInstanceInput | LevelCreateOrConnectWithoutInstanceInput[]
    upsert?: LevelUpsertWithWhereUniqueWithoutInstanceInput | LevelUpsertWithWhereUniqueWithoutInstanceInput[]
    createMany?: LevelCreateManyInstanceInputEnvelope
    set?: LevelWhereUniqueInput | LevelWhereUniqueInput[]
    disconnect?: LevelWhereUniqueInput | LevelWhereUniqueInput[]
    delete?: LevelWhereUniqueInput | LevelWhereUniqueInput[]
    connect?: LevelWhereUniqueInput | LevelWhereUniqueInput[]
    update?: LevelUpdateWithWhereUniqueWithoutInstanceInput | LevelUpdateWithWhereUniqueWithoutInstanceInput[]
    updateMany?: LevelUpdateManyWithWhereWithoutInstanceInput | LevelUpdateManyWithWhereWithoutInstanceInput[]
    deleteMany?: LevelScalarWhereInput | LevelScalarWhereInput[]
  }

  export type VersionUpdateManyWithoutInstanceNestedInput = {
    create?: XOR<VersionCreateWithoutInstanceInput, VersionUncheckedCreateWithoutInstanceInput> | VersionCreateWithoutInstanceInput[] | VersionUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: VersionCreateOrConnectWithoutInstanceInput | VersionCreateOrConnectWithoutInstanceInput[]
    upsert?: VersionUpsertWithWhereUniqueWithoutInstanceInput | VersionUpsertWithWhereUniqueWithoutInstanceInput[]
    createMany?: VersionCreateManyInstanceInputEnvelope
    set?: VersionWhereUniqueInput | VersionWhereUniqueInput[]
    disconnect?: VersionWhereUniqueInput | VersionWhereUniqueInput[]
    delete?: VersionWhereUniqueInput | VersionWhereUniqueInput[]
    connect?: VersionWhereUniqueInput | VersionWhereUniqueInput[]
    update?: VersionUpdateWithWhereUniqueWithoutInstanceInput | VersionUpdateWithWhereUniqueWithoutInstanceInput[]
    updateMany?: VersionUpdateManyWithWhereWithoutInstanceInput | VersionUpdateManyWithWhereWithoutInstanceInput[]
    deleteMany?: VersionScalarWhereInput | VersionScalarWhereInput[]
  }

  export type CurrencyUpdateManyWithoutInstanceNestedInput = {
    create?: XOR<CurrencyCreateWithoutInstanceInput, CurrencyUncheckedCreateWithoutInstanceInput> | CurrencyCreateWithoutInstanceInput[] | CurrencyUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: CurrencyCreateOrConnectWithoutInstanceInput | CurrencyCreateOrConnectWithoutInstanceInput[]
    upsert?: CurrencyUpsertWithWhereUniqueWithoutInstanceInput | CurrencyUpsertWithWhereUniqueWithoutInstanceInput[]
    createMany?: CurrencyCreateManyInstanceInputEnvelope
    set?: CurrencyWhereUniqueInput | CurrencyWhereUniqueInput[]
    disconnect?: CurrencyWhereUniqueInput | CurrencyWhereUniqueInput[]
    delete?: CurrencyWhereUniqueInput | CurrencyWhereUniqueInput[]
    connect?: CurrencyWhereUniqueInput | CurrencyWhereUniqueInput[]
    update?: CurrencyUpdateWithWhereUniqueWithoutInstanceInput | CurrencyUpdateWithWhereUniqueWithoutInstanceInput[]
    updateMany?: CurrencyUpdateManyWithWhereWithoutInstanceInput | CurrencyUpdateManyWithWhereWithoutInstanceInput[]
    deleteMany?: CurrencyScalarWhereInput | CurrencyScalarWhereInput[]
  }

  export type AccountUpdateManyWithoutInstanceNestedInput = {
    create?: XOR<AccountCreateWithoutInstanceInput, AccountUncheckedCreateWithoutInstanceInput> | AccountCreateWithoutInstanceInput[] | AccountUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutInstanceInput | AccountCreateOrConnectWithoutInstanceInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutInstanceInput | AccountUpsertWithWhereUniqueWithoutInstanceInput[]
    createMany?: AccountCreateManyInstanceInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutInstanceInput | AccountUpdateWithWhereUniqueWithoutInstanceInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutInstanceInput | AccountUpdateManyWithWhereWithoutInstanceInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type ModelUpdateManyWithoutInstanceNestedInput = {
    create?: XOR<ModelCreateWithoutInstanceInput, ModelUncheckedCreateWithoutInstanceInput> | ModelCreateWithoutInstanceInput[] | ModelUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: ModelCreateOrConnectWithoutInstanceInput | ModelCreateOrConnectWithoutInstanceInput[]
    upsert?: ModelUpsertWithWhereUniqueWithoutInstanceInput | ModelUpsertWithWhereUniqueWithoutInstanceInput[]
    createMany?: ModelCreateManyInstanceInputEnvelope
    set?: ModelWhereUniqueInput | ModelWhereUniqueInput[]
    disconnect?: ModelWhereUniqueInput | ModelWhereUniqueInput[]
    delete?: ModelWhereUniqueInput | ModelWhereUniqueInput[]
    connect?: ModelWhereUniqueInput | ModelWhereUniqueInput[]
    update?: ModelUpdateWithWhereUniqueWithoutInstanceInput | ModelUpdateWithWhereUniqueWithoutInstanceInput[]
    updateMany?: ModelUpdateManyWithWhereWithoutInstanceInput | ModelUpdateManyWithWhereWithoutInstanceInput[]
    deleteMany?: ModelScalarWhereInput | ModelScalarWhereInput[]
  }

  export type DimensionUpdateManyWithoutInstanceNestedInput = {
    create?: XOR<DimensionCreateWithoutInstanceInput, DimensionUncheckedCreateWithoutInstanceInput> | DimensionCreateWithoutInstanceInput[] | DimensionUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: DimensionCreateOrConnectWithoutInstanceInput | DimensionCreateOrConnectWithoutInstanceInput[]
    upsert?: DimensionUpsertWithWhereUniqueWithoutInstanceInput | DimensionUpsertWithWhereUniqueWithoutInstanceInput[]
    createMany?: DimensionCreateManyInstanceInputEnvelope
    set?: DimensionWhereUniqueInput | DimensionWhereUniqueInput[]
    disconnect?: DimensionWhereUniqueInput | DimensionWhereUniqueInput[]
    delete?: DimensionWhereUniqueInput | DimensionWhereUniqueInput[]
    connect?: DimensionWhereUniqueInput | DimensionWhereUniqueInput[]
    update?: DimensionUpdateWithWhereUniqueWithoutInstanceInput | DimensionUpdateWithWhereUniqueWithoutInstanceInput[]
    updateMany?: DimensionUpdateManyWithWhereWithoutInstanceInput | DimensionUpdateManyWithWhereWithoutInstanceInput[]
    deleteMany?: DimensionScalarWhereInput | DimensionScalarWhereInput[]
  }

  export type DimensionValueUpdateManyWithoutInstanceNestedInput = {
    create?: XOR<DimensionValueCreateWithoutInstanceInput, DimensionValueUncheckedCreateWithoutInstanceInput> | DimensionValueCreateWithoutInstanceInput[] | DimensionValueUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: DimensionValueCreateOrConnectWithoutInstanceInput | DimensionValueCreateOrConnectWithoutInstanceInput[]
    upsert?: DimensionValueUpsertWithWhereUniqueWithoutInstanceInput | DimensionValueUpsertWithWhereUniqueWithoutInstanceInput[]
    createMany?: DimensionValueCreateManyInstanceInputEnvelope
    set?: DimensionValueWhereUniqueInput | DimensionValueWhereUniqueInput[]
    disconnect?: DimensionValueWhereUniqueInput | DimensionValueWhereUniqueInput[]
    delete?: DimensionValueWhereUniqueInput | DimensionValueWhereUniqueInput[]
    connect?: DimensionValueWhereUniqueInput | DimensionValueWhereUniqueInput[]
    update?: DimensionValueUpdateWithWhereUniqueWithoutInstanceInput | DimensionValueUpdateWithWhereUniqueWithoutInstanceInput[]
    updateMany?: DimensionValueUpdateManyWithWhereWithoutInstanceInput | DimensionValueUpdateManyWithWhereWithoutInstanceInput[]
    deleteMany?: DimensionValueScalarWhereInput | DimensionValueScalarWhereInput[]
  }

  export type LevelAttributeUpdateManyWithoutInstanceNestedInput = {
    create?: XOR<LevelAttributeCreateWithoutInstanceInput, LevelAttributeUncheckedCreateWithoutInstanceInput> | LevelAttributeCreateWithoutInstanceInput[] | LevelAttributeUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: LevelAttributeCreateOrConnectWithoutInstanceInput | LevelAttributeCreateOrConnectWithoutInstanceInput[]
    upsert?: LevelAttributeUpsertWithWhereUniqueWithoutInstanceInput | LevelAttributeUpsertWithWhereUniqueWithoutInstanceInput[]
    createMany?: LevelAttributeCreateManyInstanceInputEnvelope
    set?: LevelAttributeWhereUniqueInput | LevelAttributeWhereUniqueInput[]
    disconnect?: LevelAttributeWhereUniqueInput | LevelAttributeWhereUniqueInput[]
    delete?: LevelAttributeWhereUniqueInput | LevelAttributeWhereUniqueInput[]
    connect?: LevelAttributeWhereUniqueInput | LevelAttributeWhereUniqueInput[]
    update?: LevelAttributeUpdateWithWhereUniqueWithoutInstanceInput | LevelAttributeUpdateWithWhereUniqueWithoutInstanceInput[]
    updateMany?: LevelAttributeUpdateManyWithWhereWithoutInstanceInput | LevelAttributeUpdateManyWithWhereWithoutInstanceInput[]
    deleteMany?: LevelAttributeScalarWhereInput | LevelAttributeScalarWhereInput[]
  }

  export type DimensionValueAttributeUpdateManyWithoutInstanceNestedInput = {
    create?: XOR<DimensionValueAttributeCreateWithoutInstanceInput, DimensionValueAttributeUncheckedCreateWithoutInstanceInput> | DimensionValueAttributeCreateWithoutInstanceInput[] | DimensionValueAttributeUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: DimensionValueAttributeCreateOrConnectWithoutInstanceInput | DimensionValueAttributeCreateOrConnectWithoutInstanceInput[]
    upsert?: DimensionValueAttributeUpsertWithWhereUniqueWithoutInstanceInput | DimensionValueAttributeUpsertWithWhereUniqueWithoutInstanceInput[]
    createMany?: DimensionValueAttributeCreateManyInstanceInputEnvelope
    set?: DimensionValueAttributeWhereUniqueInput | DimensionValueAttributeWhereUniqueInput[]
    disconnect?: DimensionValueAttributeWhereUniqueInput | DimensionValueAttributeWhereUniqueInput[]
    delete?: DimensionValueAttributeWhereUniqueInput | DimensionValueAttributeWhereUniqueInput[]
    connect?: DimensionValueAttributeWhereUniqueInput | DimensionValueAttributeWhereUniqueInput[]
    update?: DimensionValueAttributeUpdateWithWhereUniqueWithoutInstanceInput | DimensionValueAttributeUpdateWithWhereUniqueWithoutInstanceInput[]
    updateMany?: DimensionValueAttributeUpdateManyWithWhereWithoutInstanceInput | DimensionValueAttributeUpdateManyWithWhereWithoutInstanceInput[]
    deleteMany?: DimensionValueAttributeScalarWhereInput | DimensionValueAttributeScalarWhereInput[]
  }

  export type AccountAttributeUpdateManyWithoutInstanceNestedInput = {
    create?: XOR<AccountAttributeCreateWithoutInstanceInput, AccountAttributeUncheckedCreateWithoutInstanceInput> | AccountAttributeCreateWithoutInstanceInput[] | AccountAttributeUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: AccountAttributeCreateOrConnectWithoutInstanceInput | AccountAttributeCreateOrConnectWithoutInstanceInput[]
    upsert?: AccountAttributeUpsertWithWhereUniqueWithoutInstanceInput | AccountAttributeUpsertWithWhereUniqueWithoutInstanceInput[]
    createMany?: AccountAttributeCreateManyInstanceInputEnvelope
    set?: AccountAttributeWhereUniqueInput | AccountAttributeWhereUniqueInput[]
    disconnect?: AccountAttributeWhereUniqueInput | AccountAttributeWhereUniqueInput[]
    delete?: AccountAttributeWhereUniqueInput | AccountAttributeWhereUniqueInput[]
    connect?: AccountAttributeWhereUniqueInput | AccountAttributeWhereUniqueInput[]
    update?: AccountAttributeUpdateWithWhereUniqueWithoutInstanceInput | AccountAttributeUpdateWithWhereUniqueWithoutInstanceInput[]
    updateMany?: AccountAttributeUpdateManyWithWhereWithoutInstanceInput | AccountAttributeUpdateManyWithWhereWithoutInstanceInput[]
    deleteMany?: AccountAttributeScalarWhereInput | AccountAttributeScalarWhereInput[]
  }

  export type LevelAttributeValueUpdateManyWithoutInstanceNestedInput = {
    create?: XOR<LevelAttributeValueCreateWithoutInstanceInput, LevelAttributeValueUncheckedCreateWithoutInstanceInput> | LevelAttributeValueCreateWithoutInstanceInput[] | LevelAttributeValueUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: LevelAttributeValueCreateOrConnectWithoutInstanceInput | LevelAttributeValueCreateOrConnectWithoutInstanceInput[]
    upsert?: LevelAttributeValueUpsertWithWhereUniqueWithoutInstanceInput | LevelAttributeValueUpsertWithWhereUniqueWithoutInstanceInput[]
    createMany?: LevelAttributeValueCreateManyInstanceInputEnvelope
    set?: LevelAttributeValueWhereUniqueInput | LevelAttributeValueWhereUniqueInput[]
    disconnect?: LevelAttributeValueWhereUniqueInput | LevelAttributeValueWhereUniqueInput[]
    delete?: LevelAttributeValueWhereUniqueInput | LevelAttributeValueWhereUniqueInput[]
    connect?: LevelAttributeValueWhereUniqueInput | LevelAttributeValueWhereUniqueInput[]
    update?: LevelAttributeValueUpdateWithWhereUniqueWithoutInstanceInput | LevelAttributeValueUpdateWithWhereUniqueWithoutInstanceInput[]
    updateMany?: LevelAttributeValueUpdateManyWithWhereWithoutInstanceInput | LevelAttributeValueUpdateManyWithWhereWithoutInstanceInput[]
    deleteMany?: LevelAttributeValueScalarWhereInput | LevelAttributeValueScalarWhereInput[]
  }

  export type AccountAttributeValueUpdateManyWithoutInstanceNestedInput = {
    create?: XOR<AccountAttributeValueCreateWithoutInstanceInput, AccountAttributeValueUncheckedCreateWithoutInstanceInput> | AccountAttributeValueCreateWithoutInstanceInput[] | AccountAttributeValueUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: AccountAttributeValueCreateOrConnectWithoutInstanceInput | AccountAttributeValueCreateOrConnectWithoutInstanceInput[]
    upsert?: AccountAttributeValueUpsertWithWhereUniqueWithoutInstanceInput | AccountAttributeValueUpsertWithWhereUniqueWithoutInstanceInput[]
    createMany?: AccountAttributeValueCreateManyInstanceInputEnvelope
    set?: AccountAttributeValueWhereUniqueInput | AccountAttributeValueWhereUniqueInput[]
    disconnect?: AccountAttributeValueWhereUniqueInput | AccountAttributeValueWhereUniqueInput[]
    delete?: AccountAttributeValueWhereUniqueInput | AccountAttributeValueWhereUniqueInput[]
    connect?: AccountAttributeValueWhereUniqueInput | AccountAttributeValueWhereUniqueInput[]
    update?: AccountAttributeValueUpdateWithWhereUniqueWithoutInstanceInput | AccountAttributeValueUpdateWithWhereUniqueWithoutInstanceInput[]
    updateMany?: AccountAttributeValueUpdateManyWithWhereWithoutInstanceInput | AccountAttributeValueUpdateManyWithWhereWithoutInstanceInput[]
    deleteMany?: AccountAttributeValueScalarWhereInput | AccountAttributeValueScalarWhereInput[]
  }

  export type DimensionValueAttributeValueUpdateManyWithoutInstanceNestedInput = {
    create?: XOR<DimensionValueAttributeValueCreateWithoutInstanceInput, DimensionValueAttributeValueUncheckedCreateWithoutInstanceInput> | DimensionValueAttributeValueCreateWithoutInstanceInput[] | DimensionValueAttributeValueUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: DimensionValueAttributeValueCreateOrConnectWithoutInstanceInput | DimensionValueAttributeValueCreateOrConnectWithoutInstanceInput[]
    upsert?: DimensionValueAttributeValueUpsertWithWhereUniqueWithoutInstanceInput | DimensionValueAttributeValueUpsertWithWhereUniqueWithoutInstanceInput[]
    createMany?: DimensionValueAttributeValueCreateManyInstanceInputEnvelope
    set?: DimensionValueAttributeValueWhereUniqueInput | DimensionValueAttributeValueWhereUniqueInput[]
    disconnect?: DimensionValueAttributeValueWhereUniqueInput | DimensionValueAttributeValueWhereUniqueInput[]
    delete?: DimensionValueAttributeValueWhereUniqueInput | DimensionValueAttributeValueWhereUniqueInput[]
    connect?: DimensionValueAttributeValueWhereUniqueInput | DimensionValueAttributeValueWhereUniqueInput[]
    update?: DimensionValueAttributeValueUpdateWithWhereUniqueWithoutInstanceInput | DimensionValueAttributeValueUpdateWithWhereUniqueWithoutInstanceInput[]
    updateMany?: DimensionValueAttributeValueUpdateManyWithWhereWithoutInstanceInput | DimensionValueAttributeValueUpdateManyWithWhereWithoutInstanceInput[]
    deleteMany?: DimensionValueAttributeValueScalarWhereInput | DimensionValueAttributeValueScalarWhereInput[]
  }

  export type ModelDataUpdateManyWithoutInstanceNestedInput = {
    create?: XOR<ModelDataCreateWithoutInstanceInput, ModelDataUncheckedCreateWithoutInstanceInput> | ModelDataCreateWithoutInstanceInput[] | ModelDataUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: ModelDataCreateOrConnectWithoutInstanceInput | ModelDataCreateOrConnectWithoutInstanceInput[]
    upsert?: ModelDataUpsertWithWhereUniqueWithoutInstanceInput | ModelDataUpsertWithWhereUniqueWithoutInstanceInput[]
    createMany?: ModelDataCreateManyInstanceInputEnvelope
    set?: ModelDataWhereUniqueInput | ModelDataWhereUniqueInput[]
    disconnect?: ModelDataWhereUniqueInput | ModelDataWhereUniqueInput[]
    delete?: ModelDataWhereUniqueInput | ModelDataWhereUniqueInput[]
    connect?: ModelDataWhereUniqueInput | ModelDataWhereUniqueInput[]
    update?: ModelDataUpdateWithWhereUniqueWithoutInstanceInput | ModelDataUpdateWithWhereUniqueWithoutInstanceInput[]
    updateMany?: ModelDataUpdateManyWithWhereWithoutInstanceInput | ModelDataUpdateManyWithWhereWithoutInstanceInput[]
    deleteMany?: ModelDataScalarWhereInput | ModelDataScalarWhereInput[]
  }

  export type ModelDataCalculationsUpdateManyWithoutInstanceNestedInput = {
    create?: XOR<ModelDataCalculationsCreateWithoutInstanceInput, ModelDataCalculationsUncheckedCreateWithoutInstanceInput> | ModelDataCalculationsCreateWithoutInstanceInput[] | ModelDataCalculationsUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: ModelDataCalculationsCreateOrConnectWithoutInstanceInput | ModelDataCalculationsCreateOrConnectWithoutInstanceInput[]
    upsert?: ModelDataCalculationsUpsertWithWhereUniqueWithoutInstanceInput | ModelDataCalculationsUpsertWithWhereUniqueWithoutInstanceInput[]
    createMany?: ModelDataCalculationsCreateManyInstanceInputEnvelope
    set?: ModelDataCalculationsWhereUniqueInput | ModelDataCalculationsWhereUniqueInput[]
    disconnect?: ModelDataCalculationsWhereUniqueInput | ModelDataCalculationsWhereUniqueInput[]
    delete?: ModelDataCalculationsWhereUniqueInput | ModelDataCalculationsWhereUniqueInput[]
    connect?: ModelDataCalculationsWhereUniqueInput | ModelDataCalculationsWhereUniqueInput[]
    update?: ModelDataCalculationsUpdateWithWhereUniqueWithoutInstanceInput | ModelDataCalculationsUpdateWithWhereUniqueWithoutInstanceInput[]
    updateMany?: ModelDataCalculationsUpdateManyWithWhereWithoutInstanceInput | ModelDataCalculationsUpdateManyWithWhereWithoutInstanceInput[]
    deleteMany?: ModelDataCalculationsScalarWhereInput | ModelDataCalculationsScalarWhereInput[]
  }

  export type ModelAccountStructureUpdateManyWithoutInstanceNestedInput = {
    create?: XOR<ModelAccountStructureCreateWithoutInstanceInput, ModelAccountStructureUncheckedCreateWithoutInstanceInput> | ModelAccountStructureCreateWithoutInstanceInput[] | ModelAccountStructureUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: ModelAccountStructureCreateOrConnectWithoutInstanceInput | ModelAccountStructureCreateOrConnectWithoutInstanceInput[]
    upsert?: ModelAccountStructureUpsertWithWhereUniqueWithoutInstanceInput | ModelAccountStructureUpsertWithWhereUniqueWithoutInstanceInput[]
    createMany?: ModelAccountStructureCreateManyInstanceInputEnvelope
    set?: ModelAccountStructureWhereUniqueInput | ModelAccountStructureWhereUniqueInput[]
    disconnect?: ModelAccountStructureWhereUniqueInput | ModelAccountStructureWhereUniqueInput[]
    delete?: ModelAccountStructureWhereUniqueInput | ModelAccountStructureWhereUniqueInput[]
    connect?: ModelAccountStructureWhereUniqueInput | ModelAccountStructureWhereUniqueInput[]
    update?: ModelAccountStructureUpdateWithWhereUniqueWithoutInstanceInput | ModelAccountStructureUpdateWithWhereUniqueWithoutInstanceInput[]
    updateMany?: ModelAccountStructureUpdateManyWithWhereWithoutInstanceInput | ModelAccountStructureUpdateManyWithWhereWithoutInstanceInput[]
    deleteMany?: ModelAccountStructureScalarWhereInput | ModelAccountStructureScalarWhereInput[]
  }

  export type TableUpdateManyWithoutInstanceNestedInput = {
    create?: XOR<TableCreateWithoutInstanceInput, TableUncheckedCreateWithoutInstanceInput> | TableCreateWithoutInstanceInput[] | TableUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: TableCreateOrConnectWithoutInstanceInput | TableCreateOrConnectWithoutInstanceInput[]
    upsert?: TableUpsertWithWhereUniqueWithoutInstanceInput | TableUpsertWithWhereUniqueWithoutInstanceInput[]
    createMany?: TableCreateManyInstanceInputEnvelope
    set?: TableWhereUniqueInput | TableWhereUniqueInput[]
    disconnect?: TableWhereUniqueInput | TableWhereUniqueInput[]
    delete?: TableWhereUniqueInput | TableWhereUniqueInput[]
    connect?: TableWhereUniqueInput | TableWhereUniqueInput[]
    update?: TableUpdateWithWhereUniqueWithoutInstanceInput | TableUpdateWithWhereUniqueWithoutInstanceInput[]
    updateMany?: TableUpdateManyWithWhereWithoutInstanceInput | TableUpdateManyWithWhereWithoutInstanceInput[]
    deleteMany?: TableScalarWhereInput | TableScalarWhereInput[]
  }

  export type TableDataUpdateManyWithoutInstanceNestedInput = {
    create?: XOR<TableDataCreateWithoutInstanceInput, TableDataUncheckedCreateWithoutInstanceInput> | TableDataCreateWithoutInstanceInput[] | TableDataUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: TableDataCreateOrConnectWithoutInstanceInput | TableDataCreateOrConnectWithoutInstanceInput[]
    upsert?: TableDataUpsertWithWhereUniqueWithoutInstanceInput | TableDataUpsertWithWhereUniqueWithoutInstanceInput[]
    createMany?: TableDataCreateManyInstanceInputEnvelope
    set?: TableDataWhereUniqueInput | TableDataWhereUniqueInput[]
    disconnect?: TableDataWhereUniqueInput | TableDataWhereUniqueInput[]
    delete?: TableDataWhereUniqueInput | TableDataWhereUniqueInput[]
    connect?: TableDataWhereUniqueInput | TableDataWhereUniqueInput[]
    update?: TableDataUpdateWithWhereUniqueWithoutInstanceInput | TableDataUpdateWithWhereUniqueWithoutInstanceInput[]
    updateMany?: TableDataUpdateManyWithWhereWithoutInstanceInput | TableDataUpdateManyWithWhereWithoutInstanceInput[]
    deleteMany?: TableDataScalarWhereInput | TableDataScalarWhereInput[]
  }

  export type LevelUncheckedUpdateManyWithoutInstanceNestedInput = {
    create?: XOR<LevelCreateWithoutInstanceInput, LevelUncheckedCreateWithoutInstanceInput> | LevelCreateWithoutInstanceInput[] | LevelUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: LevelCreateOrConnectWithoutInstanceInput | LevelCreateOrConnectWithoutInstanceInput[]
    upsert?: LevelUpsertWithWhereUniqueWithoutInstanceInput | LevelUpsertWithWhereUniqueWithoutInstanceInput[]
    createMany?: LevelCreateManyInstanceInputEnvelope
    set?: LevelWhereUniqueInput | LevelWhereUniqueInput[]
    disconnect?: LevelWhereUniqueInput | LevelWhereUniqueInput[]
    delete?: LevelWhereUniqueInput | LevelWhereUniqueInput[]
    connect?: LevelWhereUniqueInput | LevelWhereUniqueInput[]
    update?: LevelUpdateWithWhereUniqueWithoutInstanceInput | LevelUpdateWithWhereUniqueWithoutInstanceInput[]
    updateMany?: LevelUpdateManyWithWhereWithoutInstanceInput | LevelUpdateManyWithWhereWithoutInstanceInput[]
    deleteMany?: LevelScalarWhereInput | LevelScalarWhereInput[]
  }

  export type VersionUncheckedUpdateManyWithoutInstanceNestedInput = {
    create?: XOR<VersionCreateWithoutInstanceInput, VersionUncheckedCreateWithoutInstanceInput> | VersionCreateWithoutInstanceInput[] | VersionUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: VersionCreateOrConnectWithoutInstanceInput | VersionCreateOrConnectWithoutInstanceInput[]
    upsert?: VersionUpsertWithWhereUniqueWithoutInstanceInput | VersionUpsertWithWhereUniqueWithoutInstanceInput[]
    createMany?: VersionCreateManyInstanceInputEnvelope
    set?: VersionWhereUniqueInput | VersionWhereUniqueInput[]
    disconnect?: VersionWhereUniqueInput | VersionWhereUniqueInput[]
    delete?: VersionWhereUniqueInput | VersionWhereUniqueInput[]
    connect?: VersionWhereUniqueInput | VersionWhereUniqueInput[]
    update?: VersionUpdateWithWhereUniqueWithoutInstanceInput | VersionUpdateWithWhereUniqueWithoutInstanceInput[]
    updateMany?: VersionUpdateManyWithWhereWithoutInstanceInput | VersionUpdateManyWithWhereWithoutInstanceInput[]
    deleteMany?: VersionScalarWhereInput | VersionScalarWhereInput[]
  }

  export type CurrencyUncheckedUpdateManyWithoutInstanceNestedInput = {
    create?: XOR<CurrencyCreateWithoutInstanceInput, CurrencyUncheckedCreateWithoutInstanceInput> | CurrencyCreateWithoutInstanceInput[] | CurrencyUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: CurrencyCreateOrConnectWithoutInstanceInput | CurrencyCreateOrConnectWithoutInstanceInput[]
    upsert?: CurrencyUpsertWithWhereUniqueWithoutInstanceInput | CurrencyUpsertWithWhereUniqueWithoutInstanceInput[]
    createMany?: CurrencyCreateManyInstanceInputEnvelope
    set?: CurrencyWhereUniqueInput | CurrencyWhereUniqueInput[]
    disconnect?: CurrencyWhereUniqueInput | CurrencyWhereUniqueInput[]
    delete?: CurrencyWhereUniqueInput | CurrencyWhereUniqueInput[]
    connect?: CurrencyWhereUniqueInput | CurrencyWhereUniqueInput[]
    update?: CurrencyUpdateWithWhereUniqueWithoutInstanceInput | CurrencyUpdateWithWhereUniqueWithoutInstanceInput[]
    updateMany?: CurrencyUpdateManyWithWhereWithoutInstanceInput | CurrencyUpdateManyWithWhereWithoutInstanceInput[]
    deleteMany?: CurrencyScalarWhereInput | CurrencyScalarWhereInput[]
  }

  export type AccountUncheckedUpdateManyWithoutInstanceNestedInput = {
    create?: XOR<AccountCreateWithoutInstanceInput, AccountUncheckedCreateWithoutInstanceInput> | AccountCreateWithoutInstanceInput[] | AccountUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutInstanceInput | AccountCreateOrConnectWithoutInstanceInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutInstanceInput | AccountUpsertWithWhereUniqueWithoutInstanceInput[]
    createMany?: AccountCreateManyInstanceInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutInstanceInput | AccountUpdateWithWhereUniqueWithoutInstanceInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutInstanceInput | AccountUpdateManyWithWhereWithoutInstanceInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type ModelUncheckedUpdateManyWithoutInstanceNestedInput = {
    create?: XOR<ModelCreateWithoutInstanceInput, ModelUncheckedCreateWithoutInstanceInput> | ModelCreateWithoutInstanceInput[] | ModelUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: ModelCreateOrConnectWithoutInstanceInput | ModelCreateOrConnectWithoutInstanceInput[]
    upsert?: ModelUpsertWithWhereUniqueWithoutInstanceInput | ModelUpsertWithWhereUniqueWithoutInstanceInput[]
    createMany?: ModelCreateManyInstanceInputEnvelope
    set?: ModelWhereUniqueInput | ModelWhereUniqueInput[]
    disconnect?: ModelWhereUniqueInput | ModelWhereUniqueInput[]
    delete?: ModelWhereUniqueInput | ModelWhereUniqueInput[]
    connect?: ModelWhereUniqueInput | ModelWhereUniqueInput[]
    update?: ModelUpdateWithWhereUniqueWithoutInstanceInput | ModelUpdateWithWhereUniqueWithoutInstanceInput[]
    updateMany?: ModelUpdateManyWithWhereWithoutInstanceInput | ModelUpdateManyWithWhereWithoutInstanceInput[]
    deleteMany?: ModelScalarWhereInput | ModelScalarWhereInput[]
  }

  export type DimensionUncheckedUpdateManyWithoutInstanceNestedInput = {
    create?: XOR<DimensionCreateWithoutInstanceInput, DimensionUncheckedCreateWithoutInstanceInput> | DimensionCreateWithoutInstanceInput[] | DimensionUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: DimensionCreateOrConnectWithoutInstanceInput | DimensionCreateOrConnectWithoutInstanceInput[]
    upsert?: DimensionUpsertWithWhereUniqueWithoutInstanceInput | DimensionUpsertWithWhereUniqueWithoutInstanceInput[]
    createMany?: DimensionCreateManyInstanceInputEnvelope
    set?: DimensionWhereUniqueInput | DimensionWhereUniqueInput[]
    disconnect?: DimensionWhereUniqueInput | DimensionWhereUniqueInput[]
    delete?: DimensionWhereUniqueInput | DimensionWhereUniqueInput[]
    connect?: DimensionWhereUniqueInput | DimensionWhereUniqueInput[]
    update?: DimensionUpdateWithWhereUniqueWithoutInstanceInput | DimensionUpdateWithWhereUniqueWithoutInstanceInput[]
    updateMany?: DimensionUpdateManyWithWhereWithoutInstanceInput | DimensionUpdateManyWithWhereWithoutInstanceInput[]
    deleteMany?: DimensionScalarWhereInput | DimensionScalarWhereInput[]
  }

  export type DimensionValueUncheckedUpdateManyWithoutInstanceNestedInput = {
    create?: XOR<DimensionValueCreateWithoutInstanceInput, DimensionValueUncheckedCreateWithoutInstanceInput> | DimensionValueCreateWithoutInstanceInput[] | DimensionValueUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: DimensionValueCreateOrConnectWithoutInstanceInput | DimensionValueCreateOrConnectWithoutInstanceInput[]
    upsert?: DimensionValueUpsertWithWhereUniqueWithoutInstanceInput | DimensionValueUpsertWithWhereUniqueWithoutInstanceInput[]
    createMany?: DimensionValueCreateManyInstanceInputEnvelope
    set?: DimensionValueWhereUniqueInput | DimensionValueWhereUniqueInput[]
    disconnect?: DimensionValueWhereUniqueInput | DimensionValueWhereUniqueInput[]
    delete?: DimensionValueWhereUniqueInput | DimensionValueWhereUniqueInput[]
    connect?: DimensionValueWhereUniqueInput | DimensionValueWhereUniqueInput[]
    update?: DimensionValueUpdateWithWhereUniqueWithoutInstanceInput | DimensionValueUpdateWithWhereUniqueWithoutInstanceInput[]
    updateMany?: DimensionValueUpdateManyWithWhereWithoutInstanceInput | DimensionValueUpdateManyWithWhereWithoutInstanceInput[]
    deleteMany?: DimensionValueScalarWhereInput | DimensionValueScalarWhereInput[]
  }

  export type LevelAttributeUncheckedUpdateManyWithoutInstanceNestedInput = {
    create?: XOR<LevelAttributeCreateWithoutInstanceInput, LevelAttributeUncheckedCreateWithoutInstanceInput> | LevelAttributeCreateWithoutInstanceInput[] | LevelAttributeUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: LevelAttributeCreateOrConnectWithoutInstanceInput | LevelAttributeCreateOrConnectWithoutInstanceInput[]
    upsert?: LevelAttributeUpsertWithWhereUniqueWithoutInstanceInput | LevelAttributeUpsertWithWhereUniqueWithoutInstanceInput[]
    createMany?: LevelAttributeCreateManyInstanceInputEnvelope
    set?: LevelAttributeWhereUniqueInput | LevelAttributeWhereUniqueInput[]
    disconnect?: LevelAttributeWhereUniqueInput | LevelAttributeWhereUniqueInput[]
    delete?: LevelAttributeWhereUniqueInput | LevelAttributeWhereUniqueInput[]
    connect?: LevelAttributeWhereUniqueInput | LevelAttributeWhereUniqueInput[]
    update?: LevelAttributeUpdateWithWhereUniqueWithoutInstanceInput | LevelAttributeUpdateWithWhereUniqueWithoutInstanceInput[]
    updateMany?: LevelAttributeUpdateManyWithWhereWithoutInstanceInput | LevelAttributeUpdateManyWithWhereWithoutInstanceInput[]
    deleteMany?: LevelAttributeScalarWhereInput | LevelAttributeScalarWhereInput[]
  }

  export type DimensionValueAttributeUncheckedUpdateManyWithoutInstanceNestedInput = {
    create?: XOR<DimensionValueAttributeCreateWithoutInstanceInput, DimensionValueAttributeUncheckedCreateWithoutInstanceInput> | DimensionValueAttributeCreateWithoutInstanceInput[] | DimensionValueAttributeUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: DimensionValueAttributeCreateOrConnectWithoutInstanceInput | DimensionValueAttributeCreateOrConnectWithoutInstanceInput[]
    upsert?: DimensionValueAttributeUpsertWithWhereUniqueWithoutInstanceInput | DimensionValueAttributeUpsertWithWhereUniqueWithoutInstanceInput[]
    createMany?: DimensionValueAttributeCreateManyInstanceInputEnvelope
    set?: DimensionValueAttributeWhereUniqueInput | DimensionValueAttributeWhereUniqueInput[]
    disconnect?: DimensionValueAttributeWhereUniqueInput | DimensionValueAttributeWhereUniqueInput[]
    delete?: DimensionValueAttributeWhereUniqueInput | DimensionValueAttributeWhereUniqueInput[]
    connect?: DimensionValueAttributeWhereUniqueInput | DimensionValueAttributeWhereUniqueInput[]
    update?: DimensionValueAttributeUpdateWithWhereUniqueWithoutInstanceInput | DimensionValueAttributeUpdateWithWhereUniqueWithoutInstanceInput[]
    updateMany?: DimensionValueAttributeUpdateManyWithWhereWithoutInstanceInput | DimensionValueAttributeUpdateManyWithWhereWithoutInstanceInput[]
    deleteMany?: DimensionValueAttributeScalarWhereInput | DimensionValueAttributeScalarWhereInput[]
  }

  export type AccountAttributeUncheckedUpdateManyWithoutInstanceNestedInput = {
    create?: XOR<AccountAttributeCreateWithoutInstanceInput, AccountAttributeUncheckedCreateWithoutInstanceInput> | AccountAttributeCreateWithoutInstanceInput[] | AccountAttributeUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: AccountAttributeCreateOrConnectWithoutInstanceInput | AccountAttributeCreateOrConnectWithoutInstanceInput[]
    upsert?: AccountAttributeUpsertWithWhereUniqueWithoutInstanceInput | AccountAttributeUpsertWithWhereUniqueWithoutInstanceInput[]
    createMany?: AccountAttributeCreateManyInstanceInputEnvelope
    set?: AccountAttributeWhereUniqueInput | AccountAttributeWhereUniqueInput[]
    disconnect?: AccountAttributeWhereUniqueInput | AccountAttributeWhereUniqueInput[]
    delete?: AccountAttributeWhereUniqueInput | AccountAttributeWhereUniqueInput[]
    connect?: AccountAttributeWhereUniqueInput | AccountAttributeWhereUniqueInput[]
    update?: AccountAttributeUpdateWithWhereUniqueWithoutInstanceInput | AccountAttributeUpdateWithWhereUniqueWithoutInstanceInput[]
    updateMany?: AccountAttributeUpdateManyWithWhereWithoutInstanceInput | AccountAttributeUpdateManyWithWhereWithoutInstanceInput[]
    deleteMany?: AccountAttributeScalarWhereInput | AccountAttributeScalarWhereInput[]
  }

  export type LevelAttributeValueUncheckedUpdateManyWithoutInstanceNestedInput = {
    create?: XOR<LevelAttributeValueCreateWithoutInstanceInput, LevelAttributeValueUncheckedCreateWithoutInstanceInput> | LevelAttributeValueCreateWithoutInstanceInput[] | LevelAttributeValueUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: LevelAttributeValueCreateOrConnectWithoutInstanceInput | LevelAttributeValueCreateOrConnectWithoutInstanceInput[]
    upsert?: LevelAttributeValueUpsertWithWhereUniqueWithoutInstanceInput | LevelAttributeValueUpsertWithWhereUniqueWithoutInstanceInput[]
    createMany?: LevelAttributeValueCreateManyInstanceInputEnvelope
    set?: LevelAttributeValueWhereUniqueInput | LevelAttributeValueWhereUniqueInput[]
    disconnect?: LevelAttributeValueWhereUniqueInput | LevelAttributeValueWhereUniqueInput[]
    delete?: LevelAttributeValueWhereUniqueInput | LevelAttributeValueWhereUniqueInput[]
    connect?: LevelAttributeValueWhereUniqueInput | LevelAttributeValueWhereUniqueInput[]
    update?: LevelAttributeValueUpdateWithWhereUniqueWithoutInstanceInput | LevelAttributeValueUpdateWithWhereUniqueWithoutInstanceInput[]
    updateMany?: LevelAttributeValueUpdateManyWithWhereWithoutInstanceInput | LevelAttributeValueUpdateManyWithWhereWithoutInstanceInput[]
    deleteMany?: LevelAttributeValueScalarWhereInput | LevelAttributeValueScalarWhereInput[]
  }

  export type AccountAttributeValueUncheckedUpdateManyWithoutInstanceNestedInput = {
    create?: XOR<AccountAttributeValueCreateWithoutInstanceInput, AccountAttributeValueUncheckedCreateWithoutInstanceInput> | AccountAttributeValueCreateWithoutInstanceInput[] | AccountAttributeValueUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: AccountAttributeValueCreateOrConnectWithoutInstanceInput | AccountAttributeValueCreateOrConnectWithoutInstanceInput[]
    upsert?: AccountAttributeValueUpsertWithWhereUniqueWithoutInstanceInput | AccountAttributeValueUpsertWithWhereUniqueWithoutInstanceInput[]
    createMany?: AccountAttributeValueCreateManyInstanceInputEnvelope
    set?: AccountAttributeValueWhereUniqueInput | AccountAttributeValueWhereUniqueInput[]
    disconnect?: AccountAttributeValueWhereUniqueInput | AccountAttributeValueWhereUniqueInput[]
    delete?: AccountAttributeValueWhereUniqueInput | AccountAttributeValueWhereUniqueInput[]
    connect?: AccountAttributeValueWhereUniqueInput | AccountAttributeValueWhereUniqueInput[]
    update?: AccountAttributeValueUpdateWithWhereUniqueWithoutInstanceInput | AccountAttributeValueUpdateWithWhereUniqueWithoutInstanceInput[]
    updateMany?: AccountAttributeValueUpdateManyWithWhereWithoutInstanceInput | AccountAttributeValueUpdateManyWithWhereWithoutInstanceInput[]
    deleteMany?: AccountAttributeValueScalarWhereInput | AccountAttributeValueScalarWhereInput[]
  }

  export type DimensionValueAttributeValueUncheckedUpdateManyWithoutInstanceNestedInput = {
    create?: XOR<DimensionValueAttributeValueCreateWithoutInstanceInput, DimensionValueAttributeValueUncheckedCreateWithoutInstanceInput> | DimensionValueAttributeValueCreateWithoutInstanceInput[] | DimensionValueAttributeValueUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: DimensionValueAttributeValueCreateOrConnectWithoutInstanceInput | DimensionValueAttributeValueCreateOrConnectWithoutInstanceInput[]
    upsert?: DimensionValueAttributeValueUpsertWithWhereUniqueWithoutInstanceInput | DimensionValueAttributeValueUpsertWithWhereUniqueWithoutInstanceInput[]
    createMany?: DimensionValueAttributeValueCreateManyInstanceInputEnvelope
    set?: DimensionValueAttributeValueWhereUniqueInput | DimensionValueAttributeValueWhereUniqueInput[]
    disconnect?: DimensionValueAttributeValueWhereUniqueInput | DimensionValueAttributeValueWhereUniqueInput[]
    delete?: DimensionValueAttributeValueWhereUniqueInput | DimensionValueAttributeValueWhereUniqueInput[]
    connect?: DimensionValueAttributeValueWhereUniqueInput | DimensionValueAttributeValueWhereUniqueInput[]
    update?: DimensionValueAttributeValueUpdateWithWhereUniqueWithoutInstanceInput | DimensionValueAttributeValueUpdateWithWhereUniqueWithoutInstanceInput[]
    updateMany?: DimensionValueAttributeValueUpdateManyWithWhereWithoutInstanceInput | DimensionValueAttributeValueUpdateManyWithWhereWithoutInstanceInput[]
    deleteMany?: DimensionValueAttributeValueScalarWhereInput | DimensionValueAttributeValueScalarWhereInput[]
  }

  export type ModelDataUncheckedUpdateManyWithoutInstanceNestedInput = {
    create?: XOR<ModelDataCreateWithoutInstanceInput, ModelDataUncheckedCreateWithoutInstanceInput> | ModelDataCreateWithoutInstanceInput[] | ModelDataUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: ModelDataCreateOrConnectWithoutInstanceInput | ModelDataCreateOrConnectWithoutInstanceInput[]
    upsert?: ModelDataUpsertWithWhereUniqueWithoutInstanceInput | ModelDataUpsertWithWhereUniqueWithoutInstanceInput[]
    createMany?: ModelDataCreateManyInstanceInputEnvelope
    set?: ModelDataWhereUniqueInput | ModelDataWhereUniqueInput[]
    disconnect?: ModelDataWhereUniqueInput | ModelDataWhereUniqueInput[]
    delete?: ModelDataWhereUniqueInput | ModelDataWhereUniqueInput[]
    connect?: ModelDataWhereUniqueInput | ModelDataWhereUniqueInput[]
    update?: ModelDataUpdateWithWhereUniqueWithoutInstanceInput | ModelDataUpdateWithWhereUniqueWithoutInstanceInput[]
    updateMany?: ModelDataUpdateManyWithWhereWithoutInstanceInput | ModelDataUpdateManyWithWhereWithoutInstanceInput[]
    deleteMany?: ModelDataScalarWhereInput | ModelDataScalarWhereInput[]
  }

  export type ModelDataCalculationsUncheckedUpdateManyWithoutInstanceNestedInput = {
    create?: XOR<ModelDataCalculationsCreateWithoutInstanceInput, ModelDataCalculationsUncheckedCreateWithoutInstanceInput> | ModelDataCalculationsCreateWithoutInstanceInput[] | ModelDataCalculationsUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: ModelDataCalculationsCreateOrConnectWithoutInstanceInput | ModelDataCalculationsCreateOrConnectWithoutInstanceInput[]
    upsert?: ModelDataCalculationsUpsertWithWhereUniqueWithoutInstanceInput | ModelDataCalculationsUpsertWithWhereUniqueWithoutInstanceInput[]
    createMany?: ModelDataCalculationsCreateManyInstanceInputEnvelope
    set?: ModelDataCalculationsWhereUniqueInput | ModelDataCalculationsWhereUniqueInput[]
    disconnect?: ModelDataCalculationsWhereUniqueInput | ModelDataCalculationsWhereUniqueInput[]
    delete?: ModelDataCalculationsWhereUniqueInput | ModelDataCalculationsWhereUniqueInput[]
    connect?: ModelDataCalculationsWhereUniqueInput | ModelDataCalculationsWhereUniqueInput[]
    update?: ModelDataCalculationsUpdateWithWhereUniqueWithoutInstanceInput | ModelDataCalculationsUpdateWithWhereUniqueWithoutInstanceInput[]
    updateMany?: ModelDataCalculationsUpdateManyWithWhereWithoutInstanceInput | ModelDataCalculationsUpdateManyWithWhereWithoutInstanceInput[]
    deleteMany?: ModelDataCalculationsScalarWhereInput | ModelDataCalculationsScalarWhereInput[]
  }

  export type ModelAccountStructureUncheckedUpdateManyWithoutInstanceNestedInput = {
    create?: XOR<ModelAccountStructureCreateWithoutInstanceInput, ModelAccountStructureUncheckedCreateWithoutInstanceInput> | ModelAccountStructureCreateWithoutInstanceInput[] | ModelAccountStructureUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: ModelAccountStructureCreateOrConnectWithoutInstanceInput | ModelAccountStructureCreateOrConnectWithoutInstanceInput[]
    upsert?: ModelAccountStructureUpsertWithWhereUniqueWithoutInstanceInput | ModelAccountStructureUpsertWithWhereUniqueWithoutInstanceInput[]
    createMany?: ModelAccountStructureCreateManyInstanceInputEnvelope
    set?: ModelAccountStructureWhereUniqueInput | ModelAccountStructureWhereUniqueInput[]
    disconnect?: ModelAccountStructureWhereUniqueInput | ModelAccountStructureWhereUniqueInput[]
    delete?: ModelAccountStructureWhereUniqueInput | ModelAccountStructureWhereUniqueInput[]
    connect?: ModelAccountStructureWhereUniqueInput | ModelAccountStructureWhereUniqueInput[]
    update?: ModelAccountStructureUpdateWithWhereUniqueWithoutInstanceInput | ModelAccountStructureUpdateWithWhereUniqueWithoutInstanceInput[]
    updateMany?: ModelAccountStructureUpdateManyWithWhereWithoutInstanceInput | ModelAccountStructureUpdateManyWithWhereWithoutInstanceInput[]
    deleteMany?: ModelAccountStructureScalarWhereInput | ModelAccountStructureScalarWhereInput[]
  }

  export type TableUncheckedUpdateManyWithoutInstanceNestedInput = {
    create?: XOR<TableCreateWithoutInstanceInput, TableUncheckedCreateWithoutInstanceInput> | TableCreateWithoutInstanceInput[] | TableUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: TableCreateOrConnectWithoutInstanceInput | TableCreateOrConnectWithoutInstanceInput[]
    upsert?: TableUpsertWithWhereUniqueWithoutInstanceInput | TableUpsertWithWhereUniqueWithoutInstanceInput[]
    createMany?: TableCreateManyInstanceInputEnvelope
    set?: TableWhereUniqueInput | TableWhereUniqueInput[]
    disconnect?: TableWhereUniqueInput | TableWhereUniqueInput[]
    delete?: TableWhereUniqueInput | TableWhereUniqueInput[]
    connect?: TableWhereUniqueInput | TableWhereUniqueInput[]
    update?: TableUpdateWithWhereUniqueWithoutInstanceInput | TableUpdateWithWhereUniqueWithoutInstanceInput[]
    updateMany?: TableUpdateManyWithWhereWithoutInstanceInput | TableUpdateManyWithWhereWithoutInstanceInput[]
    deleteMany?: TableScalarWhereInput | TableScalarWhereInput[]
  }

  export type TableDataUncheckedUpdateManyWithoutInstanceNestedInput = {
    create?: XOR<TableDataCreateWithoutInstanceInput, TableDataUncheckedCreateWithoutInstanceInput> | TableDataCreateWithoutInstanceInput[] | TableDataUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: TableDataCreateOrConnectWithoutInstanceInput | TableDataCreateOrConnectWithoutInstanceInput[]
    upsert?: TableDataUpsertWithWhereUniqueWithoutInstanceInput | TableDataUpsertWithWhereUniqueWithoutInstanceInput[]
    createMany?: TableDataCreateManyInstanceInputEnvelope
    set?: TableDataWhereUniqueInput | TableDataWhereUniqueInput[]
    disconnect?: TableDataWhereUniqueInput | TableDataWhereUniqueInput[]
    delete?: TableDataWhereUniqueInput | TableDataWhereUniqueInput[]
    connect?: TableDataWhereUniqueInput | TableDataWhereUniqueInput[]
    update?: TableDataUpdateWithWhereUniqueWithoutInstanceInput | TableDataUpdateWithWhereUniqueWithoutInstanceInput[]
    updateMany?: TableDataUpdateManyWithWhereWithoutInstanceInput | TableDataUpdateManyWithWhereWithoutInstanceInput[]
    deleteMany?: TableDataScalarWhereInput | TableDataScalarWhereInput[]
  }

  export type InstanceCreateNestedOneWithoutVersionsInput = {
    create?: XOR<InstanceCreateWithoutVersionsInput, InstanceUncheckedCreateWithoutVersionsInput>
    connectOrCreate?: InstanceCreateOrConnectWithoutVersionsInput
    connect?: InstanceWhereUniqueInput
  }

  export type ModelDataCreateNestedManyWithoutVersionInput = {
    create?: XOR<ModelDataCreateWithoutVersionInput, ModelDataUncheckedCreateWithoutVersionInput> | ModelDataCreateWithoutVersionInput[] | ModelDataUncheckedCreateWithoutVersionInput[]
    connectOrCreate?: ModelDataCreateOrConnectWithoutVersionInput | ModelDataCreateOrConnectWithoutVersionInput[]
    createMany?: ModelDataCreateManyVersionInputEnvelope
    connect?: ModelDataWhereUniqueInput | ModelDataWhereUniqueInput[]
  }

  export type ModelDataCalculationsCreateNestedManyWithoutVersionInput = {
    create?: XOR<ModelDataCalculationsCreateWithoutVersionInput, ModelDataCalculationsUncheckedCreateWithoutVersionInput> | ModelDataCalculationsCreateWithoutVersionInput[] | ModelDataCalculationsUncheckedCreateWithoutVersionInput[]
    connectOrCreate?: ModelDataCalculationsCreateOrConnectWithoutVersionInput | ModelDataCalculationsCreateOrConnectWithoutVersionInput[]
    createMany?: ModelDataCalculationsCreateManyVersionInputEnvelope
    connect?: ModelDataCalculationsWhereUniqueInput | ModelDataCalculationsWhereUniqueInput[]
  }

  export type ModelDataUncheckedCreateNestedManyWithoutVersionInput = {
    create?: XOR<ModelDataCreateWithoutVersionInput, ModelDataUncheckedCreateWithoutVersionInput> | ModelDataCreateWithoutVersionInput[] | ModelDataUncheckedCreateWithoutVersionInput[]
    connectOrCreate?: ModelDataCreateOrConnectWithoutVersionInput | ModelDataCreateOrConnectWithoutVersionInput[]
    createMany?: ModelDataCreateManyVersionInputEnvelope
    connect?: ModelDataWhereUniqueInput | ModelDataWhereUniqueInput[]
  }

  export type ModelDataCalculationsUncheckedCreateNestedManyWithoutVersionInput = {
    create?: XOR<ModelDataCalculationsCreateWithoutVersionInput, ModelDataCalculationsUncheckedCreateWithoutVersionInput> | ModelDataCalculationsCreateWithoutVersionInput[] | ModelDataCalculationsUncheckedCreateWithoutVersionInput[]
    connectOrCreate?: ModelDataCalculationsCreateOrConnectWithoutVersionInput | ModelDataCalculationsCreateOrConnectWithoutVersionInput[]
    createMany?: ModelDataCalculationsCreateManyVersionInputEnvelope
    connect?: ModelDataCalculationsWhereUniqueInput | ModelDataCalculationsWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type EnumversionStatusFieldUpdateOperationsInput = {
    set?: $Enums.versionStatus
  }

  export type InstanceUpdateOneRequiredWithoutVersionsNestedInput = {
    create?: XOR<InstanceCreateWithoutVersionsInput, InstanceUncheckedCreateWithoutVersionsInput>
    connectOrCreate?: InstanceCreateOrConnectWithoutVersionsInput
    upsert?: InstanceUpsertWithoutVersionsInput
    connect?: InstanceWhereUniqueInput
    update?: XOR<XOR<InstanceUpdateToOneWithWhereWithoutVersionsInput, InstanceUpdateWithoutVersionsInput>, InstanceUncheckedUpdateWithoutVersionsInput>
  }

  export type ModelDataUpdateManyWithoutVersionNestedInput = {
    create?: XOR<ModelDataCreateWithoutVersionInput, ModelDataUncheckedCreateWithoutVersionInput> | ModelDataCreateWithoutVersionInput[] | ModelDataUncheckedCreateWithoutVersionInput[]
    connectOrCreate?: ModelDataCreateOrConnectWithoutVersionInput | ModelDataCreateOrConnectWithoutVersionInput[]
    upsert?: ModelDataUpsertWithWhereUniqueWithoutVersionInput | ModelDataUpsertWithWhereUniqueWithoutVersionInput[]
    createMany?: ModelDataCreateManyVersionInputEnvelope
    set?: ModelDataWhereUniqueInput | ModelDataWhereUniqueInput[]
    disconnect?: ModelDataWhereUniqueInput | ModelDataWhereUniqueInput[]
    delete?: ModelDataWhereUniqueInput | ModelDataWhereUniqueInput[]
    connect?: ModelDataWhereUniqueInput | ModelDataWhereUniqueInput[]
    update?: ModelDataUpdateWithWhereUniqueWithoutVersionInput | ModelDataUpdateWithWhereUniqueWithoutVersionInput[]
    updateMany?: ModelDataUpdateManyWithWhereWithoutVersionInput | ModelDataUpdateManyWithWhereWithoutVersionInput[]
    deleteMany?: ModelDataScalarWhereInput | ModelDataScalarWhereInput[]
  }

  export type ModelDataCalculationsUpdateManyWithoutVersionNestedInput = {
    create?: XOR<ModelDataCalculationsCreateWithoutVersionInput, ModelDataCalculationsUncheckedCreateWithoutVersionInput> | ModelDataCalculationsCreateWithoutVersionInput[] | ModelDataCalculationsUncheckedCreateWithoutVersionInput[]
    connectOrCreate?: ModelDataCalculationsCreateOrConnectWithoutVersionInput | ModelDataCalculationsCreateOrConnectWithoutVersionInput[]
    upsert?: ModelDataCalculationsUpsertWithWhereUniqueWithoutVersionInput | ModelDataCalculationsUpsertWithWhereUniqueWithoutVersionInput[]
    createMany?: ModelDataCalculationsCreateManyVersionInputEnvelope
    set?: ModelDataCalculationsWhereUniqueInput | ModelDataCalculationsWhereUniqueInput[]
    disconnect?: ModelDataCalculationsWhereUniqueInput | ModelDataCalculationsWhereUniqueInput[]
    delete?: ModelDataCalculationsWhereUniqueInput | ModelDataCalculationsWhereUniqueInput[]
    connect?: ModelDataCalculationsWhereUniqueInput | ModelDataCalculationsWhereUniqueInput[]
    update?: ModelDataCalculationsUpdateWithWhereUniqueWithoutVersionInput | ModelDataCalculationsUpdateWithWhereUniqueWithoutVersionInput[]
    updateMany?: ModelDataCalculationsUpdateManyWithWhereWithoutVersionInput | ModelDataCalculationsUpdateManyWithWhereWithoutVersionInput[]
    deleteMany?: ModelDataCalculationsScalarWhereInput | ModelDataCalculationsScalarWhereInput[]
  }

  export type ModelDataUncheckedUpdateManyWithoutVersionNestedInput = {
    create?: XOR<ModelDataCreateWithoutVersionInput, ModelDataUncheckedCreateWithoutVersionInput> | ModelDataCreateWithoutVersionInput[] | ModelDataUncheckedCreateWithoutVersionInput[]
    connectOrCreate?: ModelDataCreateOrConnectWithoutVersionInput | ModelDataCreateOrConnectWithoutVersionInput[]
    upsert?: ModelDataUpsertWithWhereUniqueWithoutVersionInput | ModelDataUpsertWithWhereUniqueWithoutVersionInput[]
    createMany?: ModelDataCreateManyVersionInputEnvelope
    set?: ModelDataWhereUniqueInput | ModelDataWhereUniqueInput[]
    disconnect?: ModelDataWhereUniqueInput | ModelDataWhereUniqueInput[]
    delete?: ModelDataWhereUniqueInput | ModelDataWhereUniqueInput[]
    connect?: ModelDataWhereUniqueInput | ModelDataWhereUniqueInput[]
    update?: ModelDataUpdateWithWhereUniqueWithoutVersionInput | ModelDataUpdateWithWhereUniqueWithoutVersionInput[]
    updateMany?: ModelDataUpdateManyWithWhereWithoutVersionInput | ModelDataUpdateManyWithWhereWithoutVersionInput[]
    deleteMany?: ModelDataScalarWhereInput | ModelDataScalarWhereInput[]
  }

  export type ModelDataCalculationsUncheckedUpdateManyWithoutVersionNestedInput = {
    create?: XOR<ModelDataCalculationsCreateWithoutVersionInput, ModelDataCalculationsUncheckedCreateWithoutVersionInput> | ModelDataCalculationsCreateWithoutVersionInput[] | ModelDataCalculationsUncheckedCreateWithoutVersionInput[]
    connectOrCreate?: ModelDataCalculationsCreateOrConnectWithoutVersionInput | ModelDataCalculationsCreateOrConnectWithoutVersionInput[]
    upsert?: ModelDataCalculationsUpsertWithWhereUniqueWithoutVersionInput | ModelDataCalculationsUpsertWithWhereUniqueWithoutVersionInput[]
    createMany?: ModelDataCalculationsCreateManyVersionInputEnvelope
    set?: ModelDataCalculationsWhereUniqueInput | ModelDataCalculationsWhereUniqueInput[]
    disconnect?: ModelDataCalculationsWhereUniqueInput | ModelDataCalculationsWhereUniqueInput[]
    delete?: ModelDataCalculationsWhereUniqueInput | ModelDataCalculationsWhereUniqueInput[]
    connect?: ModelDataCalculationsWhereUniqueInput | ModelDataCalculationsWhereUniqueInput[]
    update?: ModelDataCalculationsUpdateWithWhereUniqueWithoutVersionInput | ModelDataCalculationsUpdateWithWhereUniqueWithoutVersionInput[]
    updateMany?: ModelDataCalculationsUpdateManyWithWhereWithoutVersionInput | ModelDataCalculationsUpdateManyWithWhereWithoutVersionInput[]
    deleteMany?: ModelDataCalculationsScalarWhereInput | ModelDataCalculationsScalarWhereInput[]
  }

  export type CurrencyCreateNestedManyWithoutCurrencyIsoCodeInput = {
    create?: XOR<CurrencyCreateWithoutCurrencyIsoCodeInput, CurrencyUncheckedCreateWithoutCurrencyIsoCodeInput> | CurrencyCreateWithoutCurrencyIsoCodeInput[] | CurrencyUncheckedCreateWithoutCurrencyIsoCodeInput[]
    connectOrCreate?: CurrencyCreateOrConnectWithoutCurrencyIsoCodeInput | CurrencyCreateOrConnectWithoutCurrencyIsoCodeInput[]
    createMany?: CurrencyCreateManyCurrencyIsoCodeInputEnvelope
    connect?: CurrencyWhereUniqueInput | CurrencyWhereUniqueInput[]
  }

  export type ConfigCreateNestedManyWithoutDefaultIsoCurrencyInput = {
    create?: XOR<ConfigCreateWithoutDefaultIsoCurrencyInput, ConfigUncheckedCreateWithoutDefaultIsoCurrencyInput> | ConfigCreateWithoutDefaultIsoCurrencyInput[] | ConfigUncheckedCreateWithoutDefaultIsoCurrencyInput[]
    connectOrCreate?: ConfigCreateOrConnectWithoutDefaultIsoCurrencyInput | ConfigCreateOrConnectWithoutDefaultIsoCurrencyInput[]
    createMany?: ConfigCreateManyDefaultIsoCurrencyInputEnvelope
    connect?: ConfigWhereUniqueInput | ConfigWhereUniqueInput[]
  }

  export type CurrencyUncheckedCreateNestedManyWithoutCurrencyIsoCodeInput = {
    create?: XOR<CurrencyCreateWithoutCurrencyIsoCodeInput, CurrencyUncheckedCreateWithoutCurrencyIsoCodeInput> | CurrencyCreateWithoutCurrencyIsoCodeInput[] | CurrencyUncheckedCreateWithoutCurrencyIsoCodeInput[]
    connectOrCreate?: CurrencyCreateOrConnectWithoutCurrencyIsoCodeInput | CurrencyCreateOrConnectWithoutCurrencyIsoCodeInput[]
    createMany?: CurrencyCreateManyCurrencyIsoCodeInputEnvelope
    connect?: CurrencyWhereUniqueInput | CurrencyWhereUniqueInput[]
  }

  export type ConfigUncheckedCreateNestedManyWithoutDefaultIsoCurrencyInput = {
    create?: XOR<ConfigCreateWithoutDefaultIsoCurrencyInput, ConfigUncheckedCreateWithoutDefaultIsoCurrencyInput> | ConfigCreateWithoutDefaultIsoCurrencyInput[] | ConfigUncheckedCreateWithoutDefaultIsoCurrencyInput[]
    connectOrCreate?: ConfigCreateOrConnectWithoutDefaultIsoCurrencyInput | ConfigCreateOrConnectWithoutDefaultIsoCurrencyInput[]
    createMany?: ConfigCreateManyDefaultIsoCurrencyInputEnvelope
    connect?: ConfigWhereUniqueInput | ConfigWhereUniqueInput[]
  }

  export type CurrencyUpdateManyWithoutCurrencyIsoCodeNestedInput = {
    create?: XOR<CurrencyCreateWithoutCurrencyIsoCodeInput, CurrencyUncheckedCreateWithoutCurrencyIsoCodeInput> | CurrencyCreateWithoutCurrencyIsoCodeInput[] | CurrencyUncheckedCreateWithoutCurrencyIsoCodeInput[]
    connectOrCreate?: CurrencyCreateOrConnectWithoutCurrencyIsoCodeInput | CurrencyCreateOrConnectWithoutCurrencyIsoCodeInput[]
    upsert?: CurrencyUpsertWithWhereUniqueWithoutCurrencyIsoCodeInput | CurrencyUpsertWithWhereUniqueWithoutCurrencyIsoCodeInput[]
    createMany?: CurrencyCreateManyCurrencyIsoCodeInputEnvelope
    set?: CurrencyWhereUniqueInput | CurrencyWhereUniqueInput[]
    disconnect?: CurrencyWhereUniqueInput | CurrencyWhereUniqueInput[]
    delete?: CurrencyWhereUniqueInput | CurrencyWhereUniqueInput[]
    connect?: CurrencyWhereUniqueInput | CurrencyWhereUniqueInput[]
    update?: CurrencyUpdateWithWhereUniqueWithoutCurrencyIsoCodeInput | CurrencyUpdateWithWhereUniqueWithoutCurrencyIsoCodeInput[]
    updateMany?: CurrencyUpdateManyWithWhereWithoutCurrencyIsoCodeInput | CurrencyUpdateManyWithWhereWithoutCurrencyIsoCodeInput[]
    deleteMany?: CurrencyScalarWhereInput | CurrencyScalarWhereInput[]
  }

  export type ConfigUpdateManyWithoutDefaultIsoCurrencyNestedInput = {
    create?: XOR<ConfigCreateWithoutDefaultIsoCurrencyInput, ConfigUncheckedCreateWithoutDefaultIsoCurrencyInput> | ConfigCreateWithoutDefaultIsoCurrencyInput[] | ConfigUncheckedCreateWithoutDefaultIsoCurrencyInput[]
    connectOrCreate?: ConfigCreateOrConnectWithoutDefaultIsoCurrencyInput | ConfigCreateOrConnectWithoutDefaultIsoCurrencyInput[]
    upsert?: ConfigUpsertWithWhereUniqueWithoutDefaultIsoCurrencyInput | ConfigUpsertWithWhereUniqueWithoutDefaultIsoCurrencyInput[]
    createMany?: ConfigCreateManyDefaultIsoCurrencyInputEnvelope
    set?: ConfigWhereUniqueInput | ConfigWhereUniqueInput[]
    disconnect?: ConfigWhereUniqueInput | ConfigWhereUniqueInput[]
    delete?: ConfigWhereUniqueInput | ConfigWhereUniqueInput[]
    connect?: ConfigWhereUniqueInput | ConfigWhereUniqueInput[]
    update?: ConfigUpdateWithWhereUniqueWithoutDefaultIsoCurrencyInput | ConfigUpdateWithWhereUniqueWithoutDefaultIsoCurrencyInput[]
    updateMany?: ConfigUpdateManyWithWhereWithoutDefaultIsoCurrencyInput | ConfigUpdateManyWithWhereWithoutDefaultIsoCurrencyInput[]
    deleteMany?: ConfigScalarWhereInput | ConfigScalarWhereInput[]
  }

  export type CurrencyUncheckedUpdateManyWithoutCurrencyIsoCodeNestedInput = {
    create?: XOR<CurrencyCreateWithoutCurrencyIsoCodeInput, CurrencyUncheckedCreateWithoutCurrencyIsoCodeInput> | CurrencyCreateWithoutCurrencyIsoCodeInput[] | CurrencyUncheckedCreateWithoutCurrencyIsoCodeInput[]
    connectOrCreate?: CurrencyCreateOrConnectWithoutCurrencyIsoCodeInput | CurrencyCreateOrConnectWithoutCurrencyIsoCodeInput[]
    upsert?: CurrencyUpsertWithWhereUniqueWithoutCurrencyIsoCodeInput | CurrencyUpsertWithWhereUniqueWithoutCurrencyIsoCodeInput[]
    createMany?: CurrencyCreateManyCurrencyIsoCodeInputEnvelope
    set?: CurrencyWhereUniqueInput | CurrencyWhereUniqueInput[]
    disconnect?: CurrencyWhereUniqueInput | CurrencyWhereUniqueInput[]
    delete?: CurrencyWhereUniqueInput | CurrencyWhereUniqueInput[]
    connect?: CurrencyWhereUniqueInput | CurrencyWhereUniqueInput[]
    update?: CurrencyUpdateWithWhereUniqueWithoutCurrencyIsoCodeInput | CurrencyUpdateWithWhereUniqueWithoutCurrencyIsoCodeInput[]
    updateMany?: CurrencyUpdateManyWithWhereWithoutCurrencyIsoCodeInput | CurrencyUpdateManyWithWhereWithoutCurrencyIsoCodeInput[]
    deleteMany?: CurrencyScalarWhereInput | CurrencyScalarWhereInput[]
  }

  export type ConfigUncheckedUpdateManyWithoutDefaultIsoCurrencyNestedInput = {
    create?: XOR<ConfigCreateWithoutDefaultIsoCurrencyInput, ConfigUncheckedCreateWithoutDefaultIsoCurrencyInput> | ConfigCreateWithoutDefaultIsoCurrencyInput[] | ConfigUncheckedCreateWithoutDefaultIsoCurrencyInput[]
    connectOrCreate?: ConfigCreateOrConnectWithoutDefaultIsoCurrencyInput | ConfigCreateOrConnectWithoutDefaultIsoCurrencyInput[]
    upsert?: ConfigUpsertWithWhereUniqueWithoutDefaultIsoCurrencyInput | ConfigUpsertWithWhereUniqueWithoutDefaultIsoCurrencyInput[]
    createMany?: ConfigCreateManyDefaultIsoCurrencyInputEnvelope
    set?: ConfigWhereUniqueInput | ConfigWhereUniqueInput[]
    disconnect?: ConfigWhereUniqueInput | ConfigWhereUniqueInput[]
    delete?: ConfigWhereUniqueInput | ConfigWhereUniqueInput[]
    connect?: ConfigWhereUniqueInput | ConfigWhereUniqueInput[]
    update?: ConfigUpdateWithWhereUniqueWithoutDefaultIsoCurrencyInput | ConfigUpdateWithWhereUniqueWithoutDefaultIsoCurrencyInput[]
    updateMany?: ConfigUpdateManyWithWhereWithoutDefaultIsoCurrencyInput | ConfigUpdateManyWithWhereWithoutDefaultIsoCurrencyInput[]
    deleteMany?: ConfigScalarWhereInput | ConfigScalarWhereInput[]
  }

  export type CurrencyIsoCodeCreateNestedOneWithoutCurrenciesInput = {
    create?: XOR<CurrencyIsoCodeCreateWithoutCurrenciesInput, CurrencyIsoCodeUncheckedCreateWithoutCurrenciesInput>
    connectOrCreate?: CurrencyIsoCodeCreateOrConnectWithoutCurrenciesInput
    connect?: CurrencyIsoCodeWhereUniqueInput
  }

  export type InstanceCreateNestedOneWithoutCurrenciesInput = {
    create?: XOR<InstanceCreateWithoutCurrenciesInput, InstanceUncheckedCreateWithoutCurrenciesInput>
    connectOrCreate?: InstanceCreateOrConnectWithoutCurrenciesInput
    connect?: InstanceWhereUniqueInput
  }

  export type LevelCreateNestedManyWithoutCurrencyInput = {
    create?: XOR<LevelCreateWithoutCurrencyInput, LevelUncheckedCreateWithoutCurrencyInput> | LevelCreateWithoutCurrencyInput[] | LevelUncheckedCreateWithoutCurrencyInput[]
    connectOrCreate?: LevelCreateOrConnectWithoutCurrencyInput | LevelCreateOrConnectWithoutCurrencyInput[]
    createMany?: LevelCreateManyCurrencyInputEnvelope
    connect?: LevelWhereUniqueInput | LevelWhereUniqueInput[]
  }

  export type ConfigCreateNestedManyWithoutDefaultCurrencyInput = {
    create?: XOR<ConfigCreateWithoutDefaultCurrencyInput, ConfigUncheckedCreateWithoutDefaultCurrencyInput> | ConfigCreateWithoutDefaultCurrencyInput[] | ConfigUncheckedCreateWithoutDefaultCurrencyInput[]
    connectOrCreate?: ConfigCreateOrConnectWithoutDefaultCurrencyInput | ConfigCreateOrConnectWithoutDefaultCurrencyInput[]
    createMany?: ConfigCreateManyDefaultCurrencyInputEnvelope
    connect?: ConfigWhereUniqueInput | ConfigWhereUniqueInput[]
  }

  export type LevelUncheckedCreateNestedManyWithoutCurrencyInput = {
    create?: XOR<LevelCreateWithoutCurrencyInput, LevelUncheckedCreateWithoutCurrencyInput> | LevelCreateWithoutCurrencyInput[] | LevelUncheckedCreateWithoutCurrencyInput[]
    connectOrCreate?: LevelCreateOrConnectWithoutCurrencyInput | LevelCreateOrConnectWithoutCurrencyInput[]
    createMany?: LevelCreateManyCurrencyInputEnvelope
    connect?: LevelWhereUniqueInput | LevelWhereUniqueInput[]
  }

  export type ConfigUncheckedCreateNestedManyWithoutDefaultCurrencyInput = {
    create?: XOR<ConfigCreateWithoutDefaultCurrencyInput, ConfigUncheckedCreateWithoutDefaultCurrencyInput> | ConfigCreateWithoutDefaultCurrencyInput[] | ConfigUncheckedCreateWithoutDefaultCurrencyInput[]
    connectOrCreate?: ConfigCreateOrConnectWithoutDefaultCurrencyInput | ConfigCreateOrConnectWithoutDefaultCurrencyInput[]
    createMany?: ConfigCreateManyDefaultCurrencyInputEnvelope
    connect?: ConfigWhereUniqueInput | ConfigWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumYesNoFieldUpdateOperationsInput = {
    set?: $Enums.YesNo
  }

  export type CurrencyIsoCodeUpdateOneRequiredWithoutCurrenciesNestedInput = {
    create?: XOR<CurrencyIsoCodeCreateWithoutCurrenciesInput, CurrencyIsoCodeUncheckedCreateWithoutCurrenciesInput>
    connectOrCreate?: CurrencyIsoCodeCreateOrConnectWithoutCurrenciesInput
    upsert?: CurrencyIsoCodeUpsertWithoutCurrenciesInput
    connect?: CurrencyIsoCodeWhereUniqueInput
    update?: XOR<XOR<CurrencyIsoCodeUpdateToOneWithWhereWithoutCurrenciesInput, CurrencyIsoCodeUpdateWithoutCurrenciesInput>, CurrencyIsoCodeUncheckedUpdateWithoutCurrenciesInput>
  }

  export type InstanceUpdateOneRequiredWithoutCurrenciesNestedInput = {
    create?: XOR<InstanceCreateWithoutCurrenciesInput, InstanceUncheckedCreateWithoutCurrenciesInput>
    connectOrCreate?: InstanceCreateOrConnectWithoutCurrenciesInput
    upsert?: InstanceUpsertWithoutCurrenciesInput
    connect?: InstanceWhereUniqueInput
    update?: XOR<XOR<InstanceUpdateToOneWithWhereWithoutCurrenciesInput, InstanceUpdateWithoutCurrenciesInput>, InstanceUncheckedUpdateWithoutCurrenciesInput>
  }

  export type LevelUpdateManyWithoutCurrencyNestedInput = {
    create?: XOR<LevelCreateWithoutCurrencyInput, LevelUncheckedCreateWithoutCurrencyInput> | LevelCreateWithoutCurrencyInput[] | LevelUncheckedCreateWithoutCurrencyInput[]
    connectOrCreate?: LevelCreateOrConnectWithoutCurrencyInput | LevelCreateOrConnectWithoutCurrencyInput[]
    upsert?: LevelUpsertWithWhereUniqueWithoutCurrencyInput | LevelUpsertWithWhereUniqueWithoutCurrencyInput[]
    createMany?: LevelCreateManyCurrencyInputEnvelope
    set?: LevelWhereUniqueInput | LevelWhereUniqueInput[]
    disconnect?: LevelWhereUniqueInput | LevelWhereUniqueInput[]
    delete?: LevelWhereUniqueInput | LevelWhereUniqueInput[]
    connect?: LevelWhereUniqueInput | LevelWhereUniqueInput[]
    update?: LevelUpdateWithWhereUniqueWithoutCurrencyInput | LevelUpdateWithWhereUniqueWithoutCurrencyInput[]
    updateMany?: LevelUpdateManyWithWhereWithoutCurrencyInput | LevelUpdateManyWithWhereWithoutCurrencyInput[]
    deleteMany?: LevelScalarWhereInput | LevelScalarWhereInput[]
  }

  export type ConfigUpdateManyWithoutDefaultCurrencyNestedInput = {
    create?: XOR<ConfigCreateWithoutDefaultCurrencyInput, ConfigUncheckedCreateWithoutDefaultCurrencyInput> | ConfigCreateWithoutDefaultCurrencyInput[] | ConfigUncheckedCreateWithoutDefaultCurrencyInput[]
    connectOrCreate?: ConfigCreateOrConnectWithoutDefaultCurrencyInput | ConfigCreateOrConnectWithoutDefaultCurrencyInput[]
    upsert?: ConfigUpsertWithWhereUniqueWithoutDefaultCurrencyInput | ConfigUpsertWithWhereUniqueWithoutDefaultCurrencyInput[]
    createMany?: ConfigCreateManyDefaultCurrencyInputEnvelope
    set?: ConfigWhereUniqueInput | ConfigWhereUniqueInput[]
    disconnect?: ConfigWhereUniqueInput | ConfigWhereUniqueInput[]
    delete?: ConfigWhereUniqueInput | ConfigWhereUniqueInput[]
    connect?: ConfigWhereUniqueInput | ConfigWhereUniqueInput[]
    update?: ConfigUpdateWithWhereUniqueWithoutDefaultCurrencyInput | ConfigUpdateWithWhereUniqueWithoutDefaultCurrencyInput[]
    updateMany?: ConfigUpdateManyWithWhereWithoutDefaultCurrencyInput | ConfigUpdateManyWithWhereWithoutDefaultCurrencyInput[]
    deleteMany?: ConfigScalarWhereInput | ConfigScalarWhereInput[]
  }

  export type LevelUncheckedUpdateManyWithoutCurrencyNestedInput = {
    create?: XOR<LevelCreateWithoutCurrencyInput, LevelUncheckedCreateWithoutCurrencyInput> | LevelCreateWithoutCurrencyInput[] | LevelUncheckedCreateWithoutCurrencyInput[]
    connectOrCreate?: LevelCreateOrConnectWithoutCurrencyInput | LevelCreateOrConnectWithoutCurrencyInput[]
    upsert?: LevelUpsertWithWhereUniqueWithoutCurrencyInput | LevelUpsertWithWhereUniqueWithoutCurrencyInput[]
    createMany?: LevelCreateManyCurrencyInputEnvelope
    set?: LevelWhereUniqueInput | LevelWhereUniqueInput[]
    disconnect?: LevelWhereUniqueInput | LevelWhereUniqueInput[]
    delete?: LevelWhereUniqueInput | LevelWhereUniqueInput[]
    connect?: LevelWhereUniqueInput | LevelWhereUniqueInput[]
    update?: LevelUpdateWithWhereUniqueWithoutCurrencyInput | LevelUpdateWithWhereUniqueWithoutCurrencyInput[]
    updateMany?: LevelUpdateManyWithWhereWithoutCurrencyInput | LevelUpdateManyWithWhereWithoutCurrencyInput[]
    deleteMany?: LevelScalarWhereInput | LevelScalarWhereInput[]
  }

  export type ConfigUncheckedUpdateManyWithoutDefaultCurrencyNestedInput = {
    create?: XOR<ConfigCreateWithoutDefaultCurrencyInput, ConfigUncheckedCreateWithoutDefaultCurrencyInput> | ConfigCreateWithoutDefaultCurrencyInput[] | ConfigUncheckedCreateWithoutDefaultCurrencyInput[]
    connectOrCreate?: ConfigCreateOrConnectWithoutDefaultCurrencyInput | ConfigCreateOrConnectWithoutDefaultCurrencyInput[]
    upsert?: ConfigUpsertWithWhereUniqueWithoutDefaultCurrencyInput | ConfigUpsertWithWhereUniqueWithoutDefaultCurrencyInput[]
    createMany?: ConfigCreateManyDefaultCurrencyInputEnvelope
    set?: ConfigWhereUniqueInput | ConfigWhereUniqueInput[]
    disconnect?: ConfigWhereUniqueInput | ConfigWhereUniqueInput[]
    delete?: ConfigWhereUniqueInput | ConfigWhereUniqueInput[]
    connect?: ConfigWhereUniqueInput | ConfigWhereUniqueInput[]
    update?: ConfigUpdateWithWhereUniqueWithoutDefaultCurrencyInput | ConfigUpdateWithWhereUniqueWithoutDefaultCurrencyInput[]
    updateMany?: ConfigUpdateManyWithWhereWithoutDefaultCurrencyInput | ConfigUpdateManyWithWhereWithoutDefaultCurrencyInput[]
    deleteMany?: ConfigScalarWhereInput | ConfigScalarWhereInput[]
  }

  export type LevelAttributeAndValueCreateNestedManyWithoutLevelInput = {
    create?: XOR<LevelAttributeAndValueCreateWithoutLevelInput, LevelAttributeAndValueUncheckedCreateWithoutLevelInput> | LevelAttributeAndValueCreateWithoutLevelInput[] | LevelAttributeAndValueUncheckedCreateWithoutLevelInput[]
    connectOrCreate?: LevelAttributeAndValueCreateOrConnectWithoutLevelInput | LevelAttributeAndValueCreateOrConnectWithoutLevelInput[]
    createMany?: LevelAttributeAndValueCreateManyLevelInputEnvelope
    connect?: LevelAttributeAndValueWhereUniqueInput | LevelAttributeAndValueWhereUniqueInput[]
  }

  export type LevelCreateNestedOneWithoutChildLevelsInput = {
    create?: XOR<LevelCreateWithoutChildLevelsInput, LevelUncheckedCreateWithoutChildLevelsInput>
    connectOrCreate?: LevelCreateOrConnectWithoutChildLevelsInput
    connect?: LevelWhereUniqueInput
  }

  export type InstanceCreateNestedOneWithoutLevelsInput = {
    create?: XOR<InstanceCreateWithoutLevelsInput, InstanceUncheckedCreateWithoutLevelsInput>
    connectOrCreate?: InstanceCreateOrConnectWithoutLevelsInput
    connect?: InstanceWhereUniqueInput
  }

  export type CurrencyCreateNestedOneWithoutLevelsInput = {
    create?: XOR<CurrencyCreateWithoutLevelsInput, CurrencyUncheckedCreateWithoutLevelsInput>
    connectOrCreate?: CurrencyCreateOrConnectWithoutLevelsInput
    connect?: CurrencyWhereUniqueInput
  }

  export type LevelCreateNestedManyWithoutParentInput = {
    create?: XOR<LevelCreateWithoutParentInput, LevelUncheckedCreateWithoutParentInput> | LevelCreateWithoutParentInput[] | LevelUncheckedCreateWithoutParentInput[]
    connectOrCreate?: LevelCreateOrConnectWithoutParentInput | LevelCreateOrConnectWithoutParentInput[]
    createMany?: LevelCreateManyParentInputEnvelope
    connect?: LevelWhereUniqueInput | LevelWhereUniqueInput[]
  }

  export type ModelDataCreateNestedManyWithoutLevelInput = {
    create?: XOR<ModelDataCreateWithoutLevelInput, ModelDataUncheckedCreateWithoutLevelInput> | ModelDataCreateWithoutLevelInput[] | ModelDataUncheckedCreateWithoutLevelInput[]
    connectOrCreate?: ModelDataCreateOrConnectWithoutLevelInput | ModelDataCreateOrConnectWithoutLevelInput[]
    createMany?: ModelDataCreateManyLevelInputEnvelope
    connect?: ModelDataWhereUniqueInput | ModelDataWhereUniqueInput[]
  }

  export type ModelDataCalculationsCreateNestedManyWithoutLevelInput = {
    create?: XOR<ModelDataCalculationsCreateWithoutLevelInput, ModelDataCalculationsUncheckedCreateWithoutLevelInput> | ModelDataCalculationsCreateWithoutLevelInput[] | ModelDataCalculationsUncheckedCreateWithoutLevelInput[]
    connectOrCreate?: ModelDataCalculationsCreateOrConnectWithoutLevelInput | ModelDataCalculationsCreateOrConnectWithoutLevelInput[]
    createMany?: ModelDataCalculationsCreateManyLevelInputEnvelope
    connect?: ModelDataCalculationsWhereUniqueInput | ModelDataCalculationsWhereUniqueInput[]
  }

  export type LevelAttributeAndValueUncheckedCreateNestedManyWithoutLevelInput = {
    create?: XOR<LevelAttributeAndValueCreateWithoutLevelInput, LevelAttributeAndValueUncheckedCreateWithoutLevelInput> | LevelAttributeAndValueCreateWithoutLevelInput[] | LevelAttributeAndValueUncheckedCreateWithoutLevelInput[]
    connectOrCreate?: LevelAttributeAndValueCreateOrConnectWithoutLevelInput | LevelAttributeAndValueCreateOrConnectWithoutLevelInput[]
    createMany?: LevelAttributeAndValueCreateManyLevelInputEnvelope
    connect?: LevelAttributeAndValueWhereUniqueInput | LevelAttributeAndValueWhereUniqueInput[]
  }

  export type LevelUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<LevelCreateWithoutParentInput, LevelUncheckedCreateWithoutParentInput> | LevelCreateWithoutParentInput[] | LevelUncheckedCreateWithoutParentInput[]
    connectOrCreate?: LevelCreateOrConnectWithoutParentInput | LevelCreateOrConnectWithoutParentInput[]
    createMany?: LevelCreateManyParentInputEnvelope
    connect?: LevelWhereUniqueInput | LevelWhereUniqueInput[]
  }

  export type ModelDataUncheckedCreateNestedManyWithoutLevelInput = {
    create?: XOR<ModelDataCreateWithoutLevelInput, ModelDataUncheckedCreateWithoutLevelInput> | ModelDataCreateWithoutLevelInput[] | ModelDataUncheckedCreateWithoutLevelInput[]
    connectOrCreate?: ModelDataCreateOrConnectWithoutLevelInput | ModelDataCreateOrConnectWithoutLevelInput[]
    createMany?: ModelDataCreateManyLevelInputEnvelope
    connect?: ModelDataWhereUniqueInput | ModelDataWhereUniqueInput[]
  }

  export type ModelDataCalculationsUncheckedCreateNestedManyWithoutLevelInput = {
    create?: XOR<ModelDataCalculationsCreateWithoutLevelInput, ModelDataCalculationsUncheckedCreateWithoutLevelInput> | ModelDataCalculationsCreateWithoutLevelInput[] | ModelDataCalculationsUncheckedCreateWithoutLevelInput[]
    connectOrCreate?: ModelDataCalculationsCreateOrConnectWithoutLevelInput | ModelDataCalculationsCreateOrConnectWithoutLevelInput[]
    createMany?: ModelDataCalculationsCreateManyLevelInputEnvelope
    connect?: ModelDataCalculationsWhereUniqueInput | ModelDataCalculationsWhereUniqueInput[]
  }

  export type LevelAttributeAndValueUpdateManyWithoutLevelNestedInput = {
    create?: XOR<LevelAttributeAndValueCreateWithoutLevelInput, LevelAttributeAndValueUncheckedCreateWithoutLevelInput> | LevelAttributeAndValueCreateWithoutLevelInput[] | LevelAttributeAndValueUncheckedCreateWithoutLevelInput[]
    connectOrCreate?: LevelAttributeAndValueCreateOrConnectWithoutLevelInput | LevelAttributeAndValueCreateOrConnectWithoutLevelInput[]
    upsert?: LevelAttributeAndValueUpsertWithWhereUniqueWithoutLevelInput | LevelAttributeAndValueUpsertWithWhereUniqueWithoutLevelInput[]
    createMany?: LevelAttributeAndValueCreateManyLevelInputEnvelope
    set?: LevelAttributeAndValueWhereUniqueInput | LevelAttributeAndValueWhereUniqueInput[]
    disconnect?: LevelAttributeAndValueWhereUniqueInput | LevelAttributeAndValueWhereUniqueInput[]
    delete?: LevelAttributeAndValueWhereUniqueInput | LevelAttributeAndValueWhereUniqueInput[]
    connect?: LevelAttributeAndValueWhereUniqueInput | LevelAttributeAndValueWhereUniqueInput[]
    update?: LevelAttributeAndValueUpdateWithWhereUniqueWithoutLevelInput | LevelAttributeAndValueUpdateWithWhereUniqueWithoutLevelInput[]
    updateMany?: LevelAttributeAndValueUpdateManyWithWhereWithoutLevelInput | LevelAttributeAndValueUpdateManyWithWhereWithoutLevelInput[]
    deleteMany?: LevelAttributeAndValueScalarWhereInput | LevelAttributeAndValueScalarWhereInput[]
  }

  export type LevelUpdateOneWithoutChildLevelsNestedInput = {
    create?: XOR<LevelCreateWithoutChildLevelsInput, LevelUncheckedCreateWithoutChildLevelsInput>
    connectOrCreate?: LevelCreateOrConnectWithoutChildLevelsInput
    upsert?: LevelUpsertWithoutChildLevelsInput
    disconnect?: boolean
    delete?: LevelWhereInput | boolean
    connect?: LevelWhereUniqueInput
    update?: XOR<XOR<LevelUpdateToOneWithWhereWithoutChildLevelsInput, LevelUpdateWithoutChildLevelsInput>, LevelUncheckedUpdateWithoutChildLevelsInput>
  }

  export type InstanceUpdateOneRequiredWithoutLevelsNestedInput = {
    create?: XOR<InstanceCreateWithoutLevelsInput, InstanceUncheckedCreateWithoutLevelsInput>
    connectOrCreate?: InstanceCreateOrConnectWithoutLevelsInput
    upsert?: InstanceUpsertWithoutLevelsInput
    connect?: InstanceWhereUniqueInput
    update?: XOR<XOR<InstanceUpdateToOneWithWhereWithoutLevelsInput, InstanceUpdateWithoutLevelsInput>, InstanceUncheckedUpdateWithoutLevelsInput>
  }

  export type CurrencyUpdateOneRequiredWithoutLevelsNestedInput = {
    create?: XOR<CurrencyCreateWithoutLevelsInput, CurrencyUncheckedCreateWithoutLevelsInput>
    connectOrCreate?: CurrencyCreateOrConnectWithoutLevelsInput
    upsert?: CurrencyUpsertWithoutLevelsInput
    connect?: CurrencyWhereUniqueInput
    update?: XOR<XOR<CurrencyUpdateToOneWithWhereWithoutLevelsInput, CurrencyUpdateWithoutLevelsInput>, CurrencyUncheckedUpdateWithoutLevelsInput>
  }

  export type LevelUpdateManyWithoutParentNestedInput = {
    create?: XOR<LevelCreateWithoutParentInput, LevelUncheckedCreateWithoutParentInput> | LevelCreateWithoutParentInput[] | LevelUncheckedCreateWithoutParentInput[]
    connectOrCreate?: LevelCreateOrConnectWithoutParentInput | LevelCreateOrConnectWithoutParentInput[]
    upsert?: LevelUpsertWithWhereUniqueWithoutParentInput | LevelUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: LevelCreateManyParentInputEnvelope
    set?: LevelWhereUniqueInput | LevelWhereUniqueInput[]
    disconnect?: LevelWhereUniqueInput | LevelWhereUniqueInput[]
    delete?: LevelWhereUniqueInput | LevelWhereUniqueInput[]
    connect?: LevelWhereUniqueInput | LevelWhereUniqueInput[]
    update?: LevelUpdateWithWhereUniqueWithoutParentInput | LevelUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: LevelUpdateManyWithWhereWithoutParentInput | LevelUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: LevelScalarWhereInput | LevelScalarWhereInput[]
  }

  export type ModelDataUpdateManyWithoutLevelNestedInput = {
    create?: XOR<ModelDataCreateWithoutLevelInput, ModelDataUncheckedCreateWithoutLevelInput> | ModelDataCreateWithoutLevelInput[] | ModelDataUncheckedCreateWithoutLevelInput[]
    connectOrCreate?: ModelDataCreateOrConnectWithoutLevelInput | ModelDataCreateOrConnectWithoutLevelInput[]
    upsert?: ModelDataUpsertWithWhereUniqueWithoutLevelInput | ModelDataUpsertWithWhereUniqueWithoutLevelInput[]
    createMany?: ModelDataCreateManyLevelInputEnvelope
    set?: ModelDataWhereUniqueInput | ModelDataWhereUniqueInput[]
    disconnect?: ModelDataWhereUniqueInput | ModelDataWhereUniqueInput[]
    delete?: ModelDataWhereUniqueInput | ModelDataWhereUniqueInput[]
    connect?: ModelDataWhereUniqueInput | ModelDataWhereUniqueInput[]
    update?: ModelDataUpdateWithWhereUniqueWithoutLevelInput | ModelDataUpdateWithWhereUniqueWithoutLevelInput[]
    updateMany?: ModelDataUpdateManyWithWhereWithoutLevelInput | ModelDataUpdateManyWithWhereWithoutLevelInput[]
    deleteMany?: ModelDataScalarWhereInput | ModelDataScalarWhereInput[]
  }

  export type ModelDataCalculationsUpdateManyWithoutLevelNestedInput = {
    create?: XOR<ModelDataCalculationsCreateWithoutLevelInput, ModelDataCalculationsUncheckedCreateWithoutLevelInput> | ModelDataCalculationsCreateWithoutLevelInput[] | ModelDataCalculationsUncheckedCreateWithoutLevelInput[]
    connectOrCreate?: ModelDataCalculationsCreateOrConnectWithoutLevelInput | ModelDataCalculationsCreateOrConnectWithoutLevelInput[]
    upsert?: ModelDataCalculationsUpsertWithWhereUniqueWithoutLevelInput | ModelDataCalculationsUpsertWithWhereUniqueWithoutLevelInput[]
    createMany?: ModelDataCalculationsCreateManyLevelInputEnvelope
    set?: ModelDataCalculationsWhereUniqueInput | ModelDataCalculationsWhereUniqueInput[]
    disconnect?: ModelDataCalculationsWhereUniqueInput | ModelDataCalculationsWhereUniqueInput[]
    delete?: ModelDataCalculationsWhereUniqueInput | ModelDataCalculationsWhereUniqueInput[]
    connect?: ModelDataCalculationsWhereUniqueInput | ModelDataCalculationsWhereUniqueInput[]
    update?: ModelDataCalculationsUpdateWithWhereUniqueWithoutLevelInput | ModelDataCalculationsUpdateWithWhereUniqueWithoutLevelInput[]
    updateMany?: ModelDataCalculationsUpdateManyWithWhereWithoutLevelInput | ModelDataCalculationsUpdateManyWithWhereWithoutLevelInput[]
    deleteMany?: ModelDataCalculationsScalarWhereInput | ModelDataCalculationsScalarWhereInput[]
  }

  export type LevelAttributeAndValueUncheckedUpdateManyWithoutLevelNestedInput = {
    create?: XOR<LevelAttributeAndValueCreateWithoutLevelInput, LevelAttributeAndValueUncheckedCreateWithoutLevelInput> | LevelAttributeAndValueCreateWithoutLevelInput[] | LevelAttributeAndValueUncheckedCreateWithoutLevelInput[]
    connectOrCreate?: LevelAttributeAndValueCreateOrConnectWithoutLevelInput | LevelAttributeAndValueCreateOrConnectWithoutLevelInput[]
    upsert?: LevelAttributeAndValueUpsertWithWhereUniqueWithoutLevelInput | LevelAttributeAndValueUpsertWithWhereUniqueWithoutLevelInput[]
    createMany?: LevelAttributeAndValueCreateManyLevelInputEnvelope
    set?: LevelAttributeAndValueWhereUniqueInput | LevelAttributeAndValueWhereUniqueInput[]
    disconnect?: LevelAttributeAndValueWhereUniqueInput | LevelAttributeAndValueWhereUniqueInput[]
    delete?: LevelAttributeAndValueWhereUniqueInput | LevelAttributeAndValueWhereUniqueInput[]
    connect?: LevelAttributeAndValueWhereUniqueInput | LevelAttributeAndValueWhereUniqueInput[]
    update?: LevelAttributeAndValueUpdateWithWhereUniqueWithoutLevelInput | LevelAttributeAndValueUpdateWithWhereUniqueWithoutLevelInput[]
    updateMany?: LevelAttributeAndValueUpdateManyWithWhereWithoutLevelInput | LevelAttributeAndValueUpdateManyWithWhereWithoutLevelInput[]
    deleteMany?: LevelAttributeAndValueScalarWhereInput | LevelAttributeAndValueScalarWhereInput[]
  }

  export type LevelUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<LevelCreateWithoutParentInput, LevelUncheckedCreateWithoutParentInput> | LevelCreateWithoutParentInput[] | LevelUncheckedCreateWithoutParentInput[]
    connectOrCreate?: LevelCreateOrConnectWithoutParentInput | LevelCreateOrConnectWithoutParentInput[]
    upsert?: LevelUpsertWithWhereUniqueWithoutParentInput | LevelUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: LevelCreateManyParentInputEnvelope
    set?: LevelWhereUniqueInput | LevelWhereUniqueInput[]
    disconnect?: LevelWhereUniqueInput | LevelWhereUniqueInput[]
    delete?: LevelWhereUniqueInput | LevelWhereUniqueInput[]
    connect?: LevelWhereUniqueInput | LevelWhereUniqueInput[]
    update?: LevelUpdateWithWhereUniqueWithoutParentInput | LevelUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: LevelUpdateManyWithWhereWithoutParentInput | LevelUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: LevelScalarWhereInput | LevelScalarWhereInput[]
  }

  export type ModelDataUncheckedUpdateManyWithoutLevelNestedInput = {
    create?: XOR<ModelDataCreateWithoutLevelInput, ModelDataUncheckedCreateWithoutLevelInput> | ModelDataCreateWithoutLevelInput[] | ModelDataUncheckedCreateWithoutLevelInput[]
    connectOrCreate?: ModelDataCreateOrConnectWithoutLevelInput | ModelDataCreateOrConnectWithoutLevelInput[]
    upsert?: ModelDataUpsertWithWhereUniqueWithoutLevelInput | ModelDataUpsertWithWhereUniqueWithoutLevelInput[]
    createMany?: ModelDataCreateManyLevelInputEnvelope
    set?: ModelDataWhereUniqueInput | ModelDataWhereUniqueInput[]
    disconnect?: ModelDataWhereUniqueInput | ModelDataWhereUniqueInput[]
    delete?: ModelDataWhereUniqueInput | ModelDataWhereUniqueInput[]
    connect?: ModelDataWhereUniqueInput | ModelDataWhereUniqueInput[]
    update?: ModelDataUpdateWithWhereUniqueWithoutLevelInput | ModelDataUpdateWithWhereUniqueWithoutLevelInput[]
    updateMany?: ModelDataUpdateManyWithWhereWithoutLevelInput | ModelDataUpdateManyWithWhereWithoutLevelInput[]
    deleteMany?: ModelDataScalarWhereInput | ModelDataScalarWhereInput[]
  }

  export type ModelDataCalculationsUncheckedUpdateManyWithoutLevelNestedInput = {
    create?: XOR<ModelDataCalculationsCreateWithoutLevelInput, ModelDataCalculationsUncheckedCreateWithoutLevelInput> | ModelDataCalculationsCreateWithoutLevelInput[] | ModelDataCalculationsUncheckedCreateWithoutLevelInput[]
    connectOrCreate?: ModelDataCalculationsCreateOrConnectWithoutLevelInput | ModelDataCalculationsCreateOrConnectWithoutLevelInput[]
    upsert?: ModelDataCalculationsUpsertWithWhereUniqueWithoutLevelInput | ModelDataCalculationsUpsertWithWhereUniqueWithoutLevelInput[]
    createMany?: ModelDataCalculationsCreateManyLevelInputEnvelope
    set?: ModelDataCalculationsWhereUniqueInput | ModelDataCalculationsWhereUniqueInput[]
    disconnect?: ModelDataCalculationsWhereUniqueInput | ModelDataCalculationsWhereUniqueInput[]
    delete?: ModelDataCalculationsWhereUniqueInput | ModelDataCalculationsWhereUniqueInput[]
    connect?: ModelDataCalculationsWhereUniqueInput | ModelDataCalculationsWhereUniqueInput[]
    update?: ModelDataCalculationsUpdateWithWhereUniqueWithoutLevelInput | ModelDataCalculationsUpdateWithWhereUniqueWithoutLevelInput[]
    updateMany?: ModelDataCalculationsUpdateManyWithWhereWithoutLevelInput | ModelDataCalculationsUpdateManyWithWhereWithoutLevelInput[]
    deleteMany?: ModelDataCalculationsScalarWhereInput | ModelDataCalculationsScalarWhereInput[]
  }

  export type LevelCreateNestedOneWithoutAttributeAndValuesInput = {
    create?: XOR<LevelCreateWithoutAttributeAndValuesInput, LevelUncheckedCreateWithoutAttributeAndValuesInput>
    connectOrCreate?: LevelCreateOrConnectWithoutAttributeAndValuesInput
    connect?: LevelWhereUniqueInput
  }

  export type LevelAttributeCreateNestedOneWithoutLevelAttributeAndValuesInput = {
    create?: XOR<LevelAttributeCreateWithoutLevelAttributeAndValuesInput, LevelAttributeUncheckedCreateWithoutLevelAttributeAndValuesInput>
    connectOrCreate?: LevelAttributeCreateOrConnectWithoutLevelAttributeAndValuesInput
    connect?: LevelAttributeWhereUniqueInput
  }

  export type LevelAttributeValueCreateNestedOneWithoutLevelAttributeAndValuesInput = {
    create?: XOR<LevelAttributeValueCreateWithoutLevelAttributeAndValuesInput, LevelAttributeValueUncheckedCreateWithoutLevelAttributeAndValuesInput>
    connectOrCreate?: LevelAttributeValueCreateOrConnectWithoutLevelAttributeAndValuesInput
    connect?: LevelAttributeValueWhereUniqueInput
  }

  export type LevelUpdateOneWithoutAttributeAndValuesNestedInput = {
    create?: XOR<LevelCreateWithoutAttributeAndValuesInput, LevelUncheckedCreateWithoutAttributeAndValuesInput>
    connectOrCreate?: LevelCreateOrConnectWithoutAttributeAndValuesInput
    upsert?: LevelUpsertWithoutAttributeAndValuesInput
    disconnect?: boolean
    delete?: LevelWhereInput | boolean
    connect?: LevelWhereUniqueInput
    update?: XOR<XOR<LevelUpdateToOneWithWhereWithoutAttributeAndValuesInput, LevelUpdateWithoutAttributeAndValuesInput>, LevelUncheckedUpdateWithoutAttributeAndValuesInput>
  }

  export type LevelAttributeUpdateOneWithoutLevelAttributeAndValuesNestedInput = {
    create?: XOR<LevelAttributeCreateWithoutLevelAttributeAndValuesInput, LevelAttributeUncheckedCreateWithoutLevelAttributeAndValuesInput>
    connectOrCreate?: LevelAttributeCreateOrConnectWithoutLevelAttributeAndValuesInput
    upsert?: LevelAttributeUpsertWithoutLevelAttributeAndValuesInput
    disconnect?: boolean
    delete?: LevelAttributeWhereInput | boolean
    connect?: LevelAttributeWhereUniqueInput
    update?: XOR<XOR<LevelAttributeUpdateToOneWithWhereWithoutLevelAttributeAndValuesInput, LevelAttributeUpdateWithoutLevelAttributeAndValuesInput>, LevelAttributeUncheckedUpdateWithoutLevelAttributeAndValuesInput>
  }

  export type LevelAttributeValueUpdateOneWithoutLevelAttributeAndValuesNestedInput = {
    create?: XOR<LevelAttributeValueCreateWithoutLevelAttributeAndValuesInput, LevelAttributeValueUncheckedCreateWithoutLevelAttributeAndValuesInput>
    connectOrCreate?: LevelAttributeValueCreateOrConnectWithoutLevelAttributeAndValuesInput
    upsert?: LevelAttributeValueUpsertWithoutLevelAttributeAndValuesInput
    disconnect?: boolean
    delete?: LevelAttributeValueWhereInput | boolean
    connect?: LevelAttributeValueWhereUniqueInput
    update?: XOR<XOR<LevelAttributeValueUpdateToOneWithWhereWithoutLevelAttributeAndValuesInput, LevelAttributeValueUpdateWithoutLevelAttributeAndValuesInput>, LevelAttributeValueUncheckedUpdateWithoutLevelAttributeAndValuesInput>
  }

  export type LevelAttributeValueCreateNestedOneWithoutChildAttributeValuesInput = {
    create?: XOR<LevelAttributeValueCreateWithoutChildAttributeValuesInput, LevelAttributeValueUncheckedCreateWithoutChildAttributeValuesInput>
    connectOrCreate?: LevelAttributeValueCreateOrConnectWithoutChildAttributeValuesInput
    connect?: LevelAttributeValueWhereUniqueInput
  }

  export type LevelAttributeValueCreateNestedManyWithoutParentInput = {
    create?: XOR<LevelAttributeValueCreateWithoutParentInput, LevelAttributeValueUncheckedCreateWithoutParentInput> | LevelAttributeValueCreateWithoutParentInput[] | LevelAttributeValueUncheckedCreateWithoutParentInput[]
    connectOrCreate?: LevelAttributeValueCreateOrConnectWithoutParentInput | LevelAttributeValueCreateOrConnectWithoutParentInput[]
    createMany?: LevelAttributeValueCreateManyParentInputEnvelope
    connect?: LevelAttributeValueWhereUniqueInput | LevelAttributeValueWhereUniqueInput[]
  }

  export type InstanceCreateNestedOneWithoutLevelAttValuesInput = {
    create?: XOR<InstanceCreateWithoutLevelAttValuesInput, InstanceUncheckedCreateWithoutLevelAttValuesInput>
    connectOrCreate?: InstanceCreateOrConnectWithoutLevelAttValuesInput
    connect?: InstanceWhereUniqueInput
  }

  export type LevelAttributeCreateNestedOneWithoutLevelAttributeValuesInput = {
    create?: XOR<LevelAttributeCreateWithoutLevelAttributeValuesInput, LevelAttributeUncheckedCreateWithoutLevelAttributeValuesInput>
    connectOrCreate?: LevelAttributeCreateOrConnectWithoutLevelAttributeValuesInput
    connect?: LevelAttributeWhereUniqueInput
  }

  export type LevelAttributeAndValueCreateNestedManyWithoutAttributeValueInput = {
    create?: XOR<LevelAttributeAndValueCreateWithoutAttributeValueInput, LevelAttributeAndValueUncheckedCreateWithoutAttributeValueInput> | LevelAttributeAndValueCreateWithoutAttributeValueInput[] | LevelAttributeAndValueUncheckedCreateWithoutAttributeValueInput[]
    connectOrCreate?: LevelAttributeAndValueCreateOrConnectWithoutAttributeValueInput | LevelAttributeAndValueCreateOrConnectWithoutAttributeValueInput[]
    createMany?: LevelAttributeAndValueCreateManyAttributeValueInputEnvelope
    connect?: LevelAttributeAndValueWhereUniqueInput | LevelAttributeAndValueWhereUniqueInput[]
  }

  export type LevelAttributeValueUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<LevelAttributeValueCreateWithoutParentInput, LevelAttributeValueUncheckedCreateWithoutParentInput> | LevelAttributeValueCreateWithoutParentInput[] | LevelAttributeValueUncheckedCreateWithoutParentInput[]
    connectOrCreate?: LevelAttributeValueCreateOrConnectWithoutParentInput | LevelAttributeValueCreateOrConnectWithoutParentInput[]
    createMany?: LevelAttributeValueCreateManyParentInputEnvelope
    connect?: LevelAttributeValueWhereUniqueInput | LevelAttributeValueWhereUniqueInput[]
  }

  export type LevelAttributeAndValueUncheckedCreateNestedManyWithoutAttributeValueInput = {
    create?: XOR<LevelAttributeAndValueCreateWithoutAttributeValueInput, LevelAttributeAndValueUncheckedCreateWithoutAttributeValueInput> | LevelAttributeAndValueCreateWithoutAttributeValueInput[] | LevelAttributeAndValueUncheckedCreateWithoutAttributeValueInput[]
    connectOrCreate?: LevelAttributeAndValueCreateOrConnectWithoutAttributeValueInput | LevelAttributeAndValueCreateOrConnectWithoutAttributeValueInput[]
    createMany?: LevelAttributeAndValueCreateManyAttributeValueInputEnvelope
    connect?: LevelAttributeAndValueWhereUniqueInput | LevelAttributeAndValueWhereUniqueInput[]
  }

  export type LevelAttributeValueUpdateOneWithoutChildAttributeValuesNestedInput = {
    create?: XOR<LevelAttributeValueCreateWithoutChildAttributeValuesInput, LevelAttributeValueUncheckedCreateWithoutChildAttributeValuesInput>
    connectOrCreate?: LevelAttributeValueCreateOrConnectWithoutChildAttributeValuesInput
    upsert?: LevelAttributeValueUpsertWithoutChildAttributeValuesInput
    disconnect?: boolean
    delete?: LevelAttributeValueWhereInput | boolean
    connect?: LevelAttributeValueWhereUniqueInput
    update?: XOR<XOR<LevelAttributeValueUpdateToOneWithWhereWithoutChildAttributeValuesInput, LevelAttributeValueUpdateWithoutChildAttributeValuesInput>, LevelAttributeValueUncheckedUpdateWithoutChildAttributeValuesInput>
  }

  export type LevelAttributeValueUpdateManyWithoutParentNestedInput = {
    create?: XOR<LevelAttributeValueCreateWithoutParentInput, LevelAttributeValueUncheckedCreateWithoutParentInput> | LevelAttributeValueCreateWithoutParentInput[] | LevelAttributeValueUncheckedCreateWithoutParentInput[]
    connectOrCreate?: LevelAttributeValueCreateOrConnectWithoutParentInput | LevelAttributeValueCreateOrConnectWithoutParentInput[]
    upsert?: LevelAttributeValueUpsertWithWhereUniqueWithoutParentInput | LevelAttributeValueUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: LevelAttributeValueCreateManyParentInputEnvelope
    set?: LevelAttributeValueWhereUniqueInput | LevelAttributeValueWhereUniqueInput[]
    disconnect?: LevelAttributeValueWhereUniqueInput | LevelAttributeValueWhereUniqueInput[]
    delete?: LevelAttributeValueWhereUniqueInput | LevelAttributeValueWhereUniqueInput[]
    connect?: LevelAttributeValueWhereUniqueInput | LevelAttributeValueWhereUniqueInput[]
    update?: LevelAttributeValueUpdateWithWhereUniqueWithoutParentInput | LevelAttributeValueUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: LevelAttributeValueUpdateManyWithWhereWithoutParentInput | LevelAttributeValueUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: LevelAttributeValueScalarWhereInput | LevelAttributeValueScalarWhereInput[]
  }

  export type InstanceUpdateOneRequiredWithoutLevelAttValuesNestedInput = {
    create?: XOR<InstanceCreateWithoutLevelAttValuesInput, InstanceUncheckedCreateWithoutLevelAttValuesInput>
    connectOrCreate?: InstanceCreateOrConnectWithoutLevelAttValuesInput
    upsert?: InstanceUpsertWithoutLevelAttValuesInput
    connect?: InstanceWhereUniqueInput
    update?: XOR<XOR<InstanceUpdateToOneWithWhereWithoutLevelAttValuesInput, InstanceUpdateWithoutLevelAttValuesInput>, InstanceUncheckedUpdateWithoutLevelAttValuesInput>
  }

  export type LevelAttributeUpdateOneRequiredWithoutLevelAttributeValuesNestedInput = {
    create?: XOR<LevelAttributeCreateWithoutLevelAttributeValuesInput, LevelAttributeUncheckedCreateWithoutLevelAttributeValuesInput>
    connectOrCreate?: LevelAttributeCreateOrConnectWithoutLevelAttributeValuesInput
    upsert?: LevelAttributeUpsertWithoutLevelAttributeValuesInput
    connect?: LevelAttributeWhereUniqueInput
    update?: XOR<XOR<LevelAttributeUpdateToOneWithWhereWithoutLevelAttributeValuesInput, LevelAttributeUpdateWithoutLevelAttributeValuesInput>, LevelAttributeUncheckedUpdateWithoutLevelAttributeValuesInput>
  }

  export type LevelAttributeAndValueUpdateManyWithoutAttributeValueNestedInput = {
    create?: XOR<LevelAttributeAndValueCreateWithoutAttributeValueInput, LevelAttributeAndValueUncheckedCreateWithoutAttributeValueInput> | LevelAttributeAndValueCreateWithoutAttributeValueInput[] | LevelAttributeAndValueUncheckedCreateWithoutAttributeValueInput[]
    connectOrCreate?: LevelAttributeAndValueCreateOrConnectWithoutAttributeValueInput | LevelAttributeAndValueCreateOrConnectWithoutAttributeValueInput[]
    upsert?: LevelAttributeAndValueUpsertWithWhereUniqueWithoutAttributeValueInput | LevelAttributeAndValueUpsertWithWhereUniqueWithoutAttributeValueInput[]
    createMany?: LevelAttributeAndValueCreateManyAttributeValueInputEnvelope
    set?: LevelAttributeAndValueWhereUniqueInput | LevelAttributeAndValueWhereUniqueInput[]
    disconnect?: LevelAttributeAndValueWhereUniqueInput | LevelAttributeAndValueWhereUniqueInput[]
    delete?: LevelAttributeAndValueWhereUniqueInput | LevelAttributeAndValueWhereUniqueInput[]
    connect?: LevelAttributeAndValueWhereUniqueInput | LevelAttributeAndValueWhereUniqueInput[]
    update?: LevelAttributeAndValueUpdateWithWhereUniqueWithoutAttributeValueInput | LevelAttributeAndValueUpdateWithWhereUniqueWithoutAttributeValueInput[]
    updateMany?: LevelAttributeAndValueUpdateManyWithWhereWithoutAttributeValueInput | LevelAttributeAndValueUpdateManyWithWhereWithoutAttributeValueInput[]
    deleteMany?: LevelAttributeAndValueScalarWhereInput | LevelAttributeAndValueScalarWhereInput[]
  }

  export type LevelAttributeValueUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<LevelAttributeValueCreateWithoutParentInput, LevelAttributeValueUncheckedCreateWithoutParentInput> | LevelAttributeValueCreateWithoutParentInput[] | LevelAttributeValueUncheckedCreateWithoutParentInput[]
    connectOrCreate?: LevelAttributeValueCreateOrConnectWithoutParentInput | LevelAttributeValueCreateOrConnectWithoutParentInput[]
    upsert?: LevelAttributeValueUpsertWithWhereUniqueWithoutParentInput | LevelAttributeValueUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: LevelAttributeValueCreateManyParentInputEnvelope
    set?: LevelAttributeValueWhereUniqueInput | LevelAttributeValueWhereUniqueInput[]
    disconnect?: LevelAttributeValueWhereUniqueInput | LevelAttributeValueWhereUniqueInput[]
    delete?: LevelAttributeValueWhereUniqueInput | LevelAttributeValueWhereUniqueInput[]
    connect?: LevelAttributeValueWhereUniqueInput | LevelAttributeValueWhereUniqueInput[]
    update?: LevelAttributeValueUpdateWithWhereUniqueWithoutParentInput | LevelAttributeValueUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: LevelAttributeValueUpdateManyWithWhereWithoutParentInput | LevelAttributeValueUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: LevelAttributeValueScalarWhereInput | LevelAttributeValueScalarWhereInput[]
  }

  export type LevelAttributeAndValueUncheckedUpdateManyWithoutAttributeValueNestedInput = {
    create?: XOR<LevelAttributeAndValueCreateWithoutAttributeValueInput, LevelAttributeAndValueUncheckedCreateWithoutAttributeValueInput> | LevelAttributeAndValueCreateWithoutAttributeValueInput[] | LevelAttributeAndValueUncheckedCreateWithoutAttributeValueInput[]
    connectOrCreate?: LevelAttributeAndValueCreateOrConnectWithoutAttributeValueInput | LevelAttributeAndValueCreateOrConnectWithoutAttributeValueInput[]
    upsert?: LevelAttributeAndValueUpsertWithWhereUniqueWithoutAttributeValueInput | LevelAttributeAndValueUpsertWithWhereUniqueWithoutAttributeValueInput[]
    createMany?: LevelAttributeAndValueCreateManyAttributeValueInputEnvelope
    set?: LevelAttributeAndValueWhereUniqueInput | LevelAttributeAndValueWhereUniqueInput[]
    disconnect?: LevelAttributeAndValueWhereUniqueInput | LevelAttributeAndValueWhereUniqueInput[]
    delete?: LevelAttributeAndValueWhereUniqueInput | LevelAttributeAndValueWhereUniqueInput[]
    connect?: LevelAttributeAndValueWhereUniqueInput | LevelAttributeAndValueWhereUniqueInput[]
    update?: LevelAttributeAndValueUpdateWithWhereUniqueWithoutAttributeValueInput | LevelAttributeAndValueUpdateWithWhereUniqueWithoutAttributeValueInput[]
    updateMany?: LevelAttributeAndValueUpdateManyWithWhereWithoutAttributeValueInput | LevelAttributeAndValueUpdateManyWithWhereWithoutAttributeValueInput[]
    deleteMany?: LevelAttributeAndValueScalarWhereInput | LevelAttributeAndValueScalarWhereInput[]
  }

  export type InstanceCreateNestedOneWithoutLevelAttributesInput = {
    create?: XOR<InstanceCreateWithoutLevelAttributesInput, InstanceUncheckedCreateWithoutLevelAttributesInput>
    connectOrCreate?: InstanceCreateOrConnectWithoutLevelAttributesInput
    connect?: InstanceWhereUniqueInput
  }

  export type LevelAttributeValueCreateNestedManyWithoutLevelAttributeInput = {
    create?: XOR<LevelAttributeValueCreateWithoutLevelAttributeInput, LevelAttributeValueUncheckedCreateWithoutLevelAttributeInput> | LevelAttributeValueCreateWithoutLevelAttributeInput[] | LevelAttributeValueUncheckedCreateWithoutLevelAttributeInput[]
    connectOrCreate?: LevelAttributeValueCreateOrConnectWithoutLevelAttributeInput | LevelAttributeValueCreateOrConnectWithoutLevelAttributeInput[]
    createMany?: LevelAttributeValueCreateManyLevelAttributeInputEnvelope
    connect?: LevelAttributeValueWhereUniqueInput | LevelAttributeValueWhereUniqueInput[]
  }

  export type LevelAttributeAndValueCreateNestedManyWithoutAttributeInput = {
    create?: XOR<LevelAttributeAndValueCreateWithoutAttributeInput, LevelAttributeAndValueUncheckedCreateWithoutAttributeInput> | LevelAttributeAndValueCreateWithoutAttributeInput[] | LevelAttributeAndValueUncheckedCreateWithoutAttributeInput[]
    connectOrCreate?: LevelAttributeAndValueCreateOrConnectWithoutAttributeInput | LevelAttributeAndValueCreateOrConnectWithoutAttributeInput[]
    createMany?: LevelAttributeAndValueCreateManyAttributeInputEnvelope
    connect?: LevelAttributeAndValueWhereUniqueInput | LevelAttributeAndValueWhereUniqueInput[]
  }

  export type LevelAttributeValueUncheckedCreateNestedManyWithoutLevelAttributeInput = {
    create?: XOR<LevelAttributeValueCreateWithoutLevelAttributeInput, LevelAttributeValueUncheckedCreateWithoutLevelAttributeInput> | LevelAttributeValueCreateWithoutLevelAttributeInput[] | LevelAttributeValueUncheckedCreateWithoutLevelAttributeInput[]
    connectOrCreate?: LevelAttributeValueCreateOrConnectWithoutLevelAttributeInput | LevelAttributeValueCreateOrConnectWithoutLevelAttributeInput[]
    createMany?: LevelAttributeValueCreateManyLevelAttributeInputEnvelope
    connect?: LevelAttributeValueWhereUniqueInput | LevelAttributeValueWhereUniqueInput[]
  }

  export type LevelAttributeAndValueUncheckedCreateNestedManyWithoutAttributeInput = {
    create?: XOR<LevelAttributeAndValueCreateWithoutAttributeInput, LevelAttributeAndValueUncheckedCreateWithoutAttributeInput> | LevelAttributeAndValueCreateWithoutAttributeInput[] | LevelAttributeAndValueUncheckedCreateWithoutAttributeInput[]
    connectOrCreate?: LevelAttributeAndValueCreateOrConnectWithoutAttributeInput | LevelAttributeAndValueCreateOrConnectWithoutAttributeInput[]
    createMany?: LevelAttributeAndValueCreateManyAttributeInputEnvelope
    connect?: LevelAttributeAndValueWhereUniqueInput | LevelAttributeAndValueWhereUniqueInput[]
  }

  export type InstanceUpdateOneRequiredWithoutLevelAttributesNestedInput = {
    create?: XOR<InstanceCreateWithoutLevelAttributesInput, InstanceUncheckedCreateWithoutLevelAttributesInput>
    connectOrCreate?: InstanceCreateOrConnectWithoutLevelAttributesInput
    upsert?: InstanceUpsertWithoutLevelAttributesInput
    connect?: InstanceWhereUniqueInput
    update?: XOR<XOR<InstanceUpdateToOneWithWhereWithoutLevelAttributesInput, InstanceUpdateWithoutLevelAttributesInput>, InstanceUncheckedUpdateWithoutLevelAttributesInput>
  }

  export type LevelAttributeValueUpdateManyWithoutLevelAttributeNestedInput = {
    create?: XOR<LevelAttributeValueCreateWithoutLevelAttributeInput, LevelAttributeValueUncheckedCreateWithoutLevelAttributeInput> | LevelAttributeValueCreateWithoutLevelAttributeInput[] | LevelAttributeValueUncheckedCreateWithoutLevelAttributeInput[]
    connectOrCreate?: LevelAttributeValueCreateOrConnectWithoutLevelAttributeInput | LevelAttributeValueCreateOrConnectWithoutLevelAttributeInput[]
    upsert?: LevelAttributeValueUpsertWithWhereUniqueWithoutLevelAttributeInput | LevelAttributeValueUpsertWithWhereUniqueWithoutLevelAttributeInput[]
    createMany?: LevelAttributeValueCreateManyLevelAttributeInputEnvelope
    set?: LevelAttributeValueWhereUniqueInput | LevelAttributeValueWhereUniqueInput[]
    disconnect?: LevelAttributeValueWhereUniqueInput | LevelAttributeValueWhereUniqueInput[]
    delete?: LevelAttributeValueWhereUniqueInput | LevelAttributeValueWhereUniqueInput[]
    connect?: LevelAttributeValueWhereUniqueInput | LevelAttributeValueWhereUniqueInput[]
    update?: LevelAttributeValueUpdateWithWhereUniqueWithoutLevelAttributeInput | LevelAttributeValueUpdateWithWhereUniqueWithoutLevelAttributeInput[]
    updateMany?: LevelAttributeValueUpdateManyWithWhereWithoutLevelAttributeInput | LevelAttributeValueUpdateManyWithWhereWithoutLevelAttributeInput[]
    deleteMany?: LevelAttributeValueScalarWhereInput | LevelAttributeValueScalarWhereInput[]
  }

  export type LevelAttributeAndValueUpdateManyWithoutAttributeNestedInput = {
    create?: XOR<LevelAttributeAndValueCreateWithoutAttributeInput, LevelAttributeAndValueUncheckedCreateWithoutAttributeInput> | LevelAttributeAndValueCreateWithoutAttributeInput[] | LevelAttributeAndValueUncheckedCreateWithoutAttributeInput[]
    connectOrCreate?: LevelAttributeAndValueCreateOrConnectWithoutAttributeInput | LevelAttributeAndValueCreateOrConnectWithoutAttributeInput[]
    upsert?: LevelAttributeAndValueUpsertWithWhereUniqueWithoutAttributeInput | LevelAttributeAndValueUpsertWithWhereUniqueWithoutAttributeInput[]
    createMany?: LevelAttributeAndValueCreateManyAttributeInputEnvelope
    set?: LevelAttributeAndValueWhereUniqueInput | LevelAttributeAndValueWhereUniqueInput[]
    disconnect?: LevelAttributeAndValueWhereUniqueInput | LevelAttributeAndValueWhereUniqueInput[]
    delete?: LevelAttributeAndValueWhereUniqueInput | LevelAttributeAndValueWhereUniqueInput[]
    connect?: LevelAttributeAndValueWhereUniqueInput | LevelAttributeAndValueWhereUniqueInput[]
    update?: LevelAttributeAndValueUpdateWithWhereUniqueWithoutAttributeInput | LevelAttributeAndValueUpdateWithWhereUniqueWithoutAttributeInput[]
    updateMany?: LevelAttributeAndValueUpdateManyWithWhereWithoutAttributeInput | LevelAttributeAndValueUpdateManyWithWhereWithoutAttributeInput[]
    deleteMany?: LevelAttributeAndValueScalarWhereInput | LevelAttributeAndValueScalarWhereInput[]
  }

  export type LevelAttributeValueUncheckedUpdateManyWithoutLevelAttributeNestedInput = {
    create?: XOR<LevelAttributeValueCreateWithoutLevelAttributeInput, LevelAttributeValueUncheckedCreateWithoutLevelAttributeInput> | LevelAttributeValueCreateWithoutLevelAttributeInput[] | LevelAttributeValueUncheckedCreateWithoutLevelAttributeInput[]
    connectOrCreate?: LevelAttributeValueCreateOrConnectWithoutLevelAttributeInput | LevelAttributeValueCreateOrConnectWithoutLevelAttributeInput[]
    upsert?: LevelAttributeValueUpsertWithWhereUniqueWithoutLevelAttributeInput | LevelAttributeValueUpsertWithWhereUniqueWithoutLevelAttributeInput[]
    createMany?: LevelAttributeValueCreateManyLevelAttributeInputEnvelope
    set?: LevelAttributeValueWhereUniqueInput | LevelAttributeValueWhereUniqueInput[]
    disconnect?: LevelAttributeValueWhereUniqueInput | LevelAttributeValueWhereUniqueInput[]
    delete?: LevelAttributeValueWhereUniqueInput | LevelAttributeValueWhereUniqueInput[]
    connect?: LevelAttributeValueWhereUniqueInput | LevelAttributeValueWhereUniqueInput[]
    update?: LevelAttributeValueUpdateWithWhereUniqueWithoutLevelAttributeInput | LevelAttributeValueUpdateWithWhereUniqueWithoutLevelAttributeInput[]
    updateMany?: LevelAttributeValueUpdateManyWithWhereWithoutLevelAttributeInput | LevelAttributeValueUpdateManyWithWhereWithoutLevelAttributeInput[]
    deleteMany?: LevelAttributeValueScalarWhereInput | LevelAttributeValueScalarWhereInput[]
  }

  export type LevelAttributeAndValueUncheckedUpdateManyWithoutAttributeNestedInput = {
    create?: XOR<LevelAttributeAndValueCreateWithoutAttributeInput, LevelAttributeAndValueUncheckedCreateWithoutAttributeInput> | LevelAttributeAndValueCreateWithoutAttributeInput[] | LevelAttributeAndValueUncheckedCreateWithoutAttributeInput[]
    connectOrCreate?: LevelAttributeAndValueCreateOrConnectWithoutAttributeInput | LevelAttributeAndValueCreateOrConnectWithoutAttributeInput[]
    upsert?: LevelAttributeAndValueUpsertWithWhereUniqueWithoutAttributeInput | LevelAttributeAndValueUpsertWithWhereUniqueWithoutAttributeInput[]
    createMany?: LevelAttributeAndValueCreateManyAttributeInputEnvelope
    set?: LevelAttributeAndValueWhereUniqueInput | LevelAttributeAndValueWhereUniqueInput[]
    disconnect?: LevelAttributeAndValueWhereUniqueInput | LevelAttributeAndValueWhereUniqueInput[]
    delete?: LevelAttributeAndValueWhereUniqueInput | LevelAttributeAndValueWhereUniqueInput[]
    connect?: LevelAttributeAndValueWhereUniqueInput | LevelAttributeAndValueWhereUniqueInput[]
    update?: LevelAttributeAndValueUpdateWithWhereUniqueWithoutAttributeInput | LevelAttributeAndValueUpdateWithWhereUniqueWithoutAttributeInput[]
    updateMany?: LevelAttributeAndValueUpdateManyWithWhereWithoutAttributeInput | LevelAttributeAndValueUpdateManyWithWhereWithoutAttributeInput[]
    deleteMany?: LevelAttributeAndValueScalarWhereInput | LevelAttributeAndValueScalarWhereInput[]
  }

  export type InstanceCreateNestedOneWithoutAccountAttributesInput = {
    create?: XOR<InstanceCreateWithoutAccountAttributesInput, InstanceUncheckedCreateWithoutAccountAttributesInput>
    connectOrCreate?: InstanceCreateOrConnectWithoutAccountAttributesInput
    connect?: InstanceWhereUniqueInput
  }

  export type AccountAttributeValueCreateNestedManyWithoutAccountAttributeInput = {
    create?: XOR<AccountAttributeValueCreateWithoutAccountAttributeInput, AccountAttributeValueUncheckedCreateWithoutAccountAttributeInput> | AccountAttributeValueCreateWithoutAccountAttributeInput[] | AccountAttributeValueUncheckedCreateWithoutAccountAttributeInput[]
    connectOrCreate?: AccountAttributeValueCreateOrConnectWithoutAccountAttributeInput | AccountAttributeValueCreateOrConnectWithoutAccountAttributeInput[]
    createMany?: AccountAttributeValueCreateManyAccountAttributeInputEnvelope
    connect?: AccountAttributeValueWhereUniqueInput | AccountAttributeValueWhereUniqueInput[]
  }

  export type AccountAttributeAndValueCreateNestedManyWithoutAttributeInput = {
    create?: XOR<AccountAttributeAndValueCreateWithoutAttributeInput, AccountAttributeAndValueUncheckedCreateWithoutAttributeInput> | AccountAttributeAndValueCreateWithoutAttributeInput[] | AccountAttributeAndValueUncheckedCreateWithoutAttributeInput[]
    connectOrCreate?: AccountAttributeAndValueCreateOrConnectWithoutAttributeInput | AccountAttributeAndValueCreateOrConnectWithoutAttributeInput[]
    createMany?: AccountAttributeAndValueCreateManyAttributeInputEnvelope
    connect?: AccountAttributeAndValueWhereUniqueInput | AccountAttributeAndValueWhereUniqueInput[]
  }

  export type AccountAttributeValueUncheckedCreateNestedManyWithoutAccountAttributeInput = {
    create?: XOR<AccountAttributeValueCreateWithoutAccountAttributeInput, AccountAttributeValueUncheckedCreateWithoutAccountAttributeInput> | AccountAttributeValueCreateWithoutAccountAttributeInput[] | AccountAttributeValueUncheckedCreateWithoutAccountAttributeInput[]
    connectOrCreate?: AccountAttributeValueCreateOrConnectWithoutAccountAttributeInput | AccountAttributeValueCreateOrConnectWithoutAccountAttributeInput[]
    createMany?: AccountAttributeValueCreateManyAccountAttributeInputEnvelope
    connect?: AccountAttributeValueWhereUniqueInput | AccountAttributeValueWhereUniqueInput[]
  }

  export type AccountAttributeAndValueUncheckedCreateNestedManyWithoutAttributeInput = {
    create?: XOR<AccountAttributeAndValueCreateWithoutAttributeInput, AccountAttributeAndValueUncheckedCreateWithoutAttributeInput> | AccountAttributeAndValueCreateWithoutAttributeInput[] | AccountAttributeAndValueUncheckedCreateWithoutAttributeInput[]
    connectOrCreate?: AccountAttributeAndValueCreateOrConnectWithoutAttributeInput | AccountAttributeAndValueCreateOrConnectWithoutAttributeInput[]
    createMany?: AccountAttributeAndValueCreateManyAttributeInputEnvelope
    connect?: AccountAttributeAndValueWhereUniqueInput | AccountAttributeAndValueWhereUniqueInput[]
  }

  export type InstanceUpdateOneRequiredWithoutAccountAttributesNestedInput = {
    create?: XOR<InstanceCreateWithoutAccountAttributesInput, InstanceUncheckedCreateWithoutAccountAttributesInput>
    connectOrCreate?: InstanceCreateOrConnectWithoutAccountAttributesInput
    upsert?: InstanceUpsertWithoutAccountAttributesInput
    connect?: InstanceWhereUniqueInput
    update?: XOR<XOR<InstanceUpdateToOneWithWhereWithoutAccountAttributesInput, InstanceUpdateWithoutAccountAttributesInput>, InstanceUncheckedUpdateWithoutAccountAttributesInput>
  }

  export type AccountAttributeValueUpdateManyWithoutAccountAttributeNestedInput = {
    create?: XOR<AccountAttributeValueCreateWithoutAccountAttributeInput, AccountAttributeValueUncheckedCreateWithoutAccountAttributeInput> | AccountAttributeValueCreateWithoutAccountAttributeInput[] | AccountAttributeValueUncheckedCreateWithoutAccountAttributeInput[]
    connectOrCreate?: AccountAttributeValueCreateOrConnectWithoutAccountAttributeInput | AccountAttributeValueCreateOrConnectWithoutAccountAttributeInput[]
    upsert?: AccountAttributeValueUpsertWithWhereUniqueWithoutAccountAttributeInput | AccountAttributeValueUpsertWithWhereUniqueWithoutAccountAttributeInput[]
    createMany?: AccountAttributeValueCreateManyAccountAttributeInputEnvelope
    set?: AccountAttributeValueWhereUniqueInput | AccountAttributeValueWhereUniqueInput[]
    disconnect?: AccountAttributeValueWhereUniqueInput | AccountAttributeValueWhereUniqueInput[]
    delete?: AccountAttributeValueWhereUniqueInput | AccountAttributeValueWhereUniqueInput[]
    connect?: AccountAttributeValueWhereUniqueInput | AccountAttributeValueWhereUniqueInput[]
    update?: AccountAttributeValueUpdateWithWhereUniqueWithoutAccountAttributeInput | AccountAttributeValueUpdateWithWhereUniqueWithoutAccountAttributeInput[]
    updateMany?: AccountAttributeValueUpdateManyWithWhereWithoutAccountAttributeInput | AccountAttributeValueUpdateManyWithWhereWithoutAccountAttributeInput[]
    deleteMany?: AccountAttributeValueScalarWhereInput | AccountAttributeValueScalarWhereInput[]
  }

  export type AccountAttributeAndValueUpdateManyWithoutAttributeNestedInput = {
    create?: XOR<AccountAttributeAndValueCreateWithoutAttributeInput, AccountAttributeAndValueUncheckedCreateWithoutAttributeInput> | AccountAttributeAndValueCreateWithoutAttributeInput[] | AccountAttributeAndValueUncheckedCreateWithoutAttributeInput[]
    connectOrCreate?: AccountAttributeAndValueCreateOrConnectWithoutAttributeInput | AccountAttributeAndValueCreateOrConnectWithoutAttributeInput[]
    upsert?: AccountAttributeAndValueUpsertWithWhereUniqueWithoutAttributeInput | AccountAttributeAndValueUpsertWithWhereUniqueWithoutAttributeInput[]
    createMany?: AccountAttributeAndValueCreateManyAttributeInputEnvelope
    set?: AccountAttributeAndValueWhereUniqueInput | AccountAttributeAndValueWhereUniqueInput[]
    disconnect?: AccountAttributeAndValueWhereUniqueInput | AccountAttributeAndValueWhereUniqueInput[]
    delete?: AccountAttributeAndValueWhereUniqueInput | AccountAttributeAndValueWhereUniqueInput[]
    connect?: AccountAttributeAndValueWhereUniqueInput | AccountAttributeAndValueWhereUniqueInput[]
    update?: AccountAttributeAndValueUpdateWithWhereUniqueWithoutAttributeInput | AccountAttributeAndValueUpdateWithWhereUniqueWithoutAttributeInput[]
    updateMany?: AccountAttributeAndValueUpdateManyWithWhereWithoutAttributeInput | AccountAttributeAndValueUpdateManyWithWhereWithoutAttributeInput[]
    deleteMany?: AccountAttributeAndValueScalarWhereInput | AccountAttributeAndValueScalarWhereInput[]
  }

  export type AccountAttributeValueUncheckedUpdateManyWithoutAccountAttributeNestedInput = {
    create?: XOR<AccountAttributeValueCreateWithoutAccountAttributeInput, AccountAttributeValueUncheckedCreateWithoutAccountAttributeInput> | AccountAttributeValueCreateWithoutAccountAttributeInput[] | AccountAttributeValueUncheckedCreateWithoutAccountAttributeInput[]
    connectOrCreate?: AccountAttributeValueCreateOrConnectWithoutAccountAttributeInput | AccountAttributeValueCreateOrConnectWithoutAccountAttributeInput[]
    upsert?: AccountAttributeValueUpsertWithWhereUniqueWithoutAccountAttributeInput | AccountAttributeValueUpsertWithWhereUniqueWithoutAccountAttributeInput[]
    createMany?: AccountAttributeValueCreateManyAccountAttributeInputEnvelope
    set?: AccountAttributeValueWhereUniqueInput | AccountAttributeValueWhereUniqueInput[]
    disconnect?: AccountAttributeValueWhereUniqueInput | AccountAttributeValueWhereUniqueInput[]
    delete?: AccountAttributeValueWhereUniqueInput | AccountAttributeValueWhereUniqueInput[]
    connect?: AccountAttributeValueWhereUniqueInput | AccountAttributeValueWhereUniqueInput[]
    update?: AccountAttributeValueUpdateWithWhereUniqueWithoutAccountAttributeInput | AccountAttributeValueUpdateWithWhereUniqueWithoutAccountAttributeInput[]
    updateMany?: AccountAttributeValueUpdateManyWithWhereWithoutAccountAttributeInput | AccountAttributeValueUpdateManyWithWhereWithoutAccountAttributeInput[]
    deleteMany?: AccountAttributeValueScalarWhereInput | AccountAttributeValueScalarWhereInput[]
  }

  export type AccountAttributeAndValueUncheckedUpdateManyWithoutAttributeNestedInput = {
    create?: XOR<AccountAttributeAndValueCreateWithoutAttributeInput, AccountAttributeAndValueUncheckedCreateWithoutAttributeInput> | AccountAttributeAndValueCreateWithoutAttributeInput[] | AccountAttributeAndValueUncheckedCreateWithoutAttributeInput[]
    connectOrCreate?: AccountAttributeAndValueCreateOrConnectWithoutAttributeInput | AccountAttributeAndValueCreateOrConnectWithoutAttributeInput[]
    upsert?: AccountAttributeAndValueUpsertWithWhereUniqueWithoutAttributeInput | AccountAttributeAndValueUpsertWithWhereUniqueWithoutAttributeInput[]
    createMany?: AccountAttributeAndValueCreateManyAttributeInputEnvelope
    set?: AccountAttributeAndValueWhereUniqueInput | AccountAttributeAndValueWhereUniqueInput[]
    disconnect?: AccountAttributeAndValueWhereUniqueInput | AccountAttributeAndValueWhereUniqueInput[]
    delete?: AccountAttributeAndValueWhereUniqueInput | AccountAttributeAndValueWhereUniqueInput[]
    connect?: AccountAttributeAndValueWhereUniqueInput | AccountAttributeAndValueWhereUniqueInput[]
    update?: AccountAttributeAndValueUpdateWithWhereUniqueWithoutAttributeInput | AccountAttributeAndValueUpdateWithWhereUniqueWithoutAttributeInput[]
    updateMany?: AccountAttributeAndValueUpdateManyWithWhereWithoutAttributeInput | AccountAttributeAndValueUpdateManyWithWhereWithoutAttributeInput[]
    deleteMany?: AccountAttributeAndValueScalarWhereInput | AccountAttributeAndValueScalarWhereInput[]
  }

  export type AccountAttributeValueCreateNestedOneWithoutChildAttributeValuesInput = {
    create?: XOR<AccountAttributeValueCreateWithoutChildAttributeValuesInput, AccountAttributeValueUncheckedCreateWithoutChildAttributeValuesInput>
    connectOrCreate?: AccountAttributeValueCreateOrConnectWithoutChildAttributeValuesInput
    connect?: AccountAttributeValueWhereUniqueInput
  }

  export type AccountAttributeValueCreateNestedManyWithoutParentInput = {
    create?: XOR<AccountAttributeValueCreateWithoutParentInput, AccountAttributeValueUncheckedCreateWithoutParentInput> | AccountAttributeValueCreateWithoutParentInput[] | AccountAttributeValueUncheckedCreateWithoutParentInput[]
    connectOrCreate?: AccountAttributeValueCreateOrConnectWithoutParentInput | AccountAttributeValueCreateOrConnectWithoutParentInput[]
    createMany?: AccountAttributeValueCreateManyParentInputEnvelope
    connect?: AccountAttributeValueWhereUniqueInput | AccountAttributeValueWhereUniqueInput[]
  }

  export type AccountAttributeCreateNestedOneWithoutAccountAttributeValuesInput = {
    create?: XOR<AccountAttributeCreateWithoutAccountAttributeValuesInput, AccountAttributeUncheckedCreateWithoutAccountAttributeValuesInput>
    connectOrCreate?: AccountAttributeCreateOrConnectWithoutAccountAttributeValuesInput
    connect?: AccountAttributeWhereUniqueInput
  }

  export type InstanceCreateNestedOneWithoutAccountAttValuesInput = {
    create?: XOR<InstanceCreateWithoutAccountAttValuesInput, InstanceUncheckedCreateWithoutAccountAttValuesInput>
    connectOrCreate?: InstanceCreateOrConnectWithoutAccountAttValuesInput
    connect?: InstanceWhereUniqueInput
  }

  export type AccountAttributeAndValueCreateNestedManyWithoutAttributeValueInput = {
    create?: XOR<AccountAttributeAndValueCreateWithoutAttributeValueInput, AccountAttributeAndValueUncheckedCreateWithoutAttributeValueInput> | AccountAttributeAndValueCreateWithoutAttributeValueInput[] | AccountAttributeAndValueUncheckedCreateWithoutAttributeValueInput[]
    connectOrCreate?: AccountAttributeAndValueCreateOrConnectWithoutAttributeValueInput | AccountAttributeAndValueCreateOrConnectWithoutAttributeValueInput[]
    createMany?: AccountAttributeAndValueCreateManyAttributeValueInputEnvelope
    connect?: AccountAttributeAndValueWhereUniqueInput | AccountAttributeAndValueWhereUniqueInput[]
  }

  export type AccountAttributeValueUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<AccountAttributeValueCreateWithoutParentInput, AccountAttributeValueUncheckedCreateWithoutParentInput> | AccountAttributeValueCreateWithoutParentInput[] | AccountAttributeValueUncheckedCreateWithoutParentInput[]
    connectOrCreate?: AccountAttributeValueCreateOrConnectWithoutParentInput | AccountAttributeValueCreateOrConnectWithoutParentInput[]
    createMany?: AccountAttributeValueCreateManyParentInputEnvelope
    connect?: AccountAttributeValueWhereUniqueInput | AccountAttributeValueWhereUniqueInput[]
  }

  export type AccountAttributeAndValueUncheckedCreateNestedManyWithoutAttributeValueInput = {
    create?: XOR<AccountAttributeAndValueCreateWithoutAttributeValueInput, AccountAttributeAndValueUncheckedCreateWithoutAttributeValueInput> | AccountAttributeAndValueCreateWithoutAttributeValueInput[] | AccountAttributeAndValueUncheckedCreateWithoutAttributeValueInput[]
    connectOrCreate?: AccountAttributeAndValueCreateOrConnectWithoutAttributeValueInput | AccountAttributeAndValueCreateOrConnectWithoutAttributeValueInput[]
    createMany?: AccountAttributeAndValueCreateManyAttributeValueInputEnvelope
    connect?: AccountAttributeAndValueWhereUniqueInput | AccountAttributeAndValueWhereUniqueInput[]
  }

  export type AccountAttributeValueUpdateOneWithoutChildAttributeValuesNestedInput = {
    create?: XOR<AccountAttributeValueCreateWithoutChildAttributeValuesInput, AccountAttributeValueUncheckedCreateWithoutChildAttributeValuesInput>
    connectOrCreate?: AccountAttributeValueCreateOrConnectWithoutChildAttributeValuesInput
    upsert?: AccountAttributeValueUpsertWithoutChildAttributeValuesInput
    disconnect?: boolean
    delete?: AccountAttributeValueWhereInput | boolean
    connect?: AccountAttributeValueWhereUniqueInput
    update?: XOR<XOR<AccountAttributeValueUpdateToOneWithWhereWithoutChildAttributeValuesInput, AccountAttributeValueUpdateWithoutChildAttributeValuesInput>, AccountAttributeValueUncheckedUpdateWithoutChildAttributeValuesInput>
  }

  export type AccountAttributeValueUpdateManyWithoutParentNestedInput = {
    create?: XOR<AccountAttributeValueCreateWithoutParentInput, AccountAttributeValueUncheckedCreateWithoutParentInput> | AccountAttributeValueCreateWithoutParentInput[] | AccountAttributeValueUncheckedCreateWithoutParentInput[]
    connectOrCreate?: AccountAttributeValueCreateOrConnectWithoutParentInput | AccountAttributeValueCreateOrConnectWithoutParentInput[]
    upsert?: AccountAttributeValueUpsertWithWhereUniqueWithoutParentInput | AccountAttributeValueUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: AccountAttributeValueCreateManyParentInputEnvelope
    set?: AccountAttributeValueWhereUniqueInput | AccountAttributeValueWhereUniqueInput[]
    disconnect?: AccountAttributeValueWhereUniqueInput | AccountAttributeValueWhereUniqueInput[]
    delete?: AccountAttributeValueWhereUniqueInput | AccountAttributeValueWhereUniqueInput[]
    connect?: AccountAttributeValueWhereUniqueInput | AccountAttributeValueWhereUniqueInput[]
    update?: AccountAttributeValueUpdateWithWhereUniqueWithoutParentInput | AccountAttributeValueUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: AccountAttributeValueUpdateManyWithWhereWithoutParentInput | AccountAttributeValueUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: AccountAttributeValueScalarWhereInput | AccountAttributeValueScalarWhereInput[]
  }

  export type AccountAttributeUpdateOneRequiredWithoutAccountAttributeValuesNestedInput = {
    create?: XOR<AccountAttributeCreateWithoutAccountAttributeValuesInput, AccountAttributeUncheckedCreateWithoutAccountAttributeValuesInput>
    connectOrCreate?: AccountAttributeCreateOrConnectWithoutAccountAttributeValuesInput
    upsert?: AccountAttributeUpsertWithoutAccountAttributeValuesInput
    connect?: AccountAttributeWhereUniqueInput
    update?: XOR<XOR<AccountAttributeUpdateToOneWithWhereWithoutAccountAttributeValuesInput, AccountAttributeUpdateWithoutAccountAttributeValuesInput>, AccountAttributeUncheckedUpdateWithoutAccountAttributeValuesInput>
  }

  export type InstanceUpdateOneRequiredWithoutAccountAttValuesNestedInput = {
    create?: XOR<InstanceCreateWithoutAccountAttValuesInput, InstanceUncheckedCreateWithoutAccountAttValuesInput>
    connectOrCreate?: InstanceCreateOrConnectWithoutAccountAttValuesInput
    upsert?: InstanceUpsertWithoutAccountAttValuesInput
    connect?: InstanceWhereUniqueInput
    update?: XOR<XOR<InstanceUpdateToOneWithWhereWithoutAccountAttValuesInput, InstanceUpdateWithoutAccountAttValuesInput>, InstanceUncheckedUpdateWithoutAccountAttValuesInput>
  }

  export type AccountAttributeAndValueUpdateManyWithoutAttributeValueNestedInput = {
    create?: XOR<AccountAttributeAndValueCreateWithoutAttributeValueInput, AccountAttributeAndValueUncheckedCreateWithoutAttributeValueInput> | AccountAttributeAndValueCreateWithoutAttributeValueInput[] | AccountAttributeAndValueUncheckedCreateWithoutAttributeValueInput[]
    connectOrCreate?: AccountAttributeAndValueCreateOrConnectWithoutAttributeValueInput | AccountAttributeAndValueCreateOrConnectWithoutAttributeValueInput[]
    upsert?: AccountAttributeAndValueUpsertWithWhereUniqueWithoutAttributeValueInput | AccountAttributeAndValueUpsertWithWhereUniqueWithoutAttributeValueInput[]
    createMany?: AccountAttributeAndValueCreateManyAttributeValueInputEnvelope
    set?: AccountAttributeAndValueWhereUniqueInput | AccountAttributeAndValueWhereUniqueInput[]
    disconnect?: AccountAttributeAndValueWhereUniqueInput | AccountAttributeAndValueWhereUniqueInput[]
    delete?: AccountAttributeAndValueWhereUniqueInput | AccountAttributeAndValueWhereUniqueInput[]
    connect?: AccountAttributeAndValueWhereUniqueInput | AccountAttributeAndValueWhereUniqueInput[]
    update?: AccountAttributeAndValueUpdateWithWhereUniqueWithoutAttributeValueInput | AccountAttributeAndValueUpdateWithWhereUniqueWithoutAttributeValueInput[]
    updateMany?: AccountAttributeAndValueUpdateManyWithWhereWithoutAttributeValueInput | AccountAttributeAndValueUpdateManyWithWhereWithoutAttributeValueInput[]
    deleteMany?: AccountAttributeAndValueScalarWhereInput | AccountAttributeAndValueScalarWhereInput[]
  }

  export type AccountAttributeValueUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<AccountAttributeValueCreateWithoutParentInput, AccountAttributeValueUncheckedCreateWithoutParentInput> | AccountAttributeValueCreateWithoutParentInput[] | AccountAttributeValueUncheckedCreateWithoutParentInput[]
    connectOrCreate?: AccountAttributeValueCreateOrConnectWithoutParentInput | AccountAttributeValueCreateOrConnectWithoutParentInput[]
    upsert?: AccountAttributeValueUpsertWithWhereUniqueWithoutParentInput | AccountAttributeValueUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: AccountAttributeValueCreateManyParentInputEnvelope
    set?: AccountAttributeValueWhereUniqueInput | AccountAttributeValueWhereUniqueInput[]
    disconnect?: AccountAttributeValueWhereUniqueInput | AccountAttributeValueWhereUniqueInput[]
    delete?: AccountAttributeValueWhereUniqueInput | AccountAttributeValueWhereUniqueInput[]
    connect?: AccountAttributeValueWhereUniqueInput | AccountAttributeValueWhereUniqueInput[]
    update?: AccountAttributeValueUpdateWithWhereUniqueWithoutParentInput | AccountAttributeValueUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: AccountAttributeValueUpdateManyWithWhereWithoutParentInput | AccountAttributeValueUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: AccountAttributeValueScalarWhereInput | AccountAttributeValueScalarWhereInput[]
  }

  export type AccountAttributeAndValueUncheckedUpdateManyWithoutAttributeValueNestedInput = {
    create?: XOR<AccountAttributeAndValueCreateWithoutAttributeValueInput, AccountAttributeAndValueUncheckedCreateWithoutAttributeValueInput> | AccountAttributeAndValueCreateWithoutAttributeValueInput[] | AccountAttributeAndValueUncheckedCreateWithoutAttributeValueInput[]
    connectOrCreate?: AccountAttributeAndValueCreateOrConnectWithoutAttributeValueInput | AccountAttributeAndValueCreateOrConnectWithoutAttributeValueInput[]
    upsert?: AccountAttributeAndValueUpsertWithWhereUniqueWithoutAttributeValueInput | AccountAttributeAndValueUpsertWithWhereUniqueWithoutAttributeValueInput[]
    createMany?: AccountAttributeAndValueCreateManyAttributeValueInputEnvelope
    set?: AccountAttributeAndValueWhereUniqueInput | AccountAttributeAndValueWhereUniqueInput[]
    disconnect?: AccountAttributeAndValueWhereUniqueInput | AccountAttributeAndValueWhereUniqueInput[]
    delete?: AccountAttributeAndValueWhereUniqueInput | AccountAttributeAndValueWhereUniqueInput[]
    connect?: AccountAttributeAndValueWhereUniqueInput | AccountAttributeAndValueWhereUniqueInput[]
    update?: AccountAttributeAndValueUpdateWithWhereUniqueWithoutAttributeValueInput | AccountAttributeAndValueUpdateWithWhereUniqueWithoutAttributeValueInput[]
    updateMany?: AccountAttributeAndValueUpdateManyWithWhereWithoutAttributeValueInput | AccountAttributeAndValueUpdateManyWithWhereWithoutAttributeValueInput[]
    deleteMany?: AccountAttributeAndValueScalarWhereInput | AccountAttributeAndValueScalarWhereInput[]
  }

  export type AccountCreateNestedOneWithoutAttributeAndValuesInput = {
    create?: XOR<AccountCreateWithoutAttributeAndValuesInput, AccountUncheckedCreateWithoutAttributeAndValuesInput>
    connectOrCreate?: AccountCreateOrConnectWithoutAttributeAndValuesInput
    connect?: AccountWhereUniqueInput
  }

  export type AccountAttributeCreateNestedOneWithoutAttributeAndValuesInput = {
    create?: XOR<AccountAttributeCreateWithoutAttributeAndValuesInput, AccountAttributeUncheckedCreateWithoutAttributeAndValuesInput>
    connectOrCreate?: AccountAttributeCreateOrConnectWithoutAttributeAndValuesInput
    connect?: AccountAttributeWhereUniqueInput
  }

  export type AccountAttributeValueCreateNestedOneWithoutAttributeAndValuesInput = {
    create?: XOR<AccountAttributeValueCreateWithoutAttributeAndValuesInput, AccountAttributeValueUncheckedCreateWithoutAttributeAndValuesInput>
    connectOrCreate?: AccountAttributeValueCreateOrConnectWithoutAttributeAndValuesInput
    connect?: AccountAttributeValueWhereUniqueInput
  }

  export type AccountUpdateOneWithoutAttributeAndValuesNestedInput = {
    create?: XOR<AccountCreateWithoutAttributeAndValuesInput, AccountUncheckedCreateWithoutAttributeAndValuesInput>
    connectOrCreate?: AccountCreateOrConnectWithoutAttributeAndValuesInput
    upsert?: AccountUpsertWithoutAttributeAndValuesInput
    disconnect?: boolean
    delete?: AccountWhereInput | boolean
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutAttributeAndValuesInput, AccountUpdateWithoutAttributeAndValuesInput>, AccountUncheckedUpdateWithoutAttributeAndValuesInput>
  }

  export type AccountAttributeUpdateOneWithoutAttributeAndValuesNestedInput = {
    create?: XOR<AccountAttributeCreateWithoutAttributeAndValuesInput, AccountAttributeUncheckedCreateWithoutAttributeAndValuesInput>
    connectOrCreate?: AccountAttributeCreateOrConnectWithoutAttributeAndValuesInput
    upsert?: AccountAttributeUpsertWithoutAttributeAndValuesInput
    disconnect?: boolean
    delete?: AccountAttributeWhereInput | boolean
    connect?: AccountAttributeWhereUniqueInput
    update?: XOR<XOR<AccountAttributeUpdateToOneWithWhereWithoutAttributeAndValuesInput, AccountAttributeUpdateWithoutAttributeAndValuesInput>, AccountAttributeUncheckedUpdateWithoutAttributeAndValuesInput>
  }

  export type AccountAttributeValueUpdateOneWithoutAttributeAndValuesNestedInput = {
    create?: XOR<AccountAttributeValueCreateWithoutAttributeAndValuesInput, AccountAttributeValueUncheckedCreateWithoutAttributeAndValuesInput>
    connectOrCreate?: AccountAttributeValueCreateOrConnectWithoutAttributeAndValuesInput
    upsert?: AccountAttributeValueUpsertWithoutAttributeAndValuesInput
    disconnect?: boolean
    delete?: AccountAttributeValueWhereInput | boolean
    connect?: AccountAttributeValueWhereUniqueInput
    update?: XOR<XOR<AccountAttributeValueUpdateToOneWithWhereWithoutAttributeAndValuesInput, AccountAttributeValueUpdateWithoutAttributeAndValuesInput>, AccountAttributeValueUncheckedUpdateWithoutAttributeAndValuesInput>
  }

  export type InstanceCreateNestedOneWithoutAccountsInput = {
    create?: XOR<InstanceCreateWithoutAccountsInput, InstanceUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: InstanceCreateOrConnectWithoutAccountsInput
    connect?: InstanceWhereUniqueInput
  }

  export type AccountCreateNestedOneWithoutChildAccountsInput = {
    create?: XOR<AccountCreateWithoutChildAccountsInput, AccountUncheckedCreateWithoutChildAccountsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutChildAccountsInput
    connect?: AccountWhereUniqueInput
  }

  export type AccountCreateNestedManyWithoutParentInput = {
    create?: XOR<AccountCreateWithoutParentInput, AccountUncheckedCreateWithoutParentInput> | AccountCreateWithoutParentInput[] | AccountUncheckedCreateWithoutParentInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutParentInput | AccountCreateOrConnectWithoutParentInput[]
    createMany?: AccountCreateManyParentInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type AccountAttributeAndValueCreateNestedManyWithoutAccountInput = {
    create?: XOR<AccountAttributeAndValueCreateWithoutAccountInput, AccountAttributeAndValueUncheckedCreateWithoutAccountInput> | AccountAttributeAndValueCreateWithoutAccountInput[] | AccountAttributeAndValueUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: AccountAttributeAndValueCreateOrConnectWithoutAccountInput | AccountAttributeAndValueCreateOrConnectWithoutAccountInput[]
    createMany?: AccountAttributeAndValueCreateManyAccountInputEnvelope
    connect?: AccountAttributeAndValueWhereUniqueInput | AccountAttributeAndValueWhereUniqueInput[]
  }

  export type ModelAccountStructureCreateNestedManyWithoutAccountInput = {
    create?: XOR<ModelAccountStructureCreateWithoutAccountInput, ModelAccountStructureUncheckedCreateWithoutAccountInput> | ModelAccountStructureCreateWithoutAccountInput[] | ModelAccountStructureUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: ModelAccountStructureCreateOrConnectWithoutAccountInput | ModelAccountStructureCreateOrConnectWithoutAccountInput[]
    createMany?: ModelAccountStructureCreateManyAccountInputEnvelope
    connect?: ModelAccountStructureWhereUniqueInput | ModelAccountStructureWhereUniqueInput[]
  }

  export type ModelDataCreateNestedManyWithoutAccountInput = {
    create?: XOR<ModelDataCreateWithoutAccountInput, ModelDataUncheckedCreateWithoutAccountInput> | ModelDataCreateWithoutAccountInput[] | ModelDataUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: ModelDataCreateOrConnectWithoutAccountInput | ModelDataCreateOrConnectWithoutAccountInput[]
    createMany?: ModelDataCreateManyAccountInputEnvelope
    connect?: ModelDataWhereUniqueInput | ModelDataWhereUniqueInput[]
  }

  export type ModelDataCalculationsCreateNestedManyWithoutAccountInput = {
    create?: XOR<ModelDataCalculationsCreateWithoutAccountInput, ModelDataCalculationsUncheckedCreateWithoutAccountInput> | ModelDataCalculationsCreateWithoutAccountInput[] | ModelDataCalculationsUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: ModelDataCalculationsCreateOrConnectWithoutAccountInput | ModelDataCalculationsCreateOrConnectWithoutAccountInput[]
    createMany?: ModelDataCalculationsCreateManyAccountInputEnvelope
    connect?: ModelDataCalculationsWhereUniqueInput | ModelDataCalculationsWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<AccountCreateWithoutParentInput, AccountUncheckedCreateWithoutParentInput> | AccountCreateWithoutParentInput[] | AccountUncheckedCreateWithoutParentInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutParentInput | AccountCreateOrConnectWithoutParentInput[]
    createMany?: AccountCreateManyParentInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type AccountAttributeAndValueUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<AccountAttributeAndValueCreateWithoutAccountInput, AccountAttributeAndValueUncheckedCreateWithoutAccountInput> | AccountAttributeAndValueCreateWithoutAccountInput[] | AccountAttributeAndValueUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: AccountAttributeAndValueCreateOrConnectWithoutAccountInput | AccountAttributeAndValueCreateOrConnectWithoutAccountInput[]
    createMany?: AccountAttributeAndValueCreateManyAccountInputEnvelope
    connect?: AccountAttributeAndValueWhereUniqueInput | AccountAttributeAndValueWhereUniqueInput[]
  }

  export type ModelAccountStructureUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<ModelAccountStructureCreateWithoutAccountInput, ModelAccountStructureUncheckedCreateWithoutAccountInput> | ModelAccountStructureCreateWithoutAccountInput[] | ModelAccountStructureUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: ModelAccountStructureCreateOrConnectWithoutAccountInput | ModelAccountStructureCreateOrConnectWithoutAccountInput[]
    createMany?: ModelAccountStructureCreateManyAccountInputEnvelope
    connect?: ModelAccountStructureWhereUniqueInput | ModelAccountStructureWhereUniqueInput[]
  }

  export type ModelDataUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<ModelDataCreateWithoutAccountInput, ModelDataUncheckedCreateWithoutAccountInput> | ModelDataCreateWithoutAccountInput[] | ModelDataUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: ModelDataCreateOrConnectWithoutAccountInput | ModelDataCreateOrConnectWithoutAccountInput[]
    createMany?: ModelDataCreateManyAccountInputEnvelope
    connect?: ModelDataWhereUniqueInput | ModelDataWhereUniqueInput[]
  }

  export type ModelDataCalculationsUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<ModelDataCalculationsCreateWithoutAccountInput, ModelDataCalculationsUncheckedCreateWithoutAccountInput> | ModelDataCalculationsCreateWithoutAccountInput[] | ModelDataCalculationsUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: ModelDataCalculationsCreateOrConnectWithoutAccountInput | ModelDataCalculationsCreateOrConnectWithoutAccountInput[]
    createMany?: ModelDataCalculationsCreateManyAccountInputEnvelope
    connect?: ModelDataCalculationsWhereUniqueInput | ModelDataCalculationsWhereUniqueInput[]
  }

  export type EnumAccountTypeFieldUpdateOperationsInput = {
    set?: $Enums.AccountType
  }

  export type EnumAccountTypeTagFieldUpdateOperationsInput = {
    set?: $Enums.AccountTypeTag
  }

  export type NullableEnumActPlanByFieldUpdateOperationsInput = {
    set?: $Enums.ActPlanBy | null
    unset?: boolean
  }

  export type NullableEnumActActualsByFieldUpdateOperationsInput = {
    set?: $Enums.ActActualsBy | null
    unset?: boolean
  }

  export type EnumActDisplayAsFieldUpdateOperationsInput = {
    set?: $Enums.ActDisplayAs
  }

  export type InstanceUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<InstanceCreateWithoutAccountsInput, InstanceUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: InstanceCreateOrConnectWithoutAccountsInput
    upsert?: InstanceUpsertWithoutAccountsInput
    connect?: InstanceWhereUniqueInput
    update?: XOR<XOR<InstanceUpdateToOneWithWhereWithoutAccountsInput, InstanceUpdateWithoutAccountsInput>, InstanceUncheckedUpdateWithoutAccountsInput>
  }

  export type AccountUpdateOneWithoutChildAccountsNestedInput = {
    create?: XOR<AccountCreateWithoutChildAccountsInput, AccountUncheckedCreateWithoutChildAccountsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutChildAccountsInput
    upsert?: AccountUpsertWithoutChildAccountsInput
    disconnect?: boolean
    delete?: AccountWhereInput | boolean
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutChildAccountsInput, AccountUpdateWithoutChildAccountsInput>, AccountUncheckedUpdateWithoutChildAccountsInput>
  }

  export type AccountUpdateManyWithoutParentNestedInput = {
    create?: XOR<AccountCreateWithoutParentInput, AccountUncheckedCreateWithoutParentInput> | AccountCreateWithoutParentInput[] | AccountUncheckedCreateWithoutParentInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutParentInput | AccountCreateOrConnectWithoutParentInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutParentInput | AccountUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: AccountCreateManyParentInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutParentInput | AccountUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutParentInput | AccountUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type AccountAttributeAndValueUpdateManyWithoutAccountNestedInput = {
    create?: XOR<AccountAttributeAndValueCreateWithoutAccountInput, AccountAttributeAndValueUncheckedCreateWithoutAccountInput> | AccountAttributeAndValueCreateWithoutAccountInput[] | AccountAttributeAndValueUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: AccountAttributeAndValueCreateOrConnectWithoutAccountInput | AccountAttributeAndValueCreateOrConnectWithoutAccountInput[]
    upsert?: AccountAttributeAndValueUpsertWithWhereUniqueWithoutAccountInput | AccountAttributeAndValueUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: AccountAttributeAndValueCreateManyAccountInputEnvelope
    set?: AccountAttributeAndValueWhereUniqueInput | AccountAttributeAndValueWhereUniqueInput[]
    disconnect?: AccountAttributeAndValueWhereUniqueInput | AccountAttributeAndValueWhereUniqueInput[]
    delete?: AccountAttributeAndValueWhereUniqueInput | AccountAttributeAndValueWhereUniqueInput[]
    connect?: AccountAttributeAndValueWhereUniqueInput | AccountAttributeAndValueWhereUniqueInput[]
    update?: AccountAttributeAndValueUpdateWithWhereUniqueWithoutAccountInput | AccountAttributeAndValueUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: AccountAttributeAndValueUpdateManyWithWhereWithoutAccountInput | AccountAttributeAndValueUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: AccountAttributeAndValueScalarWhereInput | AccountAttributeAndValueScalarWhereInput[]
  }

  export type ModelAccountStructureUpdateManyWithoutAccountNestedInput = {
    create?: XOR<ModelAccountStructureCreateWithoutAccountInput, ModelAccountStructureUncheckedCreateWithoutAccountInput> | ModelAccountStructureCreateWithoutAccountInput[] | ModelAccountStructureUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: ModelAccountStructureCreateOrConnectWithoutAccountInput | ModelAccountStructureCreateOrConnectWithoutAccountInput[]
    upsert?: ModelAccountStructureUpsertWithWhereUniqueWithoutAccountInput | ModelAccountStructureUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: ModelAccountStructureCreateManyAccountInputEnvelope
    set?: ModelAccountStructureWhereUniqueInput | ModelAccountStructureWhereUniqueInput[]
    disconnect?: ModelAccountStructureWhereUniqueInput | ModelAccountStructureWhereUniqueInput[]
    delete?: ModelAccountStructureWhereUniqueInput | ModelAccountStructureWhereUniqueInput[]
    connect?: ModelAccountStructureWhereUniqueInput | ModelAccountStructureWhereUniqueInput[]
    update?: ModelAccountStructureUpdateWithWhereUniqueWithoutAccountInput | ModelAccountStructureUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: ModelAccountStructureUpdateManyWithWhereWithoutAccountInput | ModelAccountStructureUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: ModelAccountStructureScalarWhereInput | ModelAccountStructureScalarWhereInput[]
  }

  export type ModelDataUpdateManyWithoutAccountNestedInput = {
    create?: XOR<ModelDataCreateWithoutAccountInput, ModelDataUncheckedCreateWithoutAccountInput> | ModelDataCreateWithoutAccountInput[] | ModelDataUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: ModelDataCreateOrConnectWithoutAccountInput | ModelDataCreateOrConnectWithoutAccountInput[]
    upsert?: ModelDataUpsertWithWhereUniqueWithoutAccountInput | ModelDataUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: ModelDataCreateManyAccountInputEnvelope
    set?: ModelDataWhereUniqueInput | ModelDataWhereUniqueInput[]
    disconnect?: ModelDataWhereUniqueInput | ModelDataWhereUniqueInput[]
    delete?: ModelDataWhereUniqueInput | ModelDataWhereUniqueInput[]
    connect?: ModelDataWhereUniqueInput | ModelDataWhereUniqueInput[]
    update?: ModelDataUpdateWithWhereUniqueWithoutAccountInput | ModelDataUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: ModelDataUpdateManyWithWhereWithoutAccountInput | ModelDataUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: ModelDataScalarWhereInput | ModelDataScalarWhereInput[]
  }

  export type ModelDataCalculationsUpdateManyWithoutAccountNestedInput = {
    create?: XOR<ModelDataCalculationsCreateWithoutAccountInput, ModelDataCalculationsUncheckedCreateWithoutAccountInput> | ModelDataCalculationsCreateWithoutAccountInput[] | ModelDataCalculationsUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: ModelDataCalculationsCreateOrConnectWithoutAccountInput | ModelDataCalculationsCreateOrConnectWithoutAccountInput[]
    upsert?: ModelDataCalculationsUpsertWithWhereUniqueWithoutAccountInput | ModelDataCalculationsUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: ModelDataCalculationsCreateManyAccountInputEnvelope
    set?: ModelDataCalculationsWhereUniqueInput | ModelDataCalculationsWhereUniqueInput[]
    disconnect?: ModelDataCalculationsWhereUniqueInput | ModelDataCalculationsWhereUniqueInput[]
    delete?: ModelDataCalculationsWhereUniqueInput | ModelDataCalculationsWhereUniqueInput[]
    connect?: ModelDataCalculationsWhereUniqueInput | ModelDataCalculationsWhereUniqueInput[]
    update?: ModelDataCalculationsUpdateWithWhereUniqueWithoutAccountInput | ModelDataCalculationsUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: ModelDataCalculationsUpdateManyWithWhereWithoutAccountInput | ModelDataCalculationsUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: ModelDataCalculationsScalarWhereInput | ModelDataCalculationsScalarWhereInput[]
  }

  export type AccountUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<AccountCreateWithoutParentInput, AccountUncheckedCreateWithoutParentInput> | AccountCreateWithoutParentInput[] | AccountUncheckedCreateWithoutParentInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutParentInput | AccountCreateOrConnectWithoutParentInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutParentInput | AccountUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: AccountCreateManyParentInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutParentInput | AccountUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutParentInput | AccountUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type AccountAttributeAndValueUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<AccountAttributeAndValueCreateWithoutAccountInput, AccountAttributeAndValueUncheckedCreateWithoutAccountInput> | AccountAttributeAndValueCreateWithoutAccountInput[] | AccountAttributeAndValueUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: AccountAttributeAndValueCreateOrConnectWithoutAccountInput | AccountAttributeAndValueCreateOrConnectWithoutAccountInput[]
    upsert?: AccountAttributeAndValueUpsertWithWhereUniqueWithoutAccountInput | AccountAttributeAndValueUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: AccountAttributeAndValueCreateManyAccountInputEnvelope
    set?: AccountAttributeAndValueWhereUniqueInput | AccountAttributeAndValueWhereUniqueInput[]
    disconnect?: AccountAttributeAndValueWhereUniqueInput | AccountAttributeAndValueWhereUniqueInput[]
    delete?: AccountAttributeAndValueWhereUniqueInput | AccountAttributeAndValueWhereUniqueInput[]
    connect?: AccountAttributeAndValueWhereUniqueInput | AccountAttributeAndValueWhereUniqueInput[]
    update?: AccountAttributeAndValueUpdateWithWhereUniqueWithoutAccountInput | AccountAttributeAndValueUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: AccountAttributeAndValueUpdateManyWithWhereWithoutAccountInput | AccountAttributeAndValueUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: AccountAttributeAndValueScalarWhereInput | AccountAttributeAndValueScalarWhereInput[]
  }

  export type ModelAccountStructureUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<ModelAccountStructureCreateWithoutAccountInput, ModelAccountStructureUncheckedCreateWithoutAccountInput> | ModelAccountStructureCreateWithoutAccountInput[] | ModelAccountStructureUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: ModelAccountStructureCreateOrConnectWithoutAccountInput | ModelAccountStructureCreateOrConnectWithoutAccountInput[]
    upsert?: ModelAccountStructureUpsertWithWhereUniqueWithoutAccountInput | ModelAccountStructureUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: ModelAccountStructureCreateManyAccountInputEnvelope
    set?: ModelAccountStructureWhereUniqueInput | ModelAccountStructureWhereUniqueInput[]
    disconnect?: ModelAccountStructureWhereUniqueInput | ModelAccountStructureWhereUniqueInput[]
    delete?: ModelAccountStructureWhereUniqueInput | ModelAccountStructureWhereUniqueInput[]
    connect?: ModelAccountStructureWhereUniqueInput | ModelAccountStructureWhereUniqueInput[]
    update?: ModelAccountStructureUpdateWithWhereUniqueWithoutAccountInput | ModelAccountStructureUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: ModelAccountStructureUpdateManyWithWhereWithoutAccountInput | ModelAccountStructureUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: ModelAccountStructureScalarWhereInput | ModelAccountStructureScalarWhereInput[]
  }

  export type ModelDataUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<ModelDataCreateWithoutAccountInput, ModelDataUncheckedCreateWithoutAccountInput> | ModelDataCreateWithoutAccountInput[] | ModelDataUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: ModelDataCreateOrConnectWithoutAccountInput | ModelDataCreateOrConnectWithoutAccountInput[]
    upsert?: ModelDataUpsertWithWhereUniqueWithoutAccountInput | ModelDataUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: ModelDataCreateManyAccountInputEnvelope
    set?: ModelDataWhereUniqueInput | ModelDataWhereUniqueInput[]
    disconnect?: ModelDataWhereUniqueInput | ModelDataWhereUniqueInput[]
    delete?: ModelDataWhereUniqueInput | ModelDataWhereUniqueInput[]
    connect?: ModelDataWhereUniqueInput | ModelDataWhereUniqueInput[]
    update?: ModelDataUpdateWithWhereUniqueWithoutAccountInput | ModelDataUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: ModelDataUpdateManyWithWhereWithoutAccountInput | ModelDataUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: ModelDataScalarWhereInput | ModelDataScalarWhereInput[]
  }

  export type ModelDataCalculationsUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<ModelDataCalculationsCreateWithoutAccountInput, ModelDataCalculationsUncheckedCreateWithoutAccountInput> | ModelDataCalculationsCreateWithoutAccountInput[] | ModelDataCalculationsUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: ModelDataCalculationsCreateOrConnectWithoutAccountInput | ModelDataCalculationsCreateOrConnectWithoutAccountInput[]
    upsert?: ModelDataCalculationsUpsertWithWhereUniqueWithoutAccountInput | ModelDataCalculationsUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: ModelDataCalculationsCreateManyAccountInputEnvelope
    set?: ModelDataCalculationsWhereUniqueInput | ModelDataCalculationsWhereUniqueInput[]
    disconnect?: ModelDataCalculationsWhereUniqueInput | ModelDataCalculationsWhereUniqueInput[]
    delete?: ModelDataCalculationsWhereUniqueInput | ModelDataCalculationsWhereUniqueInput[]
    connect?: ModelDataCalculationsWhereUniqueInput | ModelDataCalculationsWhereUniqueInput[]
    update?: ModelDataCalculationsUpdateWithWhereUniqueWithoutAccountInput | ModelDataCalculationsUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: ModelDataCalculationsUpdateManyWithWhereWithoutAccountInput | ModelDataCalculationsUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: ModelDataCalculationsScalarWhereInput | ModelDataCalculationsScalarWhereInput[]
  }

  export type InstanceCreateNestedOneWithoutDimensionsInput = {
    create?: XOR<InstanceCreateWithoutDimensionsInput, InstanceUncheckedCreateWithoutDimensionsInput>
    connectOrCreate?: InstanceCreateOrConnectWithoutDimensionsInput
    connect?: InstanceWhereUniqueInput
  }

  export type DimensionValueCreateNestedManyWithoutDimensionInput = {
    create?: XOR<DimensionValueCreateWithoutDimensionInput, DimensionValueUncheckedCreateWithoutDimensionInput> | DimensionValueCreateWithoutDimensionInput[] | DimensionValueUncheckedCreateWithoutDimensionInput[]
    connectOrCreate?: DimensionValueCreateOrConnectWithoutDimensionInput | DimensionValueCreateOrConnectWithoutDimensionInput[]
    createMany?: DimensionValueCreateManyDimensionInputEnvelope
    connect?: DimensionValueWhereUniqueInput | DimensionValueWhereUniqueInput[]
  }

  export type DimensionValueUncheckedCreateNestedManyWithoutDimensionInput = {
    create?: XOR<DimensionValueCreateWithoutDimensionInput, DimensionValueUncheckedCreateWithoutDimensionInput> | DimensionValueCreateWithoutDimensionInput[] | DimensionValueUncheckedCreateWithoutDimensionInput[]
    connectOrCreate?: DimensionValueCreateOrConnectWithoutDimensionInput | DimensionValueCreateOrConnectWithoutDimensionInput[]
    createMany?: DimensionValueCreateManyDimensionInputEnvelope
    connect?: DimensionValueWhereUniqueInput | DimensionValueWhereUniqueInput[]
  }

  export type InstanceUpdateOneRequiredWithoutDimensionsNestedInput = {
    create?: XOR<InstanceCreateWithoutDimensionsInput, InstanceUncheckedCreateWithoutDimensionsInput>
    connectOrCreate?: InstanceCreateOrConnectWithoutDimensionsInput
    upsert?: InstanceUpsertWithoutDimensionsInput
    connect?: InstanceWhereUniqueInput
    update?: XOR<XOR<InstanceUpdateToOneWithWhereWithoutDimensionsInput, InstanceUpdateWithoutDimensionsInput>, InstanceUncheckedUpdateWithoutDimensionsInput>
  }

  export type DimensionValueUpdateManyWithoutDimensionNestedInput = {
    create?: XOR<DimensionValueCreateWithoutDimensionInput, DimensionValueUncheckedCreateWithoutDimensionInput> | DimensionValueCreateWithoutDimensionInput[] | DimensionValueUncheckedCreateWithoutDimensionInput[]
    connectOrCreate?: DimensionValueCreateOrConnectWithoutDimensionInput | DimensionValueCreateOrConnectWithoutDimensionInput[]
    upsert?: DimensionValueUpsertWithWhereUniqueWithoutDimensionInput | DimensionValueUpsertWithWhereUniqueWithoutDimensionInput[]
    createMany?: DimensionValueCreateManyDimensionInputEnvelope
    set?: DimensionValueWhereUniqueInput | DimensionValueWhereUniqueInput[]
    disconnect?: DimensionValueWhereUniqueInput | DimensionValueWhereUniqueInput[]
    delete?: DimensionValueWhereUniqueInput | DimensionValueWhereUniqueInput[]
    connect?: DimensionValueWhereUniqueInput | DimensionValueWhereUniqueInput[]
    update?: DimensionValueUpdateWithWhereUniqueWithoutDimensionInput | DimensionValueUpdateWithWhereUniqueWithoutDimensionInput[]
    updateMany?: DimensionValueUpdateManyWithWhereWithoutDimensionInput | DimensionValueUpdateManyWithWhereWithoutDimensionInput[]
    deleteMany?: DimensionValueScalarWhereInput | DimensionValueScalarWhereInput[]
  }

  export type DimensionValueUncheckedUpdateManyWithoutDimensionNestedInput = {
    create?: XOR<DimensionValueCreateWithoutDimensionInput, DimensionValueUncheckedCreateWithoutDimensionInput> | DimensionValueCreateWithoutDimensionInput[] | DimensionValueUncheckedCreateWithoutDimensionInput[]
    connectOrCreate?: DimensionValueCreateOrConnectWithoutDimensionInput | DimensionValueCreateOrConnectWithoutDimensionInput[]
    upsert?: DimensionValueUpsertWithWhereUniqueWithoutDimensionInput | DimensionValueUpsertWithWhereUniqueWithoutDimensionInput[]
    createMany?: DimensionValueCreateManyDimensionInputEnvelope
    set?: DimensionValueWhereUniqueInput | DimensionValueWhereUniqueInput[]
    disconnect?: DimensionValueWhereUniqueInput | DimensionValueWhereUniqueInput[]
    delete?: DimensionValueWhereUniqueInput | DimensionValueWhereUniqueInput[]
    connect?: DimensionValueWhereUniqueInput | DimensionValueWhereUniqueInput[]
    update?: DimensionValueUpdateWithWhereUniqueWithoutDimensionInput | DimensionValueUpdateWithWhereUniqueWithoutDimensionInput[]
    updateMany?: DimensionValueUpdateManyWithWhereWithoutDimensionInput | DimensionValueUpdateManyWithWhereWithoutDimensionInput[]
    deleteMany?: DimensionValueScalarWhereInput | DimensionValueScalarWhereInput[]
  }

  export type DimensionValueCreateNestedOneWithoutChildDimensionValuesInput = {
    create?: XOR<DimensionValueCreateWithoutChildDimensionValuesInput, DimensionValueUncheckedCreateWithoutChildDimensionValuesInput>
    connectOrCreate?: DimensionValueCreateOrConnectWithoutChildDimensionValuesInput
    connect?: DimensionValueWhereUniqueInput
  }

  export type DimensionValueCreateNestedManyWithoutParentInput = {
    create?: XOR<DimensionValueCreateWithoutParentInput, DimensionValueUncheckedCreateWithoutParentInput> | DimensionValueCreateWithoutParentInput[] | DimensionValueUncheckedCreateWithoutParentInput[]
    connectOrCreate?: DimensionValueCreateOrConnectWithoutParentInput | DimensionValueCreateOrConnectWithoutParentInput[]
    createMany?: DimensionValueCreateManyParentInputEnvelope
    connect?: DimensionValueWhereUniqueInput | DimensionValueWhereUniqueInput[]
  }

  export type DimensionValueAttributeAndValueCreateNestedManyWithoutDimensionValueInput = {
    create?: XOR<DimensionValueAttributeAndValueCreateWithoutDimensionValueInput, DimensionValueAttributeAndValueUncheckedCreateWithoutDimensionValueInput> | DimensionValueAttributeAndValueCreateWithoutDimensionValueInput[] | DimensionValueAttributeAndValueUncheckedCreateWithoutDimensionValueInput[]
    connectOrCreate?: DimensionValueAttributeAndValueCreateOrConnectWithoutDimensionValueInput | DimensionValueAttributeAndValueCreateOrConnectWithoutDimensionValueInput[]
    createMany?: DimensionValueAttributeAndValueCreateManyDimensionValueInputEnvelope
    connect?: DimensionValueAttributeAndValueWhereUniqueInput | DimensionValueAttributeAndValueWhereUniqueInput[]
  }

  export type InstanceCreateNestedOneWithoutDimensionValuesInput = {
    create?: XOR<InstanceCreateWithoutDimensionValuesInput, InstanceUncheckedCreateWithoutDimensionValuesInput>
    connectOrCreate?: InstanceCreateOrConnectWithoutDimensionValuesInput
    connect?: InstanceWhereUniqueInput
  }

  export type DimensionCreateNestedOneWithoutDimensionValuesInput = {
    create?: XOR<DimensionCreateWithoutDimensionValuesInput, DimensionUncheckedCreateWithoutDimensionValuesInput>
    connectOrCreate?: DimensionCreateOrConnectWithoutDimensionValuesInput
    connect?: DimensionWhereUniqueInput
  }

  export type DimensionValueUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<DimensionValueCreateWithoutParentInput, DimensionValueUncheckedCreateWithoutParentInput> | DimensionValueCreateWithoutParentInput[] | DimensionValueUncheckedCreateWithoutParentInput[]
    connectOrCreate?: DimensionValueCreateOrConnectWithoutParentInput | DimensionValueCreateOrConnectWithoutParentInput[]
    createMany?: DimensionValueCreateManyParentInputEnvelope
    connect?: DimensionValueWhereUniqueInput | DimensionValueWhereUniqueInput[]
  }

  export type DimensionValueAttributeAndValueUncheckedCreateNestedManyWithoutDimensionValueInput = {
    create?: XOR<DimensionValueAttributeAndValueCreateWithoutDimensionValueInput, DimensionValueAttributeAndValueUncheckedCreateWithoutDimensionValueInput> | DimensionValueAttributeAndValueCreateWithoutDimensionValueInput[] | DimensionValueAttributeAndValueUncheckedCreateWithoutDimensionValueInput[]
    connectOrCreate?: DimensionValueAttributeAndValueCreateOrConnectWithoutDimensionValueInput | DimensionValueAttributeAndValueCreateOrConnectWithoutDimensionValueInput[]
    createMany?: DimensionValueAttributeAndValueCreateManyDimensionValueInputEnvelope
    connect?: DimensionValueAttributeAndValueWhereUniqueInput | DimensionValueAttributeAndValueWhereUniqueInput[]
  }

  export type DimensionValueUpdateOneWithoutChildDimensionValuesNestedInput = {
    create?: XOR<DimensionValueCreateWithoutChildDimensionValuesInput, DimensionValueUncheckedCreateWithoutChildDimensionValuesInput>
    connectOrCreate?: DimensionValueCreateOrConnectWithoutChildDimensionValuesInput
    upsert?: DimensionValueUpsertWithoutChildDimensionValuesInput
    disconnect?: boolean
    delete?: DimensionValueWhereInput | boolean
    connect?: DimensionValueWhereUniqueInput
    update?: XOR<XOR<DimensionValueUpdateToOneWithWhereWithoutChildDimensionValuesInput, DimensionValueUpdateWithoutChildDimensionValuesInput>, DimensionValueUncheckedUpdateWithoutChildDimensionValuesInput>
  }

  export type DimensionValueUpdateManyWithoutParentNestedInput = {
    create?: XOR<DimensionValueCreateWithoutParentInput, DimensionValueUncheckedCreateWithoutParentInput> | DimensionValueCreateWithoutParentInput[] | DimensionValueUncheckedCreateWithoutParentInput[]
    connectOrCreate?: DimensionValueCreateOrConnectWithoutParentInput | DimensionValueCreateOrConnectWithoutParentInput[]
    upsert?: DimensionValueUpsertWithWhereUniqueWithoutParentInput | DimensionValueUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: DimensionValueCreateManyParentInputEnvelope
    set?: DimensionValueWhereUniqueInput | DimensionValueWhereUniqueInput[]
    disconnect?: DimensionValueWhereUniqueInput | DimensionValueWhereUniqueInput[]
    delete?: DimensionValueWhereUniqueInput | DimensionValueWhereUniqueInput[]
    connect?: DimensionValueWhereUniqueInput | DimensionValueWhereUniqueInput[]
    update?: DimensionValueUpdateWithWhereUniqueWithoutParentInput | DimensionValueUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: DimensionValueUpdateManyWithWhereWithoutParentInput | DimensionValueUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: DimensionValueScalarWhereInput | DimensionValueScalarWhereInput[]
  }

  export type DimensionValueAttributeAndValueUpdateManyWithoutDimensionValueNestedInput = {
    create?: XOR<DimensionValueAttributeAndValueCreateWithoutDimensionValueInput, DimensionValueAttributeAndValueUncheckedCreateWithoutDimensionValueInput> | DimensionValueAttributeAndValueCreateWithoutDimensionValueInput[] | DimensionValueAttributeAndValueUncheckedCreateWithoutDimensionValueInput[]
    connectOrCreate?: DimensionValueAttributeAndValueCreateOrConnectWithoutDimensionValueInput | DimensionValueAttributeAndValueCreateOrConnectWithoutDimensionValueInput[]
    upsert?: DimensionValueAttributeAndValueUpsertWithWhereUniqueWithoutDimensionValueInput | DimensionValueAttributeAndValueUpsertWithWhereUniqueWithoutDimensionValueInput[]
    createMany?: DimensionValueAttributeAndValueCreateManyDimensionValueInputEnvelope
    set?: DimensionValueAttributeAndValueWhereUniqueInput | DimensionValueAttributeAndValueWhereUniqueInput[]
    disconnect?: DimensionValueAttributeAndValueWhereUniqueInput | DimensionValueAttributeAndValueWhereUniqueInput[]
    delete?: DimensionValueAttributeAndValueWhereUniqueInput | DimensionValueAttributeAndValueWhereUniqueInput[]
    connect?: DimensionValueAttributeAndValueWhereUniqueInput | DimensionValueAttributeAndValueWhereUniqueInput[]
    update?: DimensionValueAttributeAndValueUpdateWithWhereUniqueWithoutDimensionValueInput | DimensionValueAttributeAndValueUpdateWithWhereUniqueWithoutDimensionValueInput[]
    updateMany?: DimensionValueAttributeAndValueUpdateManyWithWhereWithoutDimensionValueInput | DimensionValueAttributeAndValueUpdateManyWithWhereWithoutDimensionValueInput[]
    deleteMany?: DimensionValueAttributeAndValueScalarWhereInput | DimensionValueAttributeAndValueScalarWhereInput[]
  }

  export type InstanceUpdateOneRequiredWithoutDimensionValuesNestedInput = {
    create?: XOR<InstanceCreateWithoutDimensionValuesInput, InstanceUncheckedCreateWithoutDimensionValuesInput>
    connectOrCreate?: InstanceCreateOrConnectWithoutDimensionValuesInput
    upsert?: InstanceUpsertWithoutDimensionValuesInput
    connect?: InstanceWhereUniqueInput
    update?: XOR<XOR<InstanceUpdateToOneWithWhereWithoutDimensionValuesInput, InstanceUpdateWithoutDimensionValuesInput>, InstanceUncheckedUpdateWithoutDimensionValuesInput>
  }

  export type DimensionUpdateOneRequiredWithoutDimensionValuesNestedInput = {
    create?: XOR<DimensionCreateWithoutDimensionValuesInput, DimensionUncheckedCreateWithoutDimensionValuesInput>
    connectOrCreate?: DimensionCreateOrConnectWithoutDimensionValuesInput
    upsert?: DimensionUpsertWithoutDimensionValuesInput
    connect?: DimensionWhereUniqueInput
    update?: XOR<XOR<DimensionUpdateToOneWithWhereWithoutDimensionValuesInput, DimensionUpdateWithoutDimensionValuesInput>, DimensionUncheckedUpdateWithoutDimensionValuesInput>
  }

  export type DimensionValueUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<DimensionValueCreateWithoutParentInput, DimensionValueUncheckedCreateWithoutParentInput> | DimensionValueCreateWithoutParentInput[] | DimensionValueUncheckedCreateWithoutParentInput[]
    connectOrCreate?: DimensionValueCreateOrConnectWithoutParentInput | DimensionValueCreateOrConnectWithoutParentInput[]
    upsert?: DimensionValueUpsertWithWhereUniqueWithoutParentInput | DimensionValueUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: DimensionValueCreateManyParentInputEnvelope
    set?: DimensionValueWhereUniqueInput | DimensionValueWhereUniqueInput[]
    disconnect?: DimensionValueWhereUniqueInput | DimensionValueWhereUniqueInput[]
    delete?: DimensionValueWhereUniqueInput | DimensionValueWhereUniqueInput[]
    connect?: DimensionValueWhereUniqueInput | DimensionValueWhereUniqueInput[]
    update?: DimensionValueUpdateWithWhereUniqueWithoutParentInput | DimensionValueUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: DimensionValueUpdateManyWithWhereWithoutParentInput | DimensionValueUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: DimensionValueScalarWhereInput | DimensionValueScalarWhereInput[]
  }

  export type DimensionValueAttributeAndValueUncheckedUpdateManyWithoutDimensionValueNestedInput = {
    create?: XOR<DimensionValueAttributeAndValueCreateWithoutDimensionValueInput, DimensionValueAttributeAndValueUncheckedCreateWithoutDimensionValueInput> | DimensionValueAttributeAndValueCreateWithoutDimensionValueInput[] | DimensionValueAttributeAndValueUncheckedCreateWithoutDimensionValueInput[]
    connectOrCreate?: DimensionValueAttributeAndValueCreateOrConnectWithoutDimensionValueInput | DimensionValueAttributeAndValueCreateOrConnectWithoutDimensionValueInput[]
    upsert?: DimensionValueAttributeAndValueUpsertWithWhereUniqueWithoutDimensionValueInput | DimensionValueAttributeAndValueUpsertWithWhereUniqueWithoutDimensionValueInput[]
    createMany?: DimensionValueAttributeAndValueCreateManyDimensionValueInputEnvelope
    set?: DimensionValueAttributeAndValueWhereUniqueInput | DimensionValueAttributeAndValueWhereUniqueInput[]
    disconnect?: DimensionValueAttributeAndValueWhereUniqueInput | DimensionValueAttributeAndValueWhereUniqueInput[]
    delete?: DimensionValueAttributeAndValueWhereUniqueInput | DimensionValueAttributeAndValueWhereUniqueInput[]
    connect?: DimensionValueAttributeAndValueWhereUniqueInput | DimensionValueAttributeAndValueWhereUniqueInput[]
    update?: DimensionValueAttributeAndValueUpdateWithWhereUniqueWithoutDimensionValueInput | DimensionValueAttributeAndValueUpdateWithWhereUniqueWithoutDimensionValueInput[]
    updateMany?: DimensionValueAttributeAndValueUpdateManyWithWhereWithoutDimensionValueInput | DimensionValueAttributeAndValueUpdateManyWithWhereWithoutDimensionValueInput[]
    deleteMany?: DimensionValueAttributeAndValueScalarWhereInput | DimensionValueAttributeAndValueScalarWhereInput[]
  }

  export type InstanceCreateNestedOneWithoutDimensionValueAttributesInput = {
    create?: XOR<InstanceCreateWithoutDimensionValueAttributesInput, InstanceUncheckedCreateWithoutDimensionValueAttributesInput>
    connectOrCreate?: InstanceCreateOrConnectWithoutDimensionValueAttributesInput
    connect?: InstanceWhereUniqueInput
  }

  export type DimensionValueAttributeValueCreateNestedManyWithoutDimensionValueAttributeInput = {
    create?: XOR<DimensionValueAttributeValueCreateWithoutDimensionValueAttributeInput, DimensionValueAttributeValueUncheckedCreateWithoutDimensionValueAttributeInput> | DimensionValueAttributeValueCreateWithoutDimensionValueAttributeInput[] | DimensionValueAttributeValueUncheckedCreateWithoutDimensionValueAttributeInput[]
    connectOrCreate?: DimensionValueAttributeValueCreateOrConnectWithoutDimensionValueAttributeInput | DimensionValueAttributeValueCreateOrConnectWithoutDimensionValueAttributeInput[]
    createMany?: DimensionValueAttributeValueCreateManyDimensionValueAttributeInputEnvelope
    connect?: DimensionValueAttributeValueWhereUniqueInput | DimensionValueAttributeValueWhereUniqueInput[]
  }

  export type DimensionValueAttributeAndValueCreateNestedManyWithoutAttributeInput = {
    create?: XOR<DimensionValueAttributeAndValueCreateWithoutAttributeInput, DimensionValueAttributeAndValueUncheckedCreateWithoutAttributeInput> | DimensionValueAttributeAndValueCreateWithoutAttributeInput[] | DimensionValueAttributeAndValueUncheckedCreateWithoutAttributeInput[]
    connectOrCreate?: DimensionValueAttributeAndValueCreateOrConnectWithoutAttributeInput | DimensionValueAttributeAndValueCreateOrConnectWithoutAttributeInput[]
    createMany?: DimensionValueAttributeAndValueCreateManyAttributeInputEnvelope
    connect?: DimensionValueAttributeAndValueWhereUniqueInput | DimensionValueAttributeAndValueWhereUniqueInput[]
  }

  export type DimensionValueAttributeValueUncheckedCreateNestedManyWithoutDimensionValueAttributeInput = {
    create?: XOR<DimensionValueAttributeValueCreateWithoutDimensionValueAttributeInput, DimensionValueAttributeValueUncheckedCreateWithoutDimensionValueAttributeInput> | DimensionValueAttributeValueCreateWithoutDimensionValueAttributeInput[] | DimensionValueAttributeValueUncheckedCreateWithoutDimensionValueAttributeInput[]
    connectOrCreate?: DimensionValueAttributeValueCreateOrConnectWithoutDimensionValueAttributeInput | DimensionValueAttributeValueCreateOrConnectWithoutDimensionValueAttributeInput[]
    createMany?: DimensionValueAttributeValueCreateManyDimensionValueAttributeInputEnvelope
    connect?: DimensionValueAttributeValueWhereUniqueInput | DimensionValueAttributeValueWhereUniqueInput[]
  }

  export type DimensionValueAttributeAndValueUncheckedCreateNestedManyWithoutAttributeInput = {
    create?: XOR<DimensionValueAttributeAndValueCreateWithoutAttributeInput, DimensionValueAttributeAndValueUncheckedCreateWithoutAttributeInput> | DimensionValueAttributeAndValueCreateWithoutAttributeInput[] | DimensionValueAttributeAndValueUncheckedCreateWithoutAttributeInput[]
    connectOrCreate?: DimensionValueAttributeAndValueCreateOrConnectWithoutAttributeInput | DimensionValueAttributeAndValueCreateOrConnectWithoutAttributeInput[]
    createMany?: DimensionValueAttributeAndValueCreateManyAttributeInputEnvelope
    connect?: DimensionValueAttributeAndValueWhereUniqueInput | DimensionValueAttributeAndValueWhereUniqueInput[]
  }

  export type InstanceUpdateOneRequiredWithoutDimensionValueAttributesNestedInput = {
    create?: XOR<InstanceCreateWithoutDimensionValueAttributesInput, InstanceUncheckedCreateWithoutDimensionValueAttributesInput>
    connectOrCreate?: InstanceCreateOrConnectWithoutDimensionValueAttributesInput
    upsert?: InstanceUpsertWithoutDimensionValueAttributesInput
    connect?: InstanceWhereUniqueInput
    update?: XOR<XOR<InstanceUpdateToOneWithWhereWithoutDimensionValueAttributesInput, InstanceUpdateWithoutDimensionValueAttributesInput>, InstanceUncheckedUpdateWithoutDimensionValueAttributesInput>
  }

  export type DimensionValueAttributeValueUpdateManyWithoutDimensionValueAttributeNestedInput = {
    create?: XOR<DimensionValueAttributeValueCreateWithoutDimensionValueAttributeInput, DimensionValueAttributeValueUncheckedCreateWithoutDimensionValueAttributeInput> | DimensionValueAttributeValueCreateWithoutDimensionValueAttributeInput[] | DimensionValueAttributeValueUncheckedCreateWithoutDimensionValueAttributeInput[]
    connectOrCreate?: DimensionValueAttributeValueCreateOrConnectWithoutDimensionValueAttributeInput | DimensionValueAttributeValueCreateOrConnectWithoutDimensionValueAttributeInput[]
    upsert?: DimensionValueAttributeValueUpsertWithWhereUniqueWithoutDimensionValueAttributeInput | DimensionValueAttributeValueUpsertWithWhereUniqueWithoutDimensionValueAttributeInput[]
    createMany?: DimensionValueAttributeValueCreateManyDimensionValueAttributeInputEnvelope
    set?: DimensionValueAttributeValueWhereUniqueInput | DimensionValueAttributeValueWhereUniqueInput[]
    disconnect?: DimensionValueAttributeValueWhereUniqueInput | DimensionValueAttributeValueWhereUniqueInput[]
    delete?: DimensionValueAttributeValueWhereUniqueInput | DimensionValueAttributeValueWhereUniqueInput[]
    connect?: DimensionValueAttributeValueWhereUniqueInput | DimensionValueAttributeValueWhereUniqueInput[]
    update?: DimensionValueAttributeValueUpdateWithWhereUniqueWithoutDimensionValueAttributeInput | DimensionValueAttributeValueUpdateWithWhereUniqueWithoutDimensionValueAttributeInput[]
    updateMany?: DimensionValueAttributeValueUpdateManyWithWhereWithoutDimensionValueAttributeInput | DimensionValueAttributeValueUpdateManyWithWhereWithoutDimensionValueAttributeInput[]
    deleteMany?: DimensionValueAttributeValueScalarWhereInput | DimensionValueAttributeValueScalarWhereInput[]
  }

  export type DimensionValueAttributeAndValueUpdateManyWithoutAttributeNestedInput = {
    create?: XOR<DimensionValueAttributeAndValueCreateWithoutAttributeInput, DimensionValueAttributeAndValueUncheckedCreateWithoutAttributeInput> | DimensionValueAttributeAndValueCreateWithoutAttributeInput[] | DimensionValueAttributeAndValueUncheckedCreateWithoutAttributeInput[]
    connectOrCreate?: DimensionValueAttributeAndValueCreateOrConnectWithoutAttributeInput | DimensionValueAttributeAndValueCreateOrConnectWithoutAttributeInput[]
    upsert?: DimensionValueAttributeAndValueUpsertWithWhereUniqueWithoutAttributeInput | DimensionValueAttributeAndValueUpsertWithWhereUniqueWithoutAttributeInput[]
    createMany?: DimensionValueAttributeAndValueCreateManyAttributeInputEnvelope
    set?: DimensionValueAttributeAndValueWhereUniqueInput | DimensionValueAttributeAndValueWhereUniqueInput[]
    disconnect?: DimensionValueAttributeAndValueWhereUniqueInput | DimensionValueAttributeAndValueWhereUniqueInput[]
    delete?: DimensionValueAttributeAndValueWhereUniqueInput | DimensionValueAttributeAndValueWhereUniqueInput[]
    connect?: DimensionValueAttributeAndValueWhereUniqueInput | DimensionValueAttributeAndValueWhereUniqueInput[]
    update?: DimensionValueAttributeAndValueUpdateWithWhereUniqueWithoutAttributeInput | DimensionValueAttributeAndValueUpdateWithWhereUniqueWithoutAttributeInput[]
    updateMany?: DimensionValueAttributeAndValueUpdateManyWithWhereWithoutAttributeInput | DimensionValueAttributeAndValueUpdateManyWithWhereWithoutAttributeInput[]
    deleteMany?: DimensionValueAttributeAndValueScalarWhereInput | DimensionValueAttributeAndValueScalarWhereInput[]
  }

  export type DimensionValueAttributeValueUncheckedUpdateManyWithoutDimensionValueAttributeNestedInput = {
    create?: XOR<DimensionValueAttributeValueCreateWithoutDimensionValueAttributeInput, DimensionValueAttributeValueUncheckedCreateWithoutDimensionValueAttributeInput> | DimensionValueAttributeValueCreateWithoutDimensionValueAttributeInput[] | DimensionValueAttributeValueUncheckedCreateWithoutDimensionValueAttributeInput[]
    connectOrCreate?: DimensionValueAttributeValueCreateOrConnectWithoutDimensionValueAttributeInput | DimensionValueAttributeValueCreateOrConnectWithoutDimensionValueAttributeInput[]
    upsert?: DimensionValueAttributeValueUpsertWithWhereUniqueWithoutDimensionValueAttributeInput | DimensionValueAttributeValueUpsertWithWhereUniqueWithoutDimensionValueAttributeInput[]
    createMany?: DimensionValueAttributeValueCreateManyDimensionValueAttributeInputEnvelope
    set?: DimensionValueAttributeValueWhereUniqueInput | DimensionValueAttributeValueWhereUniqueInput[]
    disconnect?: DimensionValueAttributeValueWhereUniqueInput | DimensionValueAttributeValueWhereUniqueInput[]
    delete?: DimensionValueAttributeValueWhereUniqueInput | DimensionValueAttributeValueWhereUniqueInput[]
    connect?: DimensionValueAttributeValueWhereUniqueInput | DimensionValueAttributeValueWhereUniqueInput[]
    update?: DimensionValueAttributeValueUpdateWithWhereUniqueWithoutDimensionValueAttributeInput | DimensionValueAttributeValueUpdateWithWhereUniqueWithoutDimensionValueAttributeInput[]
    updateMany?: DimensionValueAttributeValueUpdateManyWithWhereWithoutDimensionValueAttributeInput | DimensionValueAttributeValueUpdateManyWithWhereWithoutDimensionValueAttributeInput[]
    deleteMany?: DimensionValueAttributeValueScalarWhereInput | DimensionValueAttributeValueScalarWhereInput[]
  }

  export type DimensionValueAttributeAndValueUncheckedUpdateManyWithoutAttributeNestedInput = {
    create?: XOR<DimensionValueAttributeAndValueCreateWithoutAttributeInput, DimensionValueAttributeAndValueUncheckedCreateWithoutAttributeInput> | DimensionValueAttributeAndValueCreateWithoutAttributeInput[] | DimensionValueAttributeAndValueUncheckedCreateWithoutAttributeInput[]
    connectOrCreate?: DimensionValueAttributeAndValueCreateOrConnectWithoutAttributeInput | DimensionValueAttributeAndValueCreateOrConnectWithoutAttributeInput[]
    upsert?: DimensionValueAttributeAndValueUpsertWithWhereUniqueWithoutAttributeInput | DimensionValueAttributeAndValueUpsertWithWhereUniqueWithoutAttributeInput[]
    createMany?: DimensionValueAttributeAndValueCreateManyAttributeInputEnvelope
    set?: DimensionValueAttributeAndValueWhereUniqueInput | DimensionValueAttributeAndValueWhereUniqueInput[]
    disconnect?: DimensionValueAttributeAndValueWhereUniqueInput | DimensionValueAttributeAndValueWhereUniqueInput[]
    delete?: DimensionValueAttributeAndValueWhereUniqueInput | DimensionValueAttributeAndValueWhereUniqueInput[]
    connect?: DimensionValueAttributeAndValueWhereUniqueInput | DimensionValueAttributeAndValueWhereUniqueInput[]
    update?: DimensionValueAttributeAndValueUpdateWithWhereUniqueWithoutAttributeInput | DimensionValueAttributeAndValueUpdateWithWhereUniqueWithoutAttributeInput[]
    updateMany?: DimensionValueAttributeAndValueUpdateManyWithWhereWithoutAttributeInput | DimensionValueAttributeAndValueUpdateManyWithWhereWithoutAttributeInput[]
    deleteMany?: DimensionValueAttributeAndValueScalarWhereInput | DimensionValueAttributeAndValueScalarWhereInput[]
  }

  export type InstanceCreateNestedOneWithoutDimensionValueAttributeValuesInput = {
    create?: XOR<InstanceCreateWithoutDimensionValueAttributeValuesInput, InstanceUncheckedCreateWithoutDimensionValueAttributeValuesInput>
    connectOrCreate?: InstanceCreateOrConnectWithoutDimensionValueAttributeValuesInput
    connect?: InstanceWhereUniqueInput
  }

  export type DimensionValueAttributeValueCreateNestedOneWithoutChildAttributeValuesInput = {
    create?: XOR<DimensionValueAttributeValueCreateWithoutChildAttributeValuesInput, DimensionValueAttributeValueUncheckedCreateWithoutChildAttributeValuesInput>
    connectOrCreate?: DimensionValueAttributeValueCreateOrConnectWithoutChildAttributeValuesInput
    connect?: DimensionValueAttributeValueWhereUniqueInput
  }

  export type DimensionValueAttributeValueCreateNestedManyWithoutParentInput = {
    create?: XOR<DimensionValueAttributeValueCreateWithoutParentInput, DimensionValueAttributeValueUncheckedCreateWithoutParentInput> | DimensionValueAttributeValueCreateWithoutParentInput[] | DimensionValueAttributeValueUncheckedCreateWithoutParentInput[]
    connectOrCreate?: DimensionValueAttributeValueCreateOrConnectWithoutParentInput | DimensionValueAttributeValueCreateOrConnectWithoutParentInput[]
    createMany?: DimensionValueAttributeValueCreateManyParentInputEnvelope
    connect?: DimensionValueAttributeValueWhereUniqueInput | DimensionValueAttributeValueWhereUniqueInput[]
  }

  export type DimensionValueAttributeCreateNestedOneWithoutAttributeValuesInput = {
    create?: XOR<DimensionValueAttributeCreateWithoutAttributeValuesInput, DimensionValueAttributeUncheckedCreateWithoutAttributeValuesInput>
    connectOrCreate?: DimensionValueAttributeCreateOrConnectWithoutAttributeValuesInput
    connect?: DimensionValueAttributeWhereUniqueInput
  }

  export type DimensionValueAttributeAndValueCreateNestedManyWithoutAttributeValueInput = {
    create?: XOR<DimensionValueAttributeAndValueCreateWithoutAttributeValueInput, DimensionValueAttributeAndValueUncheckedCreateWithoutAttributeValueInput> | DimensionValueAttributeAndValueCreateWithoutAttributeValueInput[] | DimensionValueAttributeAndValueUncheckedCreateWithoutAttributeValueInput[]
    connectOrCreate?: DimensionValueAttributeAndValueCreateOrConnectWithoutAttributeValueInput | DimensionValueAttributeAndValueCreateOrConnectWithoutAttributeValueInput[]
    createMany?: DimensionValueAttributeAndValueCreateManyAttributeValueInputEnvelope
    connect?: DimensionValueAttributeAndValueWhereUniqueInput | DimensionValueAttributeAndValueWhereUniqueInput[]
  }

  export type DimensionValueAttributeValueUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<DimensionValueAttributeValueCreateWithoutParentInput, DimensionValueAttributeValueUncheckedCreateWithoutParentInput> | DimensionValueAttributeValueCreateWithoutParentInput[] | DimensionValueAttributeValueUncheckedCreateWithoutParentInput[]
    connectOrCreate?: DimensionValueAttributeValueCreateOrConnectWithoutParentInput | DimensionValueAttributeValueCreateOrConnectWithoutParentInput[]
    createMany?: DimensionValueAttributeValueCreateManyParentInputEnvelope
    connect?: DimensionValueAttributeValueWhereUniqueInput | DimensionValueAttributeValueWhereUniqueInput[]
  }

  export type DimensionValueAttributeAndValueUncheckedCreateNestedManyWithoutAttributeValueInput = {
    create?: XOR<DimensionValueAttributeAndValueCreateWithoutAttributeValueInput, DimensionValueAttributeAndValueUncheckedCreateWithoutAttributeValueInput> | DimensionValueAttributeAndValueCreateWithoutAttributeValueInput[] | DimensionValueAttributeAndValueUncheckedCreateWithoutAttributeValueInput[]
    connectOrCreate?: DimensionValueAttributeAndValueCreateOrConnectWithoutAttributeValueInput | DimensionValueAttributeAndValueCreateOrConnectWithoutAttributeValueInput[]
    createMany?: DimensionValueAttributeAndValueCreateManyAttributeValueInputEnvelope
    connect?: DimensionValueAttributeAndValueWhereUniqueInput | DimensionValueAttributeAndValueWhereUniqueInput[]
  }

  export type InstanceUpdateOneRequiredWithoutDimensionValueAttributeValuesNestedInput = {
    create?: XOR<InstanceCreateWithoutDimensionValueAttributeValuesInput, InstanceUncheckedCreateWithoutDimensionValueAttributeValuesInput>
    connectOrCreate?: InstanceCreateOrConnectWithoutDimensionValueAttributeValuesInput
    upsert?: InstanceUpsertWithoutDimensionValueAttributeValuesInput
    connect?: InstanceWhereUniqueInput
    update?: XOR<XOR<InstanceUpdateToOneWithWhereWithoutDimensionValueAttributeValuesInput, InstanceUpdateWithoutDimensionValueAttributeValuesInput>, InstanceUncheckedUpdateWithoutDimensionValueAttributeValuesInput>
  }

  export type DimensionValueAttributeValueUpdateOneWithoutChildAttributeValuesNestedInput = {
    create?: XOR<DimensionValueAttributeValueCreateWithoutChildAttributeValuesInput, DimensionValueAttributeValueUncheckedCreateWithoutChildAttributeValuesInput>
    connectOrCreate?: DimensionValueAttributeValueCreateOrConnectWithoutChildAttributeValuesInput
    upsert?: DimensionValueAttributeValueUpsertWithoutChildAttributeValuesInput
    disconnect?: boolean
    delete?: DimensionValueAttributeValueWhereInput | boolean
    connect?: DimensionValueAttributeValueWhereUniqueInput
    update?: XOR<XOR<DimensionValueAttributeValueUpdateToOneWithWhereWithoutChildAttributeValuesInput, DimensionValueAttributeValueUpdateWithoutChildAttributeValuesInput>, DimensionValueAttributeValueUncheckedUpdateWithoutChildAttributeValuesInput>
  }

  export type DimensionValueAttributeValueUpdateManyWithoutParentNestedInput = {
    create?: XOR<DimensionValueAttributeValueCreateWithoutParentInput, DimensionValueAttributeValueUncheckedCreateWithoutParentInput> | DimensionValueAttributeValueCreateWithoutParentInput[] | DimensionValueAttributeValueUncheckedCreateWithoutParentInput[]
    connectOrCreate?: DimensionValueAttributeValueCreateOrConnectWithoutParentInput | DimensionValueAttributeValueCreateOrConnectWithoutParentInput[]
    upsert?: DimensionValueAttributeValueUpsertWithWhereUniqueWithoutParentInput | DimensionValueAttributeValueUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: DimensionValueAttributeValueCreateManyParentInputEnvelope
    set?: DimensionValueAttributeValueWhereUniqueInput | DimensionValueAttributeValueWhereUniqueInput[]
    disconnect?: DimensionValueAttributeValueWhereUniqueInput | DimensionValueAttributeValueWhereUniqueInput[]
    delete?: DimensionValueAttributeValueWhereUniqueInput | DimensionValueAttributeValueWhereUniqueInput[]
    connect?: DimensionValueAttributeValueWhereUniqueInput | DimensionValueAttributeValueWhereUniqueInput[]
    update?: DimensionValueAttributeValueUpdateWithWhereUniqueWithoutParentInput | DimensionValueAttributeValueUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: DimensionValueAttributeValueUpdateManyWithWhereWithoutParentInput | DimensionValueAttributeValueUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: DimensionValueAttributeValueScalarWhereInput | DimensionValueAttributeValueScalarWhereInput[]
  }

  export type DimensionValueAttributeUpdateOneRequiredWithoutAttributeValuesNestedInput = {
    create?: XOR<DimensionValueAttributeCreateWithoutAttributeValuesInput, DimensionValueAttributeUncheckedCreateWithoutAttributeValuesInput>
    connectOrCreate?: DimensionValueAttributeCreateOrConnectWithoutAttributeValuesInput
    upsert?: DimensionValueAttributeUpsertWithoutAttributeValuesInput
    connect?: DimensionValueAttributeWhereUniqueInput
    update?: XOR<XOR<DimensionValueAttributeUpdateToOneWithWhereWithoutAttributeValuesInput, DimensionValueAttributeUpdateWithoutAttributeValuesInput>, DimensionValueAttributeUncheckedUpdateWithoutAttributeValuesInput>
  }

  export type DimensionValueAttributeAndValueUpdateManyWithoutAttributeValueNestedInput = {
    create?: XOR<DimensionValueAttributeAndValueCreateWithoutAttributeValueInput, DimensionValueAttributeAndValueUncheckedCreateWithoutAttributeValueInput> | DimensionValueAttributeAndValueCreateWithoutAttributeValueInput[] | DimensionValueAttributeAndValueUncheckedCreateWithoutAttributeValueInput[]
    connectOrCreate?: DimensionValueAttributeAndValueCreateOrConnectWithoutAttributeValueInput | DimensionValueAttributeAndValueCreateOrConnectWithoutAttributeValueInput[]
    upsert?: DimensionValueAttributeAndValueUpsertWithWhereUniqueWithoutAttributeValueInput | DimensionValueAttributeAndValueUpsertWithWhereUniqueWithoutAttributeValueInput[]
    createMany?: DimensionValueAttributeAndValueCreateManyAttributeValueInputEnvelope
    set?: DimensionValueAttributeAndValueWhereUniqueInput | DimensionValueAttributeAndValueWhereUniqueInput[]
    disconnect?: DimensionValueAttributeAndValueWhereUniqueInput | DimensionValueAttributeAndValueWhereUniqueInput[]
    delete?: DimensionValueAttributeAndValueWhereUniqueInput | DimensionValueAttributeAndValueWhereUniqueInput[]
    connect?: DimensionValueAttributeAndValueWhereUniqueInput | DimensionValueAttributeAndValueWhereUniqueInput[]
    update?: DimensionValueAttributeAndValueUpdateWithWhereUniqueWithoutAttributeValueInput | DimensionValueAttributeAndValueUpdateWithWhereUniqueWithoutAttributeValueInput[]
    updateMany?: DimensionValueAttributeAndValueUpdateManyWithWhereWithoutAttributeValueInput | DimensionValueAttributeAndValueUpdateManyWithWhereWithoutAttributeValueInput[]
    deleteMany?: DimensionValueAttributeAndValueScalarWhereInput | DimensionValueAttributeAndValueScalarWhereInput[]
  }

  export type DimensionValueAttributeValueUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<DimensionValueAttributeValueCreateWithoutParentInput, DimensionValueAttributeValueUncheckedCreateWithoutParentInput> | DimensionValueAttributeValueCreateWithoutParentInput[] | DimensionValueAttributeValueUncheckedCreateWithoutParentInput[]
    connectOrCreate?: DimensionValueAttributeValueCreateOrConnectWithoutParentInput | DimensionValueAttributeValueCreateOrConnectWithoutParentInput[]
    upsert?: DimensionValueAttributeValueUpsertWithWhereUniqueWithoutParentInput | DimensionValueAttributeValueUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: DimensionValueAttributeValueCreateManyParentInputEnvelope
    set?: DimensionValueAttributeValueWhereUniqueInput | DimensionValueAttributeValueWhereUniqueInput[]
    disconnect?: DimensionValueAttributeValueWhereUniqueInput | DimensionValueAttributeValueWhereUniqueInput[]
    delete?: DimensionValueAttributeValueWhereUniqueInput | DimensionValueAttributeValueWhereUniqueInput[]
    connect?: DimensionValueAttributeValueWhereUniqueInput | DimensionValueAttributeValueWhereUniqueInput[]
    update?: DimensionValueAttributeValueUpdateWithWhereUniqueWithoutParentInput | DimensionValueAttributeValueUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: DimensionValueAttributeValueUpdateManyWithWhereWithoutParentInput | DimensionValueAttributeValueUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: DimensionValueAttributeValueScalarWhereInput | DimensionValueAttributeValueScalarWhereInput[]
  }

  export type DimensionValueAttributeAndValueUncheckedUpdateManyWithoutAttributeValueNestedInput = {
    create?: XOR<DimensionValueAttributeAndValueCreateWithoutAttributeValueInput, DimensionValueAttributeAndValueUncheckedCreateWithoutAttributeValueInput> | DimensionValueAttributeAndValueCreateWithoutAttributeValueInput[] | DimensionValueAttributeAndValueUncheckedCreateWithoutAttributeValueInput[]
    connectOrCreate?: DimensionValueAttributeAndValueCreateOrConnectWithoutAttributeValueInput | DimensionValueAttributeAndValueCreateOrConnectWithoutAttributeValueInput[]
    upsert?: DimensionValueAttributeAndValueUpsertWithWhereUniqueWithoutAttributeValueInput | DimensionValueAttributeAndValueUpsertWithWhereUniqueWithoutAttributeValueInput[]
    createMany?: DimensionValueAttributeAndValueCreateManyAttributeValueInputEnvelope
    set?: DimensionValueAttributeAndValueWhereUniqueInput | DimensionValueAttributeAndValueWhereUniqueInput[]
    disconnect?: DimensionValueAttributeAndValueWhereUniqueInput | DimensionValueAttributeAndValueWhereUniqueInput[]
    delete?: DimensionValueAttributeAndValueWhereUniqueInput | DimensionValueAttributeAndValueWhereUniqueInput[]
    connect?: DimensionValueAttributeAndValueWhereUniqueInput | DimensionValueAttributeAndValueWhereUniqueInput[]
    update?: DimensionValueAttributeAndValueUpdateWithWhereUniqueWithoutAttributeValueInput | DimensionValueAttributeAndValueUpdateWithWhereUniqueWithoutAttributeValueInput[]
    updateMany?: DimensionValueAttributeAndValueUpdateManyWithWhereWithoutAttributeValueInput | DimensionValueAttributeAndValueUpdateManyWithWhereWithoutAttributeValueInput[]
    deleteMany?: DimensionValueAttributeAndValueScalarWhereInput | DimensionValueAttributeAndValueScalarWhereInput[]
  }

  export type DimensionValueCreateNestedOneWithoutAttributeAndValuesInput = {
    create?: XOR<DimensionValueCreateWithoutAttributeAndValuesInput, DimensionValueUncheckedCreateWithoutAttributeAndValuesInput>
    connectOrCreate?: DimensionValueCreateOrConnectWithoutAttributeAndValuesInput
    connect?: DimensionValueWhereUniqueInput
  }

  export type DimensionValueAttributeCreateNestedOneWithoutAttributeAndValuesInput = {
    create?: XOR<DimensionValueAttributeCreateWithoutAttributeAndValuesInput, DimensionValueAttributeUncheckedCreateWithoutAttributeAndValuesInput>
    connectOrCreate?: DimensionValueAttributeCreateOrConnectWithoutAttributeAndValuesInput
    connect?: DimensionValueAttributeWhereUniqueInput
  }

  export type DimensionValueAttributeValueCreateNestedOneWithoutDimensionAttributeAndValuesInput = {
    create?: XOR<DimensionValueAttributeValueCreateWithoutDimensionAttributeAndValuesInput, DimensionValueAttributeValueUncheckedCreateWithoutDimensionAttributeAndValuesInput>
    connectOrCreate?: DimensionValueAttributeValueCreateOrConnectWithoutDimensionAttributeAndValuesInput
    connect?: DimensionValueAttributeValueWhereUniqueInput
  }

  export type DimensionValueUpdateOneWithoutAttributeAndValuesNestedInput = {
    create?: XOR<DimensionValueCreateWithoutAttributeAndValuesInput, DimensionValueUncheckedCreateWithoutAttributeAndValuesInput>
    connectOrCreate?: DimensionValueCreateOrConnectWithoutAttributeAndValuesInput
    upsert?: DimensionValueUpsertWithoutAttributeAndValuesInput
    disconnect?: boolean
    delete?: DimensionValueWhereInput | boolean
    connect?: DimensionValueWhereUniqueInput
    update?: XOR<XOR<DimensionValueUpdateToOneWithWhereWithoutAttributeAndValuesInput, DimensionValueUpdateWithoutAttributeAndValuesInput>, DimensionValueUncheckedUpdateWithoutAttributeAndValuesInput>
  }

  export type DimensionValueAttributeUpdateOneWithoutAttributeAndValuesNestedInput = {
    create?: XOR<DimensionValueAttributeCreateWithoutAttributeAndValuesInput, DimensionValueAttributeUncheckedCreateWithoutAttributeAndValuesInput>
    connectOrCreate?: DimensionValueAttributeCreateOrConnectWithoutAttributeAndValuesInput
    upsert?: DimensionValueAttributeUpsertWithoutAttributeAndValuesInput
    disconnect?: boolean
    delete?: DimensionValueAttributeWhereInput | boolean
    connect?: DimensionValueAttributeWhereUniqueInput
    update?: XOR<XOR<DimensionValueAttributeUpdateToOneWithWhereWithoutAttributeAndValuesInput, DimensionValueAttributeUpdateWithoutAttributeAndValuesInput>, DimensionValueAttributeUncheckedUpdateWithoutAttributeAndValuesInput>
  }

  export type DimensionValueAttributeValueUpdateOneWithoutDimensionAttributeAndValuesNestedInput = {
    create?: XOR<DimensionValueAttributeValueCreateWithoutDimensionAttributeAndValuesInput, DimensionValueAttributeValueUncheckedCreateWithoutDimensionAttributeAndValuesInput>
    connectOrCreate?: DimensionValueAttributeValueCreateOrConnectWithoutDimensionAttributeAndValuesInput
    upsert?: DimensionValueAttributeValueUpsertWithoutDimensionAttributeAndValuesInput
    disconnect?: boolean
    delete?: DimensionValueAttributeValueWhereInput | boolean
    connect?: DimensionValueAttributeValueWhereUniqueInput
    update?: XOR<XOR<DimensionValueAttributeValueUpdateToOneWithWhereWithoutDimensionAttributeAndValuesInput, DimensionValueAttributeValueUpdateWithoutDimensionAttributeAndValuesInput>, DimensionValueAttributeValueUncheckedUpdateWithoutDimensionAttributeAndValuesInput>
  }

  export type ModelCreatedimensionalityInput = {
    set: string[]
  }

  export type InstanceCreateNestedOneWithoutModelsInput = {
    create?: XOR<InstanceCreateWithoutModelsInput, InstanceUncheckedCreateWithoutModelsInput>
    connectOrCreate?: InstanceCreateOrConnectWithoutModelsInput
    connect?: InstanceWhereUniqueInput
  }

  export type ModelDataCreateNestedManyWithoutModelInput = {
    create?: XOR<ModelDataCreateWithoutModelInput, ModelDataUncheckedCreateWithoutModelInput> | ModelDataCreateWithoutModelInput[] | ModelDataUncheckedCreateWithoutModelInput[]
    connectOrCreate?: ModelDataCreateOrConnectWithoutModelInput | ModelDataCreateOrConnectWithoutModelInput[]
    createMany?: ModelDataCreateManyModelInputEnvelope
    connect?: ModelDataWhereUniqueInput | ModelDataWhereUniqueInput[]
  }

  export type ModelAccountStructureCreateNestedManyWithoutModelInput = {
    create?: XOR<ModelAccountStructureCreateWithoutModelInput, ModelAccountStructureUncheckedCreateWithoutModelInput> | ModelAccountStructureCreateWithoutModelInput[] | ModelAccountStructureUncheckedCreateWithoutModelInput[]
    connectOrCreate?: ModelAccountStructureCreateOrConnectWithoutModelInput | ModelAccountStructureCreateOrConnectWithoutModelInput[]
    createMany?: ModelAccountStructureCreateManyModelInputEnvelope
    connect?: ModelAccountStructureWhereUniqueInput | ModelAccountStructureWhereUniqueInput[]
  }

  export type ModelDataCalculationsCreateNestedManyWithoutModelInput = {
    create?: XOR<ModelDataCalculationsCreateWithoutModelInput, ModelDataCalculationsUncheckedCreateWithoutModelInput> | ModelDataCalculationsCreateWithoutModelInput[] | ModelDataCalculationsUncheckedCreateWithoutModelInput[]
    connectOrCreate?: ModelDataCalculationsCreateOrConnectWithoutModelInput | ModelDataCalculationsCreateOrConnectWithoutModelInput[]
    createMany?: ModelDataCalculationsCreateManyModelInputEnvelope
    connect?: ModelDataCalculationsWhereUniqueInput | ModelDataCalculationsWhereUniqueInput[]
  }

  export type ModelDataUncheckedCreateNestedManyWithoutModelInput = {
    create?: XOR<ModelDataCreateWithoutModelInput, ModelDataUncheckedCreateWithoutModelInput> | ModelDataCreateWithoutModelInput[] | ModelDataUncheckedCreateWithoutModelInput[]
    connectOrCreate?: ModelDataCreateOrConnectWithoutModelInput | ModelDataCreateOrConnectWithoutModelInput[]
    createMany?: ModelDataCreateManyModelInputEnvelope
    connect?: ModelDataWhereUniqueInput | ModelDataWhereUniqueInput[]
  }

  export type ModelAccountStructureUncheckedCreateNestedManyWithoutModelInput = {
    create?: XOR<ModelAccountStructureCreateWithoutModelInput, ModelAccountStructureUncheckedCreateWithoutModelInput> | ModelAccountStructureCreateWithoutModelInput[] | ModelAccountStructureUncheckedCreateWithoutModelInput[]
    connectOrCreate?: ModelAccountStructureCreateOrConnectWithoutModelInput | ModelAccountStructureCreateOrConnectWithoutModelInput[]
    createMany?: ModelAccountStructureCreateManyModelInputEnvelope
    connect?: ModelAccountStructureWhereUniqueInput | ModelAccountStructureWhereUniqueInput[]
  }

  export type ModelDataCalculationsUncheckedCreateNestedManyWithoutModelInput = {
    create?: XOR<ModelDataCalculationsCreateWithoutModelInput, ModelDataCalculationsUncheckedCreateWithoutModelInput> | ModelDataCalculationsCreateWithoutModelInput[] | ModelDataCalculationsUncheckedCreateWithoutModelInput[]
    connectOrCreate?: ModelDataCalculationsCreateOrConnectWithoutModelInput | ModelDataCalculationsCreateOrConnectWithoutModelInput[]
    createMany?: ModelDataCalculationsCreateManyModelInputEnvelope
    connect?: ModelDataCalculationsWhereUniqueInput | ModelDataCalculationsWhereUniqueInput[]
  }

  export type ModelUpdatedimensionalityInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EnumModelStatusFieldUpdateOperationsInput = {
    set?: $Enums.ModelStatus
  }

  export type InstanceUpdateOneRequiredWithoutModelsNestedInput = {
    create?: XOR<InstanceCreateWithoutModelsInput, InstanceUncheckedCreateWithoutModelsInput>
    connectOrCreate?: InstanceCreateOrConnectWithoutModelsInput
    upsert?: InstanceUpsertWithoutModelsInput
    connect?: InstanceWhereUniqueInput
    update?: XOR<XOR<InstanceUpdateToOneWithWhereWithoutModelsInput, InstanceUpdateWithoutModelsInput>, InstanceUncheckedUpdateWithoutModelsInput>
  }

  export type ModelDataUpdateManyWithoutModelNestedInput = {
    create?: XOR<ModelDataCreateWithoutModelInput, ModelDataUncheckedCreateWithoutModelInput> | ModelDataCreateWithoutModelInput[] | ModelDataUncheckedCreateWithoutModelInput[]
    connectOrCreate?: ModelDataCreateOrConnectWithoutModelInput | ModelDataCreateOrConnectWithoutModelInput[]
    upsert?: ModelDataUpsertWithWhereUniqueWithoutModelInput | ModelDataUpsertWithWhereUniqueWithoutModelInput[]
    createMany?: ModelDataCreateManyModelInputEnvelope
    set?: ModelDataWhereUniqueInput | ModelDataWhereUniqueInput[]
    disconnect?: ModelDataWhereUniqueInput | ModelDataWhereUniqueInput[]
    delete?: ModelDataWhereUniqueInput | ModelDataWhereUniqueInput[]
    connect?: ModelDataWhereUniqueInput | ModelDataWhereUniqueInput[]
    update?: ModelDataUpdateWithWhereUniqueWithoutModelInput | ModelDataUpdateWithWhereUniqueWithoutModelInput[]
    updateMany?: ModelDataUpdateManyWithWhereWithoutModelInput | ModelDataUpdateManyWithWhereWithoutModelInput[]
    deleteMany?: ModelDataScalarWhereInput | ModelDataScalarWhereInput[]
  }

  export type ModelAccountStructureUpdateManyWithoutModelNestedInput = {
    create?: XOR<ModelAccountStructureCreateWithoutModelInput, ModelAccountStructureUncheckedCreateWithoutModelInput> | ModelAccountStructureCreateWithoutModelInput[] | ModelAccountStructureUncheckedCreateWithoutModelInput[]
    connectOrCreate?: ModelAccountStructureCreateOrConnectWithoutModelInput | ModelAccountStructureCreateOrConnectWithoutModelInput[]
    upsert?: ModelAccountStructureUpsertWithWhereUniqueWithoutModelInput | ModelAccountStructureUpsertWithWhereUniqueWithoutModelInput[]
    createMany?: ModelAccountStructureCreateManyModelInputEnvelope
    set?: ModelAccountStructureWhereUniqueInput | ModelAccountStructureWhereUniqueInput[]
    disconnect?: ModelAccountStructureWhereUniqueInput | ModelAccountStructureWhereUniqueInput[]
    delete?: ModelAccountStructureWhereUniqueInput | ModelAccountStructureWhereUniqueInput[]
    connect?: ModelAccountStructureWhereUniqueInput | ModelAccountStructureWhereUniqueInput[]
    update?: ModelAccountStructureUpdateWithWhereUniqueWithoutModelInput | ModelAccountStructureUpdateWithWhereUniqueWithoutModelInput[]
    updateMany?: ModelAccountStructureUpdateManyWithWhereWithoutModelInput | ModelAccountStructureUpdateManyWithWhereWithoutModelInput[]
    deleteMany?: ModelAccountStructureScalarWhereInput | ModelAccountStructureScalarWhereInput[]
  }

  export type ModelDataCalculationsUpdateManyWithoutModelNestedInput = {
    create?: XOR<ModelDataCalculationsCreateWithoutModelInput, ModelDataCalculationsUncheckedCreateWithoutModelInput> | ModelDataCalculationsCreateWithoutModelInput[] | ModelDataCalculationsUncheckedCreateWithoutModelInput[]
    connectOrCreate?: ModelDataCalculationsCreateOrConnectWithoutModelInput | ModelDataCalculationsCreateOrConnectWithoutModelInput[]
    upsert?: ModelDataCalculationsUpsertWithWhereUniqueWithoutModelInput | ModelDataCalculationsUpsertWithWhereUniqueWithoutModelInput[]
    createMany?: ModelDataCalculationsCreateManyModelInputEnvelope
    set?: ModelDataCalculationsWhereUniqueInput | ModelDataCalculationsWhereUniqueInput[]
    disconnect?: ModelDataCalculationsWhereUniqueInput | ModelDataCalculationsWhereUniqueInput[]
    delete?: ModelDataCalculationsWhereUniqueInput | ModelDataCalculationsWhereUniqueInput[]
    connect?: ModelDataCalculationsWhereUniqueInput | ModelDataCalculationsWhereUniqueInput[]
    update?: ModelDataCalculationsUpdateWithWhereUniqueWithoutModelInput | ModelDataCalculationsUpdateWithWhereUniqueWithoutModelInput[]
    updateMany?: ModelDataCalculationsUpdateManyWithWhereWithoutModelInput | ModelDataCalculationsUpdateManyWithWhereWithoutModelInput[]
    deleteMany?: ModelDataCalculationsScalarWhereInput | ModelDataCalculationsScalarWhereInput[]
  }

  export type ModelDataUncheckedUpdateManyWithoutModelNestedInput = {
    create?: XOR<ModelDataCreateWithoutModelInput, ModelDataUncheckedCreateWithoutModelInput> | ModelDataCreateWithoutModelInput[] | ModelDataUncheckedCreateWithoutModelInput[]
    connectOrCreate?: ModelDataCreateOrConnectWithoutModelInput | ModelDataCreateOrConnectWithoutModelInput[]
    upsert?: ModelDataUpsertWithWhereUniqueWithoutModelInput | ModelDataUpsertWithWhereUniqueWithoutModelInput[]
    createMany?: ModelDataCreateManyModelInputEnvelope
    set?: ModelDataWhereUniqueInput | ModelDataWhereUniqueInput[]
    disconnect?: ModelDataWhereUniqueInput | ModelDataWhereUniqueInput[]
    delete?: ModelDataWhereUniqueInput | ModelDataWhereUniqueInput[]
    connect?: ModelDataWhereUniqueInput | ModelDataWhereUniqueInput[]
    update?: ModelDataUpdateWithWhereUniqueWithoutModelInput | ModelDataUpdateWithWhereUniqueWithoutModelInput[]
    updateMany?: ModelDataUpdateManyWithWhereWithoutModelInput | ModelDataUpdateManyWithWhereWithoutModelInput[]
    deleteMany?: ModelDataScalarWhereInput | ModelDataScalarWhereInput[]
  }

  export type ModelAccountStructureUncheckedUpdateManyWithoutModelNestedInput = {
    create?: XOR<ModelAccountStructureCreateWithoutModelInput, ModelAccountStructureUncheckedCreateWithoutModelInput> | ModelAccountStructureCreateWithoutModelInput[] | ModelAccountStructureUncheckedCreateWithoutModelInput[]
    connectOrCreate?: ModelAccountStructureCreateOrConnectWithoutModelInput | ModelAccountStructureCreateOrConnectWithoutModelInput[]
    upsert?: ModelAccountStructureUpsertWithWhereUniqueWithoutModelInput | ModelAccountStructureUpsertWithWhereUniqueWithoutModelInput[]
    createMany?: ModelAccountStructureCreateManyModelInputEnvelope
    set?: ModelAccountStructureWhereUniqueInput | ModelAccountStructureWhereUniqueInput[]
    disconnect?: ModelAccountStructureWhereUniqueInput | ModelAccountStructureWhereUniqueInput[]
    delete?: ModelAccountStructureWhereUniqueInput | ModelAccountStructureWhereUniqueInput[]
    connect?: ModelAccountStructureWhereUniqueInput | ModelAccountStructureWhereUniqueInput[]
    update?: ModelAccountStructureUpdateWithWhereUniqueWithoutModelInput | ModelAccountStructureUpdateWithWhereUniqueWithoutModelInput[]
    updateMany?: ModelAccountStructureUpdateManyWithWhereWithoutModelInput | ModelAccountStructureUpdateManyWithWhereWithoutModelInput[]
    deleteMany?: ModelAccountStructureScalarWhereInput | ModelAccountStructureScalarWhereInput[]
  }

  export type ModelDataCalculationsUncheckedUpdateManyWithoutModelNestedInput = {
    create?: XOR<ModelDataCalculationsCreateWithoutModelInput, ModelDataCalculationsUncheckedCreateWithoutModelInput> | ModelDataCalculationsCreateWithoutModelInput[] | ModelDataCalculationsUncheckedCreateWithoutModelInput[]
    connectOrCreate?: ModelDataCalculationsCreateOrConnectWithoutModelInput | ModelDataCalculationsCreateOrConnectWithoutModelInput[]
    upsert?: ModelDataCalculationsUpsertWithWhereUniqueWithoutModelInput | ModelDataCalculationsUpsertWithWhereUniqueWithoutModelInput[]
    createMany?: ModelDataCalculationsCreateManyModelInputEnvelope
    set?: ModelDataCalculationsWhereUniqueInput | ModelDataCalculationsWhereUniqueInput[]
    disconnect?: ModelDataCalculationsWhereUniqueInput | ModelDataCalculationsWhereUniqueInput[]
    delete?: ModelDataCalculationsWhereUniqueInput | ModelDataCalculationsWhereUniqueInput[]
    connect?: ModelDataCalculationsWhereUniqueInput | ModelDataCalculationsWhereUniqueInput[]
    update?: ModelDataCalculationsUpdateWithWhereUniqueWithoutModelInput | ModelDataCalculationsUpdateWithWhereUniqueWithoutModelInput[]
    updateMany?: ModelDataCalculationsUpdateManyWithWhereWithoutModelInput | ModelDataCalculationsUpdateManyWithWhereWithoutModelInput[]
    deleteMany?: ModelDataCalculationsScalarWhereInput | ModelDataCalculationsScalarWhereInput[]
  }

  export type InstanceCreateNestedOneWithoutModelAccountsInput = {
    create?: XOR<InstanceCreateWithoutModelAccountsInput, InstanceUncheckedCreateWithoutModelAccountsInput>
    connectOrCreate?: InstanceCreateOrConnectWithoutModelAccountsInput
    connect?: InstanceWhereUniqueInput
  }

  export type ModelCreateNestedOneWithoutModelAccountsInput = {
    create?: XOR<ModelCreateWithoutModelAccountsInput, ModelUncheckedCreateWithoutModelAccountsInput>
    connectOrCreate?: ModelCreateOrConnectWithoutModelAccountsInput
    connect?: ModelWhereUniqueInput
  }

  export type AccountCreateNestedOneWithoutModelAccountsInput = {
    create?: XOR<AccountCreateWithoutModelAccountsInput, AccountUncheckedCreateWithoutModelAccountsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutModelAccountsInput
    connect?: AccountWhereUniqueInput
  }

  export type ModelDataCalculationsCreateNestedManyWithoutModelAccountInput = {
    create?: XOR<ModelDataCalculationsCreateWithoutModelAccountInput, ModelDataCalculationsUncheckedCreateWithoutModelAccountInput> | ModelDataCalculationsCreateWithoutModelAccountInput[] | ModelDataCalculationsUncheckedCreateWithoutModelAccountInput[]
    connectOrCreate?: ModelDataCalculationsCreateOrConnectWithoutModelAccountInput | ModelDataCalculationsCreateOrConnectWithoutModelAccountInput[]
    createMany?: ModelDataCalculationsCreateManyModelAccountInputEnvelope
    connect?: ModelDataCalculationsWhereUniqueInput | ModelDataCalculationsWhereUniqueInput[]
  }

  export type ModelAccountStructureCreateNestedOneWithoutChildAccountsInput = {
    create?: XOR<ModelAccountStructureCreateWithoutChildAccountsInput, ModelAccountStructureUncheckedCreateWithoutChildAccountsInput>
    connectOrCreate?: ModelAccountStructureCreateOrConnectWithoutChildAccountsInput
    connect?: ModelAccountStructureWhereUniqueInput
  }

  export type ModelAccountStructureCreateNestedManyWithoutParentAccountInput = {
    create?: XOR<ModelAccountStructureCreateWithoutParentAccountInput, ModelAccountStructureUncheckedCreateWithoutParentAccountInput> | ModelAccountStructureCreateWithoutParentAccountInput[] | ModelAccountStructureUncheckedCreateWithoutParentAccountInput[]
    connectOrCreate?: ModelAccountStructureCreateOrConnectWithoutParentAccountInput | ModelAccountStructureCreateOrConnectWithoutParentAccountInput[]
    createMany?: ModelAccountStructureCreateManyParentAccountInputEnvelope
    connect?: ModelAccountStructureWhereUniqueInput | ModelAccountStructureWhereUniqueInput[]
  }

  export type ModelDataCalculationsUncheckedCreateNestedManyWithoutModelAccountInput = {
    create?: XOR<ModelDataCalculationsCreateWithoutModelAccountInput, ModelDataCalculationsUncheckedCreateWithoutModelAccountInput> | ModelDataCalculationsCreateWithoutModelAccountInput[] | ModelDataCalculationsUncheckedCreateWithoutModelAccountInput[]
    connectOrCreate?: ModelDataCalculationsCreateOrConnectWithoutModelAccountInput | ModelDataCalculationsCreateOrConnectWithoutModelAccountInput[]
    createMany?: ModelDataCalculationsCreateManyModelAccountInputEnvelope
    connect?: ModelDataCalculationsWhereUniqueInput | ModelDataCalculationsWhereUniqueInput[]
  }

  export type ModelAccountStructureUncheckedCreateNestedManyWithoutParentAccountInput = {
    create?: XOR<ModelAccountStructureCreateWithoutParentAccountInput, ModelAccountStructureUncheckedCreateWithoutParentAccountInput> | ModelAccountStructureCreateWithoutParentAccountInput[] | ModelAccountStructureUncheckedCreateWithoutParentAccountInput[]
    connectOrCreate?: ModelAccountStructureCreateOrConnectWithoutParentAccountInput | ModelAccountStructureCreateOrConnectWithoutParentAccountInput[]
    createMany?: ModelAccountStructureCreateManyParentAccountInputEnvelope
    connect?: ModelAccountStructureWhereUniqueInput | ModelAccountStructureWhereUniqueInput[]
  }

  export type InstanceUpdateOneRequiredWithoutModelAccountsNestedInput = {
    create?: XOR<InstanceCreateWithoutModelAccountsInput, InstanceUncheckedCreateWithoutModelAccountsInput>
    connectOrCreate?: InstanceCreateOrConnectWithoutModelAccountsInput
    upsert?: InstanceUpsertWithoutModelAccountsInput
    connect?: InstanceWhereUniqueInput
    update?: XOR<XOR<InstanceUpdateToOneWithWhereWithoutModelAccountsInput, InstanceUpdateWithoutModelAccountsInput>, InstanceUncheckedUpdateWithoutModelAccountsInput>
  }

  export type ModelUpdateOneRequiredWithoutModelAccountsNestedInput = {
    create?: XOR<ModelCreateWithoutModelAccountsInput, ModelUncheckedCreateWithoutModelAccountsInput>
    connectOrCreate?: ModelCreateOrConnectWithoutModelAccountsInput
    upsert?: ModelUpsertWithoutModelAccountsInput
    connect?: ModelWhereUniqueInput
    update?: XOR<XOR<ModelUpdateToOneWithWhereWithoutModelAccountsInput, ModelUpdateWithoutModelAccountsInput>, ModelUncheckedUpdateWithoutModelAccountsInput>
  }

  export type AccountUpdateOneRequiredWithoutModelAccountsNestedInput = {
    create?: XOR<AccountCreateWithoutModelAccountsInput, AccountUncheckedCreateWithoutModelAccountsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutModelAccountsInput
    upsert?: AccountUpsertWithoutModelAccountsInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutModelAccountsInput, AccountUpdateWithoutModelAccountsInput>, AccountUncheckedUpdateWithoutModelAccountsInput>
  }

  export type ModelDataCalculationsUpdateManyWithoutModelAccountNestedInput = {
    create?: XOR<ModelDataCalculationsCreateWithoutModelAccountInput, ModelDataCalculationsUncheckedCreateWithoutModelAccountInput> | ModelDataCalculationsCreateWithoutModelAccountInput[] | ModelDataCalculationsUncheckedCreateWithoutModelAccountInput[]
    connectOrCreate?: ModelDataCalculationsCreateOrConnectWithoutModelAccountInput | ModelDataCalculationsCreateOrConnectWithoutModelAccountInput[]
    upsert?: ModelDataCalculationsUpsertWithWhereUniqueWithoutModelAccountInput | ModelDataCalculationsUpsertWithWhereUniqueWithoutModelAccountInput[]
    createMany?: ModelDataCalculationsCreateManyModelAccountInputEnvelope
    set?: ModelDataCalculationsWhereUniqueInput | ModelDataCalculationsWhereUniqueInput[]
    disconnect?: ModelDataCalculationsWhereUniqueInput | ModelDataCalculationsWhereUniqueInput[]
    delete?: ModelDataCalculationsWhereUniqueInput | ModelDataCalculationsWhereUniqueInput[]
    connect?: ModelDataCalculationsWhereUniqueInput | ModelDataCalculationsWhereUniqueInput[]
    update?: ModelDataCalculationsUpdateWithWhereUniqueWithoutModelAccountInput | ModelDataCalculationsUpdateWithWhereUniqueWithoutModelAccountInput[]
    updateMany?: ModelDataCalculationsUpdateManyWithWhereWithoutModelAccountInput | ModelDataCalculationsUpdateManyWithWhereWithoutModelAccountInput[]
    deleteMany?: ModelDataCalculationsScalarWhereInput | ModelDataCalculationsScalarWhereInput[]
  }

  export type ModelAccountStructureUpdateOneWithoutChildAccountsNestedInput = {
    create?: XOR<ModelAccountStructureCreateWithoutChildAccountsInput, ModelAccountStructureUncheckedCreateWithoutChildAccountsInput>
    connectOrCreate?: ModelAccountStructureCreateOrConnectWithoutChildAccountsInput
    upsert?: ModelAccountStructureUpsertWithoutChildAccountsInput
    disconnect?: boolean
    delete?: ModelAccountStructureWhereInput | boolean
    connect?: ModelAccountStructureWhereUniqueInput
    update?: XOR<XOR<ModelAccountStructureUpdateToOneWithWhereWithoutChildAccountsInput, ModelAccountStructureUpdateWithoutChildAccountsInput>, ModelAccountStructureUncheckedUpdateWithoutChildAccountsInput>
  }

  export type ModelAccountStructureUpdateManyWithoutParentAccountNestedInput = {
    create?: XOR<ModelAccountStructureCreateWithoutParentAccountInput, ModelAccountStructureUncheckedCreateWithoutParentAccountInput> | ModelAccountStructureCreateWithoutParentAccountInput[] | ModelAccountStructureUncheckedCreateWithoutParentAccountInput[]
    connectOrCreate?: ModelAccountStructureCreateOrConnectWithoutParentAccountInput | ModelAccountStructureCreateOrConnectWithoutParentAccountInput[]
    upsert?: ModelAccountStructureUpsertWithWhereUniqueWithoutParentAccountInput | ModelAccountStructureUpsertWithWhereUniqueWithoutParentAccountInput[]
    createMany?: ModelAccountStructureCreateManyParentAccountInputEnvelope
    set?: ModelAccountStructureWhereUniqueInput | ModelAccountStructureWhereUniqueInput[]
    disconnect?: ModelAccountStructureWhereUniqueInput | ModelAccountStructureWhereUniqueInput[]
    delete?: ModelAccountStructureWhereUniqueInput | ModelAccountStructureWhereUniqueInput[]
    connect?: ModelAccountStructureWhereUniqueInput | ModelAccountStructureWhereUniqueInput[]
    update?: ModelAccountStructureUpdateWithWhereUniqueWithoutParentAccountInput | ModelAccountStructureUpdateWithWhereUniqueWithoutParentAccountInput[]
    updateMany?: ModelAccountStructureUpdateManyWithWhereWithoutParentAccountInput | ModelAccountStructureUpdateManyWithWhereWithoutParentAccountInput[]
    deleteMany?: ModelAccountStructureScalarWhereInput | ModelAccountStructureScalarWhereInput[]
  }

  export type ModelDataCalculationsUncheckedUpdateManyWithoutModelAccountNestedInput = {
    create?: XOR<ModelDataCalculationsCreateWithoutModelAccountInput, ModelDataCalculationsUncheckedCreateWithoutModelAccountInput> | ModelDataCalculationsCreateWithoutModelAccountInput[] | ModelDataCalculationsUncheckedCreateWithoutModelAccountInput[]
    connectOrCreate?: ModelDataCalculationsCreateOrConnectWithoutModelAccountInput | ModelDataCalculationsCreateOrConnectWithoutModelAccountInput[]
    upsert?: ModelDataCalculationsUpsertWithWhereUniqueWithoutModelAccountInput | ModelDataCalculationsUpsertWithWhereUniqueWithoutModelAccountInput[]
    createMany?: ModelDataCalculationsCreateManyModelAccountInputEnvelope
    set?: ModelDataCalculationsWhereUniqueInput | ModelDataCalculationsWhereUniqueInput[]
    disconnect?: ModelDataCalculationsWhereUniqueInput | ModelDataCalculationsWhereUniqueInput[]
    delete?: ModelDataCalculationsWhereUniqueInput | ModelDataCalculationsWhereUniqueInput[]
    connect?: ModelDataCalculationsWhereUniqueInput | ModelDataCalculationsWhereUniqueInput[]
    update?: ModelDataCalculationsUpdateWithWhereUniqueWithoutModelAccountInput | ModelDataCalculationsUpdateWithWhereUniqueWithoutModelAccountInput[]
    updateMany?: ModelDataCalculationsUpdateManyWithWhereWithoutModelAccountInput | ModelDataCalculationsUpdateManyWithWhereWithoutModelAccountInput[]
    deleteMany?: ModelDataCalculationsScalarWhereInput | ModelDataCalculationsScalarWhereInput[]
  }

  export type ModelAccountStructureUncheckedUpdateManyWithoutParentAccountNestedInput = {
    create?: XOR<ModelAccountStructureCreateWithoutParentAccountInput, ModelAccountStructureUncheckedCreateWithoutParentAccountInput> | ModelAccountStructureCreateWithoutParentAccountInput[] | ModelAccountStructureUncheckedCreateWithoutParentAccountInput[]
    connectOrCreate?: ModelAccountStructureCreateOrConnectWithoutParentAccountInput | ModelAccountStructureCreateOrConnectWithoutParentAccountInput[]
    upsert?: ModelAccountStructureUpsertWithWhereUniqueWithoutParentAccountInput | ModelAccountStructureUpsertWithWhereUniqueWithoutParentAccountInput[]
    createMany?: ModelAccountStructureCreateManyParentAccountInputEnvelope
    set?: ModelAccountStructureWhereUniqueInput | ModelAccountStructureWhereUniqueInput[]
    disconnect?: ModelAccountStructureWhereUniqueInput | ModelAccountStructureWhereUniqueInput[]
    delete?: ModelAccountStructureWhereUniqueInput | ModelAccountStructureWhereUniqueInput[]
    connect?: ModelAccountStructureWhereUniqueInput | ModelAccountStructureWhereUniqueInput[]
    update?: ModelAccountStructureUpdateWithWhereUniqueWithoutParentAccountInput | ModelAccountStructureUpdateWithWhereUniqueWithoutParentAccountInput[]
    updateMany?: ModelAccountStructureUpdateManyWithWhereWithoutParentAccountInput | ModelAccountStructureUpdateManyWithWhereWithoutParentAccountInput[]
    deleteMany?: ModelAccountStructureScalarWhereInput | ModelAccountStructureScalarWhereInput[]
  }

  export type ModelDataDimensionalityListCreateEnvelopeInput = {
    set?: ModelDataDimensionalityCreateInput | ModelDataDimensionalityCreateInput[]
  }

  export type ModelDataDimensionalityCreateInput = {
    dimensionId: string
    dimensionValueId: string
  }

  export type ModelCreateNestedOneWithoutModelDataInput = {
    create?: XOR<ModelCreateWithoutModelDataInput, ModelUncheckedCreateWithoutModelDataInput>
    connectOrCreate?: ModelCreateOrConnectWithoutModelDataInput
    connect?: ModelWhereUniqueInput
  }

  export type LevelCreateNestedOneWithoutModelDataInput = {
    create?: XOR<LevelCreateWithoutModelDataInput, LevelUncheckedCreateWithoutModelDataInput>
    connectOrCreate?: LevelCreateOrConnectWithoutModelDataInput
    connect?: LevelWhereUniqueInput
  }

  export type AccountCreateNestedOneWithoutModelDataInput = {
    create?: XOR<AccountCreateWithoutModelDataInput, AccountUncheckedCreateWithoutModelDataInput>
    connectOrCreate?: AccountCreateOrConnectWithoutModelDataInput
    connect?: AccountWhereUniqueInput
  }

  export type VersionCreateNestedOneWithoutModelDataInput = {
    create?: XOR<VersionCreateWithoutModelDataInput, VersionUncheckedCreateWithoutModelDataInput>
    connectOrCreate?: VersionCreateOrConnectWithoutModelDataInput
    connect?: VersionWhereUniqueInput
  }

  export type InstanceCreateNestedOneWithoutModelDataInput = {
    create?: XOR<InstanceCreateWithoutModelDataInput, InstanceUncheckedCreateWithoutModelDataInput>
    connectOrCreate?: InstanceCreateOrConnectWithoutModelDataInput
    connect?: InstanceWhereUniqueInput
  }

  export type ModelDataDimensionalityListUpdateEnvelopeInput = {
    set?: ModelDataDimensionalityCreateInput | ModelDataDimensionalityCreateInput[]
    push?: ModelDataDimensionalityCreateInput | ModelDataDimensionalityCreateInput[]
    updateMany?: ModelDataDimensionalityUpdateManyInput
    deleteMany?: ModelDataDimensionalityDeleteManyInput
  }

  export type ModelUpdateOneRequiredWithoutModelDataNestedInput = {
    create?: XOR<ModelCreateWithoutModelDataInput, ModelUncheckedCreateWithoutModelDataInput>
    connectOrCreate?: ModelCreateOrConnectWithoutModelDataInput
    upsert?: ModelUpsertWithoutModelDataInput
    connect?: ModelWhereUniqueInput
    update?: XOR<XOR<ModelUpdateToOneWithWhereWithoutModelDataInput, ModelUpdateWithoutModelDataInput>, ModelUncheckedUpdateWithoutModelDataInput>
  }

  export type LevelUpdateOneRequiredWithoutModelDataNestedInput = {
    create?: XOR<LevelCreateWithoutModelDataInput, LevelUncheckedCreateWithoutModelDataInput>
    connectOrCreate?: LevelCreateOrConnectWithoutModelDataInput
    upsert?: LevelUpsertWithoutModelDataInput
    connect?: LevelWhereUniqueInput
    update?: XOR<XOR<LevelUpdateToOneWithWhereWithoutModelDataInput, LevelUpdateWithoutModelDataInput>, LevelUncheckedUpdateWithoutModelDataInput>
  }

  export type AccountUpdateOneRequiredWithoutModelDataNestedInput = {
    create?: XOR<AccountCreateWithoutModelDataInput, AccountUncheckedCreateWithoutModelDataInput>
    connectOrCreate?: AccountCreateOrConnectWithoutModelDataInput
    upsert?: AccountUpsertWithoutModelDataInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutModelDataInput, AccountUpdateWithoutModelDataInput>, AccountUncheckedUpdateWithoutModelDataInput>
  }

  export type VersionUpdateOneRequiredWithoutModelDataNestedInput = {
    create?: XOR<VersionCreateWithoutModelDataInput, VersionUncheckedCreateWithoutModelDataInput>
    connectOrCreate?: VersionCreateOrConnectWithoutModelDataInput
    upsert?: VersionUpsertWithoutModelDataInput
    connect?: VersionWhereUniqueInput
    update?: XOR<XOR<VersionUpdateToOneWithWhereWithoutModelDataInput, VersionUpdateWithoutModelDataInput>, VersionUncheckedUpdateWithoutModelDataInput>
  }

  export type InstanceUpdateOneRequiredWithoutModelDataNestedInput = {
    create?: XOR<InstanceCreateWithoutModelDataInput, InstanceUncheckedCreateWithoutModelDataInput>
    connectOrCreate?: InstanceCreateOrConnectWithoutModelDataInput
    upsert?: InstanceUpsertWithoutModelDataInput
    connect?: InstanceWhereUniqueInput
    update?: XOR<XOR<InstanceUpdateToOneWithWhereWithoutModelDataInput, InstanceUpdateWithoutModelDataInput>, InstanceUncheckedUpdateWithoutModelDataInput>
  }

  export type ModelCreateNestedOneWithoutModelDataCalculationsInput = {
    create?: XOR<ModelCreateWithoutModelDataCalculationsInput, ModelUncheckedCreateWithoutModelDataCalculationsInput>
    connectOrCreate?: ModelCreateOrConnectWithoutModelDataCalculationsInput
    connect?: ModelWhereUniqueInput
  }

  export type LevelCreateNestedOneWithoutModeldataCalculationsInput = {
    create?: XOR<LevelCreateWithoutModeldataCalculationsInput, LevelUncheckedCreateWithoutModeldataCalculationsInput>
    connectOrCreate?: LevelCreateOrConnectWithoutModeldataCalculationsInput
    connect?: LevelWhereUniqueInput
  }

  export type AccountCreateNestedOneWithoutModeldataCalculationsInput = {
    create?: XOR<AccountCreateWithoutModeldataCalculationsInput, AccountUncheckedCreateWithoutModeldataCalculationsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutModeldataCalculationsInput
    connect?: AccountWhereUniqueInput
  }

  export type VersionCreateNestedOneWithoutModelDataCalculationsInput = {
    create?: XOR<VersionCreateWithoutModelDataCalculationsInput, VersionUncheckedCreateWithoutModelDataCalculationsInput>
    connectOrCreate?: VersionCreateOrConnectWithoutModelDataCalculationsInput
    connect?: VersionWhereUniqueInput
  }

  export type InstanceCreateNestedOneWithoutModelDataCalculationsInput = {
    create?: XOR<InstanceCreateWithoutModelDataCalculationsInput, InstanceUncheckedCreateWithoutModelDataCalculationsInput>
    connectOrCreate?: InstanceCreateOrConnectWithoutModelDataCalculationsInput
    connect?: InstanceWhereUniqueInput
  }

  export type ModelAccountStructureCreateNestedOneWithoutModeldataCalculationsInput = {
    create?: XOR<ModelAccountStructureCreateWithoutModeldataCalculationsInput, ModelAccountStructureUncheckedCreateWithoutModeldataCalculationsInput>
    connectOrCreate?: ModelAccountStructureCreateOrConnectWithoutModeldataCalculationsInput
    connect?: ModelAccountStructureWhereUniqueInput
  }

  export type ModelUpdateOneRequiredWithoutModelDataCalculationsNestedInput = {
    create?: XOR<ModelCreateWithoutModelDataCalculationsInput, ModelUncheckedCreateWithoutModelDataCalculationsInput>
    connectOrCreate?: ModelCreateOrConnectWithoutModelDataCalculationsInput
    upsert?: ModelUpsertWithoutModelDataCalculationsInput
    connect?: ModelWhereUniqueInput
    update?: XOR<XOR<ModelUpdateToOneWithWhereWithoutModelDataCalculationsInput, ModelUpdateWithoutModelDataCalculationsInput>, ModelUncheckedUpdateWithoutModelDataCalculationsInput>
  }

  export type LevelUpdateOneRequiredWithoutModeldataCalculationsNestedInput = {
    create?: XOR<LevelCreateWithoutModeldataCalculationsInput, LevelUncheckedCreateWithoutModeldataCalculationsInput>
    connectOrCreate?: LevelCreateOrConnectWithoutModeldataCalculationsInput
    upsert?: LevelUpsertWithoutModeldataCalculationsInput
    connect?: LevelWhereUniqueInput
    update?: XOR<XOR<LevelUpdateToOneWithWhereWithoutModeldataCalculationsInput, LevelUpdateWithoutModeldataCalculationsInput>, LevelUncheckedUpdateWithoutModeldataCalculationsInput>
  }

  export type AccountUpdateOneRequiredWithoutModeldataCalculationsNestedInput = {
    create?: XOR<AccountCreateWithoutModeldataCalculationsInput, AccountUncheckedCreateWithoutModeldataCalculationsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutModeldataCalculationsInput
    upsert?: AccountUpsertWithoutModeldataCalculationsInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutModeldataCalculationsInput, AccountUpdateWithoutModeldataCalculationsInput>, AccountUncheckedUpdateWithoutModeldataCalculationsInput>
  }

  export type VersionUpdateOneRequiredWithoutModelDataCalculationsNestedInput = {
    create?: XOR<VersionCreateWithoutModelDataCalculationsInput, VersionUncheckedCreateWithoutModelDataCalculationsInput>
    connectOrCreate?: VersionCreateOrConnectWithoutModelDataCalculationsInput
    upsert?: VersionUpsertWithoutModelDataCalculationsInput
    connect?: VersionWhereUniqueInput
    update?: XOR<XOR<VersionUpdateToOneWithWhereWithoutModelDataCalculationsInput, VersionUpdateWithoutModelDataCalculationsInput>, VersionUncheckedUpdateWithoutModelDataCalculationsInput>
  }

  export type InstanceUpdateOneRequiredWithoutModelDataCalculationsNestedInput = {
    create?: XOR<InstanceCreateWithoutModelDataCalculationsInput, InstanceUncheckedCreateWithoutModelDataCalculationsInput>
    connectOrCreate?: InstanceCreateOrConnectWithoutModelDataCalculationsInput
    upsert?: InstanceUpsertWithoutModelDataCalculationsInput
    connect?: InstanceWhereUniqueInput
    update?: XOR<XOR<InstanceUpdateToOneWithWhereWithoutModelDataCalculationsInput, InstanceUpdateWithoutModelDataCalculationsInput>, InstanceUncheckedUpdateWithoutModelDataCalculationsInput>
  }

  export type ModelAccountStructureUpdateOneRequiredWithoutModeldataCalculationsNestedInput = {
    create?: XOR<ModelAccountStructureCreateWithoutModeldataCalculationsInput, ModelAccountStructureUncheckedCreateWithoutModeldataCalculationsInput>
    connectOrCreate?: ModelAccountStructureCreateOrConnectWithoutModeldataCalculationsInput
    upsert?: ModelAccountStructureUpsertWithoutModeldataCalculationsInput
    connect?: ModelAccountStructureWhereUniqueInput
    update?: XOR<XOR<ModelAccountStructureUpdateToOneWithWhereWithoutModeldataCalculationsInput, ModelAccountStructureUpdateWithoutModeldataCalculationsInput>, ModelAccountStructureUncheckedUpdateWithoutModeldataCalculationsInput>
  }

  export type TableColumnDefinitionListCreateEnvelopeInput = {
    set?: TableColumnDefinitionCreateInput | TableColumnDefinitionCreateInput[]
  }

  export type TableColumnDefinitionCreateInput = {
    tableId: string
    name: string
    code: string
    type: $Enums.TableColumnType
    dimensionId?: string | null
  }

  export type InstanceCreateNestedOneWithoutTablesInput = {
    create?: XOR<InstanceCreateWithoutTablesInput, InstanceUncheckedCreateWithoutTablesInput>
    connectOrCreate?: InstanceCreateOrConnectWithoutTablesInput
    connect?: InstanceWhereUniqueInput
  }

  export type TableDataCreateNestedManyWithoutTableInput = {
    create?: XOR<TableDataCreateWithoutTableInput, TableDataUncheckedCreateWithoutTableInput> | TableDataCreateWithoutTableInput[] | TableDataUncheckedCreateWithoutTableInput[]
    connectOrCreate?: TableDataCreateOrConnectWithoutTableInput | TableDataCreateOrConnectWithoutTableInput[]
    createMany?: TableDataCreateManyTableInputEnvelope
    connect?: TableDataWhereUniqueInput | TableDataWhereUniqueInput[]
  }

  export type TableDataUncheckedCreateNestedManyWithoutTableInput = {
    create?: XOR<TableDataCreateWithoutTableInput, TableDataUncheckedCreateWithoutTableInput> | TableDataCreateWithoutTableInput[] | TableDataUncheckedCreateWithoutTableInput[]
    connectOrCreate?: TableDataCreateOrConnectWithoutTableInput | TableDataCreateOrConnectWithoutTableInput[]
    createMany?: TableDataCreateManyTableInputEnvelope
    connect?: TableDataWhereUniqueInput | TableDataWhereUniqueInput[]
  }

  export type TableColumnDefinitionListUpdateEnvelopeInput = {
    set?: TableColumnDefinitionCreateInput | TableColumnDefinitionCreateInput[]
    push?: TableColumnDefinitionCreateInput | TableColumnDefinitionCreateInput[]
    updateMany?: TableColumnDefinitionUpdateManyInput
    deleteMany?: TableColumnDefinitionDeleteManyInput
  }

  export type InstanceUpdateOneRequiredWithoutTablesNestedInput = {
    create?: XOR<InstanceCreateWithoutTablesInput, InstanceUncheckedCreateWithoutTablesInput>
    connectOrCreate?: InstanceCreateOrConnectWithoutTablesInput
    upsert?: InstanceUpsertWithoutTablesInput
    connect?: InstanceWhereUniqueInput
    update?: XOR<XOR<InstanceUpdateToOneWithWhereWithoutTablesInput, InstanceUpdateWithoutTablesInput>, InstanceUncheckedUpdateWithoutTablesInput>
  }

  export type TableDataUpdateManyWithoutTableNestedInput = {
    create?: XOR<TableDataCreateWithoutTableInput, TableDataUncheckedCreateWithoutTableInput> | TableDataCreateWithoutTableInput[] | TableDataUncheckedCreateWithoutTableInput[]
    connectOrCreate?: TableDataCreateOrConnectWithoutTableInput | TableDataCreateOrConnectWithoutTableInput[]
    upsert?: TableDataUpsertWithWhereUniqueWithoutTableInput | TableDataUpsertWithWhereUniqueWithoutTableInput[]
    createMany?: TableDataCreateManyTableInputEnvelope
    set?: TableDataWhereUniqueInput | TableDataWhereUniqueInput[]
    disconnect?: TableDataWhereUniqueInput | TableDataWhereUniqueInput[]
    delete?: TableDataWhereUniqueInput | TableDataWhereUniqueInput[]
    connect?: TableDataWhereUniqueInput | TableDataWhereUniqueInput[]
    update?: TableDataUpdateWithWhereUniqueWithoutTableInput | TableDataUpdateWithWhereUniqueWithoutTableInput[]
    updateMany?: TableDataUpdateManyWithWhereWithoutTableInput | TableDataUpdateManyWithWhereWithoutTableInput[]
    deleteMany?: TableDataScalarWhereInput | TableDataScalarWhereInput[]
  }

  export type TableDataUncheckedUpdateManyWithoutTableNestedInput = {
    create?: XOR<TableDataCreateWithoutTableInput, TableDataUncheckedCreateWithoutTableInput> | TableDataCreateWithoutTableInput[] | TableDataUncheckedCreateWithoutTableInput[]
    connectOrCreate?: TableDataCreateOrConnectWithoutTableInput | TableDataCreateOrConnectWithoutTableInput[]
    upsert?: TableDataUpsertWithWhereUniqueWithoutTableInput | TableDataUpsertWithWhereUniqueWithoutTableInput[]
    createMany?: TableDataCreateManyTableInputEnvelope
    set?: TableDataWhereUniqueInput | TableDataWhereUniqueInput[]
    disconnect?: TableDataWhereUniqueInput | TableDataWhereUniqueInput[]
    delete?: TableDataWhereUniqueInput | TableDataWhereUniqueInput[]
    connect?: TableDataWhereUniqueInput | TableDataWhereUniqueInput[]
    update?: TableDataUpdateWithWhereUniqueWithoutTableInput | TableDataUpdateWithWhereUniqueWithoutTableInput[]
    updateMany?: TableDataUpdateManyWithWhereWithoutTableInput | TableDataUpdateManyWithWhereWithoutTableInput[]
    deleteMany?: TableDataScalarWhereInput | TableDataScalarWhereInput[]
  }

  export type TableCreateNestedOneWithoutTableDataInput = {
    create?: XOR<TableCreateWithoutTableDataInput, TableUncheckedCreateWithoutTableDataInput>
    connectOrCreate?: TableCreateOrConnectWithoutTableDataInput
    connect?: TableWhereUniqueInput
  }

  export type InstanceCreateNestedOneWithoutTableDataInput = {
    create?: XOR<InstanceCreateWithoutTableDataInput, InstanceUncheckedCreateWithoutTableDataInput>
    connectOrCreate?: InstanceCreateOrConnectWithoutTableDataInput
    connect?: InstanceWhereUniqueInput
  }

  export type TableUpdateOneRequiredWithoutTableDataNestedInput = {
    create?: XOR<TableCreateWithoutTableDataInput, TableUncheckedCreateWithoutTableDataInput>
    connectOrCreate?: TableCreateOrConnectWithoutTableDataInput
    upsert?: TableUpsertWithoutTableDataInput
    connect?: TableWhereUniqueInput
    update?: XOR<XOR<TableUpdateToOneWithWhereWithoutTableDataInput, TableUpdateWithoutTableDataInput>, TableUncheckedUpdateWithoutTableDataInput>
  }

  export type InstanceUpdateOneRequiredWithoutTableDataNestedInput = {
    create?: XOR<InstanceCreateWithoutTableDataInput, InstanceUncheckedCreateWithoutTableDataInput>
    connectOrCreate?: InstanceCreateOrConnectWithoutTableDataInput
    upsert?: InstanceUpsertWithoutTableDataInput
    connect?: InstanceWhereUniqueInput
    update?: XOR<XOR<InstanceUpdateToOneWithWhereWithoutTableDataInput, InstanceUpdateWithoutTableDataInput>, InstanceUncheckedUpdateWithoutTableDataInput>
  }

  export type DataSourceCredentialCreateNestedOneWithoutDatasourcesInput = {
    create?: XOR<DataSourceCredentialCreateWithoutDatasourcesInput, DataSourceCredentialUncheckedCreateWithoutDatasourcesInput>
    connectOrCreate?: DataSourceCredentialCreateOrConnectWithoutDatasourcesInput
    connect?: DataSourceCredentialWhereUniqueInput
  }

  export type EnumDataSourceTypeFieldUpdateOperationsInput = {
    set?: $Enums.DataSourceType
  }

  export type DataSourceCredentialUpdateOneWithoutDatasourcesNestedInput = {
    create?: XOR<DataSourceCredentialCreateWithoutDatasourcesInput, DataSourceCredentialUncheckedCreateWithoutDatasourcesInput>
    connectOrCreate?: DataSourceCredentialCreateOrConnectWithoutDatasourcesInput
    upsert?: DataSourceCredentialUpsertWithoutDatasourcesInput
    disconnect?: boolean
    delete?: DataSourceCredentialWhereInput | boolean
    connect?: DataSourceCredentialWhereUniqueInput
    update?: XOR<XOR<DataSourceCredentialUpdateToOneWithWhereWithoutDatasourcesInput, DataSourceCredentialUpdateWithoutDatasourcesInput>, DataSourceCredentialUncheckedUpdateWithoutDatasourcesInput>
  }

  export type DataSourceLoaderCreateplanningTableInput = {
    set: string[]
  }

  export type EnumDataSourceLoaderTypeFieldUpdateOperationsInput = {
    set?: $Enums.DataSourceLoaderType
  }

  export type DataSourceLoaderUpdateplanningTableInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
    unset?: boolean
  }

  export type DataSourceCreateNestedManyWithoutCredentialInput = {
    create?: XOR<DataSourceCreateWithoutCredentialInput, DataSourceUncheckedCreateWithoutCredentialInput> | DataSourceCreateWithoutCredentialInput[] | DataSourceUncheckedCreateWithoutCredentialInput[]
    connectOrCreate?: DataSourceCreateOrConnectWithoutCredentialInput | DataSourceCreateOrConnectWithoutCredentialInput[]
    createMany?: DataSourceCreateManyCredentialInputEnvelope
    connect?: DataSourceWhereUniqueInput | DataSourceWhereUniqueInput[]
  }

  export type DataSourceUncheckedCreateNestedManyWithoutCredentialInput = {
    create?: XOR<DataSourceCreateWithoutCredentialInput, DataSourceUncheckedCreateWithoutCredentialInput> | DataSourceCreateWithoutCredentialInput[] | DataSourceUncheckedCreateWithoutCredentialInput[]
    connectOrCreate?: DataSourceCreateOrConnectWithoutCredentialInput | DataSourceCreateOrConnectWithoutCredentialInput[]
    createMany?: DataSourceCreateManyCredentialInputEnvelope
    connect?: DataSourceWhereUniqueInput | DataSourceWhereUniqueInput[]
  }

  export type EnumDatasourceCredentialAuthTypeFieldUpdateOperationsInput = {
    set?: $Enums.DatasourceCredentialAuthType
  }

  export type DataSourceUpdateManyWithoutCredentialNestedInput = {
    create?: XOR<DataSourceCreateWithoutCredentialInput, DataSourceUncheckedCreateWithoutCredentialInput> | DataSourceCreateWithoutCredentialInput[] | DataSourceUncheckedCreateWithoutCredentialInput[]
    connectOrCreate?: DataSourceCreateOrConnectWithoutCredentialInput | DataSourceCreateOrConnectWithoutCredentialInput[]
    upsert?: DataSourceUpsertWithWhereUniqueWithoutCredentialInput | DataSourceUpsertWithWhereUniqueWithoutCredentialInput[]
    createMany?: DataSourceCreateManyCredentialInputEnvelope
    set?: DataSourceWhereUniqueInput | DataSourceWhereUniqueInput[]
    disconnect?: DataSourceWhereUniqueInput | DataSourceWhereUniqueInput[]
    delete?: DataSourceWhereUniqueInput | DataSourceWhereUniqueInput[]
    connect?: DataSourceWhereUniqueInput | DataSourceWhereUniqueInput[]
    update?: DataSourceUpdateWithWhereUniqueWithoutCredentialInput | DataSourceUpdateWithWhereUniqueWithoutCredentialInput[]
    updateMany?: DataSourceUpdateManyWithWhereWithoutCredentialInput | DataSourceUpdateManyWithWhereWithoutCredentialInput[]
    deleteMany?: DataSourceScalarWhereInput | DataSourceScalarWhereInput[]
  }

  export type DataSourceUncheckedUpdateManyWithoutCredentialNestedInput = {
    create?: XOR<DataSourceCreateWithoutCredentialInput, DataSourceUncheckedCreateWithoutCredentialInput> | DataSourceCreateWithoutCredentialInput[] | DataSourceUncheckedCreateWithoutCredentialInput[]
    connectOrCreate?: DataSourceCreateOrConnectWithoutCredentialInput | DataSourceCreateOrConnectWithoutCredentialInput[]
    upsert?: DataSourceUpsertWithWhereUniqueWithoutCredentialInput | DataSourceUpsertWithWhereUniqueWithoutCredentialInput[]
    createMany?: DataSourceCreateManyCredentialInputEnvelope
    set?: DataSourceWhereUniqueInput | DataSourceWhereUniqueInput[]
    disconnect?: DataSourceWhereUniqueInput | DataSourceWhereUniqueInput[]
    delete?: DataSourceWhereUniqueInput | DataSourceWhereUniqueInput[]
    connect?: DataSourceWhereUniqueInput | DataSourceWhereUniqueInput[]
    update?: DataSourceUpdateWithWhereUniqueWithoutCredentialInput | DataSourceUpdateWithWhereUniqueWithoutCredentialInput[]
    updateMany?: DataSourceUpdateManyWithWhereWithoutCredentialInput | DataSourceUpdateManyWithWhereWithoutCredentialInput[]
    deleteMany?: DataSourceScalarWhereInput | DataSourceScalarWhereInput[]
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
    isSet?: boolean
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type NestedEnumuserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.userRole | EnumuserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.userRole[] | ListEnumuserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.userRole[] | ListEnumuserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumuserRoleFilter<$PrismaModel> | $Enums.userRole
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
    isSet?: boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedEnumuserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.userRole | EnumuserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.userRole[] | ListEnumuserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.userRole[] | ListEnumuserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumuserRoleWithAggregatesFilter<$PrismaModel> | $Enums.userRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumuserRoleFilter<$PrismaModel>
    _max?: NestedEnumuserRoleFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumclientStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.clientStatus | EnumclientStatusFieldRefInput<$PrismaModel>
    in?: $Enums.clientStatus[] | ListEnumclientStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.clientStatus[] | ListEnumclientStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumclientStatusFilter<$PrismaModel> | $Enums.clientStatus
  }

  export type addressTypeWhereInput = {
    AND?: addressTypeWhereInput | addressTypeWhereInput[]
    OR?: addressTypeWhereInput[]
    NOT?: addressTypeWhereInput | addressTypeWhereInput[]
    address1?: StringNullableFilter<"addressType"> | string | null
    address2?: StringNullableFilter<"addressType"> | string | null
    city?: StringNullableFilter<"addressType"> | string | null
    state?: StringNullableFilter<"addressType"> | string | null
  }

  export type NestedEnumclientStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.clientStatus | EnumclientStatusFieldRefInput<$PrismaModel>
    in?: $Enums.clientStatus[] | ListEnumclientStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.clientStatus[] | ListEnumclientStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumclientStatusWithAggregatesFilter<$PrismaModel> | $Enums.clientStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumclientStatusFilter<$PrismaModel>
    _max?: NestedEnumclientStatusFilter<$PrismaModel>
  }

  export type NestedEnuminstanceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.instanceStatus | EnuminstanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.instanceStatus[] | ListEnuminstanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.instanceStatus[] | ListEnuminstanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnuminstanceStatusFilter<$PrismaModel> | $Enums.instanceStatus
  }

  export type NestedEnuminstanceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.instanceStatus | EnuminstanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.instanceStatus[] | ListEnuminstanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.instanceStatus[] | ListEnuminstanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnuminstanceStatusWithAggregatesFilter<$PrismaModel> | $Enums.instanceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnuminstanceStatusFilter<$PrismaModel>
    _max?: NestedEnuminstanceStatusFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumversionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.versionStatus | EnumversionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.versionStatus[] | ListEnumversionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.versionStatus[] | ListEnumversionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumversionStatusFilter<$PrismaModel> | $Enums.versionStatus
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumversionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.versionStatus | EnumversionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.versionStatus[] | ListEnumversionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.versionStatus[] | ListEnumversionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumversionStatusWithAggregatesFilter<$PrismaModel> | $Enums.versionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumversionStatusFilter<$PrismaModel>
    _max?: NestedEnumversionStatusFilter<$PrismaModel>
  }

  export type NestedEnumYesNoFilter<$PrismaModel = never> = {
    equals?: $Enums.YesNo | EnumYesNoFieldRefInput<$PrismaModel>
    in?: $Enums.YesNo[] | ListEnumYesNoFieldRefInput<$PrismaModel>
    notIn?: $Enums.YesNo[] | ListEnumYesNoFieldRefInput<$PrismaModel>
    not?: NestedEnumYesNoFilter<$PrismaModel> | $Enums.YesNo
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumYesNoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.YesNo | EnumYesNoFieldRefInput<$PrismaModel>
    in?: $Enums.YesNo[] | ListEnumYesNoFieldRefInput<$PrismaModel>
    notIn?: $Enums.YesNo[] | ListEnumYesNoFieldRefInput<$PrismaModel>
    not?: NestedEnumYesNoWithAggregatesFilter<$PrismaModel> | $Enums.YesNo
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumYesNoFilter<$PrismaModel>
    _max?: NestedEnumYesNoFilter<$PrismaModel>
  }

  export type NestedEnumAccountTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountType | EnumAccountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountTypeFilter<$PrismaModel> | $Enums.AccountType
  }

  export type NestedEnumAccountTypeTagFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountTypeTag | EnumAccountTypeTagFieldRefInput<$PrismaModel>
    in?: $Enums.AccountTypeTag[] | ListEnumAccountTypeTagFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountTypeTag[] | ListEnumAccountTypeTagFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountTypeTagFilter<$PrismaModel> | $Enums.AccountTypeTag
  }

  export type NestedEnumActPlanByNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ActPlanBy | EnumActPlanByFieldRefInput<$PrismaModel> | null
    in?: $Enums.ActPlanBy[] | ListEnumActPlanByFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ActPlanBy[] | ListEnumActPlanByFieldRefInput<$PrismaModel> | null
    not?: NestedEnumActPlanByNullableFilter<$PrismaModel> | $Enums.ActPlanBy | null
    isSet?: boolean
  }

  export type NestedEnumActActualsByNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ActActualsBy | EnumActActualsByFieldRefInput<$PrismaModel> | null
    in?: $Enums.ActActualsBy[] | ListEnumActActualsByFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ActActualsBy[] | ListEnumActActualsByFieldRefInput<$PrismaModel> | null
    not?: NestedEnumActActualsByNullableFilter<$PrismaModel> | $Enums.ActActualsBy | null
    isSet?: boolean
  }

  export type NestedEnumActDisplayAsFilter<$PrismaModel = never> = {
    equals?: $Enums.ActDisplayAs | EnumActDisplayAsFieldRefInput<$PrismaModel>
    in?: $Enums.ActDisplayAs[] | ListEnumActDisplayAsFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActDisplayAs[] | ListEnumActDisplayAsFieldRefInput<$PrismaModel>
    not?: NestedEnumActDisplayAsFilter<$PrismaModel> | $Enums.ActDisplayAs
  }

  export type NestedEnumAccountTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountType | EnumAccountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountTypeWithAggregatesFilter<$PrismaModel> | $Enums.AccountType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccountTypeFilter<$PrismaModel>
    _max?: NestedEnumAccountTypeFilter<$PrismaModel>
  }

  export type NestedEnumAccountTypeTagWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountTypeTag | EnumAccountTypeTagFieldRefInput<$PrismaModel>
    in?: $Enums.AccountTypeTag[] | ListEnumAccountTypeTagFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountTypeTag[] | ListEnumAccountTypeTagFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountTypeTagWithAggregatesFilter<$PrismaModel> | $Enums.AccountTypeTag
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccountTypeTagFilter<$PrismaModel>
    _max?: NestedEnumAccountTypeTagFilter<$PrismaModel>
  }

  export type NestedEnumActPlanByNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActPlanBy | EnumActPlanByFieldRefInput<$PrismaModel> | null
    in?: $Enums.ActPlanBy[] | ListEnumActPlanByFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ActPlanBy[] | ListEnumActPlanByFieldRefInput<$PrismaModel> | null
    not?: NestedEnumActPlanByNullableWithAggregatesFilter<$PrismaModel> | $Enums.ActPlanBy | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumActPlanByNullableFilter<$PrismaModel>
    _max?: NestedEnumActPlanByNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedEnumActActualsByNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActActualsBy | EnumActActualsByFieldRefInput<$PrismaModel> | null
    in?: $Enums.ActActualsBy[] | ListEnumActActualsByFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ActActualsBy[] | ListEnumActActualsByFieldRefInput<$PrismaModel> | null
    not?: NestedEnumActActualsByNullableWithAggregatesFilter<$PrismaModel> | $Enums.ActActualsBy | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumActActualsByNullableFilter<$PrismaModel>
    _max?: NestedEnumActActualsByNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedEnumActDisplayAsWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActDisplayAs | EnumActDisplayAsFieldRefInput<$PrismaModel>
    in?: $Enums.ActDisplayAs[] | ListEnumActDisplayAsFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActDisplayAs[] | ListEnumActDisplayAsFieldRefInput<$PrismaModel>
    not?: NestedEnumActDisplayAsWithAggregatesFilter<$PrismaModel> | $Enums.ActDisplayAs
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActDisplayAsFilter<$PrismaModel>
    _max?: NestedEnumActDisplayAsFilter<$PrismaModel>
  }

  export type NestedEnumModelStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ModelStatus | EnumModelStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ModelStatus[] | ListEnumModelStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ModelStatus[] | ListEnumModelStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumModelStatusFilter<$PrismaModel> | $Enums.ModelStatus
  }

  export type NestedEnumModelStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ModelStatus | EnumModelStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ModelStatus[] | ListEnumModelStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ModelStatus[] | ListEnumModelStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumModelStatusWithAggregatesFilter<$PrismaModel> | $Enums.ModelStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumModelStatusFilter<$PrismaModel>
    _max?: NestedEnumModelStatusFilter<$PrismaModel>
  }

  export type ModelDataDimensionalityWhereInput = {
    AND?: ModelDataDimensionalityWhereInput | ModelDataDimensionalityWhereInput[]
    OR?: ModelDataDimensionalityWhereInput[]
    NOT?: ModelDataDimensionalityWhereInput | ModelDataDimensionalityWhereInput[]
    dimensionId?: StringFilter<"ModelDataDimensionality"> | string
    dimensionValueId?: StringFilter<"ModelDataDimensionality"> | string
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
  }

  export type TableColumnDefinitionWhereInput = {
    AND?: TableColumnDefinitionWhereInput | TableColumnDefinitionWhereInput[]
    OR?: TableColumnDefinitionWhereInput[]
    NOT?: TableColumnDefinitionWhereInput | TableColumnDefinitionWhereInput[]
    tableId?: StringFilter<"TableColumnDefinition"> | string
    name?: StringFilter<"TableColumnDefinition"> | string
    code?: StringFilter<"TableColumnDefinition"> | string
    type?: EnumTableColumnTypeFilter<"TableColumnDefinition"> | $Enums.TableColumnType
    dimensionId?: StringNullableFilter<"TableColumnDefinition"> | string | null
  }

  export type NestedEnumDataSourceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DataSourceType | EnumDataSourceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DataSourceType[] | ListEnumDataSourceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DataSourceType[] | ListEnumDataSourceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDataSourceTypeFilter<$PrismaModel> | $Enums.DataSourceType
  }

  export type NestedEnumDataSourceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DataSourceType | EnumDataSourceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DataSourceType[] | ListEnumDataSourceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DataSourceType[] | ListEnumDataSourceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDataSourceTypeWithAggregatesFilter<$PrismaModel> | $Enums.DataSourceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDataSourceTypeFilter<$PrismaModel>
    _max?: NestedEnumDataSourceTypeFilter<$PrismaModel>
  }

  export type NestedEnumDataSourceLoaderTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DataSourceLoaderType | EnumDataSourceLoaderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DataSourceLoaderType[] | ListEnumDataSourceLoaderTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DataSourceLoaderType[] | ListEnumDataSourceLoaderTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDataSourceLoaderTypeFilter<$PrismaModel> | $Enums.DataSourceLoaderType
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
    isSet?: boolean
  }

  export type NestedEnumDataSourceLoaderTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DataSourceLoaderType | EnumDataSourceLoaderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DataSourceLoaderType[] | ListEnumDataSourceLoaderTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DataSourceLoaderType[] | ListEnumDataSourceLoaderTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDataSourceLoaderTypeWithAggregatesFilter<$PrismaModel> | $Enums.DataSourceLoaderType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDataSourceLoaderTypeFilter<$PrismaModel>
    _max?: NestedEnumDataSourceLoaderTypeFilter<$PrismaModel>
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
    isSet?: boolean
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    isSet?: boolean
  }

  export type NestedEnumDatasourceCredentialAuthTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DatasourceCredentialAuthType | EnumDatasourceCredentialAuthTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DatasourceCredentialAuthType[] | ListEnumDatasourceCredentialAuthTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DatasourceCredentialAuthType[] | ListEnumDatasourceCredentialAuthTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDatasourceCredentialAuthTypeFilter<$PrismaModel> | $Enums.DatasourceCredentialAuthType
  }

  export type NestedEnumDatasourceCredentialAuthTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DatasourceCredentialAuthType | EnumDatasourceCredentialAuthTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DatasourceCredentialAuthType[] | ListEnumDatasourceCredentialAuthTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DatasourceCredentialAuthType[] | ListEnumDatasourceCredentialAuthTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDatasourceCredentialAuthTypeWithAggregatesFilter<$PrismaModel> | $Enums.DatasourceCredentialAuthType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDatasourceCredentialAuthTypeFilter<$PrismaModel>
    _max?: NestedEnumDatasourceCredentialAuthTypeFilter<$PrismaModel>
  }

  export type CurrencyIsoCodeCreateWithoutConfigInput = {
    id?: string
    code: string
    name: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    currencies?: CurrencyCreateNestedManyWithoutCurrencyIsoCodeInput
  }

  export type CurrencyIsoCodeUncheckedCreateWithoutConfigInput = {
    id?: string
    code: string
    name: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    currencies?: CurrencyUncheckedCreateNestedManyWithoutCurrencyIsoCodeInput
  }

  export type CurrencyIsoCodeCreateOrConnectWithoutConfigInput = {
    where: CurrencyIsoCodeWhereUniqueInput
    create: XOR<CurrencyIsoCodeCreateWithoutConfigInput, CurrencyIsoCodeUncheckedCreateWithoutConfigInput>
  }

  export type CurrencyCreateWithoutDefaultsInput = {
    id?: string
    name: string
    code: string
    assignedLevels: number
    isDefault?: $Enums.YesNo
    clientId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    currencyIsoCode: CurrencyIsoCodeCreateNestedOneWithoutCurrenciesInput
    instance: InstanceCreateNestedOneWithoutCurrenciesInput
    levels?: LevelCreateNestedManyWithoutCurrencyInput
  }

  export type CurrencyUncheckedCreateWithoutDefaultsInput = {
    id?: string
    name: string
    code: string
    currencyIsoCodeId: string
    assignedLevels: number
    isDefault?: $Enums.YesNo
    clientId: string
    instanceId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    levels?: LevelUncheckedCreateNestedManyWithoutCurrencyInput
  }

  export type CurrencyCreateOrConnectWithoutDefaultsInput = {
    where: CurrencyWhereUniqueInput
    create: XOR<CurrencyCreateWithoutDefaultsInput, CurrencyUncheckedCreateWithoutDefaultsInput>
  }

  export type CurrencyIsoCodeUpsertWithoutConfigInput = {
    update: XOR<CurrencyIsoCodeUpdateWithoutConfigInput, CurrencyIsoCodeUncheckedUpdateWithoutConfigInput>
    create: XOR<CurrencyIsoCodeCreateWithoutConfigInput, CurrencyIsoCodeUncheckedCreateWithoutConfigInput>
    where?: CurrencyIsoCodeWhereInput
  }

  export type CurrencyIsoCodeUpdateToOneWithWhereWithoutConfigInput = {
    where?: CurrencyIsoCodeWhereInput
    data: XOR<CurrencyIsoCodeUpdateWithoutConfigInput, CurrencyIsoCodeUncheckedUpdateWithoutConfigInput>
  }

  export type CurrencyIsoCodeUpdateWithoutConfigInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currencies?: CurrencyUpdateManyWithoutCurrencyIsoCodeNestedInput
  }

  export type CurrencyIsoCodeUncheckedUpdateWithoutConfigInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currencies?: CurrencyUncheckedUpdateManyWithoutCurrencyIsoCodeNestedInput
  }

  export type CurrencyUpsertWithoutDefaultsInput = {
    update: XOR<CurrencyUpdateWithoutDefaultsInput, CurrencyUncheckedUpdateWithoutDefaultsInput>
    create: XOR<CurrencyCreateWithoutDefaultsInput, CurrencyUncheckedCreateWithoutDefaultsInput>
    where?: CurrencyWhereInput
  }

  export type CurrencyUpdateToOneWithWhereWithoutDefaultsInput = {
    where?: CurrencyWhereInput
    data: XOR<CurrencyUpdateWithoutDefaultsInput, CurrencyUncheckedUpdateWithoutDefaultsInput>
  }

  export type CurrencyUpdateWithoutDefaultsInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    assignedLevels?: IntFieldUpdateOperationsInput | number
    isDefault?: EnumYesNoFieldUpdateOperationsInput | $Enums.YesNo
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currencyIsoCode?: CurrencyIsoCodeUpdateOneRequiredWithoutCurrenciesNestedInput
    instance?: InstanceUpdateOneRequiredWithoutCurrenciesNestedInput
    levels?: LevelUpdateManyWithoutCurrencyNestedInput
  }

  export type CurrencyUncheckedUpdateWithoutDefaultsInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    currencyIsoCodeId?: StringFieldUpdateOperationsInput | string
    assignedLevels?: IntFieldUpdateOperationsInput | number
    isDefault?: EnumYesNoFieldUpdateOperationsInput | $Enums.YesNo
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    levels?: LevelUncheckedUpdateManyWithoutCurrencyNestedInput
  }

  export type ClientCreateWithoutCountryInput = {
    id?: string
    name: string
    code: string
    status?: $Enums.clientStatus
    address?: XOR<addressTypeNullableCreateEnvelopeInput, addressTypeCreateInput> | null
    contactId?: string | null
    lastLogin?: Date | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    users?: UserCreateNestedManyWithoutClientInput
    instances?: InstanceCreateNestedManyWithoutClientInput
    Permission?: PermissionCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutCountryInput = {
    id?: string
    name: string
    code: string
    status?: $Enums.clientStatus
    address?: XOR<addressTypeNullableCreateEnvelopeInput, addressTypeCreateInput> | null
    contactId?: string | null
    lastLogin?: Date | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    users?: UserUncheckedCreateNestedManyWithoutClientInput
    instances?: InstanceUncheckedCreateNestedManyWithoutClientInput
    Permission?: PermissionUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutCountryInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutCountryInput, ClientUncheckedCreateWithoutCountryInput>
  }

  export type ClientCreateManyCountryInputEnvelope = {
    data: ClientCreateManyCountryInput | ClientCreateManyCountryInput[]
  }

  export type UserCreateWithoutCountryInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    authProviderId: string
    role?: $Enums.userRole
    permissions?: UserCreatepermissionsInput | string[]
    defaultInstance: string
    selectedInstance?: string | null
    lastLogin?: Date | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    client: ClientCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutCountryInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    authProviderId: string
    role?: $Enums.userRole
    permissions?: UserCreatepermissionsInput | string[]
    clientId: string
    defaultInstance: string
    selectedInstance?: string | null
    lastLogin?: Date | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type UserCreateOrConnectWithoutCountryInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCountryInput, UserUncheckedCreateWithoutCountryInput>
  }

  export type UserCreateManyCountryInputEnvelope = {
    data: UserCreateManyCountryInput | UserCreateManyCountryInput[]
  }

  export type ClientUpsertWithWhereUniqueWithoutCountryInput = {
    where: ClientWhereUniqueInput
    update: XOR<ClientUpdateWithoutCountryInput, ClientUncheckedUpdateWithoutCountryInput>
    create: XOR<ClientCreateWithoutCountryInput, ClientUncheckedCreateWithoutCountryInput>
  }

  export type ClientUpdateWithWhereUniqueWithoutCountryInput = {
    where: ClientWhereUniqueInput
    data: XOR<ClientUpdateWithoutCountryInput, ClientUncheckedUpdateWithoutCountryInput>
  }

  export type ClientUpdateManyWithWhereWithoutCountryInput = {
    where: ClientScalarWhereInput
    data: XOR<ClientUpdateManyMutationInput, ClientUncheckedUpdateManyWithoutCountryInput>
  }

  export type ClientScalarWhereInput = {
    AND?: ClientScalarWhereInput | ClientScalarWhereInput[]
    OR?: ClientScalarWhereInput[]
    NOT?: ClientScalarWhereInput | ClientScalarWhereInput[]
    id?: StringFilter<"Client"> | string
    name?: StringFilter<"Client"> | string
    code?: StringFilter<"Client"> | string
    status?: EnumclientStatusFilter<"Client"> | $Enums.clientStatus
    countryId?: StringNullableFilter<"Client"> | string | null
    contactId?: StringNullableFilter<"Client"> | string | null
    lastLogin?: DateTimeFilter<"Client"> | Date | string
    createdAt?: DateTimeNullableFilter<"Client"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Client"> | Date | string | null
  }

  export type UserUpsertWithWhereUniqueWithoutCountryInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutCountryInput, UserUncheckedUpdateWithoutCountryInput>
    create: XOR<UserCreateWithoutCountryInput, UserUncheckedCreateWithoutCountryInput>
  }

  export type UserUpdateWithWhereUniqueWithoutCountryInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutCountryInput, UserUncheckedUpdateWithoutCountryInput>
  }

  export type UserUpdateManyWithWhereWithoutCountryInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutCountryInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    authProviderId?: StringFilter<"User"> | string
    role?: EnumuserRoleFilter<"User"> | $Enums.userRole
    countryId?: StringNullableFilter<"User"> | string | null
    permissions?: StringNullableListFilter<"User">
    clientId?: StringFilter<"User"> | string
    defaultInstance?: StringFilter<"User"> | string
    selectedInstance?: StringNullableFilter<"User"> | string | null
    lastLogin?: DateTimeFilter<"User"> | Date | string
    createdAt?: DateTimeNullableFilter<"User"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"User"> | Date | string | null
  }

  export type CountryCreateWithoutUserInput = {
    id?: string
    name: string
    iso_3166_2_code: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    Client?: ClientCreateNestedManyWithoutCountryInput
  }

  export type CountryUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    iso_3166_2_code: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    Client?: ClientUncheckedCreateNestedManyWithoutCountryInput
  }

  export type CountryCreateOrConnectWithoutUserInput = {
    where: CountryWhereUniqueInput
    create: XOR<CountryCreateWithoutUserInput, CountryUncheckedCreateWithoutUserInput>
  }

  export type ClientCreateWithoutUsersInput = {
    id?: string
    name: string
    code: string
    status?: $Enums.clientStatus
    address?: XOR<addressTypeNullableCreateEnvelopeInput, addressTypeCreateInput> | null
    contactId?: string | null
    lastLogin?: Date | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    country?: CountryCreateNestedOneWithoutClientInput
    instances?: InstanceCreateNestedManyWithoutClientInput
    Permission?: PermissionCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    code: string
    status?: $Enums.clientStatus
    address?: XOR<addressTypeNullableCreateEnvelopeInput, addressTypeCreateInput> | null
    countryId?: string | null
    contactId?: string | null
    lastLogin?: Date | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    instances?: InstanceUncheckedCreateNestedManyWithoutClientInput
    Permission?: PermissionUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutUsersInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutUsersInput, ClientUncheckedCreateWithoutUsersInput>
  }

  export type CountryUpsertWithoutUserInput = {
    update: XOR<CountryUpdateWithoutUserInput, CountryUncheckedUpdateWithoutUserInput>
    create: XOR<CountryCreateWithoutUserInput, CountryUncheckedCreateWithoutUserInput>
    where?: CountryWhereInput
  }

  export type CountryUpdateToOneWithWhereWithoutUserInput = {
    where?: CountryWhereInput
    data: XOR<CountryUpdateWithoutUserInput, CountryUncheckedUpdateWithoutUserInput>
  }

  export type CountryUpdateWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    iso_3166_2_code?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Client?: ClientUpdateManyWithoutCountryNestedInput
  }

  export type CountryUncheckedUpdateWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    iso_3166_2_code?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Client?: ClientUncheckedUpdateManyWithoutCountryNestedInput
  }

  export type ClientUpsertWithoutUsersInput = {
    update: XOR<ClientUpdateWithoutUsersInput, ClientUncheckedUpdateWithoutUsersInput>
    create: XOR<ClientCreateWithoutUsersInput, ClientUncheckedCreateWithoutUsersInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutUsersInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutUsersInput, ClientUncheckedUpdateWithoutUsersInput>
  }

  export type ClientUpdateWithoutUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumclientStatusFieldUpdateOperationsInput | $Enums.clientStatus
    address?: XOR<addressTypeNullableUpdateEnvelopeInput, addressTypeCreateInput> | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: CountryUpdateOneWithoutClientNestedInput
    instances?: InstanceUpdateManyWithoutClientNestedInput
    Permission?: PermissionUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumclientStatusFieldUpdateOperationsInput | $Enums.clientStatus
    address?: XOR<addressTypeNullableUpdateEnvelopeInput, addressTypeCreateInput> | null
    countryId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instances?: InstanceUncheckedUpdateManyWithoutClientNestedInput
    Permission?: PermissionUncheckedUpdateManyWithoutClientNestedInput
  }

  export type CountryCreateWithoutClientInput = {
    id?: string
    name: string
    iso_3166_2_code: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    User?: UserCreateNestedManyWithoutCountryInput
  }

  export type CountryUncheckedCreateWithoutClientInput = {
    id?: string
    name: string
    iso_3166_2_code: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    User?: UserUncheckedCreateNestedManyWithoutCountryInput
  }

  export type CountryCreateOrConnectWithoutClientInput = {
    where: CountryWhereUniqueInput
    create: XOR<CountryCreateWithoutClientInput, CountryUncheckedCreateWithoutClientInput>
  }

  export type UserCreateWithoutClientInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    authProviderId: string
    role?: $Enums.userRole
    permissions?: UserCreatepermissionsInput | string[]
    defaultInstance: string
    selectedInstance?: string | null
    lastLogin?: Date | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    country?: CountryCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutClientInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    authProviderId: string
    role?: $Enums.userRole
    countryId?: string | null
    permissions?: UserCreatepermissionsInput | string[]
    defaultInstance: string
    selectedInstance?: string | null
    lastLogin?: Date | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type UserCreateOrConnectWithoutClientInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutClientInput, UserUncheckedCreateWithoutClientInput>
  }

  export type UserCreateManyClientInputEnvelope = {
    data: UserCreateManyClientInput | UserCreateManyClientInput[]
  }

  export type InstanceCreateWithoutClientInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    status?: $Enums.instanceStatus
    userIds?: InstanceCreateuserIdsInput | string[]
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    levels?: LevelCreateNestedManyWithoutInstanceInput
    versions?: VersionCreateNestedManyWithoutInstanceInput
    currencies?: CurrencyCreateNestedManyWithoutInstanceInput
    accounts?: AccountCreateNestedManyWithoutInstanceInput
    models?: ModelCreateNestedManyWithoutInstanceInput
    dimensions?: DimensionCreateNestedManyWithoutInstanceInput
    dimensionValues?: DimensionValueCreateNestedManyWithoutInstanceInput
    levelAttributes?: LevelAttributeCreateNestedManyWithoutInstanceInput
    dimensionValueAttributes?: DimensionValueAttributeCreateNestedManyWithoutInstanceInput
    accountAttributes?: AccountAttributeCreateNestedManyWithoutInstanceInput
    levelAttValues?: LevelAttributeValueCreateNestedManyWithoutInstanceInput
    accountAttValues?: AccountAttributeValueCreateNestedManyWithoutInstanceInput
    dimensionValueAttributeValues?: DimensionValueAttributeValueCreateNestedManyWithoutInstanceInput
    modelData?: ModelDataCreateNestedManyWithoutInstanceInput
    modelDataCalculations?: ModelDataCalculationsCreateNestedManyWithoutInstanceInput
    modelAccounts?: ModelAccountStructureCreateNestedManyWithoutInstanceInput
    tables?: TableCreateNestedManyWithoutInstanceInput
    tableData?: TableDataCreateNestedManyWithoutInstanceInput
  }

  export type InstanceUncheckedCreateWithoutClientInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    status?: $Enums.instanceStatus
    userIds?: InstanceCreateuserIdsInput | string[]
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    levels?: LevelUncheckedCreateNestedManyWithoutInstanceInput
    versions?: VersionUncheckedCreateNestedManyWithoutInstanceInput
    currencies?: CurrencyUncheckedCreateNestedManyWithoutInstanceInput
    accounts?: AccountUncheckedCreateNestedManyWithoutInstanceInput
    models?: ModelUncheckedCreateNestedManyWithoutInstanceInput
    dimensions?: DimensionUncheckedCreateNestedManyWithoutInstanceInput
    dimensionValues?: DimensionValueUncheckedCreateNestedManyWithoutInstanceInput
    levelAttributes?: LevelAttributeUncheckedCreateNestedManyWithoutInstanceInput
    dimensionValueAttributes?: DimensionValueAttributeUncheckedCreateNestedManyWithoutInstanceInput
    accountAttributes?: AccountAttributeUncheckedCreateNestedManyWithoutInstanceInput
    levelAttValues?: LevelAttributeValueUncheckedCreateNestedManyWithoutInstanceInput
    accountAttValues?: AccountAttributeValueUncheckedCreateNestedManyWithoutInstanceInput
    dimensionValueAttributeValues?: DimensionValueAttributeValueUncheckedCreateNestedManyWithoutInstanceInput
    modelData?: ModelDataUncheckedCreateNestedManyWithoutInstanceInput
    modelDataCalculations?: ModelDataCalculationsUncheckedCreateNestedManyWithoutInstanceInput
    modelAccounts?: ModelAccountStructureUncheckedCreateNestedManyWithoutInstanceInput
    tables?: TableUncheckedCreateNestedManyWithoutInstanceInput
    tableData?: TableDataUncheckedCreateNestedManyWithoutInstanceInput
  }

  export type InstanceCreateOrConnectWithoutClientInput = {
    where: InstanceWhereUniqueInput
    create: XOR<InstanceCreateWithoutClientInput, InstanceUncheckedCreateWithoutClientInput>
  }

  export type InstanceCreateManyClientInputEnvelope = {
    data: InstanceCreateManyClientInput | InstanceCreateManyClientInput[]
  }

  export type PermissionCreateWithoutClientInput = {
    id?: string
    name: string
    code: string
    actions?: PermissionCreateactionsInput | string[]
    subjects?: PermissionCreatesubjectsInput | string[]
    description?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type PermissionUncheckedCreateWithoutClientInput = {
    id?: string
    name: string
    code: string
    actions?: PermissionCreateactionsInput | string[]
    subjects?: PermissionCreatesubjectsInput | string[]
    description?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type PermissionCreateOrConnectWithoutClientInput = {
    where: PermissionWhereUniqueInput
    create: XOR<PermissionCreateWithoutClientInput, PermissionUncheckedCreateWithoutClientInput>
  }

  export type PermissionCreateManyClientInputEnvelope = {
    data: PermissionCreateManyClientInput | PermissionCreateManyClientInput[]
  }

  export type addressTypeUpsertInput = {
    set: addressTypeCreateInput | null
    update: addressTypeUpdateInput
  }

  export type CountryUpsertWithoutClientInput = {
    update: XOR<CountryUpdateWithoutClientInput, CountryUncheckedUpdateWithoutClientInput>
    create: XOR<CountryCreateWithoutClientInput, CountryUncheckedCreateWithoutClientInput>
    where?: CountryWhereInput
  }

  export type CountryUpdateToOneWithWhereWithoutClientInput = {
    where?: CountryWhereInput
    data: XOR<CountryUpdateWithoutClientInput, CountryUncheckedUpdateWithoutClientInput>
  }

  export type CountryUpdateWithoutClientInput = {
    name?: StringFieldUpdateOperationsInput | string
    iso_3166_2_code?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    User?: UserUpdateManyWithoutCountryNestedInput
  }

  export type CountryUncheckedUpdateWithoutClientInput = {
    name?: StringFieldUpdateOperationsInput | string
    iso_3166_2_code?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    User?: UserUncheckedUpdateManyWithoutCountryNestedInput
  }

  export type UserUpsertWithWhereUniqueWithoutClientInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutClientInput, UserUncheckedUpdateWithoutClientInput>
    create: XOR<UserCreateWithoutClientInput, UserUncheckedCreateWithoutClientInput>
  }

  export type UserUpdateWithWhereUniqueWithoutClientInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutClientInput, UserUncheckedUpdateWithoutClientInput>
  }

  export type UserUpdateManyWithWhereWithoutClientInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutClientInput>
  }

  export type InstanceUpsertWithWhereUniqueWithoutClientInput = {
    where: InstanceWhereUniqueInput
    update: XOR<InstanceUpdateWithoutClientInput, InstanceUncheckedUpdateWithoutClientInput>
    create: XOR<InstanceCreateWithoutClientInput, InstanceUncheckedCreateWithoutClientInput>
  }

  export type InstanceUpdateWithWhereUniqueWithoutClientInput = {
    where: InstanceWhereUniqueInput
    data: XOR<InstanceUpdateWithoutClientInput, InstanceUncheckedUpdateWithoutClientInput>
  }

  export type InstanceUpdateManyWithWhereWithoutClientInput = {
    where: InstanceScalarWhereInput
    data: XOR<InstanceUpdateManyMutationInput, InstanceUncheckedUpdateManyWithoutClientInput>
  }

  export type InstanceScalarWhereInput = {
    AND?: InstanceScalarWhereInput | InstanceScalarWhereInput[]
    OR?: InstanceScalarWhereInput[]
    NOT?: InstanceScalarWhereInput | InstanceScalarWhereInput[]
    id?: StringFilter<"Instance"> | string
    code?: StringFilter<"Instance"> | string
    name?: StringFilter<"Instance"> | string
    clientId?: StringFilter<"Instance"> | string
    description?: StringNullableFilter<"Instance"> | string | null
    status?: EnuminstanceStatusFilter<"Instance"> | $Enums.instanceStatus
    userIds?: StringNullableListFilter<"Instance">
    createdAt?: DateTimeNullableFilter<"Instance"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Instance"> | Date | string | null
  }

  export type PermissionUpsertWithWhereUniqueWithoutClientInput = {
    where: PermissionWhereUniqueInput
    update: XOR<PermissionUpdateWithoutClientInput, PermissionUncheckedUpdateWithoutClientInput>
    create: XOR<PermissionCreateWithoutClientInput, PermissionUncheckedCreateWithoutClientInput>
  }

  export type PermissionUpdateWithWhereUniqueWithoutClientInput = {
    where: PermissionWhereUniqueInput
    data: XOR<PermissionUpdateWithoutClientInput, PermissionUncheckedUpdateWithoutClientInput>
  }

  export type PermissionUpdateManyWithWhereWithoutClientInput = {
    where: PermissionScalarWhereInput
    data: XOR<PermissionUpdateManyMutationInput, PermissionUncheckedUpdateManyWithoutClientInput>
  }

  export type PermissionScalarWhereInput = {
    AND?: PermissionScalarWhereInput | PermissionScalarWhereInput[]
    OR?: PermissionScalarWhereInput[]
    NOT?: PermissionScalarWhereInput | PermissionScalarWhereInput[]
    id?: StringFilter<"Permission"> | string
    name?: StringFilter<"Permission"> | string
    code?: StringFilter<"Permission"> | string
    clientId?: StringFilter<"Permission"> | string
    actions?: StringNullableListFilter<"Permission">
    subjects?: StringNullableListFilter<"Permission">
    description?: StringNullableFilter<"Permission"> | string | null
    createdAt?: DateTimeNullableFilter<"Permission"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Permission"> | Date | string | null
  }

  export type ClientCreateWithoutPermissionInput = {
    id?: string
    name: string
    code: string
    status?: $Enums.clientStatus
    address?: XOR<addressTypeNullableCreateEnvelopeInput, addressTypeCreateInput> | null
    contactId?: string | null
    lastLogin?: Date | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    country?: CountryCreateNestedOneWithoutClientInput
    users?: UserCreateNestedManyWithoutClientInput
    instances?: InstanceCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutPermissionInput = {
    id?: string
    name: string
    code: string
    status?: $Enums.clientStatus
    address?: XOR<addressTypeNullableCreateEnvelopeInput, addressTypeCreateInput> | null
    countryId?: string | null
    contactId?: string | null
    lastLogin?: Date | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    users?: UserUncheckedCreateNestedManyWithoutClientInput
    instances?: InstanceUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutPermissionInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutPermissionInput, ClientUncheckedCreateWithoutPermissionInput>
  }

  export type ClientUpsertWithoutPermissionInput = {
    update: XOR<ClientUpdateWithoutPermissionInput, ClientUncheckedUpdateWithoutPermissionInput>
    create: XOR<ClientCreateWithoutPermissionInput, ClientUncheckedCreateWithoutPermissionInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutPermissionInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutPermissionInput, ClientUncheckedUpdateWithoutPermissionInput>
  }

  export type ClientUpdateWithoutPermissionInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumclientStatusFieldUpdateOperationsInput | $Enums.clientStatus
    address?: XOR<addressTypeNullableUpdateEnvelopeInput, addressTypeCreateInput> | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: CountryUpdateOneWithoutClientNestedInput
    users?: UserUpdateManyWithoutClientNestedInput
    instances?: InstanceUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutPermissionInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumclientStatusFieldUpdateOperationsInput | $Enums.clientStatus
    address?: XOR<addressTypeNullableUpdateEnvelopeInput, addressTypeCreateInput> | null
    countryId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: UserUncheckedUpdateManyWithoutClientNestedInput
    instances?: InstanceUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ClientCreateWithoutInstancesInput = {
    id?: string
    name: string
    code: string
    status?: $Enums.clientStatus
    address?: XOR<addressTypeNullableCreateEnvelopeInput, addressTypeCreateInput> | null
    contactId?: string | null
    lastLogin?: Date | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    country?: CountryCreateNestedOneWithoutClientInput
    users?: UserCreateNestedManyWithoutClientInput
    Permission?: PermissionCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutInstancesInput = {
    id?: string
    name: string
    code: string
    status?: $Enums.clientStatus
    address?: XOR<addressTypeNullableCreateEnvelopeInput, addressTypeCreateInput> | null
    countryId?: string | null
    contactId?: string | null
    lastLogin?: Date | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    users?: UserUncheckedCreateNestedManyWithoutClientInput
    Permission?: PermissionUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutInstancesInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutInstancesInput, ClientUncheckedCreateWithoutInstancesInput>
  }

  export type LevelCreateWithoutInstanceInput = {
    id?: string
    code: string
    name: string
    isRoot?: boolean
    description?: string | null
    clientId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    AttributeAndValues?: LevelAttributeAndValueCreateNestedManyWithoutLevelInput
    parent?: LevelCreateNestedOneWithoutChildLevelsInput
    currency: CurrencyCreateNestedOneWithoutLevelsInput
    childLevels?: LevelCreateNestedManyWithoutParentInput
    modelData?: ModelDataCreateNestedManyWithoutLevelInput
    modeldataCalculations?: ModelDataCalculationsCreateNestedManyWithoutLevelInput
  }

  export type LevelUncheckedCreateWithoutInstanceInput = {
    id?: string
    code: string
    name: string
    isRoot?: boolean
    description?: string | null
    parentId?: string | null
    clientId: string
    currencyId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    AttributeAndValues?: LevelAttributeAndValueUncheckedCreateNestedManyWithoutLevelInput
    childLevels?: LevelUncheckedCreateNestedManyWithoutParentInput
    modelData?: ModelDataUncheckedCreateNestedManyWithoutLevelInput
    modeldataCalculations?: ModelDataCalculationsUncheckedCreateNestedManyWithoutLevelInput
  }

  export type LevelCreateOrConnectWithoutInstanceInput = {
    where: LevelWhereUniqueInput
    create: XOR<LevelCreateWithoutInstanceInput, LevelUncheckedCreateWithoutInstanceInput>
  }

  export type LevelCreateManyInstanceInputEnvelope = {
    data: LevelCreateManyInstanceInput | LevelCreateManyInstanceInput[]
  }

  export type VersionCreateWithoutInstanceInput = {
    id?: string
    code: string
    name: string
    begin: Date | string
    end: Date | string
    startOfPlan: Date | string
    description?: string | null
    isDefault?: boolean
    isActuals?: boolean
    status?: $Enums.versionStatus
    clientId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    modelData?: ModelDataCreateNestedManyWithoutVersionInput
    modelDataCalculations?: ModelDataCalculationsCreateNestedManyWithoutVersionInput
  }

  export type VersionUncheckedCreateWithoutInstanceInput = {
    id?: string
    code: string
    name: string
    begin: Date | string
    end: Date | string
    startOfPlan: Date | string
    description?: string | null
    isDefault?: boolean
    isActuals?: boolean
    status?: $Enums.versionStatus
    clientId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    modelData?: ModelDataUncheckedCreateNestedManyWithoutVersionInput
    modelDataCalculations?: ModelDataCalculationsUncheckedCreateNestedManyWithoutVersionInput
  }

  export type VersionCreateOrConnectWithoutInstanceInput = {
    where: VersionWhereUniqueInput
    create: XOR<VersionCreateWithoutInstanceInput, VersionUncheckedCreateWithoutInstanceInput>
  }

  export type VersionCreateManyInstanceInputEnvelope = {
    data: VersionCreateManyInstanceInput | VersionCreateManyInstanceInput[]
  }

  export type CurrencyCreateWithoutInstanceInput = {
    id?: string
    name: string
    code: string
    assignedLevels: number
    isDefault?: $Enums.YesNo
    clientId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    currencyIsoCode: CurrencyIsoCodeCreateNestedOneWithoutCurrenciesInput
    levels?: LevelCreateNestedManyWithoutCurrencyInput
    defaults?: ConfigCreateNestedManyWithoutDefaultCurrencyInput
  }

  export type CurrencyUncheckedCreateWithoutInstanceInput = {
    id?: string
    name: string
    code: string
    currencyIsoCodeId: string
    assignedLevels: number
    isDefault?: $Enums.YesNo
    clientId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    levels?: LevelUncheckedCreateNestedManyWithoutCurrencyInput
    defaults?: ConfigUncheckedCreateNestedManyWithoutDefaultCurrencyInput
  }

  export type CurrencyCreateOrConnectWithoutInstanceInput = {
    where: CurrencyWhereUniqueInput
    create: XOR<CurrencyCreateWithoutInstanceInput, CurrencyUncheckedCreateWithoutInstanceInput>
  }

  export type CurrencyCreateManyInstanceInputEnvelope = {
    data: CurrencyCreateManyInstanceInput | CurrencyCreateManyInstanceInput[]
  }

  export type AccountCreateWithoutInstanceInput = {
    id?: string
    code: string
    name: string
    isRoot?: boolean
    isModelRoot?: boolean
    accountType: $Enums.AccountType
    accountTypeTag: $Enums.AccountTypeTag
    group?: $Enums.YesNo
    plannedBy?: $Enums.ActPlanBy | null
    actualsBy?: $Enums.ActActualsBy | null
    displayAs?: $Enums.ActDisplayAs
    containsSalaryInfo?: $Enums.YesNo
    description?: string | null
    clientId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    parent?: AccountCreateNestedOneWithoutChildAccountsInput
    childAccounts?: AccountCreateNestedManyWithoutParentInput
    AttributeAndValues?: AccountAttributeAndValueCreateNestedManyWithoutAccountInput
    modelAccounts?: ModelAccountStructureCreateNestedManyWithoutAccountInput
    modelData?: ModelDataCreateNestedManyWithoutAccountInput
    modeldataCalculations?: ModelDataCalculationsCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutInstanceInput = {
    id?: string
    code: string
    name: string
    isRoot?: boolean
    isModelRoot?: boolean
    accountType: $Enums.AccountType
    accountTypeTag: $Enums.AccountTypeTag
    group?: $Enums.YesNo
    plannedBy?: $Enums.ActPlanBy | null
    actualsBy?: $Enums.ActActualsBy | null
    displayAs?: $Enums.ActDisplayAs
    containsSalaryInfo?: $Enums.YesNo
    description?: string | null
    clientId: string
    parentId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    childAccounts?: AccountUncheckedCreateNestedManyWithoutParentInput
    AttributeAndValues?: AccountAttributeAndValueUncheckedCreateNestedManyWithoutAccountInput
    modelAccounts?: ModelAccountStructureUncheckedCreateNestedManyWithoutAccountInput
    modelData?: ModelDataUncheckedCreateNestedManyWithoutAccountInput
    modeldataCalculations?: ModelDataCalculationsUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutInstanceInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutInstanceInput, AccountUncheckedCreateWithoutInstanceInput>
  }

  export type AccountCreateManyInstanceInputEnvelope = {
    data: AccountCreateManyInstanceInput | AccountCreateManyInstanceInput[]
  }

  export type ModelCreateWithoutInstanceInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    dimensionality?: ModelCreatedimensionalityInput | string[]
    status?: $Enums.ModelStatus
    isDefault?: boolean
    clientId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    rootAccountId: string
    modelData?: ModelDataCreateNestedManyWithoutModelInput
    modelAccounts?: ModelAccountStructureCreateNestedManyWithoutModelInput
    modelDataCalculations?: ModelDataCalculationsCreateNestedManyWithoutModelInput
  }

  export type ModelUncheckedCreateWithoutInstanceInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    dimensionality?: ModelCreatedimensionalityInput | string[]
    status?: $Enums.ModelStatus
    isDefault?: boolean
    clientId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    rootAccountId: string
    modelData?: ModelDataUncheckedCreateNestedManyWithoutModelInput
    modelAccounts?: ModelAccountStructureUncheckedCreateNestedManyWithoutModelInput
    modelDataCalculations?: ModelDataCalculationsUncheckedCreateNestedManyWithoutModelInput
  }

  export type ModelCreateOrConnectWithoutInstanceInput = {
    where: ModelWhereUniqueInput
    create: XOR<ModelCreateWithoutInstanceInput, ModelUncheckedCreateWithoutInstanceInput>
  }

  export type ModelCreateManyInstanceInputEnvelope = {
    data: ModelCreateManyInstanceInput | ModelCreateManyInstanceInput[]
  }

  export type DimensionCreateWithoutInstanceInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    dimensionValueDefault?: string | null
    clientId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    dimensionValues?: DimensionValueCreateNestedManyWithoutDimensionInput
  }

  export type DimensionUncheckedCreateWithoutInstanceInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    dimensionValueDefault?: string | null
    clientId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    dimensionValues?: DimensionValueUncheckedCreateNestedManyWithoutDimensionInput
  }

  export type DimensionCreateOrConnectWithoutInstanceInput = {
    where: DimensionWhereUniqueInput
    create: XOR<DimensionCreateWithoutInstanceInput, DimensionUncheckedCreateWithoutInstanceInput>
  }

  export type DimensionCreateManyInstanceInputEnvelope = {
    data: DimensionCreateManyInstanceInput | DimensionCreateManyInstanceInput[]
  }

  export type DimensionValueCreateWithoutInstanceInput = {
    id?: string
    code: string
    name: string
    clientId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    parent?: DimensionValueCreateNestedOneWithoutChildDimensionValuesInput
    childDimensionValues?: DimensionValueCreateNestedManyWithoutParentInput
    AttributeAndValues?: DimensionValueAttributeAndValueCreateNestedManyWithoutDimensionValueInput
    dimension: DimensionCreateNestedOneWithoutDimensionValuesInput
  }

  export type DimensionValueUncheckedCreateWithoutInstanceInput = {
    id?: string
    code: string
    name: string
    parentId?: string | null
    clientId: string
    dimensionId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    childDimensionValues?: DimensionValueUncheckedCreateNestedManyWithoutParentInput
    AttributeAndValues?: DimensionValueAttributeAndValueUncheckedCreateNestedManyWithoutDimensionValueInput
  }

  export type DimensionValueCreateOrConnectWithoutInstanceInput = {
    where: DimensionValueWhereUniqueInput
    create: XOR<DimensionValueCreateWithoutInstanceInput, DimensionValueUncheckedCreateWithoutInstanceInput>
  }

  export type DimensionValueCreateManyInstanceInputEnvelope = {
    data: DimensionValueCreateManyInstanceInput | DimensionValueCreateManyInstanceInput[]
  }

  export type LevelAttributeCreateWithoutInstanceInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    clientId: string
    attributeValueDefault?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    levelAttributeValues?: LevelAttributeValueCreateNestedManyWithoutLevelAttributeInput
    levelAttributeAndValues?: LevelAttributeAndValueCreateNestedManyWithoutAttributeInput
  }

  export type LevelAttributeUncheckedCreateWithoutInstanceInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    clientId: string
    attributeValueDefault?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    levelAttributeValues?: LevelAttributeValueUncheckedCreateNestedManyWithoutLevelAttributeInput
    levelAttributeAndValues?: LevelAttributeAndValueUncheckedCreateNestedManyWithoutAttributeInput
  }

  export type LevelAttributeCreateOrConnectWithoutInstanceInput = {
    where: LevelAttributeWhereUniqueInput
    create: XOR<LevelAttributeCreateWithoutInstanceInput, LevelAttributeUncheckedCreateWithoutInstanceInput>
  }

  export type LevelAttributeCreateManyInstanceInputEnvelope = {
    data: LevelAttributeCreateManyInstanceInput | LevelAttributeCreateManyInstanceInput[]
  }

  export type DimensionValueAttributeCreateWithoutInstanceInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    clientId: string
    updatedAt?: Date | string | null
    createdAt?: Date | string | null
    AttributeValues?: DimensionValueAttributeValueCreateNestedManyWithoutDimensionValueAttributeInput
    AttributeAndValues?: DimensionValueAttributeAndValueCreateNestedManyWithoutAttributeInput
  }

  export type DimensionValueAttributeUncheckedCreateWithoutInstanceInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    clientId: string
    updatedAt?: Date | string | null
    createdAt?: Date | string | null
    AttributeValues?: DimensionValueAttributeValueUncheckedCreateNestedManyWithoutDimensionValueAttributeInput
    AttributeAndValues?: DimensionValueAttributeAndValueUncheckedCreateNestedManyWithoutAttributeInput
  }

  export type DimensionValueAttributeCreateOrConnectWithoutInstanceInput = {
    where: DimensionValueAttributeWhereUniqueInput
    create: XOR<DimensionValueAttributeCreateWithoutInstanceInput, DimensionValueAttributeUncheckedCreateWithoutInstanceInput>
  }

  export type DimensionValueAttributeCreateManyInstanceInputEnvelope = {
    data: DimensionValueAttributeCreateManyInstanceInput | DimensionValueAttributeCreateManyInstanceInput[]
  }

  export type AccountAttributeCreateWithoutInstanceInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    attributeValueDefault?: string | null
    clientId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    accountAttributeValues?: AccountAttributeValueCreateNestedManyWithoutAccountAttributeInput
    AttributeAndValues?: AccountAttributeAndValueCreateNestedManyWithoutAttributeInput
  }

  export type AccountAttributeUncheckedCreateWithoutInstanceInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    attributeValueDefault?: string | null
    clientId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    accountAttributeValues?: AccountAttributeValueUncheckedCreateNestedManyWithoutAccountAttributeInput
    AttributeAndValues?: AccountAttributeAndValueUncheckedCreateNestedManyWithoutAttributeInput
  }

  export type AccountAttributeCreateOrConnectWithoutInstanceInput = {
    where: AccountAttributeWhereUniqueInput
    create: XOR<AccountAttributeCreateWithoutInstanceInput, AccountAttributeUncheckedCreateWithoutInstanceInput>
  }

  export type AccountAttributeCreateManyInstanceInputEnvelope = {
    data: AccountAttributeCreateManyInstanceInput | AccountAttributeCreateManyInstanceInput[]
  }

  export type LevelAttributeValueCreateWithoutInstanceInput = {
    id?: string
    code: string
    name: string
    clientId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    parent?: LevelAttributeValueCreateNestedOneWithoutChildAttributeValuesInput
    childAttributeValues?: LevelAttributeValueCreateNestedManyWithoutParentInput
    levelAttribute: LevelAttributeCreateNestedOneWithoutLevelAttributeValuesInput
    levelAttributeAndValues?: LevelAttributeAndValueCreateNestedManyWithoutAttributeValueInput
  }

  export type LevelAttributeValueUncheckedCreateWithoutInstanceInput = {
    id?: string
    code: string
    name: string
    attributeId: string
    parentId?: string | null
    clientId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    childAttributeValues?: LevelAttributeValueUncheckedCreateNestedManyWithoutParentInput
    levelAttributeAndValues?: LevelAttributeAndValueUncheckedCreateNestedManyWithoutAttributeValueInput
  }

  export type LevelAttributeValueCreateOrConnectWithoutInstanceInput = {
    where: LevelAttributeValueWhereUniqueInput
    create: XOR<LevelAttributeValueCreateWithoutInstanceInput, LevelAttributeValueUncheckedCreateWithoutInstanceInput>
  }

  export type LevelAttributeValueCreateManyInstanceInputEnvelope = {
    data: LevelAttributeValueCreateManyInstanceInput | LevelAttributeValueCreateManyInstanceInput[]
  }

  export type AccountAttributeValueCreateWithoutInstanceInput = {
    id?: string
    code: string
    name: string
    clientId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    parent?: AccountAttributeValueCreateNestedOneWithoutChildAttributeValuesInput
    childAttributeValues?: AccountAttributeValueCreateNestedManyWithoutParentInput
    accountAttribute: AccountAttributeCreateNestedOneWithoutAccountAttributeValuesInput
    AttributeAndValues?: AccountAttributeAndValueCreateNestedManyWithoutAttributeValueInput
  }

  export type AccountAttributeValueUncheckedCreateWithoutInstanceInput = {
    id?: string
    code: string
    name: string
    attributeId: string
    parentId?: string | null
    clientId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    childAttributeValues?: AccountAttributeValueUncheckedCreateNestedManyWithoutParentInput
    AttributeAndValues?: AccountAttributeAndValueUncheckedCreateNestedManyWithoutAttributeValueInput
  }

  export type AccountAttributeValueCreateOrConnectWithoutInstanceInput = {
    where: AccountAttributeValueWhereUniqueInput
    create: XOR<AccountAttributeValueCreateWithoutInstanceInput, AccountAttributeValueUncheckedCreateWithoutInstanceInput>
  }

  export type AccountAttributeValueCreateManyInstanceInputEnvelope = {
    data: AccountAttributeValueCreateManyInstanceInput | AccountAttributeValueCreateManyInstanceInput[]
  }

  export type DimensionValueAttributeValueCreateWithoutInstanceInput = {
    id?: string
    code: string
    name: string
    clientId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    parent?: DimensionValueAttributeValueCreateNestedOneWithoutChildAttributeValuesInput
    childAttributeValues?: DimensionValueAttributeValueCreateNestedManyWithoutParentInput
    dimensionValueAttribute: DimensionValueAttributeCreateNestedOneWithoutAttributeValuesInput
    dimensionAttributeAndValues?: DimensionValueAttributeAndValueCreateNestedManyWithoutAttributeValueInput
  }

  export type DimensionValueAttributeValueUncheckedCreateWithoutInstanceInput = {
    id?: string
    code: string
    name: string
    attributeId: string
    clientId: string
    parentId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    childAttributeValues?: DimensionValueAttributeValueUncheckedCreateNestedManyWithoutParentInput
    dimensionAttributeAndValues?: DimensionValueAttributeAndValueUncheckedCreateNestedManyWithoutAttributeValueInput
  }

  export type DimensionValueAttributeValueCreateOrConnectWithoutInstanceInput = {
    where: DimensionValueAttributeValueWhereUniqueInput
    create: XOR<DimensionValueAttributeValueCreateWithoutInstanceInput, DimensionValueAttributeValueUncheckedCreateWithoutInstanceInput>
  }

  export type DimensionValueAttributeValueCreateManyInstanceInputEnvelope = {
    data: DimensionValueAttributeValueCreateManyInstanceInput | DimensionValueAttributeValueCreateManyInstanceInput[]
  }

  export type ModelDataCreateWithoutInstanceInput = {
    id?: string
    clientId: string
    dimensionality?: XOR<ModelDataDimensionalityListCreateEnvelopeInput, ModelDataDimensionalityCreateInput> | ModelDataDimensionalityCreateInput[]
    timespan: InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    model: ModelCreateNestedOneWithoutModelDataInput
    level: LevelCreateNestedOneWithoutModelDataInput
    account: AccountCreateNestedOneWithoutModelDataInput
    version: VersionCreateNestedOneWithoutModelDataInput
  }

  export type ModelDataUncheckedCreateWithoutInstanceInput = {
    id?: string
    clientId: string
    modelId: string
    versionId: string
    levelId: string
    accountId: string
    dimensionality?: XOR<ModelDataDimensionalityListCreateEnvelopeInput, ModelDataDimensionalityCreateInput> | ModelDataDimensionalityCreateInput[]
    timespan: InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ModelDataCreateOrConnectWithoutInstanceInput = {
    where: ModelDataWhereUniqueInput
    create: XOR<ModelDataCreateWithoutInstanceInput, ModelDataUncheckedCreateWithoutInstanceInput>
  }

  export type ModelDataCreateManyInstanceInputEnvelope = {
    data: ModelDataCreateManyInstanceInput | ModelDataCreateManyInstanceInput[]
  }

  export type ModelDataCalculationsCreateWithoutInstanceInput = {
    id?: string
    clientId: string
    calculations: InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    model: ModelCreateNestedOneWithoutModelDataCalculationsInput
    level: LevelCreateNestedOneWithoutModeldataCalculationsInput
    account: AccountCreateNestedOneWithoutModeldataCalculationsInput
    version: VersionCreateNestedOneWithoutModelDataCalculationsInput
    modelAccount: ModelAccountStructureCreateNestedOneWithoutModeldataCalculationsInput
  }

  export type ModelDataCalculationsUncheckedCreateWithoutInstanceInput = {
    id?: string
    clientId: string
    modelId: string
    versionId: string
    levelId: string
    accountId: string
    modelAccountId: string
    calculations: InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ModelDataCalculationsCreateOrConnectWithoutInstanceInput = {
    where: ModelDataCalculationsWhereUniqueInput
    create: XOR<ModelDataCalculationsCreateWithoutInstanceInput, ModelDataCalculationsUncheckedCreateWithoutInstanceInput>
  }

  export type ModelDataCalculationsCreateManyInstanceInputEnvelope = {
    data: ModelDataCalculationsCreateManyInstanceInput | ModelDataCalculationsCreateManyInstanceInput[]
  }

  export type ModelAccountStructureCreateWithoutInstanceInput = {
    id?: string
    isRoot?: boolean
    clientId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    model: ModelCreateNestedOneWithoutModelAccountsInput
    account: AccountCreateNestedOneWithoutModelAccountsInput
    modeldataCalculations?: ModelDataCalculationsCreateNestedManyWithoutModelAccountInput
    parentAccount?: ModelAccountStructureCreateNestedOneWithoutChildAccountsInput
    childAccounts?: ModelAccountStructureCreateNestedManyWithoutParentAccountInput
  }

  export type ModelAccountStructureUncheckedCreateWithoutInstanceInput = {
    id?: string
    isRoot?: boolean
    clientId: string
    parentId?: string | null
    modelId: string
    accountId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    modeldataCalculations?: ModelDataCalculationsUncheckedCreateNestedManyWithoutModelAccountInput
    childAccounts?: ModelAccountStructureUncheckedCreateNestedManyWithoutParentAccountInput
  }

  export type ModelAccountStructureCreateOrConnectWithoutInstanceInput = {
    where: ModelAccountStructureWhereUniqueInput
    create: XOR<ModelAccountStructureCreateWithoutInstanceInput, ModelAccountStructureUncheckedCreateWithoutInstanceInput>
  }

  export type ModelAccountStructureCreateManyInstanceInputEnvelope = {
    data: ModelAccountStructureCreateManyInstanceInput | ModelAccountStructureCreateManyInstanceInput[]
  }

  export type TableCreateWithoutInstanceInput = {
    id?: string
    clientId: string
    name: string
    code: string
    description?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    status: $Enums.ModelStatus
    columnDefinitions?: XOR<TableColumnDefinitionListCreateEnvelopeInput, TableColumnDefinitionCreateInput> | TableColumnDefinitionCreateInput[]
    tableData?: TableDataCreateNestedManyWithoutTableInput
  }

  export type TableUncheckedCreateWithoutInstanceInput = {
    id?: string
    clientId: string
    name: string
    code: string
    description?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    status: $Enums.ModelStatus
    columnDefinitions?: XOR<TableColumnDefinitionListCreateEnvelopeInput, TableColumnDefinitionCreateInput> | TableColumnDefinitionCreateInput[]
    tableData?: TableDataUncheckedCreateNestedManyWithoutTableInput
  }

  export type TableCreateOrConnectWithoutInstanceInput = {
    where: TableWhereUniqueInput
    create: XOR<TableCreateWithoutInstanceInput, TableUncheckedCreateWithoutInstanceInput>
  }

  export type TableCreateManyInstanceInputEnvelope = {
    data: TableCreateManyInstanceInput | TableCreateManyInstanceInput[]
  }

  export type TableDataCreateWithoutInstanceInput = {
    id?: string
    clientId: string
    rowKey: string
    versionId: string
    levelId: string
    data: InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    table: TableCreateNestedOneWithoutTableDataInput
  }

  export type TableDataUncheckedCreateWithoutInstanceInput = {
    id?: string
    clientId: string
    tableId: string
    rowKey: string
    versionId: string
    levelId: string
    data: InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type TableDataCreateOrConnectWithoutInstanceInput = {
    where: TableDataWhereUniqueInput
    create: XOR<TableDataCreateWithoutInstanceInput, TableDataUncheckedCreateWithoutInstanceInput>
  }

  export type TableDataCreateManyInstanceInputEnvelope = {
    data: TableDataCreateManyInstanceInput | TableDataCreateManyInstanceInput[]
  }

  export type ClientUpsertWithoutInstancesInput = {
    update: XOR<ClientUpdateWithoutInstancesInput, ClientUncheckedUpdateWithoutInstancesInput>
    create: XOR<ClientCreateWithoutInstancesInput, ClientUncheckedCreateWithoutInstancesInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutInstancesInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutInstancesInput, ClientUncheckedUpdateWithoutInstancesInput>
  }

  export type ClientUpdateWithoutInstancesInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumclientStatusFieldUpdateOperationsInput | $Enums.clientStatus
    address?: XOR<addressTypeNullableUpdateEnvelopeInput, addressTypeCreateInput> | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: CountryUpdateOneWithoutClientNestedInput
    users?: UserUpdateManyWithoutClientNestedInput
    Permission?: PermissionUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutInstancesInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumclientStatusFieldUpdateOperationsInput | $Enums.clientStatus
    address?: XOR<addressTypeNullableUpdateEnvelopeInput, addressTypeCreateInput> | null
    countryId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: UserUncheckedUpdateManyWithoutClientNestedInput
    Permission?: PermissionUncheckedUpdateManyWithoutClientNestedInput
  }

  export type LevelUpsertWithWhereUniqueWithoutInstanceInput = {
    where: LevelWhereUniqueInput
    update: XOR<LevelUpdateWithoutInstanceInput, LevelUncheckedUpdateWithoutInstanceInput>
    create: XOR<LevelCreateWithoutInstanceInput, LevelUncheckedCreateWithoutInstanceInput>
  }

  export type LevelUpdateWithWhereUniqueWithoutInstanceInput = {
    where: LevelWhereUniqueInput
    data: XOR<LevelUpdateWithoutInstanceInput, LevelUncheckedUpdateWithoutInstanceInput>
  }

  export type LevelUpdateManyWithWhereWithoutInstanceInput = {
    where: LevelScalarWhereInput
    data: XOR<LevelUpdateManyMutationInput, LevelUncheckedUpdateManyWithoutInstanceInput>
  }

  export type LevelScalarWhereInput = {
    AND?: LevelScalarWhereInput | LevelScalarWhereInput[]
    OR?: LevelScalarWhereInput[]
    NOT?: LevelScalarWhereInput | LevelScalarWhereInput[]
    id?: StringFilter<"Level"> | string
    code?: StringFilter<"Level"> | string
    name?: StringFilter<"Level"> | string
    isRoot?: BoolFilter<"Level"> | boolean
    description?: StringNullableFilter<"Level"> | string | null
    parentId?: StringNullableFilter<"Level"> | string | null
    clientId?: StringFilter<"Level"> | string
    instanceId?: StringFilter<"Level"> | string
    currencyId?: StringFilter<"Level"> | string
    createdAt?: DateTimeNullableFilter<"Level"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Level"> | Date | string | null
  }

  export type VersionUpsertWithWhereUniqueWithoutInstanceInput = {
    where: VersionWhereUniqueInput
    update: XOR<VersionUpdateWithoutInstanceInput, VersionUncheckedUpdateWithoutInstanceInput>
    create: XOR<VersionCreateWithoutInstanceInput, VersionUncheckedCreateWithoutInstanceInput>
  }

  export type VersionUpdateWithWhereUniqueWithoutInstanceInput = {
    where: VersionWhereUniqueInput
    data: XOR<VersionUpdateWithoutInstanceInput, VersionUncheckedUpdateWithoutInstanceInput>
  }

  export type VersionUpdateManyWithWhereWithoutInstanceInput = {
    where: VersionScalarWhereInput
    data: XOR<VersionUpdateManyMutationInput, VersionUncheckedUpdateManyWithoutInstanceInput>
  }

  export type VersionScalarWhereInput = {
    AND?: VersionScalarWhereInput | VersionScalarWhereInput[]
    OR?: VersionScalarWhereInput[]
    NOT?: VersionScalarWhereInput | VersionScalarWhereInput[]
    id?: StringFilter<"Version"> | string
    code?: StringFilter<"Version"> | string
    name?: StringFilter<"Version"> | string
    begin?: DateTimeFilter<"Version"> | Date | string
    end?: DateTimeFilter<"Version"> | Date | string
    startOfPlan?: DateTimeFilter<"Version"> | Date | string
    description?: StringNullableFilter<"Version"> | string | null
    isDefault?: BoolFilter<"Version"> | boolean
    isActuals?: BoolFilter<"Version"> | boolean
    status?: EnumversionStatusFilter<"Version"> | $Enums.versionStatus
    clientId?: StringFilter<"Version"> | string
    instanceId?: StringFilter<"Version"> | string
    createdAt?: DateTimeNullableFilter<"Version"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Version"> | Date | string | null
  }

  export type CurrencyUpsertWithWhereUniqueWithoutInstanceInput = {
    where: CurrencyWhereUniqueInput
    update: XOR<CurrencyUpdateWithoutInstanceInput, CurrencyUncheckedUpdateWithoutInstanceInput>
    create: XOR<CurrencyCreateWithoutInstanceInput, CurrencyUncheckedCreateWithoutInstanceInput>
  }

  export type CurrencyUpdateWithWhereUniqueWithoutInstanceInput = {
    where: CurrencyWhereUniqueInput
    data: XOR<CurrencyUpdateWithoutInstanceInput, CurrencyUncheckedUpdateWithoutInstanceInput>
  }

  export type CurrencyUpdateManyWithWhereWithoutInstanceInput = {
    where: CurrencyScalarWhereInput
    data: XOR<CurrencyUpdateManyMutationInput, CurrencyUncheckedUpdateManyWithoutInstanceInput>
  }

  export type CurrencyScalarWhereInput = {
    AND?: CurrencyScalarWhereInput | CurrencyScalarWhereInput[]
    OR?: CurrencyScalarWhereInput[]
    NOT?: CurrencyScalarWhereInput | CurrencyScalarWhereInput[]
    id?: StringFilter<"Currency"> | string
    name?: StringFilter<"Currency"> | string
    code?: StringFilter<"Currency"> | string
    currencyIsoCodeId?: StringFilter<"Currency"> | string
    assignedLevels?: IntFilter<"Currency"> | number
    isDefault?: EnumYesNoFilter<"Currency"> | $Enums.YesNo
    clientId?: StringFilter<"Currency"> | string
    instanceId?: StringFilter<"Currency"> | string
    createdAt?: DateTimeNullableFilter<"Currency"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Currency"> | Date | string | null
  }

  export type AccountUpsertWithWhereUniqueWithoutInstanceInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutInstanceInput, AccountUncheckedUpdateWithoutInstanceInput>
    create: XOR<AccountCreateWithoutInstanceInput, AccountUncheckedCreateWithoutInstanceInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutInstanceInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutInstanceInput, AccountUncheckedUpdateWithoutInstanceInput>
  }

  export type AccountUpdateManyWithWhereWithoutInstanceInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutInstanceInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    id?: StringFilter<"Account"> | string
    code?: StringFilter<"Account"> | string
    name?: StringFilter<"Account"> | string
    isRoot?: BoolFilter<"Account"> | boolean
    isModelRoot?: BoolFilter<"Account"> | boolean
    accountType?: EnumAccountTypeFilter<"Account"> | $Enums.AccountType
    accountTypeTag?: EnumAccountTypeTagFilter<"Account"> | $Enums.AccountTypeTag
    group?: EnumYesNoFilter<"Account"> | $Enums.YesNo
    plannedBy?: EnumActPlanByNullableFilter<"Account"> | $Enums.ActPlanBy | null
    actualsBy?: EnumActActualsByNullableFilter<"Account"> | $Enums.ActActualsBy | null
    displayAs?: EnumActDisplayAsFilter<"Account"> | $Enums.ActDisplayAs
    containsSalaryInfo?: EnumYesNoFilter<"Account"> | $Enums.YesNo
    description?: StringNullableFilter<"Account"> | string | null
    instanceId?: StringFilter<"Account"> | string
    clientId?: StringFilter<"Account"> | string
    parentId?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Account"> | Date | string | null
  }

  export type ModelUpsertWithWhereUniqueWithoutInstanceInput = {
    where: ModelWhereUniqueInput
    update: XOR<ModelUpdateWithoutInstanceInput, ModelUncheckedUpdateWithoutInstanceInput>
    create: XOR<ModelCreateWithoutInstanceInput, ModelUncheckedCreateWithoutInstanceInput>
  }

  export type ModelUpdateWithWhereUniqueWithoutInstanceInput = {
    where: ModelWhereUniqueInput
    data: XOR<ModelUpdateWithoutInstanceInput, ModelUncheckedUpdateWithoutInstanceInput>
  }

  export type ModelUpdateManyWithWhereWithoutInstanceInput = {
    where: ModelScalarWhereInput
    data: XOR<ModelUpdateManyMutationInput, ModelUncheckedUpdateManyWithoutInstanceInput>
  }

  export type ModelScalarWhereInput = {
    AND?: ModelScalarWhereInput | ModelScalarWhereInput[]
    OR?: ModelScalarWhereInput[]
    NOT?: ModelScalarWhereInput | ModelScalarWhereInput[]
    id?: StringFilter<"Model"> | string
    code?: StringFilter<"Model"> | string
    name?: StringFilter<"Model"> | string
    description?: StringNullableFilter<"Model"> | string | null
    dimensionality?: StringNullableListFilter<"Model">
    status?: EnumModelStatusFilter<"Model"> | $Enums.ModelStatus
    isDefault?: BoolFilter<"Model"> | boolean
    instanceId?: StringFilter<"Model"> | string
    clientId?: StringFilter<"Model"> | string
    createdAt?: DateTimeNullableFilter<"Model"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Model"> | Date | string | null
    rootAccountId?: StringFilter<"Model"> | string
  }

  export type DimensionUpsertWithWhereUniqueWithoutInstanceInput = {
    where: DimensionWhereUniqueInput
    update: XOR<DimensionUpdateWithoutInstanceInput, DimensionUncheckedUpdateWithoutInstanceInput>
    create: XOR<DimensionCreateWithoutInstanceInput, DimensionUncheckedCreateWithoutInstanceInput>
  }

  export type DimensionUpdateWithWhereUniqueWithoutInstanceInput = {
    where: DimensionWhereUniqueInput
    data: XOR<DimensionUpdateWithoutInstanceInput, DimensionUncheckedUpdateWithoutInstanceInput>
  }

  export type DimensionUpdateManyWithWhereWithoutInstanceInput = {
    where: DimensionScalarWhereInput
    data: XOR<DimensionUpdateManyMutationInput, DimensionUncheckedUpdateManyWithoutInstanceInput>
  }

  export type DimensionScalarWhereInput = {
    AND?: DimensionScalarWhereInput | DimensionScalarWhereInput[]
    OR?: DimensionScalarWhereInput[]
    NOT?: DimensionScalarWhereInput | DimensionScalarWhereInput[]
    id?: StringFilter<"Dimension"> | string
    code?: StringFilter<"Dimension"> | string
    name?: StringFilter<"Dimension"> | string
    description?: StringNullableFilter<"Dimension"> | string | null
    dimensionValueDefault?: StringNullableFilter<"Dimension"> | string | null
    clientId?: StringFilter<"Dimension"> | string
    instanceId?: StringFilter<"Dimension"> | string
    createdAt?: DateTimeNullableFilter<"Dimension"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Dimension"> | Date | string | null
  }

  export type DimensionValueUpsertWithWhereUniqueWithoutInstanceInput = {
    where: DimensionValueWhereUniqueInput
    update: XOR<DimensionValueUpdateWithoutInstanceInput, DimensionValueUncheckedUpdateWithoutInstanceInput>
    create: XOR<DimensionValueCreateWithoutInstanceInput, DimensionValueUncheckedCreateWithoutInstanceInput>
  }

  export type DimensionValueUpdateWithWhereUniqueWithoutInstanceInput = {
    where: DimensionValueWhereUniqueInput
    data: XOR<DimensionValueUpdateWithoutInstanceInput, DimensionValueUncheckedUpdateWithoutInstanceInput>
  }

  export type DimensionValueUpdateManyWithWhereWithoutInstanceInput = {
    where: DimensionValueScalarWhereInput
    data: XOR<DimensionValueUpdateManyMutationInput, DimensionValueUncheckedUpdateManyWithoutInstanceInput>
  }

  export type DimensionValueScalarWhereInput = {
    AND?: DimensionValueScalarWhereInput | DimensionValueScalarWhereInput[]
    OR?: DimensionValueScalarWhereInput[]
    NOT?: DimensionValueScalarWhereInput | DimensionValueScalarWhereInput[]
    id?: StringFilter<"DimensionValue"> | string
    code?: StringFilter<"DimensionValue"> | string
    name?: StringFilter<"DimensionValue"> | string
    parentId?: StringNullableFilter<"DimensionValue"> | string | null
    clientId?: StringFilter<"DimensionValue"> | string
    instanceId?: StringFilter<"DimensionValue"> | string
    dimensionId?: StringFilter<"DimensionValue"> | string
    createdAt?: DateTimeNullableFilter<"DimensionValue"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"DimensionValue"> | Date | string | null
  }

  export type LevelAttributeUpsertWithWhereUniqueWithoutInstanceInput = {
    where: LevelAttributeWhereUniqueInput
    update: XOR<LevelAttributeUpdateWithoutInstanceInput, LevelAttributeUncheckedUpdateWithoutInstanceInput>
    create: XOR<LevelAttributeCreateWithoutInstanceInput, LevelAttributeUncheckedCreateWithoutInstanceInput>
  }

  export type LevelAttributeUpdateWithWhereUniqueWithoutInstanceInput = {
    where: LevelAttributeWhereUniqueInput
    data: XOR<LevelAttributeUpdateWithoutInstanceInput, LevelAttributeUncheckedUpdateWithoutInstanceInput>
  }

  export type LevelAttributeUpdateManyWithWhereWithoutInstanceInput = {
    where: LevelAttributeScalarWhereInput
    data: XOR<LevelAttributeUpdateManyMutationInput, LevelAttributeUncheckedUpdateManyWithoutInstanceInput>
  }

  export type LevelAttributeScalarWhereInput = {
    AND?: LevelAttributeScalarWhereInput | LevelAttributeScalarWhereInput[]
    OR?: LevelAttributeScalarWhereInput[]
    NOT?: LevelAttributeScalarWhereInput | LevelAttributeScalarWhereInput[]
    id?: StringFilter<"LevelAttribute"> | string
    code?: StringFilter<"LevelAttribute"> | string
    name?: StringFilter<"LevelAttribute"> | string
    description?: StringNullableFilter<"LevelAttribute"> | string | null
    clientId?: StringFilter<"LevelAttribute"> | string
    instanceId?: StringFilter<"LevelAttribute"> | string
    attributeValueDefault?: StringNullableFilter<"LevelAttribute"> | string | null
    createdAt?: DateTimeNullableFilter<"LevelAttribute"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"LevelAttribute"> | Date | string | null
  }

  export type DimensionValueAttributeUpsertWithWhereUniqueWithoutInstanceInput = {
    where: DimensionValueAttributeWhereUniqueInput
    update: XOR<DimensionValueAttributeUpdateWithoutInstanceInput, DimensionValueAttributeUncheckedUpdateWithoutInstanceInput>
    create: XOR<DimensionValueAttributeCreateWithoutInstanceInput, DimensionValueAttributeUncheckedCreateWithoutInstanceInput>
  }

  export type DimensionValueAttributeUpdateWithWhereUniqueWithoutInstanceInput = {
    where: DimensionValueAttributeWhereUniqueInput
    data: XOR<DimensionValueAttributeUpdateWithoutInstanceInput, DimensionValueAttributeUncheckedUpdateWithoutInstanceInput>
  }

  export type DimensionValueAttributeUpdateManyWithWhereWithoutInstanceInput = {
    where: DimensionValueAttributeScalarWhereInput
    data: XOR<DimensionValueAttributeUpdateManyMutationInput, DimensionValueAttributeUncheckedUpdateManyWithoutInstanceInput>
  }

  export type DimensionValueAttributeScalarWhereInput = {
    AND?: DimensionValueAttributeScalarWhereInput | DimensionValueAttributeScalarWhereInput[]
    OR?: DimensionValueAttributeScalarWhereInput[]
    NOT?: DimensionValueAttributeScalarWhereInput | DimensionValueAttributeScalarWhereInput[]
    id?: StringFilter<"DimensionValueAttribute"> | string
    code?: StringFilter<"DimensionValueAttribute"> | string
    name?: StringFilter<"DimensionValueAttribute"> | string
    description?: StringNullableFilter<"DimensionValueAttribute"> | string | null
    clientId?: StringFilter<"DimensionValueAttribute"> | string
    instanceId?: StringFilter<"DimensionValueAttribute"> | string
    updatedAt?: DateTimeNullableFilter<"DimensionValueAttribute"> | Date | string | null
    createdAt?: DateTimeNullableFilter<"DimensionValueAttribute"> | Date | string | null
  }

  export type AccountAttributeUpsertWithWhereUniqueWithoutInstanceInput = {
    where: AccountAttributeWhereUniqueInput
    update: XOR<AccountAttributeUpdateWithoutInstanceInput, AccountAttributeUncheckedUpdateWithoutInstanceInput>
    create: XOR<AccountAttributeCreateWithoutInstanceInput, AccountAttributeUncheckedCreateWithoutInstanceInput>
  }

  export type AccountAttributeUpdateWithWhereUniqueWithoutInstanceInput = {
    where: AccountAttributeWhereUniqueInput
    data: XOR<AccountAttributeUpdateWithoutInstanceInput, AccountAttributeUncheckedUpdateWithoutInstanceInput>
  }

  export type AccountAttributeUpdateManyWithWhereWithoutInstanceInput = {
    where: AccountAttributeScalarWhereInput
    data: XOR<AccountAttributeUpdateManyMutationInput, AccountAttributeUncheckedUpdateManyWithoutInstanceInput>
  }

  export type AccountAttributeScalarWhereInput = {
    AND?: AccountAttributeScalarWhereInput | AccountAttributeScalarWhereInput[]
    OR?: AccountAttributeScalarWhereInput[]
    NOT?: AccountAttributeScalarWhereInput | AccountAttributeScalarWhereInput[]
    id?: StringFilter<"AccountAttribute"> | string
    code?: StringFilter<"AccountAttribute"> | string
    name?: StringFilter<"AccountAttribute"> | string
    description?: StringNullableFilter<"AccountAttribute"> | string | null
    attributeValueDefault?: StringNullableFilter<"AccountAttribute"> | string | null
    clientId?: StringFilter<"AccountAttribute"> | string
    instanceId?: StringFilter<"AccountAttribute"> | string
    createdAt?: DateTimeNullableFilter<"AccountAttribute"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"AccountAttribute"> | Date | string | null
  }

  export type LevelAttributeValueUpsertWithWhereUniqueWithoutInstanceInput = {
    where: LevelAttributeValueWhereUniqueInput
    update: XOR<LevelAttributeValueUpdateWithoutInstanceInput, LevelAttributeValueUncheckedUpdateWithoutInstanceInput>
    create: XOR<LevelAttributeValueCreateWithoutInstanceInput, LevelAttributeValueUncheckedCreateWithoutInstanceInput>
  }

  export type LevelAttributeValueUpdateWithWhereUniqueWithoutInstanceInput = {
    where: LevelAttributeValueWhereUniqueInput
    data: XOR<LevelAttributeValueUpdateWithoutInstanceInput, LevelAttributeValueUncheckedUpdateWithoutInstanceInput>
  }

  export type LevelAttributeValueUpdateManyWithWhereWithoutInstanceInput = {
    where: LevelAttributeValueScalarWhereInput
    data: XOR<LevelAttributeValueUpdateManyMutationInput, LevelAttributeValueUncheckedUpdateManyWithoutInstanceInput>
  }

  export type LevelAttributeValueScalarWhereInput = {
    AND?: LevelAttributeValueScalarWhereInput | LevelAttributeValueScalarWhereInput[]
    OR?: LevelAttributeValueScalarWhereInput[]
    NOT?: LevelAttributeValueScalarWhereInput | LevelAttributeValueScalarWhereInput[]
    id?: StringFilter<"LevelAttributeValue"> | string
    code?: StringFilter<"LevelAttributeValue"> | string
    name?: StringFilter<"LevelAttributeValue"> | string
    attributeId?: StringFilter<"LevelAttributeValue"> | string
    parentId?: StringNullableFilter<"LevelAttributeValue"> | string | null
    clientId?: StringFilter<"LevelAttributeValue"> | string
    instanceId?: StringFilter<"LevelAttributeValue"> | string
    createdAt?: DateTimeNullableFilter<"LevelAttributeValue"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"LevelAttributeValue"> | Date | string | null
  }

  export type AccountAttributeValueUpsertWithWhereUniqueWithoutInstanceInput = {
    where: AccountAttributeValueWhereUniqueInput
    update: XOR<AccountAttributeValueUpdateWithoutInstanceInput, AccountAttributeValueUncheckedUpdateWithoutInstanceInput>
    create: XOR<AccountAttributeValueCreateWithoutInstanceInput, AccountAttributeValueUncheckedCreateWithoutInstanceInput>
  }

  export type AccountAttributeValueUpdateWithWhereUniqueWithoutInstanceInput = {
    where: AccountAttributeValueWhereUniqueInput
    data: XOR<AccountAttributeValueUpdateWithoutInstanceInput, AccountAttributeValueUncheckedUpdateWithoutInstanceInput>
  }

  export type AccountAttributeValueUpdateManyWithWhereWithoutInstanceInput = {
    where: AccountAttributeValueScalarWhereInput
    data: XOR<AccountAttributeValueUpdateManyMutationInput, AccountAttributeValueUncheckedUpdateManyWithoutInstanceInput>
  }

  export type AccountAttributeValueScalarWhereInput = {
    AND?: AccountAttributeValueScalarWhereInput | AccountAttributeValueScalarWhereInput[]
    OR?: AccountAttributeValueScalarWhereInput[]
    NOT?: AccountAttributeValueScalarWhereInput | AccountAttributeValueScalarWhereInput[]
    id?: StringFilter<"AccountAttributeValue"> | string
    code?: StringFilter<"AccountAttributeValue"> | string
    name?: StringFilter<"AccountAttributeValue"> | string
    attributeId?: StringFilter<"AccountAttributeValue"> | string
    parentId?: StringNullableFilter<"AccountAttributeValue"> | string | null
    clientId?: StringFilter<"AccountAttributeValue"> | string
    instanceId?: StringFilter<"AccountAttributeValue"> | string
    createdAt?: DateTimeNullableFilter<"AccountAttributeValue"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"AccountAttributeValue"> | Date | string | null
  }

  export type DimensionValueAttributeValueUpsertWithWhereUniqueWithoutInstanceInput = {
    where: DimensionValueAttributeValueWhereUniqueInput
    update: XOR<DimensionValueAttributeValueUpdateWithoutInstanceInput, DimensionValueAttributeValueUncheckedUpdateWithoutInstanceInput>
    create: XOR<DimensionValueAttributeValueCreateWithoutInstanceInput, DimensionValueAttributeValueUncheckedCreateWithoutInstanceInput>
  }

  export type DimensionValueAttributeValueUpdateWithWhereUniqueWithoutInstanceInput = {
    where: DimensionValueAttributeValueWhereUniqueInput
    data: XOR<DimensionValueAttributeValueUpdateWithoutInstanceInput, DimensionValueAttributeValueUncheckedUpdateWithoutInstanceInput>
  }

  export type DimensionValueAttributeValueUpdateManyWithWhereWithoutInstanceInput = {
    where: DimensionValueAttributeValueScalarWhereInput
    data: XOR<DimensionValueAttributeValueUpdateManyMutationInput, DimensionValueAttributeValueUncheckedUpdateManyWithoutInstanceInput>
  }

  export type DimensionValueAttributeValueScalarWhereInput = {
    AND?: DimensionValueAttributeValueScalarWhereInput | DimensionValueAttributeValueScalarWhereInput[]
    OR?: DimensionValueAttributeValueScalarWhereInput[]
    NOT?: DimensionValueAttributeValueScalarWhereInput | DimensionValueAttributeValueScalarWhereInput[]
    id?: StringFilter<"DimensionValueAttributeValue"> | string
    code?: StringFilter<"DimensionValueAttributeValue"> | string
    name?: StringFilter<"DimensionValueAttributeValue"> | string
    attributeId?: StringFilter<"DimensionValueAttributeValue"> | string
    clientId?: StringFilter<"DimensionValueAttributeValue"> | string
    parentId?: StringNullableFilter<"DimensionValueAttributeValue"> | string | null
    instanceId?: StringFilter<"DimensionValueAttributeValue"> | string
    createdAt?: DateTimeNullableFilter<"DimensionValueAttributeValue"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"DimensionValueAttributeValue"> | Date | string | null
  }

  export type ModelDataUpsertWithWhereUniqueWithoutInstanceInput = {
    where: ModelDataWhereUniqueInput
    update: XOR<ModelDataUpdateWithoutInstanceInput, ModelDataUncheckedUpdateWithoutInstanceInput>
    create: XOR<ModelDataCreateWithoutInstanceInput, ModelDataUncheckedCreateWithoutInstanceInput>
  }

  export type ModelDataUpdateWithWhereUniqueWithoutInstanceInput = {
    where: ModelDataWhereUniqueInput
    data: XOR<ModelDataUpdateWithoutInstanceInput, ModelDataUncheckedUpdateWithoutInstanceInput>
  }

  export type ModelDataUpdateManyWithWhereWithoutInstanceInput = {
    where: ModelDataScalarWhereInput
    data: XOR<ModelDataUpdateManyMutationInput, ModelDataUncheckedUpdateManyWithoutInstanceInput>
  }

  export type ModelDataScalarWhereInput = {
    AND?: ModelDataScalarWhereInput | ModelDataScalarWhereInput[]
    OR?: ModelDataScalarWhereInput[]
    NOT?: ModelDataScalarWhereInput | ModelDataScalarWhereInput[]
    id?: StringFilter<"ModelData"> | string
    clientId?: StringFilter<"ModelData"> | string
    instanceId?: StringFilter<"ModelData"> | string
    modelId?: StringFilter<"ModelData"> | string
    versionId?: StringFilter<"ModelData"> | string
    levelId?: StringFilter<"ModelData"> | string
    accountId?: StringFilter<"ModelData"> | string
    timespan?: JsonFilter<"ModelData">
    createdAt?: DateTimeNullableFilter<"ModelData"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"ModelData"> | Date | string | null
  }

  export type ModelDataCalculationsUpsertWithWhereUniqueWithoutInstanceInput = {
    where: ModelDataCalculationsWhereUniqueInput
    update: XOR<ModelDataCalculationsUpdateWithoutInstanceInput, ModelDataCalculationsUncheckedUpdateWithoutInstanceInput>
    create: XOR<ModelDataCalculationsCreateWithoutInstanceInput, ModelDataCalculationsUncheckedCreateWithoutInstanceInput>
  }

  export type ModelDataCalculationsUpdateWithWhereUniqueWithoutInstanceInput = {
    where: ModelDataCalculationsWhereUniqueInput
    data: XOR<ModelDataCalculationsUpdateWithoutInstanceInput, ModelDataCalculationsUncheckedUpdateWithoutInstanceInput>
  }

  export type ModelDataCalculationsUpdateManyWithWhereWithoutInstanceInput = {
    where: ModelDataCalculationsScalarWhereInput
    data: XOR<ModelDataCalculationsUpdateManyMutationInput, ModelDataCalculationsUncheckedUpdateManyWithoutInstanceInput>
  }

  export type ModelDataCalculationsScalarWhereInput = {
    AND?: ModelDataCalculationsScalarWhereInput | ModelDataCalculationsScalarWhereInput[]
    OR?: ModelDataCalculationsScalarWhereInput[]
    NOT?: ModelDataCalculationsScalarWhereInput | ModelDataCalculationsScalarWhereInput[]
    id?: StringFilter<"ModelDataCalculations"> | string
    clientId?: StringFilter<"ModelDataCalculations"> | string
    instanceId?: StringFilter<"ModelDataCalculations"> | string
    modelId?: StringFilter<"ModelDataCalculations"> | string
    versionId?: StringFilter<"ModelDataCalculations"> | string
    levelId?: StringFilter<"ModelDataCalculations"> | string
    accountId?: StringFilter<"ModelDataCalculations"> | string
    modelAccountId?: StringFilter<"ModelDataCalculations"> | string
    calculations?: JsonFilter<"ModelDataCalculations">
    createdAt?: DateTimeNullableFilter<"ModelDataCalculations"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"ModelDataCalculations"> | Date | string | null
  }

  export type ModelAccountStructureUpsertWithWhereUniqueWithoutInstanceInput = {
    where: ModelAccountStructureWhereUniqueInput
    update: XOR<ModelAccountStructureUpdateWithoutInstanceInput, ModelAccountStructureUncheckedUpdateWithoutInstanceInput>
    create: XOR<ModelAccountStructureCreateWithoutInstanceInput, ModelAccountStructureUncheckedCreateWithoutInstanceInput>
  }

  export type ModelAccountStructureUpdateWithWhereUniqueWithoutInstanceInput = {
    where: ModelAccountStructureWhereUniqueInput
    data: XOR<ModelAccountStructureUpdateWithoutInstanceInput, ModelAccountStructureUncheckedUpdateWithoutInstanceInput>
  }

  export type ModelAccountStructureUpdateManyWithWhereWithoutInstanceInput = {
    where: ModelAccountStructureScalarWhereInput
    data: XOR<ModelAccountStructureUpdateManyMutationInput, ModelAccountStructureUncheckedUpdateManyWithoutInstanceInput>
  }

  export type ModelAccountStructureScalarWhereInput = {
    AND?: ModelAccountStructureScalarWhereInput | ModelAccountStructureScalarWhereInput[]
    OR?: ModelAccountStructureScalarWhereInput[]
    NOT?: ModelAccountStructureScalarWhereInput | ModelAccountStructureScalarWhereInput[]
    id?: StringFilter<"ModelAccountStructure"> | string
    instanceId?: StringFilter<"ModelAccountStructure"> | string
    isRoot?: BoolFilter<"ModelAccountStructure"> | boolean
    clientId?: StringFilter<"ModelAccountStructure"> | string
    parentId?: StringNullableFilter<"ModelAccountStructure"> | string | null
    modelId?: StringFilter<"ModelAccountStructure"> | string
    accountId?: StringFilter<"ModelAccountStructure"> | string
    createdAt?: DateTimeNullableFilter<"ModelAccountStructure"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"ModelAccountStructure"> | Date | string | null
  }

  export type TableUpsertWithWhereUniqueWithoutInstanceInput = {
    where: TableWhereUniqueInput
    update: XOR<TableUpdateWithoutInstanceInput, TableUncheckedUpdateWithoutInstanceInput>
    create: XOR<TableCreateWithoutInstanceInput, TableUncheckedCreateWithoutInstanceInput>
  }

  export type TableUpdateWithWhereUniqueWithoutInstanceInput = {
    where: TableWhereUniqueInput
    data: XOR<TableUpdateWithoutInstanceInput, TableUncheckedUpdateWithoutInstanceInput>
  }

  export type TableUpdateManyWithWhereWithoutInstanceInput = {
    where: TableScalarWhereInput
    data: XOR<TableUpdateManyMutationInput, TableUncheckedUpdateManyWithoutInstanceInput>
  }

  export type TableScalarWhereInput = {
    AND?: TableScalarWhereInput | TableScalarWhereInput[]
    OR?: TableScalarWhereInput[]
    NOT?: TableScalarWhereInput | TableScalarWhereInput[]
    id?: StringFilter<"Table"> | string
    clientId?: StringFilter<"Table"> | string
    instanceId?: StringFilter<"Table"> | string
    name?: StringFilter<"Table"> | string
    code?: StringFilter<"Table"> | string
    description?: StringNullableFilter<"Table"> | string | null
    createdAt?: DateTimeNullableFilter<"Table"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Table"> | Date | string | null
    status?: EnumModelStatusFilter<"Table"> | $Enums.ModelStatus
  }

  export type TableDataUpsertWithWhereUniqueWithoutInstanceInput = {
    where: TableDataWhereUniqueInput
    update: XOR<TableDataUpdateWithoutInstanceInput, TableDataUncheckedUpdateWithoutInstanceInput>
    create: XOR<TableDataCreateWithoutInstanceInput, TableDataUncheckedCreateWithoutInstanceInput>
  }

  export type TableDataUpdateWithWhereUniqueWithoutInstanceInput = {
    where: TableDataWhereUniqueInput
    data: XOR<TableDataUpdateWithoutInstanceInput, TableDataUncheckedUpdateWithoutInstanceInput>
  }

  export type TableDataUpdateManyWithWhereWithoutInstanceInput = {
    where: TableDataScalarWhereInput
    data: XOR<TableDataUpdateManyMutationInput, TableDataUncheckedUpdateManyWithoutInstanceInput>
  }

  export type TableDataScalarWhereInput = {
    AND?: TableDataScalarWhereInput | TableDataScalarWhereInput[]
    OR?: TableDataScalarWhereInput[]
    NOT?: TableDataScalarWhereInput | TableDataScalarWhereInput[]
    id?: StringFilter<"TableData"> | string
    clientId?: StringFilter<"TableData"> | string
    instanceId?: StringFilter<"TableData"> | string
    tableId?: StringFilter<"TableData"> | string
    rowKey?: StringFilter<"TableData"> | string
    versionId?: StringFilter<"TableData"> | string
    levelId?: StringFilter<"TableData"> | string
    data?: JsonFilter<"TableData">
    createdAt?: DateTimeNullableFilter<"TableData"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"TableData"> | Date | string | null
  }

  export type InstanceCreateWithoutVersionsInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    status?: $Enums.instanceStatus
    userIds?: InstanceCreateuserIdsInput | string[]
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    client: ClientCreateNestedOneWithoutInstancesInput
    levels?: LevelCreateNestedManyWithoutInstanceInput
    currencies?: CurrencyCreateNestedManyWithoutInstanceInput
    accounts?: AccountCreateNestedManyWithoutInstanceInput
    models?: ModelCreateNestedManyWithoutInstanceInput
    dimensions?: DimensionCreateNestedManyWithoutInstanceInput
    dimensionValues?: DimensionValueCreateNestedManyWithoutInstanceInput
    levelAttributes?: LevelAttributeCreateNestedManyWithoutInstanceInput
    dimensionValueAttributes?: DimensionValueAttributeCreateNestedManyWithoutInstanceInput
    accountAttributes?: AccountAttributeCreateNestedManyWithoutInstanceInput
    levelAttValues?: LevelAttributeValueCreateNestedManyWithoutInstanceInput
    accountAttValues?: AccountAttributeValueCreateNestedManyWithoutInstanceInput
    dimensionValueAttributeValues?: DimensionValueAttributeValueCreateNestedManyWithoutInstanceInput
    modelData?: ModelDataCreateNestedManyWithoutInstanceInput
    modelDataCalculations?: ModelDataCalculationsCreateNestedManyWithoutInstanceInput
    modelAccounts?: ModelAccountStructureCreateNestedManyWithoutInstanceInput
    tables?: TableCreateNestedManyWithoutInstanceInput
    tableData?: TableDataCreateNestedManyWithoutInstanceInput
  }

  export type InstanceUncheckedCreateWithoutVersionsInput = {
    id?: string
    code: string
    name: string
    clientId: string
    description?: string | null
    status?: $Enums.instanceStatus
    userIds?: InstanceCreateuserIdsInput | string[]
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    levels?: LevelUncheckedCreateNestedManyWithoutInstanceInput
    currencies?: CurrencyUncheckedCreateNestedManyWithoutInstanceInput
    accounts?: AccountUncheckedCreateNestedManyWithoutInstanceInput
    models?: ModelUncheckedCreateNestedManyWithoutInstanceInput
    dimensions?: DimensionUncheckedCreateNestedManyWithoutInstanceInput
    dimensionValues?: DimensionValueUncheckedCreateNestedManyWithoutInstanceInput
    levelAttributes?: LevelAttributeUncheckedCreateNestedManyWithoutInstanceInput
    dimensionValueAttributes?: DimensionValueAttributeUncheckedCreateNestedManyWithoutInstanceInput
    accountAttributes?: AccountAttributeUncheckedCreateNestedManyWithoutInstanceInput
    levelAttValues?: LevelAttributeValueUncheckedCreateNestedManyWithoutInstanceInput
    accountAttValues?: AccountAttributeValueUncheckedCreateNestedManyWithoutInstanceInput
    dimensionValueAttributeValues?: DimensionValueAttributeValueUncheckedCreateNestedManyWithoutInstanceInput
    modelData?: ModelDataUncheckedCreateNestedManyWithoutInstanceInput
    modelDataCalculations?: ModelDataCalculationsUncheckedCreateNestedManyWithoutInstanceInput
    modelAccounts?: ModelAccountStructureUncheckedCreateNestedManyWithoutInstanceInput
    tables?: TableUncheckedCreateNestedManyWithoutInstanceInput
    tableData?: TableDataUncheckedCreateNestedManyWithoutInstanceInput
  }

  export type InstanceCreateOrConnectWithoutVersionsInput = {
    where: InstanceWhereUniqueInput
    create: XOR<InstanceCreateWithoutVersionsInput, InstanceUncheckedCreateWithoutVersionsInput>
  }

  export type ModelDataCreateWithoutVersionInput = {
    id?: string
    clientId: string
    dimensionality?: XOR<ModelDataDimensionalityListCreateEnvelopeInput, ModelDataDimensionalityCreateInput> | ModelDataDimensionalityCreateInput[]
    timespan: InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    model: ModelCreateNestedOneWithoutModelDataInput
    level: LevelCreateNestedOneWithoutModelDataInput
    account: AccountCreateNestedOneWithoutModelDataInput
    instance: InstanceCreateNestedOneWithoutModelDataInput
  }

  export type ModelDataUncheckedCreateWithoutVersionInput = {
    id?: string
    clientId: string
    instanceId: string
    modelId: string
    levelId: string
    accountId: string
    dimensionality?: XOR<ModelDataDimensionalityListCreateEnvelopeInput, ModelDataDimensionalityCreateInput> | ModelDataDimensionalityCreateInput[]
    timespan: InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ModelDataCreateOrConnectWithoutVersionInput = {
    where: ModelDataWhereUniqueInput
    create: XOR<ModelDataCreateWithoutVersionInput, ModelDataUncheckedCreateWithoutVersionInput>
  }

  export type ModelDataCreateManyVersionInputEnvelope = {
    data: ModelDataCreateManyVersionInput | ModelDataCreateManyVersionInput[]
  }

  export type ModelDataCalculationsCreateWithoutVersionInput = {
    id?: string
    clientId: string
    calculations: InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    model: ModelCreateNestedOneWithoutModelDataCalculationsInput
    level: LevelCreateNestedOneWithoutModeldataCalculationsInput
    account: AccountCreateNestedOneWithoutModeldataCalculationsInput
    instance: InstanceCreateNestedOneWithoutModelDataCalculationsInput
    modelAccount: ModelAccountStructureCreateNestedOneWithoutModeldataCalculationsInput
  }

  export type ModelDataCalculationsUncheckedCreateWithoutVersionInput = {
    id?: string
    clientId: string
    instanceId: string
    modelId: string
    levelId: string
    accountId: string
    modelAccountId: string
    calculations: InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ModelDataCalculationsCreateOrConnectWithoutVersionInput = {
    where: ModelDataCalculationsWhereUniqueInput
    create: XOR<ModelDataCalculationsCreateWithoutVersionInput, ModelDataCalculationsUncheckedCreateWithoutVersionInput>
  }

  export type ModelDataCalculationsCreateManyVersionInputEnvelope = {
    data: ModelDataCalculationsCreateManyVersionInput | ModelDataCalculationsCreateManyVersionInput[]
  }

  export type InstanceUpsertWithoutVersionsInput = {
    update: XOR<InstanceUpdateWithoutVersionsInput, InstanceUncheckedUpdateWithoutVersionsInput>
    create: XOR<InstanceCreateWithoutVersionsInput, InstanceUncheckedCreateWithoutVersionsInput>
    where?: InstanceWhereInput
  }

  export type InstanceUpdateToOneWithWhereWithoutVersionsInput = {
    where?: InstanceWhereInput
    data: XOR<InstanceUpdateWithoutVersionsInput, InstanceUncheckedUpdateWithoutVersionsInput>
  }

  export type InstanceUpdateWithoutVersionsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnuminstanceStatusFieldUpdateOperationsInput | $Enums.instanceStatus
    userIds?: InstanceUpdateuserIdsInput | string[]
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    client?: ClientUpdateOneRequiredWithoutInstancesNestedInput
    levels?: LevelUpdateManyWithoutInstanceNestedInput
    currencies?: CurrencyUpdateManyWithoutInstanceNestedInput
    accounts?: AccountUpdateManyWithoutInstanceNestedInput
    models?: ModelUpdateManyWithoutInstanceNestedInput
    dimensions?: DimensionUpdateManyWithoutInstanceNestedInput
    dimensionValues?: DimensionValueUpdateManyWithoutInstanceNestedInput
    levelAttributes?: LevelAttributeUpdateManyWithoutInstanceNestedInput
    dimensionValueAttributes?: DimensionValueAttributeUpdateManyWithoutInstanceNestedInput
    accountAttributes?: AccountAttributeUpdateManyWithoutInstanceNestedInput
    levelAttValues?: LevelAttributeValueUpdateManyWithoutInstanceNestedInput
    accountAttValues?: AccountAttributeValueUpdateManyWithoutInstanceNestedInput
    dimensionValueAttributeValues?: DimensionValueAttributeValueUpdateManyWithoutInstanceNestedInput
    modelData?: ModelDataUpdateManyWithoutInstanceNestedInput
    modelDataCalculations?: ModelDataCalculationsUpdateManyWithoutInstanceNestedInput
    modelAccounts?: ModelAccountStructureUpdateManyWithoutInstanceNestedInput
    tables?: TableUpdateManyWithoutInstanceNestedInput
    tableData?: TableDataUpdateManyWithoutInstanceNestedInput
  }

  export type InstanceUncheckedUpdateWithoutVersionsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnuminstanceStatusFieldUpdateOperationsInput | $Enums.instanceStatus
    userIds?: InstanceUpdateuserIdsInput | string[]
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    levels?: LevelUncheckedUpdateManyWithoutInstanceNestedInput
    currencies?: CurrencyUncheckedUpdateManyWithoutInstanceNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutInstanceNestedInput
    models?: ModelUncheckedUpdateManyWithoutInstanceNestedInput
    dimensions?: DimensionUncheckedUpdateManyWithoutInstanceNestedInput
    dimensionValues?: DimensionValueUncheckedUpdateManyWithoutInstanceNestedInput
    levelAttributes?: LevelAttributeUncheckedUpdateManyWithoutInstanceNestedInput
    dimensionValueAttributes?: DimensionValueAttributeUncheckedUpdateManyWithoutInstanceNestedInput
    accountAttributes?: AccountAttributeUncheckedUpdateManyWithoutInstanceNestedInput
    levelAttValues?: LevelAttributeValueUncheckedUpdateManyWithoutInstanceNestedInput
    accountAttValues?: AccountAttributeValueUncheckedUpdateManyWithoutInstanceNestedInput
    dimensionValueAttributeValues?: DimensionValueAttributeValueUncheckedUpdateManyWithoutInstanceNestedInput
    modelData?: ModelDataUncheckedUpdateManyWithoutInstanceNestedInput
    modelDataCalculations?: ModelDataCalculationsUncheckedUpdateManyWithoutInstanceNestedInput
    modelAccounts?: ModelAccountStructureUncheckedUpdateManyWithoutInstanceNestedInput
    tables?: TableUncheckedUpdateManyWithoutInstanceNestedInput
    tableData?: TableDataUncheckedUpdateManyWithoutInstanceNestedInput
  }

  export type ModelDataUpsertWithWhereUniqueWithoutVersionInput = {
    where: ModelDataWhereUniqueInput
    update: XOR<ModelDataUpdateWithoutVersionInput, ModelDataUncheckedUpdateWithoutVersionInput>
    create: XOR<ModelDataCreateWithoutVersionInput, ModelDataUncheckedCreateWithoutVersionInput>
  }

  export type ModelDataUpdateWithWhereUniqueWithoutVersionInput = {
    where: ModelDataWhereUniqueInput
    data: XOR<ModelDataUpdateWithoutVersionInput, ModelDataUncheckedUpdateWithoutVersionInput>
  }

  export type ModelDataUpdateManyWithWhereWithoutVersionInput = {
    where: ModelDataScalarWhereInput
    data: XOR<ModelDataUpdateManyMutationInput, ModelDataUncheckedUpdateManyWithoutVersionInput>
  }

  export type ModelDataCalculationsUpsertWithWhereUniqueWithoutVersionInput = {
    where: ModelDataCalculationsWhereUniqueInput
    update: XOR<ModelDataCalculationsUpdateWithoutVersionInput, ModelDataCalculationsUncheckedUpdateWithoutVersionInput>
    create: XOR<ModelDataCalculationsCreateWithoutVersionInput, ModelDataCalculationsUncheckedCreateWithoutVersionInput>
  }

  export type ModelDataCalculationsUpdateWithWhereUniqueWithoutVersionInput = {
    where: ModelDataCalculationsWhereUniqueInput
    data: XOR<ModelDataCalculationsUpdateWithoutVersionInput, ModelDataCalculationsUncheckedUpdateWithoutVersionInput>
  }

  export type ModelDataCalculationsUpdateManyWithWhereWithoutVersionInput = {
    where: ModelDataCalculationsScalarWhereInput
    data: XOR<ModelDataCalculationsUpdateManyMutationInput, ModelDataCalculationsUncheckedUpdateManyWithoutVersionInput>
  }

  export type CurrencyCreateWithoutCurrencyIsoCodeInput = {
    id?: string
    name: string
    code: string
    assignedLevels: number
    isDefault?: $Enums.YesNo
    clientId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    instance: InstanceCreateNestedOneWithoutCurrenciesInput
    levels?: LevelCreateNestedManyWithoutCurrencyInput
    defaults?: ConfigCreateNestedManyWithoutDefaultCurrencyInput
  }

  export type CurrencyUncheckedCreateWithoutCurrencyIsoCodeInput = {
    id?: string
    name: string
    code: string
    assignedLevels: number
    isDefault?: $Enums.YesNo
    clientId: string
    instanceId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    levels?: LevelUncheckedCreateNestedManyWithoutCurrencyInput
    defaults?: ConfigUncheckedCreateNestedManyWithoutDefaultCurrencyInput
  }

  export type CurrencyCreateOrConnectWithoutCurrencyIsoCodeInput = {
    where: CurrencyWhereUniqueInput
    create: XOR<CurrencyCreateWithoutCurrencyIsoCodeInput, CurrencyUncheckedCreateWithoutCurrencyIsoCodeInput>
  }

  export type CurrencyCreateManyCurrencyIsoCodeInputEnvelope = {
    data: CurrencyCreateManyCurrencyIsoCodeInput | CurrencyCreateManyCurrencyIsoCodeInput[]
  }

  export type ConfigCreateWithoutDefaultIsoCurrencyInput = {
    id?: string
    defaultTopLevelName: string
    defaultTopLevelDescription: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    defaultCurrency: CurrencyCreateNestedOneWithoutDefaultsInput
  }

  export type ConfigUncheckedCreateWithoutDefaultIsoCurrencyInput = {
    id?: string
    defaultCurrencyId: string
    defaultTopLevelName: string
    defaultTopLevelDescription: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ConfigCreateOrConnectWithoutDefaultIsoCurrencyInput = {
    where: ConfigWhereUniqueInput
    create: XOR<ConfigCreateWithoutDefaultIsoCurrencyInput, ConfigUncheckedCreateWithoutDefaultIsoCurrencyInput>
  }

  export type ConfigCreateManyDefaultIsoCurrencyInputEnvelope = {
    data: ConfigCreateManyDefaultIsoCurrencyInput | ConfigCreateManyDefaultIsoCurrencyInput[]
  }

  export type CurrencyUpsertWithWhereUniqueWithoutCurrencyIsoCodeInput = {
    where: CurrencyWhereUniqueInput
    update: XOR<CurrencyUpdateWithoutCurrencyIsoCodeInput, CurrencyUncheckedUpdateWithoutCurrencyIsoCodeInput>
    create: XOR<CurrencyCreateWithoutCurrencyIsoCodeInput, CurrencyUncheckedCreateWithoutCurrencyIsoCodeInput>
  }

  export type CurrencyUpdateWithWhereUniqueWithoutCurrencyIsoCodeInput = {
    where: CurrencyWhereUniqueInput
    data: XOR<CurrencyUpdateWithoutCurrencyIsoCodeInput, CurrencyUncheckedUpdateWithoutCurrencyIsoCodeInput>
  }

  export type CurrencyUpdateManyWithWhereWithoutCurrencyIsoCodeInput = {
    where: CurrencyScalarWhereInput
    data: XOR<CurrencyUpdateManyMutationInput, CurrencyUncheckedUpdateManyWithoutCurrencyIsoCodeInput>
  }

  export type ConfigUpsertWithWhereUniqueWithoutDefaultIsoCurrencyInput = {
    where: ConfigWhereUniqueInput
    update: XOR<ConfigUpdateWithoutDefaultIsoCurrencyInput, ConfigUncheckedUpdateWithoutDefaultIsoCurrencyInput>
    create: XOR<ConfigCreateWithoutDefaultIsoCurrencyInput, ConfigUncheckedCreateWithoutDefaultIsoCurrencyInput>
  }

  export type ConfigUpdateWithWhereUniqueWithoutDefaultIsoCurrencyInput = {
    where: ConfigWhereUniqueInput
    data: XOR<ConfigUpdateWithoutDefaultIsoCurrencyInput, ConfigUncheckedUpdateWithoutDefaultIsoCurrencyInput>
  }

  export type ConfigUpdateManyWithWhereWithoutDefaultIsoCurrencyInput = {
    where: ConfigScalarWhereInput
    data: XOR<ConfigUpdateManyMutationInput, ConfigUncheckedUpdateManyWithoutDefaultIsoCurrencyInput>
  }

  export type ConfigScalarWhereInput = {
    AND?: ConfigScalarWhereInput | ConfigScalarWhereInput[]
    OR?: ConfigScalarWhereInput[]
    NOT?: ConfigScalarWhereInput | ConfigScalarWhereInput[]
    id?: StringFilter<"Config"> | string
    defaultIsoCurrencyId?: StringFilter<"Config"> | string
    defaultCurrencyId?: StringFilter<"Config"> | string
    defaultTopLevelName?: StringFilter<"Config"> | string
    defaultTopLevelDescription?: StringFilter<"Config"> | string
    createdAt?: DateTimeNullableFilter<"Config"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Config"> | Date | string | null
  }

  export type CurrencyIsoCodeCreateWithoutCurrenciesInput = {
    id?: string
    code: string
    name: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    config?: ConfigCreateNestedManyWithoutDefaultIsoCurrencyInput
  }

  export type CurrencyIsoCodeUncheckedCreateWithoutCurrenciesInput = {
    id?: string
    code: string
    name: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    config?: ConfigUncheckedCreateNestedManyWithoutDefaultIsoCurrencyInput
  }

  export type CurrencyIsoCodeCreateOrConnectWithoutCurrenciesInput = {
    where: CurrencyIsoCodeWhereUniqueInput
    create: XOR<CurrencyIsoCodeCreateWithoutCurrenciesInput, CurrencyIsoCodeUncheckedCreateWithoutCurrenciesInput>
  }

  export type InstanceCreateWithoutCurrenciesInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    status?: $Enums.instanceStatus
    userIds?: InstanceCreateuserIdsInput | string[]
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    client: ClientCreateNestedOneWithoutInstancesInput
    levels?: LevelCreateNestedManyWithoutInstanceInput
    versions?: VersionCreateNestedManyWithoutInstanceInput
    accounts?: AccountCreateNestedManyWithoutInstanceInput
    models?: ModelCreateNestedManyWithoutInstanceInput
    dimensions?: DimensionCreateNestedManyWithoutInstanceInput
    dimensionValues?: DimensionValueCreateNestedManyWithoutInstanceInput
    levelAttributes?: LevelAttributeCreateNestedManyWithoutInstanceInput
    dimensionValueAttributes?: DimensionValueAttributeCreateNestedManyWithoutInstanceInput
    accountAttributes?: AccountAttributeCreateNestedManyWithoutInstanceInput
    levelAttValues?: LevelAttributeValueCreateNestedManyWithoutInstanceInput
    accountAttValues?: AccountAttributeValueCreateNestedManyWithoutInstanceInput
    dimensionValueAttributeValues?: DimensionValueAttributeValueCreateNestedManyWithoutInstanceInput
    modelData?: ModelDataCreateNestedManyWithoutInstanceInput
    modelDataCalculations?: ModelDataCalculationsCreateNestedManyWithoutInstanceInput
    modelAccounts?: ModelAccountStructureCreateNestedManyWithoutInstanceInput
    tables?: TableCreateNestedManyWithoutInstanceInput
    tableData?: TableDataCreateNestedManyWithoutInstanceInput
  }

  export type InstanceUncheckedCreateWithoutCurrenciesInput = {
    id?: string
    code: string
    name: string
    clientId: string
    description?: string | null
    status?: $Enums.instanceStatus
    userIds?: InstanceCreateuserIdsInput | string[]
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    levels?: LevelUncheckedCreateNestedManyWithoutInstanceInput
    versions?: VersionUncheckedCreateNestedManyWithoutInstanceInput
    accounts?: AccountUncheckedCreateNestedManyWithoutInstanceInput
    models?: ModelUncheckedCreateNestedManyWithoutInstanceInput
    dimensions?: DimensionUncheckedCreateNestedManyWithoutInstanceInput
    dimensionValues?: DimensionValueUncheckedCreateNestedManyWithoutInstanceInput
    levelAttributes?: LevelAttributeUncheckedCreateNestedManyWithoutInstanceInput
    dimensionValueAttributes?: DimensionValueAttributeUncheckedCreateNestedManyWithoutInstanceInput
    accountAttributes?: AccountAttributeUncheckedCreateNestedManyWithoutInstanceInput
    levelAttValues?: LevelAttributeValueUncheckedCreateNestedManyWithoutInstanceInput
    accountAttValues?: AccountAttributeValueUncheckedCreateNestedManyWithoutInstanceInput
    dimensionValueAttributeValues?: DimensionValueAttributeValueUncheckedCreateNestedManyWithoutInstanceInput
    modelData?: ModelDataUncheckedCreateNestedManyWithoutInstanceInput
    modelDataCalculations?: ModelDataCalculationsUncheckedCreateNestedManyWithoutInstanceInput
    modelAccounts?: ModelAccountStructureUncheckedCreateNestedManyWithoutInstanceInput
    tables?: TableUncheckedCreateNestedManyWithoutInstanceInput
    tableData?: TableDataUncheckedCreateNestedManyWithoutInstanceInput
  }

  export type InstanceCreateOrConnectWithoutCurrenciesInput = {
    where: InstanceWhereUniqueInput
    create: XOR<InstanceCreateWithoutCurrenciesInput, InstanceUncheckedCreateWithoutCurrenciesInput>
  }

  export type LevelCreateWithoutCurrencyInput = {
    id?: string
    code: string
    name: string
    isRoot?: boolean
    description?: string | null
    clientId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    AttributeAndValues?: LevelAttributeAndValueCreateNestedManyWithoutLevelInput
    parent?: LevelCreateNestedOneWithoutChildLevelsInput
    instance: InstanceCreateNestedOneWithoutLevelsInput
    childLevels?: LevelCreateNestedManyWithoutParentInput
    modelData?: ModelDataCreateNestedManyWithoutLevelInput
    modeldataCalculations?: ModelDataCalculationsCreateNestedManyWithoutLevelInput
  }

  export type LevelUncheckedCreateWithoutCurrencyInput = {
    id?: string
    code: string
    name: string
    isRoot?: boolean
    description?: string | null
    parentId?: string | null
    clientId: string
    instanceId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    AttributeAndValues?: LevelAttributeAndValueUncheckedCreateNestedManyWithoutLevelInput
    childLevels?: LevelUncheckedCreateNestedManyWithoutParentInput
    modelData?: ModelDataUncheckedCreateNestedManyWithoutLevelInput
    modeldataCalculations?: ModelDataCalculationsUncheckedCreateNestedManyWithoutLevelInput
  }

  export type LevelCreateOrConnectWithoutCurrencyInput = {
    where: LevelWhereUniqueInput
    create: XOR<LevelCreateWithoutCurrencyInput, LevelUncheckedCreateWithoutCurrencyInput>
  }

  export type LevelCreateManyCurrencyInputEnvelope = {
    data: LevelCreateManyCurrencyInput | LevelCreateManyCurrencyInput[]
  }

  export type ConfigCreateWithoutDefaultCurrencyInput = {
    id?: string
    defaultTopLevelName: string
    defaultTopLevelDescription: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    defaultIsoCurrency: CurrencyIsoCodeCreateNestedOneWithoutConfigInput
  }

  export type ConfigUncheckedCreateWithoutDefaultCurrencyInput = {
    id?: string
    defaultIsoCurrencyId: string
    defaultTopLevelName: string
    defaultTopLevelDescription: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ConfigCreateOrConnectWithoutDefaultCurrencyInput = {
    where: ConfigWhereUniqueInput
    create: XOR<ConfigCreateWithoutDefaultCurrencyInput, ConfigUncheckedCreateWithoutDefaultCurrencyInput>
  }

  export type ConfigCreateManyDefaultCurrencyInputEnvelope = {
    data: ConfigCreateManyDefaultCurrencyInput | ConfigCreateManyDefaultCurrencyInput[]
  }

  export type CurrencyIsoCodeUpsertWithoutCurrenciesInput = {
    update: XOR<CurrencyIsoCodeUpdateWithoutCurrenciesInput, CurrencyIsoCodeUncheckedUpdateWithoutCurrenciesInput>
    create: XOR<CurrencyIsoCodeCreateWithoutCurrenciesInput, CurrencyIsoCodeUncheckedCreateWithoutCurrenciesInput>
    where?: CurrencyIsoCodeWhereInput
  }

  export type CurrencyIsoCodeUpdateToOneWithWhereWithoutCurrenciesInput = {
    where?: CurrencyIsoCodeWhereInput
    data: XOR<CurrencyIsoCodeUpdateWithoutCurrenciesInput, CurrencyIsoCodeUncheckedUpdateWithoutCurrenciesInput>
  }

  export type CurrencyIsoCodeUpdateWithoutCurrenciesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    config?: ConfigUpdateManyWithoutDefaultIsoCurrencyNestedInput
  }

  export type CurrencyIsoCodeUncheckedUpdateWithoutCurrenciesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    config?: ConfigUncheckedUpdateManyWithoutDefaultIsoCurrencyNestedInput
  }

  export type InstanceUpsertWithoutCurrenciesInput = {
    update: XOR<InstanceUpdateWithoutCurrenciesInput, InstanceUncheckedUpdateWithoutCurrenciesInput>
    create: XOR<InstanceCreateWithoutCurrenciesInput, InstanceUncheckedCreateWithoutCurrenciesInput>
    where?: InstanceWhereInput
  }

  export type InstanceUpdateToOneWithWhereWithoutCurrenciesInput = {
    where?: InstanceWhereInput
    data: XOR<InstanceUpdateWithoutCurrenciesInput, InstanceUncheckedUpdateWithoutCurrenciesInput>
  }

  export type InstanceUpdateWithoutCurrenciesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnuminstanceStatusFieldUpdateOperationsInput | $Enums.instanceStatus
    userIds?: InstanceUpdateuserIdsInput | string[]
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    client?: ClientUpdateOneRequiredWithoutInstancesNestedInput
    levels?: LevelUpdateManyWithoutInstanceNestedInput
    versions?: VersionUpdateManyWithoutInstanceNestedInput
    accounts?: AccountUpdateManyWithoutInstanceNestedInput
    models?: ModelUpdateManyWithoutInstanceNestedInput
    dimensions?: DimensionUpdateManyWithoutInstanceNestedInput
    dimensionValues?: DimensionValueUpdateManyWithoutInstanceNestedInput
    levelAttributes?: LevelAttributeUpdateManyWithoutInstanceNestedInput
    dimensionValueAttributes?: DimensionValueAttributeUpdateManyWithoutInstanceNestedInput
    accountAttributes?: AccountAttributeUpdateManyWithoutInstanceNestedInput
    levelAttValues?: LevelAttributeValueUpdateManyWithoutInstanceNestedInput
    accountAttValues?: AccountAttributeValueUpdateManyWithoutInstanceNestedInput
    dimensionValueAttributeValues?: DimensionValueAttributeValueUpdateManyWithoutInstanceNestedInput
    modelData?: ModelDataUpdateManyWithoutInstanceNestedInput
    modelDataCalculations?: ModelDataCalculationsUpdateManyWithoutInstanceNestedInput
    modelAccounts?: ModelAccountStructureUpdateManyWithoutInstanceNestedInput
    tables?: TableUpdateManyWithoutInstanceNestedInput
    tableData?: TableDataUpdateManyWithoutInstanceNestedInput
  }

  export type InstanceUncheckedUpdateWithoutCurrenciesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnuminstanceStatusFieldUpdateOperationsInput | $Enums.instanceStatus
    userIds?: InstanceUpdateuserIdsInput | string[]
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    levels?: LevelUncheckedUpdateManyWithoutInstanceNestedInput
    versions?: VersionUncheckedUpdateManyWithoutInstanceNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutInstanceNestedInput
    models?: ModelUncheckedUpdateManyWithoutInstanceNestedInput
    dimensions?: DimensionUncheckedUpdateManyWithoutInstanceNestedInput
    dimensionValues?: DimensionValueUncheckedUpdateManyWithoutInstanceNestedInput
    levelAttributes?: LevelAttributeUncheckedUpdateManyWithoutInstanceNestedInput
    dimensionValueAttributes?: DimensionValueAttributeUncheckedUpdateManyWithoutInstanceNestedInput
    accountAttributes?: AccountAttributeUncheckedUpdateManyWithoutInstanceNestedInput
    levelAttValues?: LevelAttributeValueUncheckedUpdateManyWithoutInstanceNestedInput
    accountAttValues?: AccountAttributeValueUncheckedUpdateManyWithoutInstanceNestedInput
    dimensionValueAttributeValues?: DimensionValueAttributeValueUncheckedUpdateManyWithoutInstanceNestedInput
    modelData?: ModelDataUncheckedUpdateManyWithoutInstanceNestedInput
    modelDataCalculations?: ModelDataCalculationsUncheckedUpdateManyWithoutInstanceNestedInput
    modelAccounts?: ModelAccountStructureUncheckedUpdateManyWithoutInstanceNestedInput
    tables?: TableUncheckedUpdateManyWithoutInstanceNestedInput
    tableData?: TableDataUncheckedUpdateManyWithoutInstanceNestedInput
  }

  export type LevelUpsertWithWhereUniqueWithoutCurrencyInput = {
    where: LevelWhereUniqueInput
    update: XOR<LevelUpdateWithoutCurrencyInput, LevelUncheckedUpdateWithoutCurrencyInput>
    create: XOR<LevelCreateWithoutCurrencyInput, LevelUncheckedCreateWithoutCurrencyInput>
  }

  export type LevelUpdateWithWhereUniqueWithoutCurrencyInput = {
    where: LevelWhereUniqueInput
    data: XOR<LevelUpdateWithoutCurrencyInput, LevelUncheckedUpdateWithoutCurrencyInput>
  }

  export type LevelUpdateManyWithWhereWithoutCurrencyInput = {
    where: LevelScalarWhereInput
    data: XOR<LevelUpdateManyMutationInput, LevelUncheckedUpdateManyWithoutCurrencyInput>
  }

  export type ConfigUpsertWithWhereUniqueWithoutDefaultCurrencyInput = {
    where: ConfigWhereUniqueInput
    update: XOR<ConfigUpdateWithoutDefaultCurrencyInput, ConfigUncheckedUpdateWithoutDefaultCurrencyInput>
    create: XOR<ConfigCreateWithoutDefaultCurrencyInput, ConfigUncheckedCreateWithoutDefaultCurrencyInput>
  }

  export type ConfigUpdateWithWhereUniqueWithoutDefaultCurrencyInput = {
    where: ConfigWhereUniqueInput
    data: XOR<ConfigUpdateWithoutDefaultCurrencyInput, ConfigUncheckedUpdateWithoutDefaultCurrencyInput>
  }

  export type ConfigUpdateManyWithWhereWithoutDefaultCurrencyInput = {
    where: ConfigScalarWhereInput
    data: XOR<ConfigUpdateManyMutationInput, ConfigUncheckedUpdateManyWithoutDefaultCurrencyInput>
  }

  export type LevelAttributeAndValueCreateWithoutLevelInput = {
    id?: string
    clientId: string
    instanceId: string
    levelCode: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    attribute?: LevelAttributeCreateNestedOneWithoutLevelAttributeAndValuesInput
    attributeValue?: LevelAttributeValueCreateNestedOneWithoutLevelAttributeAndValuesInput
  }

  export type LevelAttributeAndValueUncheckedCreateWithoutLevelInput = {
    id?: string
    clientId: string
    instanceId: string
    attributeId: string
    attributeValueId: string
    levelCode: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type LevelAttributeAndValueCreateOrConnectWithoutLevelInput = {
    where: LevelAttributeAndValueWhereUniqueInput
    create: XOR<LevelAttributeAndValueCreateWithoutLevelInput, LevelAttributeAndValueUncheckedCreateWithoutLevelInput>
  }

  export type LevelAttributeAndValueCreateManyLevelInputEnvelope = {
    data: LevelAttributeAndValueCreateManyLevelInput | LevelAttributeAndValueCreateManyLevelInput[]
  }

  export type LevelCreateWithoutChildLevelsInput = {
    id?: string
    code: string
    name: string
    isRoot?: boolean
    description?: string | null
    clientId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    AttributeAndValues?: LevelAttributeAndValueCreateNestedManyWithoutLevelInput
    parent?: LevelCreateNestedOneWithoutChildLevelsInput
    instance: InstanceCreateNestedOneWithoutLevelsInput
    currency: CurrencyCreateNestedOneWithoutLevelsInput
    modelData?: ModelDataCreateNestedManyWithoutLevelInput
    modeldataCalculations?: ModelDataCalculationsCreateNestedManyWithoutLevelInput
  }

  export type LevelUncheckedCreateWithoutChildLevelsInput = {
    id?: string
    code: string
    name: string
    isRoot?: boolean
    description?: string | null
    parentId?: string | null
    clientId: string
    instanceId: string
    currencyId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    AttributeAndValues?: LevelAttributeAndValueUncheckedCreateNestedManyWithoutLevelInput
    modelData?: ModelDataUncheckedCreateNestedManyWithoutLevelInput
    modeldataCalculations?: ModelDataCalculationsUncheckedCreateNestedManyWithoutLevelInput
  }

  export type LevelCreateOrConnectWithoutChildLevelsInput = {
    where: LevelWhereUniqueInput
    create: XOR<LevelCreateWithoutChildLevelsInput, LevelUncheckedCreateWithoutChildLevelsInput>
  }

  export type InstanceCreateWithoutLevelsInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    status?: $Enums.instanceStatus
    userIds?: InstanceCreateuserIdsInput | string[]
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    client: ClientCreateNestedOneWithoutInstancesInput
    versions?: VersionCreateNestedManyWithoutInstanceInput
    currencies?: CurrencyCreateNestedManyWithoutInstanceInput
    accounts?: AccountCreateNestedManyWithoutInstanceInput
    models?: ModelCreateNestedManyWithoutInstanceInput
    dimensions?: DimensionCreateNestedManyWithoutInstanceInput
    dimensionValues?: DimensionValueCreateNestedManyWithoutInstanceInput
    levelAttributes?: LevelAttributeCreateNestedManyWithoutInstanceInput
    dimensionValueAttributes?: DimensionValueAttributeCreateNestedManyWithoutInstanceInput
    accountAttributes?: AccountAttributeCreateNestedManyWithoutInstanceInput
    levelAttValues?: LevelAttributeValueCreateNestedManyWithoutInstanceInput
    accountAttValues?: AccountAttributeValueCreateNestedManyWithoutInstanceInput
    dimensionValueAttributeValues?: DimensionValueAttributeValueCreateNestedManyWithoutInstanceInput
    modelData?: ModelDataCreateNestedManyWithoutInstanceInput
    modelDataCalculations?: ModelDataCalculationsCreateNestedManyWithoutInstanceInput
    modelAccounts?: ModelAccountStructureCreateNestedManyWithoutInstanceInput
    tables?: TableCreateNestedManyWithoutInstanceInput
    tableData?: TableDataCreateNestedManyWithoutInstanceInput
  }

  export type InstanceUncheckedCreateWithoutLevelsInput = {
    id?: string
    code: string
    name: string
    clientId: string
    description?: string | null
    status?: $Enums.instanceStatus
    userIds?: InstanceCreateuserIdsInput | string[]
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    versions?: VersionUncheckedCreateNestedManyWithoutInstanceInput
    currencies?: CurrencyUncheckedCreateNestedManyWithoutInstanceInput
    accounts?: AccountUncheckedCreateNestedManyWithoutInstanceInput
    models?: ModelUncheckedCreateNestedManyWithoutInstanceInput
    dimensions?: DimensionUncheckedCreateNestedManyWithoutInstanceInput
    dimensionValues?: DimensionValueUncheckedCreateNestedManyWithoutInstanceInput
    levelAttributes?: LevelAttributeUncheckedCreateNestedManyWithoutInstanceInput
    dimensionValueAttributes?: DimensionValueAttributeUncheckedCreateNestedManyWithoutInstanceInput
    accountAttributes?: AccountAttributeUncheckedCreateNestedManyWithoutInstanceInput
    levelAttValues?: LevelAttributeValueUncheckedCreateNestedManyWithoutInstanceInput
    accountAttValues?: AccountAttributeValueUncheckedCreateNestedManyWithoutInstanceInput
    dimensionValueAttributeValues?: DimensionValueAttributeValueUncheckedCreateNestedManyWithoutInstanceInput
    modelData?: ModelDataUncheckedCreateNestedManyWithoutInstanceInput
    modelDataCalculations?: ModelDataCalculationsUncheckedCreateNestedManyWithoutInstanceInput
    modelAccounts?: ModelAccountStructureUncheckedCreateNestedManyWithoutInstanceInput
    tables?: TableUncheckedCreateNestedManyWithoutInstanceInput
    tableData?: TableDataUncheckedCreateNestedManyWithoutInstanceInput
  }

  export type InstanceCreateOrConnectWithoutLevelsInput = {
    where: InstanceWhereUniqueInput
    create: XOR<InstanceCreateWithoutLevelsInput, InstanceUncheckedCreateWithoutLevelsInput>
  }

  export type CurrencyCreateWithoutLevelsInput = {
    id?: string
    name: string
    code: string
    assignedLevels: number
    isDefault?: $Enums.YesNo
    clientId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    currencyIsoCode: CurrencyIsoCodeCreateNestedOneWithoutCurrenciesInput
    instance: InstanceCreateNestedOneWithoutCurrenciesInput
    defaults?: ConfigCreateNestedManyWithoutDefaultCurrencyInput
  }

  export type CurrencyUncheckedCreateWithoutLevelsInput = {
    id?: string
    name: string
    code: string
    currencyIsoCodeId: string
    assignedLevels: number
    isDefault?: $Enums.YesNo
    clientId: string
    instanceId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    defaults?: ConfigUncheckedCreateNestedManyWithoutDefaultCurrencyInput
  }

  export type CurrencyCreateOrConnectWithoutLevelsInput = {
    where: CurrencyWhereUniqueInput
    create: XOR<CurrencyCreateWithoutLevelsInput, CurrencyUncheckedCreateWithoutLevelsInput>
  }

  export type LevelCreateWithoutParentInput = {
    id?: string
    code: string
    name: string
    isRoot?: boolean
    description?: string | null
    clientId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    AttributeAndValues?: LevelAttributeAndValueCreateNestedManyWithoutLevelInput
    instance: InstanceCreateNestedOneWithoutLevelsInput
    currency: CurrencyCreateNestedOneWithoutLevelsInput
    childLevels?: LevelCreateNestedManyWithoutParentInput
    modelData?: ModelDataCreateNestedManyWithoutLevelInput
    modeldataCalculations?: ModelDataCalculationsCreateNestedManyWithoutLevelInput
  }

  export type LevelUncheckedCreateWithoutParentInput = {
    id?: string
    code: string
    name: string
    isRoot?: boolean
    description?: string | null
    clientId: string
    instanceId: string
    currencyId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    AttributeAndValues?: LevelAttributeAndValueUncheckedCreateNestedManyWithoutLevelInput
    childLevels?: LevelUncheckedCreateNestedManyWithoutParentInput
    modelData?: ModelDataUncheckedCreateNestedManyWithoutLevelInput
    modeldataCalculations?: ModelDataCalculationsUncheckedCreateNestedManyWithoutLevelInput
  }

  export type LevelCreateOrConnectWithoutParentInput = {
    where: LevelWhereUniqueInput
    create: XOR<LevelCreateWithoutParentInput, LevelUncheckedCreateWithoutParentInput>
  }

  export type LevelCreateManyParentInputEnvelope = {
    data: LevelCreateManyParentInput | LevelCreateManyParentInput[]
  }

  export type ModelDataCreateWithoutLevelInput = {
    id?: string
    clientId: string
    dimensionality?: XOR<ModelDataDimensionalityListCreateEnvelopeInput, ModelDataDimensionalityCreateInput> | ModelDataDimensionalityCreateInput[]
    timespan: InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    model: ModelCreateNestedOneWithoutModelDataInput
    account: AccountCreateNestedOneWithoutModelDataInput
    version: VersionCreateNestedOneWithoutModelDataInput
    instance: InstanceCreateNestedOneWithoutModelDataInput
  }

  export type ModelDataUncheckedCreateWithoutLevelInput = {
    id?: string
    clientId: string
    instanceId: string
    modelId: string
    versionId: string
    accountId: string
    dimensionality?: XOR<ModelDataDimensionalityListCreateEnvelopeInput, ModelDataDimensionalityCreateInput> | ModelDataDimensionalityCreateInput[]
    timespan: InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ModelDataCreateOrConnectWithoutLevelInput = {
    where: ModelDataWhereUniqueInput
    create: XOR<ModelDataCreateWithoutLevelInput, ModelDataUncheckedCreateWithoutLevelInput>
  }

  export type ModelDataCreateManyLevelInputEnvelope = {
    data: ModelDataCreateManyLevelInput | ModelDataCreateManyLevelInput[]
  }

  export type ModelDataCalculationsCreateWithoutLevelInput = {
    id?: string
    clientId: string
    calculations: InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    model: ModelCreateNestedOneWithoutModelDataCalculationsInput
    account: AccountCreateNestedOneWithoutModeldataCalculationsInput
    version: VersionCreateNestedOneWithoutModelDataCalculationsInput
    instance: InstanceCreateNestedOneWithoutModelDataCalculationsInput
    modelAccount: ModelAccountStructureCreateNestedOneWithoutModeldataCalculationsInput
  }

  export type ModelDataCalculationsUncheckedCreateWithoutLevelInput = {
    id?: string
    clientId: string
    instanceId: string
    modelId: string
    versionId: string
    accountId: string
    modelAccountId: string
    calculations: InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ModelDataCalculationsCreateOrConnectWithoutLevelInput = {
    where: ModelDataCalculationsWhereUniqueInput
    create: XOR<ModelDataCalculationsCreateWithoutLevelInput, ModelDataCalculationsUncheckedCreateWithoutLevelInput>
  }

  export type ModelDataCalculationsCreateManyLevelInputEnvelope = {
    data: ModelDataCalculationsCreateManyLevelInput | ModelDataCalculationsCreateManyLevelInput[]
  }

  export type LevelAttributeAndValueUpsertWithWhereUniqueWithoutLevelInput = {
    where: LevelAttributeAndValueWhereUniqueInput
    update: XOR<LevelAttributeAndValueUpdateWithoutLevelInput, LevelAttributeAndValueUncheckedUpdateWithoutLevelInput>
    create: XOR<LevelAttributeAndValueCreateWithoutLevelInput, LevelAttributeAndValueUncheckedCreateWithoutLevelInput>
  }

  export type LevelAttributeAndValueUpdateWithWhereUniqueWithoutLevelInput = {
    where: LevelAttributeAndValueWhereUniqueInput
    data: XOR<LevelAttributeAndValueUpdateWithoutLevelInput, LevelAttributeAndValueUncheckedUpdateWithoutLevelInput>
  }

  export type LevelAttributeAndValueUpdateManyWithWhereWithoutLevelInput = {
    where: LevelAttributeAndValueScalarWhereInput
    data: XOR<LevelAttributeAndValueUpdateManyMutationInput, LevelAttributeAndValueUncheckedUpdateManyWithoutLevelInput>
  }

  export type LevelAttributeAndValueScalarWhereInput = {
    AND?: LevelAttributeAndValueScalarWhereInput | LevelAttributeAndValueScalarWhereInput[]
    OR?: LevelAttributeAndValueScalarWhereInput[]
    NOT?: LevelAttributeAndValueScalarWhereInput | LevelAttributeAndValueScalarWhereInput[]
    id?: StringFilter<"LevelAttributeAndValue"> | string
    levelId?: StringFilter<"LevelAttributeAndValue"> | string
    clientId?: StringFilter<"LevelAttributeAndValue"> | string
    instanceId?: StringFilter<"LevelAttributeAndValue"> | string
    attributeId?: StringFilter<"LevelAttributeAndValue"> | string
    attributeValueId?: StringFilter<"LevelAttributeAndValue"> | string
    levelCode?: StringFilter<"LevelAttributeAndValue"> | string
    createdAt?: DateTimeNullableFilter<"LevelAttributeAndValue"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"LevelAttributeAndValue"> | Date | string | null
  }

  export type LevelUpsertWithoutChildLevelsInput = {
    update: XOR<LevelUpdateWithoutChildLevelsInput, LevelUncheckedUpdateWithoutChildLevelsInput>
    create: XOR<LevelCreateWithoutChildLevelsInput, LevelUncheckedCreateWithoutChildLevelsInput>
    where?: LevelWhereInput
  }

  export type LevelUpdateToOneWithWhereWithoutChildLevelsInput = {
    where?: LevelWhereInput
    data: XOR<LevelUpdateWithoutChildLevelsInput, LevelUncheckedUpdateWithoutChildLevelsInput>
  }

  export type LevelUpdateWithoutChildLevelsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isRoot?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    AttributeAndValues?: LevelAttributeAndValueUpdateManyWithoutLevelNestedInput
    parent?: LevelUpdateOneWithoutChildLevelsNestedInput
    instance?: InstanceUpdateOneRequiredWithoutLevelsNestedInput
    currency?: CurrencyUpdateOneRequiredWithoutLevelsNestedInput
    modelData?: ModelDataUpdateManyWithoutLevelNestedInput
    modeldataCalculations?: ModelDataCalculationsUpdateManyWithoutLevelNestedInput
  }

  export type LevelUncheckedUpdateWithoutChildLevelsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isRoot?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    currencyId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    AttributeAndValues?: LevelAttributeAndValueUncheckedUpdateManyWithoutLevelNestedInput
    modelData?: ModelDataUncheckedUpdateManyWithoutLevelNestedInput
    modeldataCalculations?: ModelDataCalculationsUncheckedUpdateManyWithoutLevelNestedInput
  }

  export type InstanceUpsertWithoutLevelsInput = {
    update: XOR<InstanceUpdateWithoutLevelsInput, InstanceUncheckedUpdateWithoutLevelsInput>
    create: XOR<InstanceCreateWithoutLevelsInput, InstanceUncheckedCreateWithoutLevelsInput>
    where?: InstanceWhereInput
  }

  export type InstanceUpdateToOneWithWhereWithoutLevelsInput = {
    where?: InstanceWhereInput
    data: XOR<InstanceUpdateWithoutLevelsInput, InstanceUncheckedUpdateWithoutLevelsInput>
  }

  export type InstanceUpdateWithoutLevelsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnuminstanceStatusFieldUpdateOperationsInput | $Enums.instanceStatus
    userIds?: InstanceUpdateuserIdsInput | string[]
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    client?: ClientUpdateOneRequiredWithoutInstancesNestedInput
    versions?: VersionUpdateManyWithoutInstanceNestedInput
    currencies?: CurrencyUpdateManyWithoutInstanceNestedInput
    accounts?: AccountUpdateManyWithoutInstanceNestedInput
    models?: ModelUpdateManyWithoutInstanceNestedInput
    dimensions?: DimensionUpdateManyWithoutInstanceNestedInput
    dimensionValues?: DimensionValueUpdateManyWithoutInstanceNestedInput
    levelAttributes?: LevelAttributeUpdateManyWithoutInstanceNestedInput
    dimensionValueAttributes?: DimensionValueAttributeUpdateManyWithoutInstanceNestedInput
    accountAttributes?: AccountAttributeUpdateManyWithoutInstanceNestedInput
    levelAttValues?: LevelAttributeValueUpdateManyWithoutInstanceNestedInput
    accountAttValues?: AccountAttributeValueUpdateManyWithoutInstanceNestedInput
    dimensionValueAttributeValues?: DimensionValueAttributeValueUpdateManyWithoutInstanceNestedInput
    modelData?: ModelDataUpdateManyWithoutInstanceNestedInput
    modelDataCalculations?: ModelDataCalculationsUpdateManyWithoutInstanceNestedInput
    modelAccounts?: ModelAccountStructureUpdateManyWithoutInstanceNestedInput
    tables?: TableUpdateManyWithoutInstanceNestedInput
    tableData?: TableDataUpdateManyWithoutInstanceNestedInput
  }

  export type InstanceUncheckedUpdateWithoutLevelsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnuminstanceStatusFieldUpdateOperationsInput | $Enums.instanceStatus
    userIds?: InstanceUpdateuserIdsInput | string[]
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    versions?: VersionUncheckedUpdateManyWithoutInstanceNestedInput
    currencies?: CurrencyUncheckedUpdateManyWithoutInstanceNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutInstanceNestedInput
    models?: ModelUncheckedUpdateManyWithoutInstanceNestedInput
    dimensions?: DimensionUncheckedUpdateManyWithoutInstanceNestedInput
    dimensionValues?: DimensionValueUncheckedUpdateManyWithoutInstanceNestedInput
    levelAttributes?: LevelAttributeUncheckedUpdateManyWithoutInstanceNestedInput
    dimensionValueAttributes?: DimensionValueAttributeUncheckedUpdateManyWithoutInstanceNestedInput
    accountAttributes?: AccountAttributeUncheckedUpdateManyWithoutInstanceNestedInput
    levelAttValues?: LevelAttributeValueUncheckedUpdateManyWithoutInstanceNestedInput
    accountAttValues?: AccountAttributeValueUncheckedUpdateManyWithoutInstanceNestedInput
    dimensionValueAttributeValues?: DimensionValueAttributeValueUncheckedUpdateManyWithoutInstanceNestedInput
    modelData?: ModelDataUncheckedUpdateManyWithoutInstanceNestedInput
    modelDataCalculations?: ModelDataCalculationsUncheckedUpdateManyWithoutInstanceNestedInput
    modelAccounts?: ModelAccountStructureUncheckedUpdateManyWithoutInstanceNestedInput
    tables?: TableUncheckedUpdateManyWithoutInstanceNestedInput
    tableData?: TableDataUncheckedUpdateManyWithoutInstanceNestedInput
  }

  export type CurrencyUpsertWithoutLevelsInput = {
    update: XOR<CurrencyUpdateWithoutLevelsInput, CurrencyUncheckedUpdateWithoutLevelsInput>
    create: XOR<CurrencyCreateWithoutLevelsInput, CurrencyUncheckedCreateWithoutLevelsInput>
    where?: CurrencyWhereInput
  }

  export type CurrencyUpdateToOneWithWhereWithoutLevelsInput = {
    where?: CurrencyWhereInput
    data: XOR<CurrencyUpdateWithoutLevelsInput, CurrencyUncheckedUpdateWithoutLevelsInput>
  }

  export type CurrencyUpdateWithoutLevelsInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    assignedLevels?: IntFieldUpdateOperationsInput | number
    isDefault?: EnumYesNoFieldUpdateOperationsInput | $Enums.YesNo
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currencyIsoCode?: CurrencyIsoCodeUpdateOneRequiredWithoutCurrenciesNestedInput
    instance?: InstanceUpdateOneRequiredWithoutCurrenciesNestedInput
    defaults?: ConfigUpdateManyWithoutDefaultCurrencyNestedInput
  }

  export type CurrencyUncheckedUpdateWithoutLevelsInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    currencyIsoCodeId?: StringFieldUpdateOperationsInput | string
    assignedLevels?: IntFieldUpdateOperationsInput | number
    isDefault?: EnumYesNoFieldUpdateOperationsInput | $Enums.YesNo
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    defaults?: ConfigUncheckedUpdateManyWithoutDefaultCurrencyNestedInput
  }

  export type LevelUpsertWithWhereUniqueWithoutParentInput = {
    where: LevelWhereUniqueInput
    update: XOR<LevelUpdateWithoutParentInput, LevelUncheckedUpdateWithoutParentInput>
    create: XOR<LevelCreateWithoutParentInput, LevelUncheckedCreateWithoutParentInput>
  }

  export type LevelUpdateWithWhereUniqueWithoutParentInput = {
    where: LevelWhereUniqueInput
    data: XOR<LevelUpdateWithoutParentInput, LevelUncheckedUpdateWithoutParentInput>
  }

  export type LevelUpdateManyWithWhereWithoutParentInput = {
    where: LevelScalarWhereInput
    data: XOR<LevelUpdateManyMutationInput, LevelUncheckedUpdateManyWithoutParentInput>
  }

  export type ModelDataUpsertWithWhereUniqueWithoutLevelInput = {
    where: ModelDataWhereUniqueInput
    update: XOR<ModelDataUpdateWithoutLevelInput, ModelDataUncheckedUpdateWithoutLevelInput>
    create: XOR<ModelDataCreateWithoutLevelInput, ModelDataUncheckedCreateWithoutLevelInput>
  }

  export type ModelDataUpdateWithWhereUniqueWithoutLevelInput = {
    where: ModelDataWhereUniqueInput
    data: XOR<ModelDataUpdateWithoutLevelInput, ModelDataUncheckedUpdateWithoutLevelInput>
  }

  export type ModelDataUpdateManyWithWhereWithoutLevelInput = {
    where: ModelDataScalarWhereInput
    data: XOR<ModelDataUpdateManyMutationInput, ModelDataUncheckedUpdateManyWithoutLevelInput>
  }

  export type ModelDataCalculationsUpsertWithWhereUniqueWithoutLevelInput = {
    where: ModelDataCalculationsWhereUniqueInput
    update: XOR<ModelDataCalculationsUpdateWithoutLevelInput, ModelDataCalculationsUncheckedUpdateWithoutLevelInput>
    create: XOR<ModelDataCalculationsCreateWithoutLevelInput, ModelDataCalculationsUncheckedCreateWithoutLevelInput>
  }

  export type ModelDataCalculationsUpdateWithWhereUniqueWithoutLevelInput = {
    where: ModelDataCalculationsWhereUniqueInput
    data: XOR<ModelDataCalculationsUpdateWithoutLevelInput, ModelDataCalculationsUncheckedUpdateWithoutLevelInput>
  }

  export type ModelDataCalculationsUpdateManyWithWhereWithoutLevelInput = {
    where: ModelDataCalculationsScalarWhereInput
    data: XOR<ModelDataCalculationsUpdateManyMutationInput, ModelDataCalculationsUncheckedUpdateManyWithoutLevelInput>
  }

  export type LevelCreateWithoutAttributeAndValuesInput = {
    id?: string
    code: string
    name: string
    isRoot?: boolean
    description?: string | null
    clientId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    parent?: LevelCreateNestedOneWithoutChildLevelsInput
    instance: InstanceCreateNestedOneWithoutLevelsInput
    currency: CurrencyCreateNestedOneWithoutLevelsInput
    childLevels?: LevelCreateNestedManyWithoutParentInput
    modelData?: ModelDataCreateNestedManyWithoutLevelInput
    modeldataCalculations?: ModelDataCalculationsCreateNestedManyWithoutLevelInput
  }

  export type LevelUncheckedCreateWithoutAttributeAndValuesInput = {
    id?: string
    code: string
    name: string
    isRoot?: boolean
    description?: string | null
    parentId?: string | null
    clientId: string
    instanceId: string
    currencyId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    childLevels?: LevelUncheckedCreateNestedManyWithoutParentInput
    modelData?: ModelDataUncheckedCreateNestedManyWithoutLevelInput
    modeldataCalculations?: ModelDataCalculationsUncheckedCreateNestedManyWithoutLevelInput
  }

  export type LevelCreateOrConnectWithoutAttributeAndValuesInput = {
    where: LevelWhereUniqueInput
    create: XOR<LevelCreateWithoutAttributeAndValuesInput, LevelUncheckedCreateWithoutAttributeAndValuesInput>
  }

  export type LevelAttributeCreateWithoutLevelAttributeAndValuesInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    clientId: string
    attributeValueDefault?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    instance: InstanceCreateNestedOneWithoutLevelAttributesInput
    levelAttributeValues?: LevelAttributeValueCreateNestedManyWithoutLevelAttributeInput
  }

  export type LevelAttributeUncheckedCreateWithoutLevelAttributeAndValuesInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    clientId: string
    instanceId: string
    attributeValueDefault?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    levelAttributeValues?: LevelAttributeValueUncheckedCreateNestedManyWithoutLevelAttributeInput
  }

  export type LevelAttributeCreateOrConnectWithoutLevelAttributeAndValuesInput = {
    where: LevelAttributeWhereUniqueInput
    create: XOR<LevelAttributeCreateWithoutLevelAttributeAndValuesInput, LevelAttributeUncheckedCreateWithoutLevelAttributeAndValuesInput>
  }

  export type LevelAttributeValueCreateWithoutLevelAttributeAndValuesInput = {
    id?: string
    code: string
    name: string
    clientId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    parent?: LevelAttributeValueCreateNestedOneWithoutChildAttributeValuesInput
    childAttributeValues?: LevelAttributeValueCreateNestedManyWithoutParentInput
    instance: InstanceCreateNestedOneWithoutLevelAttValuesInput
    levelAttribute: LevelAttributeCreateNestedOneWithoutLevelAttributeValuesInput
  }

  export type LevelAttributeValueUncheckedCreateWithoutLevelAttributeAndValuesInput = {
    id?: string
    code: string
    name: string
    attributeId: string
    parentId?: string | null
    clientId: string
    instanceId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    childAttributeValues?: LevelAttributeValueUncheckedCreateNestedManyWithoutParentInput
  }

  export type LevelAttributeValueCreateOrConnectWithoutLevelAttributeAndValuesInput = {
    where: LevelAttributeValueWhereUniqueInput
    create: XOR<LevelAttributeValueCreateWithoutLevelAttributeAndValuesInput, LevelAttributeValueUncheckedCreateWithoutLevelAttributeAndValuesInput>
  }

  export type LevelUpsertWithoutAttributeAndValuesInput = {
    update: XOR<LevelUpdateWithoutAttributeAndValuesInput, LevelUncheckedUpdateWithoutAttributeAndValuesInput>
    create: XOR<LevelCreateWithoutAttributeAndValuesInput, LevelUncheckedCreateWithoutAttributeAndValuesInput>
    where?: LevelWhereInput
  }

  export type LevelUpdateToOneWithWhereWithoutAttributeAndValuesInput = {
    where?: LevelWhereInput
    data: XOR<LevelUpdateWithoutAttributeAndValuesInput, LevelUncheckedUpdateWithoutAttributeAndValuesInput>
  }

  export type LevelUpdateWithoutAttributeAndValuesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isRoot?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parent?: LevelUpdateOneWithoutChildLevelsNestedInput
    instance?: InstanceUpdateOneRequiredWithoutLevelsNestedInput
    currency?: CurrencyUpdateOneRequiredWithoutLevelsNestedInput
    childLevels?: LevelUpdateManyWithoutParentNestedInput
    modelData?: ModelDataUpdateManyWithoutLevelNestedInput
    modeldataCalculations?: ModelDataCalculationsUpdateManyWithoutLevelNestedInput
  }

  export type LevelUncheckedUpdateWithoutAttributeAndValuesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isRoot?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    currencyId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    childLevels?: LevelUncheckedUpdateManyWithoutParentNestedInput
    modelData?: ModelDataUncheckedUpdateManyWithoutLevelNestedInput
    modeldataCalculations?: ModelDataCalculationsUncheckedUpdateManyWithoutLevelNestedInput
  }

  export type LevelAttributeUpsertWithoutLevelAttributeAndValuesInput = {
    update: XOR<LevelAttributeUpdateWithoutLevelAttributeAndValuesInput, LevelAttributeUncheckedUpdateWithoutLevelAttributeAndValuesInput>
    create: XOR<LevelAttributeCreateWithoutLevelAttributeAndValuesInput, LevelAttributeUncheckedCreateWithoutLevelAttributeAndValuesInput>
    where?: LevelAttributeWhereInput
  }

  export type LevelAttributeUpdateToOneWithWhereWithoutLevelAttributeAndValuesInput = {
    where?: LevelAttributeWhereInput
    data: XOR<LevelAttributeUpdateWithoutLevelAttributeAndValuesInput, LevelAttributeUncheckedUpdateWithoutLevelAttributeAndValuesInput>
  }

  export type LevelAttributeUpdateWithoutLevelAttributeAndValuesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    attributeValueDefault?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instance?: InstanceUpdateOneRequiredWithoutLevelAttributesNestedInput
    levelAttributeValues?: LevelAttributeValueUpdateManyWithoutLevelAttributeNestedInput
  }

  export type LevelAttributeUncheckedUpdateWithoutLevelAttributeAndValuesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    attributeValueDefault?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    levelAttributeValues?: LevelAttributeValueUncheckedUpdateManyWithoutLevelAttributeNestedInput
  }

  export type LevelAttributeValueUpsertWithoutLevelAttributeAndValuesInput = {
    update: XOR<LevelAttributeValueUpdateWithoutLevelAttributeAndValuesInput, LevelAttributeValueUncheckedUpdateWithoutLevelAttributeAndValuesInput>
    create: XOR<LevelAttributeValueCreateWithoutLevelAttributeAndValuesInput, LevelAttributeValueUncheckedCreateWithoutLevelAttributeAndValuesInput>
    where?: LevelAttributeValueWhereInput
  }

  export type LevelAttributeValueUpdateToOneWithWhereWithoutLevelAttributeAndValuesInput = {
    where?: LevelAttributeValueWhereInput
    data: XOR<LevelAttributeValueUpdateWithoutLevelAttributeAndValuesInput, LevelAttributeValueUncheckedUpdateWithoutLevelAttributeAndValuesInput>
  }

  export type LevelAttributeValueUpdateWithoutLevelAttributeAndValuesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parent?: LevelAttributeValueUpdateOneWithoutChildAttributeValuesNestedInput
    childAttributeValues?: LevelAttributeValueUpdateManyWithoutParentNestedInput
    instance?: InstanceUpdateOneRequiredWithoutLevelAttValuesNestedInput
    levelAttribute?: LevelAttributeUpdateOneRequiredWithoutLevelAttributeValuesNestedInput
  }

  export type LevelAttributeValueUncheckedUpdateWithoutLevelAttributeAndValuesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    attributeId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    childAttributeValues?: LevelAttributeValueUncheckedUpdateManyWithoutParentNestedInput
  }

  export type LevelAttributeValueCreateWithoutChildAttributeValuesInput = {
    id?: string
    code: string
    name: string
    clientId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    parent?: LevelAttributeValueCreateNestedOneWithoutChildAttributeValuesInput
    instance: InstanceCreateNestedOneWithoutLevelAttValuesInput
    levelAttribute: LevelAttributeCreateNestedOneWithoutLevelAttributeValuesInput
    levelAttributeAndValues?: LevelAttributeAndValueCreateNestedManyWithoutAttributeValueInput
  }

  export type LevelAttributeValueUncheckedCreateWithoutChildAttributeValuesInput = {
    id?: string
    code: string
    name: string
    attributeId: string
    parentId?: string | null
    clientId: string
    instanceId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    levelAttributeAndValues?: LevelAttributeAndValueUncheckedCreateNestedManyWithoutAttributeValueInput
  }

  export type LevelAttributeValueCreateOrConnectWithoutChildAttributeValuesInput = {
    where: LevelAttributeValueWhereUniqueInput
    create: XOR<LevelAttributeValueCreateWithoutChildAttributeValuesInput, LevelAttributeValueUncheckedCreateWithoutChildAttributeValuesInput>
  }

  export type LevelAttributeValueCreateWithoutParentInput = {
    id?: string
    code: string
    name: string
    clientId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    childAttributeValues?: LevelAttributeValueCreateNestedManyWithoutParentInput
    instance: InstanceCreateNestedOneWithoutLevelAttValuesInput
    levelAttribute: LevelAttributeCreateNestedOneWithoutLevelAttributeValuesInput
    levelAttributeAndValues?: LevelAttributeAndValueCreateNestedManyWithoutAttributeValueInput
  }

  export type LevelAttributeValueUncheckedCreateWithoutParentInput = {
    id?: string
    code: string
    name: string
    attributeId: string
    clientId: string
    instanceId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    childAttributeValues?: LevelAttributeValueUncheckedCreateNestedManyWithoutParentInput
    levelAttributeAndValues?: LevelAttributeAndValueUncheckedCreateNestedManyWithoutAttributeValueInput
  }

  export type LevelAttributeValueCreateOrConnectWithoutParentInput = {
    where: LevelAttributeValueWhereUniqueInput
    create: XOR<LevelAttributeValueCreateWithoutParentInput, LevelAttributeValueUncheckedCreateWithoutParentInput>
  }

  export type LevelAttributeValueCreateManyParentInputEnvelope = {
    data: LevelAttributeValueCreateManyParentInput | LevelAttributeValueCreateManyParentInput[]
  }

  export type InstanceCreateWithoutLevelAttValuesInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    status?: $Enums.instanceStatus
    userIds?: InstanceCreateuserIdsInput | string[]
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    client: ClientCreateNestedOneWithoutInstancesInput
    levels?: LevelCreateNestedManyWithoutInstanceInput
    versions?: VersionCreateNestedManyWithoutInstanceInput
    currencies?: CurrencyCreateNestedManyWithoutInstanceInput
    accounts?: AccountCreateNestedManyWithoutInstanceInput
    models?: ModelCreateNestedManyWithoutInstanceInput
    dimensions?: DimensionCreateNestedManyWithoutInstanceInput
    dimensionValues?: DimensionValueCreateNestedManyWithoutInstanceInput
    levelAttributes?: LevelAttributeCreateNestedManyWithoutInstanceInput
    dimensionValueAttributes?: DimensionValueAttributeCreateNestedManyWithoutInstanceInput
    accountAttributes?: AccountAttributeCreateNestedManyWithoutInstanceInput
    accountAttValues?: AccountAttributeValueCreateNestedManyWithoutInstanceInput
    dimensionValueAttributeValues?: DimensionValueAttributeValueCreateNestedManyWithoutInstanceInput
    modelData?: ModelDataCreateNestedManyWithoutInstanceInput
    modelDataCalculations?: ModelDataCalculationsCreateNestedManyWithoutInstanceInput
    modelAccounts?: ModelAccountStructureCreateNestedManyWithoutInstanceInput
    tables?: TableCreateNestedManyWithoutInstanceInput
    tableData?: TableDataCreateNestedManyWithoutInstanceInput
  }

  export type InstanceUncheckedCreateWithoutLevelAttValuesInput = {
    id?: string
    code: string
    name: string
    clientId: string
    description?: string | null
    status?: $Enums.instanceStatus
    userIds?: InstanceCreateuserIdsInput | string[]
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    levels?: LevelUncheckedCreateNestedManyWithoutInstanceInput
    versions?: VersionUncheckedCreateNestedManyWithoutInstanceInput
    currencies?: CurrencyUncheckedCreateNestedManyWithoutInstanceInput
    accounts?: AccountUncheckedCreateNestedManyWithoutInstanceInput
    models?: ModelUncheckedCreateNestedManyWithoutInstanceInput
    dimensions?: DimensionUncheckedCreateNestedManyWithoutInstanceInput
    dimensionValues?: DimensionValueUncheckedCreateNestedManyWithoutInstanceInput
    levelAttributes?: LevelAttributeUncheckedCreateNestedManyWithoutInstanceInput
    dimensionValueAttributes?: DimensionValueAttributeUncheckedCreateNestedManyWithoutInstanceInput
    accountAttributes?: AccountAttributeUncheckedCreateNestedManyWithoutInstanceInput
    accountAttValues?: AccountAttributeValueUncheckedCreateNestedManyWithoutInstanceInput
    dimensionValueAttributeValues?: DimensionValueAttributeValueUncheckedCreateNestedManyWithoutInstanceInput
    modelData?: ModelDataUncheckedCreateNestedManyWithoutInstanceInput
    modelDataCalculations?: ModelDataCalculationsUncheckedCreateNestedManyWithoutInstanceInput
    modelAccounts?: ModelAccountStructureUncheckedCreateNestedManyWithoutInstanceInput
    tables?: TableUncheckedCreateNestedManyWithoutInstanceInput
    tableData?: TableDataUncheckedCreateNestedManyWithoutInstanceInput
  }

  export type InstanceCreateOrConnectWithoutLevelAttValuesInput = {
    where: InstanceWhereUniqueInput
    create: XOR<InstanceCreateWithoutLevelAttValuesInput, InstanceUncheckedCreateWithoutLevelAttValuesInput>
  }

  export type LevelAttributeCreateWithoutLevelAttributeValuesInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    clientId: string
    attributeValueDefault?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    instance: InstanceCreateNestedOneWithoutLevelAttributesInput
    levelAttributeAndValues?: LevelAttributeAndValueCreateNestedManyWithoutAttributeInput
  }

  export type LevelAttributeUncheckedCreateWithoutLevelAttributeValuesInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    clientId: string
    instanceId: string
    attributeValueDefault?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    levelAttributeAndValues?: LevelAttributeAndValueUncheckedCreateNestedManyWithoutAttributeInput
  }

  export type LevelAttributeCreateOrConnectWithoutLevelAttributeValuesInput = {
    where: LevelAttributeWhereUniqueInput
    create: XOR<LevelAttributeCreateWithoutLevelAttributeValuesInput, LevelAttributeUncheckedCreateWithoutLevelAttributeValuesInput>
  }

  export type LevelAttributeAndValueCreateWithoutAttributeValueInput = {
    id?: string
    clientId: string
    instanceId: string
    levelCode: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    level?: LevelCreateNestedOneWithoutAttributeAndValuesInput
    attribute?: LevelAttributeCreateNestedOneWithoutLevelAttributeAndValuesInput
  }

  export type LevelAttributeAndValueUncheckedCreateWithoutAttributeValueInput = {
    id?: string
    levelId: string
    clientId: string
    instanceId: string
    attributeId: string
    levelCode: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type LevelAttributeAndValueCreateOrConnectWithoutAttributeValueInput = {
    where: LevelAttributeAndValueWhereUniqueInput
    create: XOR<LevelAttributeAndValueCreateWithoutAttributeValueInput, LevelAttributeAndValueUncheckedCreateWithoutAttributeValueInput>
  }

  export type LevelAttributeAndValueCreateManyAttributeValueInputEnvelope = {
    data: LevelAttributeAndValueCreateManyAttributeValueInput | LevelAttributeAndValueCreateManyAttributeValueInput[]
  }

  export type LevelAttributeValueUpsertWithoutChildAttributeValuesInput = {
    update: XOR<LevelAttributeValueUpdateWithoutChildAttributeValuesInput, LevelAttributeValueUncheckedUpdateWithoutChildAttributeValuesInput>
    create: XOR<LevelAttributeValueCreateWithoutChildAttributeValuesInput, LevelAttributeValueUncheckedCreateWithoutChildAttributeValuesInput>
    where?: LevelAttributeValueWhereInput
  }

  export type LevelAttributeValueUpdateToOneWithWhereWithoutChildAttributeValuesInput = {
    where?: LevelAttributeValueWhereInput
    data: XOR<LevelAttributeValueUpdateWithoutChildAttributeValuesInput, LevelAttributeValueUncheckedUpdateWithoutChildAttributeValuesInput>
  }

  export type LevelAttributeValueUpdateWithoutChildAttributeValuesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parent?: LevelAttributeValueUpdateOneWithoutChildAttributeValuesNestedInput
    instance?: InstanceUpdateOneRequiredWithoutLevelAttValuesNestedInput
    levelAttribute?: LevelAttributeUpdateOneRequiredWithoutLevelAttributeValuesNestedInput
    levelAttributeAndValues?: LevelAttributeAndValueUpdateManyWithoutAttributeValueNestedInput
  }

  export type LevelAttributeValueUncheckedUpdateWithoutChildAttributeValuesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    attributeId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    levelAttributeAndValues?: LevelAttributeAndValueUncheckedUpdateManyWithoutAttributeValueNestedInput
  }

  export type LevelAttributeValueUpsertWithWhereUniqueWithoutParentInput = {
    where: LevelAttributeValueWhereUniqueInput
    update: XOR<LevelAttributeValueUpdateWithoutParentInput, LevelAttributeValueUncheckedUpdateWithoutParentInput>
    create: XOR<LevelAttributeValueCreateWithoutParentInput, LevelAttributeValueUncheckedCreateWithoutParentInput>
  }

  export type LevelAttributeValueUpdateWithWhereUniqueWithoutParentInput = {
    where: LevelAttributeValueWhereUniqueInput
    data: XOR<LevelAttributeValueUpdateWithoutParentInput, LevelAttributeValueUncheckedUpdateWithoutParentInput>
  }

  export type LevelAttributeValueUpdateManyWithWhereWithoutParentInput = {
    where: LevelAttributeValueScalarWhereInput
    data: XOR<LevelAttributeValueUpdateManyMutationInput, LevelAttributeValueUncheckedUpdateManyWithoutParentInput>
  }

  export type InstanceUpsertWithoutLevelAttValuesInput = {
    update: XOR<InstanceUpdateWithoutLevelAttValuesInput, InstanceUncheckedUpdateWithoutLevelAttValuesInput>
    create: XOR<InstanceCreateWithoutLevelAttValuesInput, InstanceUncheckedCreateWithoutLevelAttValuesInput>
    where?: InstanceWhereInput
  }

  export type InstanceUpdateToOneWithWhereWithoutLevelAttValuesInput = {
    where?: InstanceWhereInput
    data: XOR<InstanceUpdateWithoutLevelAttValuesInput, InstanceUncheckedUpdateWithoutLevelAttValuesInput>
  }

  export type InstanceUpdateWithoutLevelAttValuesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnuminstanceStatusFieldUpdateOperationsInput | $Enums.instanceStatus
    userIds?: InstanceUpdateuserIdsInput | string[]
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    client?: ClientUpdateOneRequiredWithoutInstancesNestedInput
    levels?: LevelUpdateManyWithoutInstanceNestedInput
    versions?: VersionUpdateManyWithoutInstanceNestedInput
    currencies?: CurrencyUpdateManyWithoutInstanceNestedInput
    accounts?: AccountUpdateManyWithoutInstanceNestedInput
    models?: ModelUpdateManyWithoutInstanceNestedInput
    dimensions?: DimensionUpdateManyWithoutInstanceNestedInput
    dimensionValues?: DimensionValueUpdateManyWithoutInstanceNestedInput
    levelAttributes?: LevelAttributeUpdateManyWithoutInstanceNestedInput
    dimensionValueAttributes?: DimensionValueAttributeUpdateManyWithoutInstanceNestedInput
    accountAttributes?: AccountAttributeUpdateManyWithoutInstanceNestedInput
    accountAttValues?: AccountAttributeValueUpdateManyWithoutInstanceNestedInput
    dimensionValueAttributeValues?: DimensionValueAttributeValueUpdateManyWithoutInstanceNestedInput
    modelData?: ModelDataUpdateManyWithoutInstanceNestedInput
    modelDataCalculations?: ModelDataCalculationsUpdateManyWithoutInstanceNestedInput
    modelAccounts?: ModelAccountStructureUpdateManyWithoutInstanceNestedInput
    tables?: TableUpdateManyWithoutInstanceNestedInput
    tableData?: TableDataUpdateManyWithoutInstanceNestedInput
  }

  export type InstanceUncheckedUpdateWithoutLevelAttValuesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnuminstanceStatusFieldUpdateOperationsInput | $Enums.instanceStatus
    userIds?: InstanceUpdateuserIdsInput | string[]
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    levels?: LevelUncheckedUpdateManyWithoutInstanceNestedInput
    versions?: VersionUncheckedUpdateManyWithoutInstanceNestedInput
    currencies?: CurrencyUncheckedUpdateManyWithoutInstanceNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutInstanceNestedInput
    models?: ModelUncheckedUpdateManyWithoutInstanceNestedInput
    dimensions?: DimensionUncheckedUpdateManyWithoutInstanceNestedInput
    dimensionValues?: DimensionValueUncheckedUpdateManyWithoutInstanceNestedInput
    levelAttributes?: LevelAttributeUncheckedUpdateManyWithoutInstanceNestedInput
    dimensionValueAttributes?: DimensionValueAttributeUncheckedUpdateManyWithoutInstanceNestedInput
    accountAttributes?: AccountAttributeUncheckedUpdateManyWithoutInstanceNestedInput
    accountAttValues?: AccountAttributeValueUncheckedUpdateManyWithoutInstanceNestedInput
    dimensionValueAttributeValues?: DimensionValueAttributeValueUncheckedUpdateManyWithoutInstanceNestedInput
    modelData?: ModelDataUncheckedUpdateManyWithoutInstanceNestedInput
    modelDataCalculations?: ModelDataCalculationsUncheckedUpdateManyWithoutInstanceNestedInput
    modelAccounts?: ModelAccountStructureUncheckedUpdateManyWithoutInstanceNestedInput
    tables?: TableUncheckedUpdateManyWithoutInstanceNestedInput
    tableData?: TableDataUncheckedUpdateManyWithoutInstanceNestedInput
  }

  export type LevelAttributeUpsertWithoutLevelAttributeValuesInput = {
    update: XOR<LevelAttributeUpdateWithoutLevelAttributeValuesInput, LevelAttributeUncheckedUpdateWithoutLevelAttributeValuesInput>
    create: XOR<LevelAttributeCreateWithoutLevelAttributeValuesInput, LevelAttributeUncheckedCreateWithoutLevelAttributeValuesInput>
    where?: LevelAttributeWhereInput
  }

  export type LevelAttributeUpdateToOneWithWhereWithoutLevelAttributeValuesInput = {
    where?: LevelAttributeWhereInput
    data: XOR<LevelAttributeUpdateWithoutLevelAttributeValuesInput, LevelAttributeUncheckedUpdateWithoutLevelAttributeValuesInput>
  }

  export type LevelAttributeUpdateWithoutLevelAttributeValuesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    attributeValueDefault?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instance?: InstanceUpdateOneRequiredWithoutLevelAttributesNestedInput
    levelAttributeAndValues?: LevelAttributeAndValueUpdateManyWithoutAttributeNestedInput
  }

  export type LevelAttributeUncheckedUpdateWithoutLevelAttributeValuesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    attributeValueDefault?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    levelAttributeAndValues?: LevelAttributeAndValueUncheckedUpdateManyWithoutAttributeNestedInput
  }

  export type LevelAttributeAndValueUpsertWithWhereUniqueWithoutAttributeValueInput = {
    where: LevelAttributeAndValueWhereUniqueInput
    update: XOR<LevelAttributeAndValueUpdateWithoutAttributeValueInput, LevelAttributeAndValueUncheckedUpdateWithoutAttributeValueInput>
    create: XOR<LevelAttributeAndValueCreateWithoutAttributeValueInput, LevelAttributeAndValueUncheckedCreateWithoutAttributeValueInput>
  }

  export type LevelAttributeAndValueUpdateWithWhereUniqueWithoutAttributeValueInput = {
    where: LevelAttributeAndValueWhereUniqueInput
    data: XOR<LevelAttributeAndValueUpdateWithoutAttributeValueInput, LevelAttributeAndValueUncheckedUpdateWithoutAttributeValueInput>
  }

  export type LevelAttributeAndValueUpdateManyWithWhereWithoutAttributeValueInput = {
    where: LevelAttributeAndValueScalarWhereInput
    data: XOR<LevelAttributeAndValueUpdateManyMutationInput, LevelAttributeAndValueUncheckedUpdateManyWithoutAttributeValueInput>
  }

  export type InstanceCreateWithoutLevelAttributesInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    status?: $Enums.instanceStatus
    userIds?: InstanceCreateuserIdsInput | string[]
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    client: ClientCreateNestedOneWithoutInstancesInput
    levels?: LevelCreateNestedManyWithoutInstanceInput
    versions?: VersionCreateNestedManyWithoutInstanceInput
    currencies?: CurrencyCreateNestedManyWithoutInstanceInput
    accounts?: AccountCreateNestedManyWithoutInstanceInput
    models?: ModelCreateNestedManyWithoutInstanceInput
    dimensions?: DimensionCreateNestedManyWithoutInstanceInput
    dimensionValues?: DimensionValueCreateNestedManyWithoutInstanceInput
    dimensionValueAttributes?: DimensionValueAttributeCreateNestedManyWithoutInstanceInput
    accountAttributes?: AccountAttributeCreateNestedManyWithoutInstanceInput
    levelAttValues?: LevelAttributeValueCreateNestedManyWithoutInstanceInput
    accountAttValues?: AccountAttributeValueCreateNestedManyWithoutInstanceInput
    dimensionValueAttributeValues?: DimensionValueAttributeValueCreateNestedManyWithoutInstanceInput
    modelData?: ModelDataCreateNestedManyWithoutInstanceInput
    modelDataCalculations?: ModelDataCalculationsCreateNestedManyWithoutInstanceInput
    modelAccounts?: ModelAccountStructureCreateNestedManyWithoutInstanceInput
    tables?: TableCreateNestedManyWithoutInstanceInput
    tableData?: TableDataCreateNestedManyWithoutInstanceInput
  }

  export type InstanceUncheckedCreateWithoutLevelAttributesInput = {
    id?: string
    code: string
    name: string
    clientId: string
    description?: string | null
    status?: $Enums.instanceStatus
    userIds?: InstanceCreateuserIdsInput | string[]
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    levels?: LevelUncheckedCreateNestedManyWithoutInstanceInput
    versions?: VersionUncheckedCreateNestedManyWithoutInstanceInput
    currencies?: CurrencyUncheckedCreateNestedManyWithoutInstanceInput
    accounts?: AccountUncheckedCreateNestedManyWithoutInstanceInput
    models?: ModelUncheckedCreateNestedManyWithoutInstanceInput
    dimensions?: DimensionUncheckedCreateNestedManyWithoutInstanceInput
    dimensionValues?: DimensionValueUncheckedCreateNestedManyWithoutInstanceInput
    dimensionValueAttributes?: DimensionValueAttributeUncheckedCreateNestedManyWithoutInstanceInput
    accountAttributes?: AccountAttributeUncheckedCreateNestedManyWithoutInstanceInput
    levelAttValues?: LevelAttributeValueUncheckedCreateNestedManyWithoutInstanceInput
    accountAttValues?: AccountAttributeValueUncheckedCreateNestedManyWithoutInstanceInput
    dimensionValueAttributeValues?: DimensionValueAttributeValueUncheckedCreateNestedManyWithoutInstanceInput
    modelData?: ModelDataUncheckedCreateNestedManyWithoutInstanceInput
    modelDataCalculations?: ModelDataCalculationsUncheckedCreateNestedManyWithoutInstanceInput
    modelAccounts?: ModelAccountStructureUncheckedCreateNestedManyWithoutInstanceInput
    tables?: TableUncheckedCreateNestedManyWithoutInstanceInput
    tableData?: TableDataUncheckedCreateNestedManyWithoutInstanceInput
  }

  export type InstanceCreateOrConnectWithoutLevelAttributesInput = {
    where: InstanceWhereUniqueInput
    create: XOR<InstanceCreateWithoutLevelAttributesInput, InstanceUncheckedCreateWithoutLevelAttributesInput>
  }

  export type LevelAttributeValueCreateWithoutLevelAttributeInput = {
    id?: string
    code: string
    name: string
    clientId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    parent?: LevelAttributeValueCreateNestedOneWithoutChildAttributeValuesInput
    childAttributeValues?: LevelAttributeValueCreateNestedManyWithoutParentInput
    instance: InstanceCreateNestedOneWithoutLevelAttValuesInput
    levelAttributeAndValues?: LevelAttributeAndValueCreateNestedManyWithoutAttributeValueInput
  }

  export type LevelAttributeValueUncheckedCreateWithoutLevelAttributeInput = {
    id?: string
    code: string
    name: string
    parentId?: string | null
    clientId: string
    instanceId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    childAttributeValues?: LevelAttributeValueUncheckedCreateNestedManyWithoutParentInput
    levelAttributeAndValues?: LevelAttributeAndValueUncheckedCreateNestedManyWithoutAttributeValueInput
  }

  export type LevelAttributeValueCreateOrConnectWithoutLevelAttributeInput = {
    where: LevelAttributeValueWhereUniqueInput
    create: XOR<LevelAttributeValueCreateWithoutLevelAttributeInput, LevelAttributeValueUncheckedCreateWithoutLevelAttributeInput>
  }

  export type LevelAttributeValueCreateManyLevelAttributeInputEnvelope = {
    data: LevelAttributeValueCreateManyLevelAttributeInput | LevelAttributeValueCreateManyLevelAttributeInput[]
  }

  export type LevelAttributeAndValueCreateWithoutAttributeInput = {
    id?: string
    clientId: string
    instanceId: string
    levelCode: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    level?: LevelCreateNestedOneWithoutAttributeAndValuesInput
    attributeValue?: LevelAttributeValueCreateNestedOneWithoutLevelAttributeAndValuesInput
  }

  export type LevelAttributeAndValueUncheckedCreateWithoutAttributeInput = {
    id?: string
    levelId: string
    clientId: string
    instanceId: string
    attributeValueId: string
    levelCode: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type LevelAttributeAndValueCreateOrConnectWithoutAttributeInput = {
    where: LevelAttributeAndValueWhereUniqueInput
    create: XOR<LevelAttributeAndValueCreateWithoutAttributeInput, LevelAttributeAndValueUncheckedCreateWithoutAttributeInput>
  }

  export type LevelAttributeAndValueCreateManyAttributeInputEnvelope = {
    data: LevelAttributeAndValueCreateManyAttributeInput | LevelAttributeAndValueCreateManyAttributeInput[]
  }

  export type InstanceUpsertWithoutLevelAttributesInput = {
    update: XOR<InstanceUpdateWithoutLevelAttributesInput, InstanceUncheckedUpdateWithoutLevelAttributesInput>
    create: XOR<InstanceCreateWithoutLevelAttributesInput, InstanceUncheckedCreateWithoutLevelAttributesInput>
    where?: InstanceWhereInput
  }

  export type InstanceUpdateToOneWithWhereWithoutLevelAttributesInput = {
    where?: InstanceWhereInput
    data: XOR<InstanceUpdateWithoutLevelAttributesInput, InstanceUncheckedUpdateWithoutLevelAttributesInput>
  }

  export type InstanceUpdateWithoutLevelAttributesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnuminstanceStatusFieldUpdateOperationsInput | $Enums.instanceStatus
    userIds?: InstanceUpdateuserIdsInput | string[]
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    client?: ClientUpdateOneRequiredWithoutInstancesNestedInput
    levels?: LevelUpdateManyWithoutInstanceNestedInput
    versions?: VersionUpdateManyWithoutInstanceNestedInput
    currencies?: CurrencyUpdateManyWithoutInstanceNestedInput
    accounts?: AccountUpdateManyWithoutInstanceNestedInput
    models?: ModelUpdateManyWithoutInstanceNestedInput
    dimensions?: DimensionUpdateManyWithoutInstanceNestedInput
    dimensionValues?: DimensionValueUpdateManyWithoutInstanceNestedInput
    dimensionValueAttributes?: DimensionValueAttributeUpdateManyWithoutInstanceNestedInput
    accountAttributes?: AccountAttributeUpdateManyWithoutInstanceNestedInput
    levelAttValues?: LevelAttributeValueUpdateManyWithoutInstanceNestedInput
    accountAttValues?: AccountAttributeValueUpdateManyWithoutInstanceNestedInput
    dimensionValueAttributeValues?: DimensionValueAttributeValueUpdateManyWithoutInstanceNestedInput
    modelData?: ModelDataUpdateManyWithoutInstanceNestedInput
    modelDataCalculations?: ModelDataCalculationsUpdateManyWithoutInstanceNestedInput
    modelAccounts?: ModelAccountStructureUpdateManyWithoutInstanceNestedInput
    tables?: TableUpdateManyWithoutInstanceNestedInput
    tableData?: TableDataUpdateManyWithoutInstanceNestedInput
  }

  export type InstanceUncheckedUpdateWithoutLevelAttributesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnuminstanceStatusFieldUpdateOperationsInput | $Enums.instanceStatus
    userIds?: InstanceUpdateuserIdsInput | string[]
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    levels?: LevelUncheckedUpdateManyWithoutInstanceNestedInput
    versions?: VersionUncheckedUpdateManyWithoutInstanceNestedInput
    currencies?: CurrencyUncheckedUpdateManyWithoutInstanceNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutInstanceNestedInput
    models?: ModelUncheckedUpdateManyWithoutInstanceNestedInput
    dimensions?: DimensionUncheckedUpdateManyWithoutInstanceNestedInput
    dimensionValues?: DimensionValueUncheckedUpdateManyWithoutInstanceNestedInput
    dimensionValueAttributes?: DimensionValueAttributeUncheckedUpdateManyWithoutInstanceNestedInput
    accountAttributes?: AccountAttributeUncheckedUpdateManyWithoutInstanceNestedInput
    levelAttValues?: LevelAttributeValueUncheckedUpdateManyWithoutInstanceNestedInput
    accountAttValues?: AccountAttributeValueUncheckedUpdateManyWithoutInstanceNestedInput
    dimensionValueAttributeValues?: DimensionValueAttributeValueUncheckedUpdateManyWithoutInstanceNestedInput
    modelData?: ModelDataUncheckedUpdateManyWithoutInstanceNestedInput
    modelDataCalculations?: ModelDataCalculationsUncheckedUpdateManyWithoutInstanceNestedInput
    modelAccounts?: ModelAccountStructureUncheckedUpdateManyWithoutInstanceNestedInput
    tables?: TableUncheckedUpdateManyWithoutInstanceNestedInput
    tableData?: TableDataUncheckedUpdateManyWithoutInstanceNestedInput
  }

  export type LevelAttributeValueUpsertWithWhereUniqueWithoutLevelAttributeInput = {
    where: LevelAttributeValueWhereUniqueInput
    update: XOR<LevelAttributeValueUpdateWithoutLevelAttributeInput, LevelAttributeValueUncheckedUpdateWithoutLevelAttributeInput>
    create: XOR<LevelAttributeValueCreateWithoutLevelAttributeInput, LevelAttributeValueUncheckedCreateWithoutLevelAttributeInput>
  }

  export type LevelAttributeValueUpdateWithWhereUniqueWithoutLevelAttributeInput = {
    where: LevelAttributeValueWhereUniqueInput
    data: XOR<LevelAttributeValueUpdateWithoutLevelAttributeInput, LevelAttributeValueUncheckedUpdateWithoutLevelAttributeInput>
  }

  export type LevelAttributeValueUpdateManyWithWhereWithoutLevelAttributeInput = {
    where: LevelAttributeValueScalarWhereInput
    data: XOR<LevelAttributeValueUpdateManyMutationInput, LevelAttributeValueUncheckedUpdateManyWithoutLevelAttributeInput>
  }

  export type LevelAttributeAndValueUpsertWithWhereUniqueWithoutAttributeInput = {
    where: LevelAttributeAndValueWhereUniqueInput
    update: XOR<LevelAttributeAndValueUpdateWithoutAttributeInput, LevelAttributeAndValueUncheckedUpdateWithoutAttributeInput>
    create: XOR<LevelAttributeAndValueCreateWithoutAttributeInput, LevelAttributeAndValueUncheckedCreateWithoutAttributeInput>
  }

  export type LevelAttributeAndValueUpdateWithWhereUniqueWithoutAttributeInput = {
    where: LevelAttributeAndValueWhereUniqueInput
    data: XOR<LevelAttributeAndValueUpdateWithoutAttributeInput, LevelAttributeAndValueUncheckedUpdateWithoutAttributeInput>
  }

  export type LevelAttributeAndValueUpdateManyWithWhereWithoutAttributeInput = {
    where: LevelAttributeAndValueScalarWhereInput
    data: XOR<LevelAttributeAndValueUpdateManyMutationInput, LevelAttributeAndValueUncheckedUpdateManyWithoutAttributeInput>
  }

  export type InstanceCreateWithoutAccountAttributesInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    status?: $Enums.instanceStatus
    userIds?: InstanceCreateuserIdsInput | string[]
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    client: ClientCreateNestedOneWithoutInstancesInput
    levels?: LevelCreateNestedManyWithoutInstanceInput
    versions?: VersionCreateNestedManyWithoutInstanceInput
    currencies?: CurrencyCreateNestedManyWithoutInstanceInput
    accounts?: AccountCreateNestedManyWithoutInstanceInput
    models?: ModelCreateNestedManyWithoutInstanceInput
    dimensions?: DimensionCreateNestedManyWithoutInstanceInput
    dimensionValues?: DimensionValueCreateNestedManyWithoutInstanceInput
    levelAttributes?: LevelAttributeCreateNestedManyWithoutInstanceInput
    dimensionValueAttributes?: DimensionValueAttributeCreateNestedManyWithoutInstanceInput
    levelAttValues?: LevelAttributeValueCreateNestedManyWithoutInstanceInput
    accountAttValues?: AccountAttributeValueCreateNestedManyWithoutInstanceInput
    dimensionValueAttributeValues?: DimensionValueAttributeValueCreateNestedManyWithoutInstanceInput
    modelData?: ModelDataCreateNestedManyWithoutInstanceInput
    modelDataCalculations?: ModelDataCalculationsCreateNestedManyWithoutInstanceInput
    modelAccounts?: ModelAccountStructureCreateNestedManyWithoutInstanceInput
    tables?: TableCreateNestedManyWithoutInstanceInput
    tableData?: TableDataCreateNestedManyWithoutInstanceInput
  }

  export type InstanceUncheckedCreateWithoutAccountAttributesInput = {
    id?: string
    code: string
    name: string
    clientId: string
    description?: string | null
    status?: $Enums.instanceStatus
    userIds?: InstanceCreateuserIdsInput | string[]
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    levels?: LevelUncheckedCreateNestedManyWithoutInstanceInput
    versions?: VersionUncheckedCreateNestedManyWithoutInstanceInput
    currencies?: CurrencyUncheckedCreateNestedManyWithoutInstanceInput
    accounts?: AccountUncheckedCreateNestedManyWithoutInstanceInput
    models?: ModelUncheckedCreateNestedManyWithoutInstanceInput
    dimensions?: DimensionUncheckedCreateNestedManyWithoutInstanceInput
    dimensionValues?: DimensionValueUncheckedCreateNestedManyWithoutInstanceInput
    levelAttributes?: LevelAttributeUncheckedCreateNestedManyWithoutInstanceInput
    dimensionValueAttributes?: DimensionValueAttributeUncheckedCreateNestedManyWithoutInstanceInput
    levelAttValues?: LevelAttributeValueUncheckedCreateNestedManyWithoutInstanceInput
    accountAttValues?: AccountAttributeValueUncheckedCreateNestedManyWithoutInstanceInput
    dimensionValueAttributeValues?: DimensionValueAttributeValueUncheckedCreateNestedManyWithoutInstanceInput
    modelData?: ModelDataUncheckedCreateNestedManyWithoutInstanceInput
    modelDataCalculations?: ModelDataCalculationsUncheckedCreateNestedManyWithoutInstanceInput
    modelAccounts?: ModelAccountStructureUncheckedCreateNestedManyWithoutInstanceInput
    tables?: TableUncheckedCreateNestedManyWithoutInstanceInput
    tableData?: TableDataUncheckedCreateNestedManyWithoutInstanceInput
  }

  export type InstanceCreateOrConnectWithoutAccountAttributesInput = {
    where: InstanceWhereUniqueInput
    create: XOR<InstanceCreateWithoutAccountAttributesInput, InstanceUncheckedCreateWithoutAccountAttributesInput>
  }

  export type AccountAttributeValueCreateWithoutAccountAttributeInput = {
    id?: string
    code: string
    name: string
    clientId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    parent?: AccountAttributeValueCreateNestedOneWithoutChildAttributeValuesInput
    childAttributeValues?: AccountAttributeValueCreateNestedManyWithoutParentInput
    instance: InstanceCreateNestedOneWithoutAccountAttValuesInput
    AttributeAndValues?: AccountAttributeAndValueCreateNestedManyWithoutAttributeValueInput
  }

  export type AccountAttributeValueUncheckedCreateWithoutAccountAttributeInput = {
    id?: string
    code: string
    name: string
    parentId?: string | null
    clientId: string
    instanceId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    childAttributeValues?: AccountAttributeValueUncheckedCreateNestedManyWithoutParentInput
    AttributeAndValues?: AccountAttributeAndValueUncheckedCreateNestedManyWithoutAttributeValueInput
  }

  export type AccountAttributeValueCreateOrConnectWithoutAccountAttributeInput = {
    where: AccountAttributeValueWhereUniqueInput
    create: XOR<AccountAttributeValueCreateWithoutAccountAttributeInput, AccountAttributeValueUncheckedCreateWithoutAccountAttributeInput>
  }

  export type AccountAttributeValueCreateManyAccountAttributeInputEnvelope = {
    data: AccountAttributeValueCreateManyAccountAttributeInput | AccountAttributeValueCreateManyAccountAttributeInput[]
  }

  export type AccountAttributeAndValueCreateWithoutAttributeInput = {
    id?: string
    clientId: string
    instanceId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    account?: AccountCreateNestedOneWithoutAttributeAndValuesInput
    attributeValue?: AccountAttributeValueCreateNestedOneWithoutAttributeAndValuesInput
  }

  export type AccountAttributeAndValueUncheckedCreateWithoutAttributeInput = {
    id?: string
    accountId: string
    clientId: string
    instanceId: string
    attributeValueId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type AccountAttributeAndValueCreateOrConnectWithoutAttributeInput = {
    where: AccountAttributeAndValueWhereUniqueInput
    create: XOR<AccountAttributeAndValueCreateWithoutAttributeInput, AccountAttributeAndValueUncheckedCreateWithoutAttributeInput>
  }

  export type AccountAttributeAndValueCreateManyAttributeInputEnvelope = {
    data: AccountAttributeAndValueCreateManyAttributeInput | AccountAttributeAndValueCreateManyAttributeInput[]
  }

  export type InstanceUpsertWithoutAccountAttributesInput = {
    update: XOR<InstanceUpdateWithoutAccountAttributesInput, InstanceUncheckedUpdateWithoutAccountAttributesInput>
    create: XOR<InstanceCreateWithoutAccountAttributesInput, InstanceUncheckedCreateWithoutAccountAttributesInput>
    where?: InstanceWhereInput
  }

  export type InstanceUpdateToOneWithWhereWithoutAccountAttributesInput = {
    where?: InstanceWhereInput
    data: XOR<InstanceUpdateWithoutAccountAttributesInput, InstanceUncheckedUpdateWithoutAccountAttributesInput>
  }

  export type InstanceUpdateWithoutAccountAttributesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnuminstanceStatusFieldUpdateOperationsInput | $Enums.instanceStatus
    userIds?: InstanceUpdateuserIdsInput | string[]
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    client?: ClientUpdateOneRequiredWithoutInstancesNestedInput
    levels?: LevelUpdateManyWithoutInstanceNestedInput
    versions?: VersionUpdateManyWithoutInstanceNestedInput
    currencies?: CurrencyUpdateManyWithoutInstanceNestedInput
    accounts?: AccountUpdateManyWithoutInstanceNestedInput
    models?: ModelUpdateManyWithoutInstanceNestedInput
    dimensions?: DimensionUpdateManyWithoutInstanceNestedInput
    dimensionValues?: DimensionValueUpdateManyWithoutInstanceNestedInput
    levelAttributes?: LevelAttributeUpdateManyWithoutInstanceNestedInput
    dimensionValueAttributes?: DimensionValueAttributeUpdateManyWithoutInstanceNestedInput
    levelAttValues?: LevelAttributeValueUpdateManyWithoutInstanceNestedInput
    accountAttValues?: AccountAttributeValueUpdateManyWithoutInstanceNestedInput
    dimensionValueAttributeValues?: DimensionValueAttributeValueUpdateManyWithoutInstanceNestedInput
    modelData?: ModelDataUpdateManyWithoutInstanceNestedInput
    modelDataCalculations?: ModelDataCalculationsUpdateManyWithoutInstanceNestedInput
    modelAccounts?: ModelAccountStructureUpdateManyWithoutInstanceNestedInput
    tables?: TableUpdateManyWithoutInstanceNestedInput
    tableData?: TableDataUpdateManyWithoutInstanceNestedInput
  }

  export type InstanceUncheckedUpdateWithoutAccountAttributesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnuminstanceStatusFieldUpdateOperationsInput | $Enums.instanceStatus
    userIds?: InstanceUpdateuserIdsInput | string[]
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    levels?: LevelUncheckedUpdateManyWithoutInstanceNestedInput
    versions?: VersionUncheckedUpdateManyWithoutInstanceNestedInput
    currencies?: CurrencyUncheckedUpdateManyWithoutInstanceNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutInstanceNestedInput
    models?: ModelUncheckedUpdateManyWithoutInstanceNestedInput
    dimensions?: DimensionUncheckedUpdateManyWithoutInstanceNestedInput
    dimensionValues?: DimensionValueUncheckedUpdateManyWithoutInstanceNestedInput
    levelAttributes?: LevelAttributeUncheckedUpdateManyWithoutInstanceNestedInput
    dimensionValueAttributes?: DimensionValueAttributeUncheckedUpdateManyWithoutInstanceNestedInput
    levelAttValues?: LevelAttributeValueUncheckedUpdateManyWithoutInstanceNestedInput
    accountAttValues?: AccountAttributeValueUncheckedUpdateManyWithoutInstanceNestedInput
    dimensionValueAttributeValues?: DimensionValueAttributeValueUncheckedUpdateManyWithoutInstanceNestedInput
    modelData?: ModelDataUncheckedUpdateManyWithoutInstanceNestedInput
    modelDataCalculations?: ModelDataCalculationsUncheckedUpdateManyWithoutInstanceNestedInput
    modelAccounts?: ModelAccountStructureUncheckedUpdateManyWithoutInstanceNestedInput
    tables?: TableUncheckedUpdateManyWithoutInstanceNestedInput
    tableData?: TableDataUncheckedUpdateManyWithoutInstanceNestedInput
  }

  export type AccountAttributeValueUpsertWithWhereUniqueWithoutAccountAttributeInput = {
    where: AccountAttributeValueWhereUniqueInput
    update: XOR<AccountAttributeValueUpdateWithoutAccountAttributeInput, AccountAttributeValueUncheckedUpdateWithoutAccountAttributeInput>
    create: XOR<AccountAttributeValueCreateWithoutAccountAttributeInput, AccountAttributeValueUncheckedCreateWithoutAccountAttributeInput>
  }

  export type AccountAttributeValueUpdateWithWhereUniqueWithoutAccountAttributeInput = {
    where: AccountAttributeValueWhereUniqueInput
    data: XOR<AccountAttributeValueUpdateWithoutAccountAttributeInput, AccountAttributeValueUncheckedUpdateWithoutAccountAttributeInput>
  }

  export type AccountAttributeValueUpdateManyWithWhereWithoutAccountAttributeInput = {
    where: AccountAttributeValueScalarWhereInput
    data: XOR<AccountAttributeValueUpdateManyMutationInput, AccountAttributeValueUncheckedUpdateManyWithoutAccountAttributeInput>
  }

  export type AccountAttributeAndValueUpsertWithWhereUniqueWithoutAttributeInput = {
    where: AccountAttributeAndValueWhereUniqueInput
    update: XOR<AccountAttributeAndValueUpdateWithoutAttributeInput, AccountAttributeAndValueUncheckedUpdateWithoutAttributeInput>
    create: XOR<AccountAttributeAndValueCreateWithoutAttributeInput, AccountAttributeAndValueUncheckedCreateWithoutAttributeInput>
  }

  export type AccountAttributeAndValueUpdateWithWhereUniqueWithoutAttributeInput = {
    where: AccountAttributeAndValueWhereUniqueInput
    data: XOR<AccountAttributeAndValueUpdateWithoutAttributeInput, AccountAttributeAndValueUncheckedUpdateWithoutAttributeInput>
  }

  export type AccountAttributeAndValueUpdateManyWithWhereWithoutAttributeInput = {
    where: AccountAttributeAndValueScalarWhereInput
    data: XOR<AccountAttributeAndValueUpdateManyMutationInput, AccountAttributeAndValueUncheckedUpdateManyWithoutAttributeInput>
  }

  export type AccountAttributeAndValueScalarWhereInput = {
    AND?: AccountAttributeAndValueScalarWhereInput | AccountAttributeAndValueScalarWhereInput[]
    OR?: AccountAttributeAndValueScalarWhereInput[]
    NOT?: AccountAttributeAndValueScalarWhereInput | AccountAttributeAndValueScalarWhereInput[]
    id?: StringFilter<"AccountAttributeAndValue"> | string
    accountId?: StringFilter<"AccountAttributeAndValue"> | string
    clientId?: StringFilter<"AccountAttributeAndValue"> | string
    instanceId?: StringFilter<"AccountAttributeAndValue"> | string
    attributeId?: StringFilter<"AccountAttributeAndValue"> | string
    attributeValueId?: StringFilter<"AccountAttributeAndValue"> | string
    createdAt?: DateTimeNullableFilter<"AccountAttributeAndValue"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"AccountAttributeAndValue"> | Date | string | null
  }

  export type AccountAttributeValueCreateWithoutChildAttributeValuesInput = {
    id?: string
    code: string
    name: string
    clientId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    parent?: AccountAttributeValueCreateNestedOneWithoutChildAttributeValuesInput
    accountAttribute: AccountAttributeCreateNestedOneWithoutAccountAttributeValuesInput
    instance: InstanceCreateNestedOneWithoutAccountAttValuesInput
    AttributeAndValues?: AccountAttributeAndValueCreateNestedManyWithoutAttributeValueInput
  }

  export type AccountAttributeValueUncheckedCreateWithoutChildAttributeValuesInput = {
    id?: string
    code: string
    name: string
    attributeId: string
    parentId?: string | null
    clientId: string
    instanceId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    AttributeAndValues?: AccountAttributeAndValueUncheckedCreateNestedManyWithoutAttributeValueInput
  }

  export type AccountAttributeValueCreateOrConnectWithoutChildAttributeValuesInput = {
    where: AccountAttributeValueWhereUniqueInput
    create: XOR<AccountAttributeValueCreateWithoutChildAttributeValuesInput, AccountAttributeValueUncheckedCreateWithoutChildAttributeValuesInput>
  }

  export type AccountAttributeValueCreateWithoutParentInput = {
    id?: string
    code: string
    name: string
    clientId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    childAttributeValues?: AccountAttributeValueCreateNestedManyWithoutParentInput
    accountAttribute: AccountAttributeCreateNestedOneWithoutAccountAttributeValuesInput
    instance: InstanceCreateNestedOneWithoutAccountAttValuesInput
    AttributeAndValues?: AccountAttributeAndValueCreateNestedManyWithoutAttributeValueInput
  }

  export type AccountAttributeValueUncheckedCreateWithoutParentInput = {
    id?: string
    code: string
    name: string
    attributeId: string
    clientId: string
    instanceId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    childAttributeValues?: AccountAttributeValueUncheckedCreateNestedManyWithoutParentInput
    AttributeAndValues?: AccountAttributeAndValueUncheckedCreateNestedManyWithoutAttributeValueInput
  }

  export type AccountAttributeValueCreateOrConnectWithoutParentInput = {
    where: AccountAttributeValueWhereUniqueInput
    create: XOR<AccountAttributeValueCreateWithoutParentInput, AccountAttributeValueUncheckedCreateWithoutParentInput>
  }

  export type AccountAttributeValueCreateManyParentInputEnvelope = {
    data: AccountAttributeValueCreateManyParentInput | AccountAttributeValueCreateManyParentInput[]
  }

  export type AccountAttributeCreateWithoutAccountAttributeValuesInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    attributeValueDefault?: string | null
    clientId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    instance: InstanceCreateNestedOneWithoutAccountAttributesInput
    AttributeAndValues?: AccountAttributeAndValueCreateNestedManyWithoutAttributeInput
  }

  export type AccountAttributeUncheckedCreateWithoutAccountAttributeValuesInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    attributeValueDefault?: string | null
    clientId: string
    instanceId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    AttributeAndValues?: AccountAttributeAndValueUncheckedCreateNestedManyWithoutAttributeInput
  }

  export type AccountAttributeCreateOrConnectWithoutAccountAttributeValuesInput = {
    where: AccountAttributeWhereUniqueInput
    create: XOR<AccountAttributeCreateWithoutAccountAttributeValuesInput, AccountAttributeUncheckedCreateWithoutAccountAttributeValuesInput>
  }

  export type InstanceCreateWithoutAccountAttValuesInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    status?: $Enums.instanceStatus
    userIds?: InstanceCreateuserIdsInput | string[]
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    client: ClientCreateNestedOneWithoutInstancesInput
    levels?: LevelCreateNestedManyWithoutInstanceInput
    versions?: VersionCreateNestedManyWithoutInstanceInput
    currencies?: CurrencyCreateNestedManyWithoutInstanceInput
    accounts?: AccountCreateNestedManyWithoutInstanceInput
    models?: ModelCreateNestedManyWithoutInstanceInput
    dimensions?: DimensionCreateNestedManyWithoutInstanceInput
    dimensionValues?: DimensionValueCreateNestedManyWithoutInstanceInput
    levelAttributes?: LevelAttributeCreateNestedManyWithoutInstanceInput
    dimensionValueAttributes?: DimensionValueAttributeCreateNestedManyWithoutInstanceInput
    accountAttributes?: AccountAttributeCreateNestedManyWithoutInstanceInput
    levelAttValues?: LevelAttributeValueCreateNestedManyWithoutInstanceInput
    dimensionValueAttributeValues?: DimensionValueAttributeValueCreateNestedManyWithoutInstanceInput
    modelData?: ModelDataCreateNestedManyWithoutInstanceInput
    modelDataCalculations?: ModelDataCalculationsCreateNestedManyWithoutInstanceInput
    modelAccounts?: ModelAccountStructureCreateNestedManyWithoutInstanceInput
    tables?: TableCreateNestedManyWithoutInstanceInput
    tableData?: TableDataCreateNestedManyWithoutInstanceInput
  }

  export type InstanceUncheckedCreateWithoutAccountAttValuesInput = {
    id?: string
    code: string
    name: string
    clientId: string
    description?: string | null
    status?: $Enums.instanceStatus
    userIds?: InstanceCreateuserIdsInput | string[]
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    levels?: LevelUncheckedCreateNestedManyWithoutInstanceInput
    versions?: VersionUncheckedCreateNestedManyWithoutInstanceInput
    currencies?: CurrencyUncheckedCreateNestedManyWithoutInstanceInput
    accounts?: AccountUncheckedCreateNestedManyWithoutInstanceInput
    models?: ModelUncheckedCreateNestedManyWithoutInstanceInput
    dimensions?: DimensionUncheckedCreateNestedManyWithoutInstanceInput
    dimensionValues?: DimensionValueUncheckedCreateNestedManyWithoutInstanceInput
    levelAttributes?: LevelAttributeUncheckedCreateNestedManyWithoutInstanceInput
    dimensionValueAttributes?: DimensionValueAttributeUncheckedCreateNestedManyWithoutInstanceInput
    accountAttributes?: AccountAttributeUncheckedCreateNestedManyWithoutInstanceInput
    levelAttValues?: LevelAttributeValueUncheckedCreateNestedManyWithoutInstanceInput
    dimensionValueAttributeValues?: DimensionValueAttributeValueUncheckedCreateNestedManyWithoutInstanceInput
    modelData?: ModelDataUncheckedCreateNestedManyWithoutInstanceInput
    modelDataCalculations?: ModelDataCalculationsUncheckedCreateNestedManyWithoutInstanceInput
    modelAccounts?: ModelAccountStructureUncheckedCreateNestedManyWithoutInstanceInput
    tables?: TableUncheckedCreateNestedManyWithoutInstanceInput
    tableData?: TableDataUncheckedCreateNestedManyWithoutInstanceInput
  }

  export type InstanceCreateOrConnectWithoutAccountAttValuesInput = {
    where: InstanceWhereUniqueInput
    create: XOR<InstanceCreateWithoutAccountAttValuesInput, InstanceUncheckedCreateWithoutAccountAttValuesInput>
  }

  export type AccountAttributeAndValueCreateWithoutAttributeValueInput = {
    id?: string
    clientId: string
    instanceId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    account?: AccountCreateNestedOneWithoutAttributeAndValuesInput
    attribute?: AccountAttributeCreateNestedOneWithoutAttributeAndValuesInput
  }

  export type AccountAttributeAndValueUncheckedCreateWithoutAttributeValueInput = {
    id?: string
    accountId: string
    clientId: string
    instanceId: string
    attributeId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type AccountAttributeAndValueCreateOrConnectWithoutAttributeValueInput = {
    where: AccountAttributeAndValueWhereUniqueInput
    create: XOR<AccountAttributeAndValueCreateWithoutAttributeValueInput, AccountAttributeAndValueUncheckedCreateWithoutAttributeValueInput>
  }

  export type AccountAttributeAndValueCreateManyAttributeValueInputEnvelope = {
    data: AccountAttributeAndValueCreateManyAttributeValueInput | AccountAttributeAndValueCreateManyAttributeValueInput[]
  }

  export type AccountAttributeValueUpsertWithoutChildAttributeValuesInput = {
    update: XOR<AccountAttributeValueUpdateWithoutChildAttributeValuesInput, AccountAttributeValueUncheckedUpdateWithoutChildAttributeValuesInput>
    create: XOR<AccountAttributeValueCreateWithoutChildAttributeValuesInput, AccountAttributeValueUncheckedCreateWithoutChildAttributeValuesInput>
    where?: AccountAttributeValueWhereInput
  }

  export type AccountAttributeValueUpdateToOneWithWhereWithoutChildAttributeValuesInput = {
    where?: AccountAttributeValueWhereInput
    data: XOR<AccountAttributeValueUpdateWithoutChildAttributeValuesInput, AccountAttributeValueUncheckedUpdateWithoutChildAttributeValuesInput>
  }

  export type AccountAttributeValueUpdateWithoutChildAttributeValuesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parent?: AccountAttributeValueUpdateOneWithoutChildAttributeValuesNestedInput
    accountAttribute?: AccountAttributeUpdateOneRequiredWithoutAccountAttributeValuesNestedInput
    instance?: InstanceUpdateOneRequiredWithoutAccountAttValuesNestedInput
    AttributeAndValues?: AccountAttributeAndValueUpdateManyWithoutAttributeValueNestedInput
  }

  export type AccountAttributeValueUncheckedUpdateWithoutChildAttributeValuesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    attributeId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    AttributeAndValues?: AccountAttributeAndValueUncheckedUpdateManyWithoutAttributeValueNestedInput
  }

  export type AccountAttributeValueUpsertWithWhereUniqueWithoutParentInput = {
    where: AccountAttributeValueWhereUniqueInput
    update: XOR<AccountAttributeValueUpdateWithoutParentInput, AccountAttributeValueUncheckedUpdateWithoutParentInput>
    create: XOR<AccountAttributeValueCreateWithoutParentInput, AccountAttributeValueUncheckedCreateWithoutParentInput>
  }

  export type AccountAttributeValueUpdateWithWhereUniqueWithoutParentInput = {
    where: AccountAttributeValueWhereUniqueInput
    data: XOR<AccountAttributeValueUpdateWithoutParentInput, AccountAttributeValueUncheckedUpdateWithoutParentInput>
  }

  export type AccountAttributeValueUpdateManyWithWhereWithoutParentInput = {
    where: AccountAttributeValueScalarWhereInput
    data: XOR<AccountAttributeValueUpdateManyMutationInput, AccountAttributeValueUncheckedUpdateManyWithoutParentInput>
  }

  export type AccountAttributeUpsertWithoutAccountAttributeValuesInput = {
    update: XOR<AccountAttributeUpdateWithoutAccountAttributeValuesInput, AccountAttributeUncheckedUpdateWithoutAccountAttributeValuesInput>
    create: XOR<AccountAttributeCreateWithoutAccountAttributeValuesInput, AccountAttributeUncheckedCreateWithoutAccountAttributeValuesInput>
    where?: AccountAttributeWhereInput
  }

  export type AccountAttributeUpdateToOneWithWhereWithoutAccountAttributeValuesInput = {
    where?: AccountAttributeWhereInput
    data: XOR<AccountAttributeUpdateWithoutAccountAttributeValuesInput, AccountAttributeUncheckedUpdateWithoutAccountAttributeValuesInput>
  }

  export type AccountAttributeUpdateWithoutAccountAttributeValuesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    attributeValueDefault?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instance?: InstanceUpdateOneRequiredWithoutAccountAttributesNestedInput
    AttributeAndValues?: AccountAttributeAndValueUpdateManyWithoutAttributeNestedInput
  }

  export type AccountAttributeUncheckedUpdateWithoutAccountAttributeValuesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    attributeValueDefault?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    AttributeAndValues?: AccountAttributeAndValueUncheckedUpdateManyWithoutAttributeNestedInput
  }

  export type InstanceUpsertWithoutAccountAttValuesInput = {
    update: XOR<InstanceUpdateWithoutAccountAttValuesInput, InstanceUncheckedUpdateWithoutAccountAttValuesInput>
    create: XOR<InstanceCreateWithoutAccountAttValuesInput, InstanceUncheckedCreateWithoutAccountAttValuesInput>
    where?: InstanceWhereInput
  }

  export type InstanceUpdateToOneWithWhereWithoutAccountAttValuesInput = {
    where?: InstanceWhereInput
    data: XOR<InstanceUpdateWithoutAccountAttValuesInput, InstanceUncheckedUpdateWithoutAccountAttValuesInput>
  }

  export type InstanceUpdateWithoutAccountAttValuesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnuminstanceStatusFieldUpdateOperationsInput | $Enums.instanceStatus
    userIds?: InstanceUpdateuserIdsInput | string[]
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    client?: ClientUpdateOneRequiredWithoutInstancesNestedInput
    levels?: LevelUpdateManyWithoutInstanceNestedInput
    versions?: VersionUpdateManyWithoutInstanceNestedInput
    currencies?: CurrencyUpdateManyWithoutInstanceNestedInput
    accounts?: AccountUpdateManyWithoutInstanceNestedInput
    models?: ModelUpdateManyWithoutInstanceNestedInput
    dimensions?: DimensionUpdateManyWithoutInstanceNestedInput
    dimensionValues?: DimensionValueUpdateManyWithoutInstanceNestedInput
    levelAttributes?: LevelAttributeUpdateManyWithoutInstanceNestedInput
    dimensionValueAttributes?: DimensionValueAttributeUpdateManyWithoutInstanceNestedInput
    accountAttributes?: AccountAttributeUpdateManyWithoutInstanceNestedInput
    levelAttValues?: LevelAttributeValueUpdateManyWithoutInstanceNestedInput
    dimensionValueAttributeValues?: DimensionValueAttributeValueUpdateManyWithoutInstanceNestedInput
    modelData?: ModelDataUpdateManyWithoutInstanceNestedInput
    modelDataCalculations?: ModelDataCalculationsUpdateManyWithoutInstanceNestedInput
    modelAccounts?: ModelAccountStructureUpdateManyWithoutInstanceNestedInput
    tables?: TableUpdateManyWithoutInstanceNestedInput
    tableData?: TableDataUpdateManyWithoutInstanceNestedInput
  }

  export type InstanceUncheckedUpdateWithoutAccountAttValuesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnuminstanceStatusFieldUpdateOperationsInput | $Enums.instanceStatus
    userIds?: InstanceUpdateuserIdsInput | string[]
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    levels?: LevelUncheckedUpdateManyWithoutInstanceNestedInput
    versions?: VersionUncheckedUpdateManyWithoutInstanceNestedInput
    currencies?: CurrencyUncheckedUpdateManyWithoutInstanceNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutInstanceNestedInput
    models?: ModelUncheckedUpdateManyWithoutInstanceNestedInput
    dimensions?: DimensionUncheckedUpdateManyWithoutInstanceNestedInput
    dimensionValues?: DimensionValueUncheckedUpdateManyWithoutInstanceNestedInput
    levelAttributes?: LevelAttributeUncheckedUpdateManyWithoutInstanceNestedInput
    dimensionValueAttributes?: DimensionValueAttributeUncheckedUpdateManyWithoutInstanceNestedInput
    accountAttributes?: AccountAttributeUncheckedUpdateManyWithoutInstanceNestedInput
    levelAttValues?: LevelAttributeValueUncheckedUpdateManyWithoutInstanceNestedInput
    dimensionValueAttributeValues?: DimensionValueAttributeValueUncheckedUpdateManyWithoutInstanceNestedInput
    modelData?: ModelDataUncheckedUpdateManyWithoutInstanceNestedInput
    modelDataCalculations?: ModelDataCalculationsUncheckedUpdateManyWithoutInstanceNestedInput
    modelAccounts?: ModelAccountStructureUncheckedUpdateManyWithoutInstanceNestedInput
    tables?: TableUncheckedUpdateManyWithoutInstanceNestedInput
    tableData?: TableDataUncheckedUpdateManyWithoutInstanceNestedInput
  }

  export type AccountAttributeAndValueUpsertWithWhereUniqueWithoutAttributeValueInput = {
    where: AccountAttributeAndValueWhereUniqueInput
    update: XOR<AccountAttributeAndValueUpdateWithoutAttributeValueInput, AccountAttributeAndValueUncheckedUpdateWithoutAttributeValueInput>
    create: XOR<AccountAttributeAndValueCreateWithoutAttributeValueInput, AccountAttributeAndValueUncheckedCreateWithoutAttributeValueInput>
  }

  export type AccountAttributeAndValueUpdateWithWhereUniqueWithoutAttributeValueInput = {
    where: AccountAttributeAndValueWhereUniqueInput
    data: XOR<AccountAttributeAndValueUpdateWithoutAttributeValueInput, AccountAttributeAndValueUncheckedUpdateWithoutAttributeValueInput>
  }

  export type AccountAttributeAndValueUpdateManyWithWhereWithoutAttributeValueInput = {
    where: AccountAttributeAndValueScalarWhereInput
    data: XOR<AccountAttributeAndValueUpdateManyMutationInput, AccountAttributeAndValueUncheckedUpdateManyWithoutAttributeValueInput>
  }

  export type AccountCreateWithoutAttributeAndValuesInput = {
    id?: string
    code: string
    name: string
    isRoot?: boolean
    isModelRoot?: boolean
    accountType: $Enums.AccountType
    accountTypeTag: $Enums.AccountTypeTag
    group?: $Enums.YesNo
    plannedBy?: $Enums.ActPlanBy | null
    actualsBy?: $Enums.ActActualsBy | null
    displayAs?: $Enums.ActDisplayAs
    containsSalaryInfo?: $Enums.YesNo
    description?: string | null
    clientId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    instance: InstanceCreateNestedOneWithoutAccountsInput
    parent?: AccountCreateNestedOneWithoutChildAccountsInput
    childAccounts?: AccountCreateNestedManyWithoutParentInput
    modelAccounts?: ModelAccountStructureCreateNestedManyWithoutAccountInput
    modelData?: ModelDataCreateNestedManyWithoutAccountInput
    modeldataCalculations?: ModelDataCalculationsCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutAttributeAndValuesInput = {
    id?: string
    code: string
    name: string
    isRoot?: boolean
    isModelRoot?: boolean
    accountType: $Enums.AccountType
    accountTypeTag: $Enums.AccountTypeTag
    group?: $Enums.YesNo
    plannedBy?: $Enums.ActPlanBy | null
    actualsBy?: $Enums.ActActualsBy | null
    displayAs?: $Enums.ActDisplayAs
    containsSalaryInfo?: $Enums.YesNo
    description?: string | null
    instanceId: string
    clientId: string
    parentId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    childAccounts?: AccountUncheckedCreateNestedManyWithoutParentInput
    modelAccounts?: ModelAccountStructureUncheckedCreateNestedManyWithoutAccountInput
    modelData?: ModelDataUncheckedCreateNestedManyWithoutAccountInput
    modeldataCalculations?: ModelDataCalculationsUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutAttributeAndValuesInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutAttributeAndValuesInput, AccountUncheckedCreateWithoutAttributeAndValuesInput>
  }

  export type AccountAttributeCreateWithoutAttributeAndValuesInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    attributeValueDefault?: string | null
    clientId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    instance: InstanceCreateNestedOneWithoutAccountAttributesInput
    accountAttributeValues?: AccountAttributeValueCreateNestedManyWithoutAccountAttributeInput
  }

  export type AccountAttributeUncheckedCreateWithoutAttributeAndValuesInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    attributeValueDefault?: string | null
    clientId: string
    instanceId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    accountAttributeValues?: AccountAttributeValueUncheckedCreateNestedManyWithoutAccountAttributeInput
  }

  export type AccountAttributeCreateOrConnectWithoutAttributeAndValuesInput = {
    where: AccountAttributeWhereUniqueInput
    create: XOR<AccountAttributeCreateWithoutAttributeAndValuesInput, AccountAttributeUncheckedCreateWithoutAttributeAndValuesInput>
  }

  export type AccountAttributeValueCreateWithoutAttributeAndValuesInput = {
    id?: string
    code: string
    name: string
    clientId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    parent?: AccountAttributeValueCreateNestedOneWithoutChildAttributeValuesInput
    childAttributeValues?: AccountAttributeValueCreateNestedManyWithoutParentInput
    accountAttribute: AccountAttributeCreateNestedOneWithoutAccountAttributeValuesInput
    instance: InstanceCreateNestedOneWithoutAccountAttValuesInput
  }

  export type AccountAttributeValueUncheckedCreateWithoutAttributeAndValuesInput = {
    id?: string
    code: string
    name: string
    attributeId: string
    parentId?: string | null
    clientId: string
    instanceId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    childAttributeValues?: AccountAttributeValueUncheckedCreateNestedManyWithoutParentInput
  }

  export type AccountAttributeValueCreateOrConnectWithoutAttributeAndValuesInput = {
    where: AccountAttributeValueWhereUniqueInput
    create: XOR<AccountAttributeValueCreateWithoutAttributeAndValuesInput, AccountAttributeValueUncheckedCreateWithoutAttributeAndValuesInput>
  }

  export type AccountUpsertWithoutAttributeAndValuesInput = {
    update: XOR<AccountUpdateWithoutAttributeAndValuesInput, AccountUncheckedUpdateWithoutAttributeAndValuesInput>
    create: XOR<AccountCreateWithoutAttributeAndValuesInput, AccountUncheckedCreateWithoutAttributeAndValuesInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutAttributeAndValuesInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutAttributeAndValuesInput, AccountUncheckedUpdateWithoutAttributeAndValuesInput>
  }

  export type AccountUpdateWithoutAttributeAndValuesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isRoot?: BoolFieldUpdateOperationsInput | boolean
    isModelRoot?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    accountTypeTag?: EnumAccountTypeTagFieldUpdateOperationsInput | $Enums.AccountTypeTag
    group?: EnumYesNoFieldUpdateOperationsInput | $Enums.YesNo
    plannedBy?: NullableEnumActPlanByFieldUpdateOperationsInput | $Enums.ActPlanBy | null
    actualsBy?: NullableEnumActActualsByFieldUpdateOperationsInput | $Enums.ActActualsBy | null
    displayAs?: EnumActDisplayAsFieldUpdateOperationsInput | $Enums.ActDisplayAs
    containsSalaryInfo?: EnumYesNoFieldUpdateOperationsInput | $Enums.YesNo
    description?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instance?: InstanceUpdateOneRequiredWithoutAccountsNestedInput
    parent?: AccountUpdateOneWithoutChildAccountsNestedInput
    childAccounts?: AccountUpdateManyWithoutParentNestedInput
    modelAccounts?: ModelAccountStructureUpdateManyWithoutAccountNestedInput
    modelData?: ModelDataUpdateManyWithoutAccountNestedInput
    modeldataCalculations?: ModelDataCalculationsUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutAttributeAndValuesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isRoot?: BoolFieldUpdateOperationsInput | boolean
    isModelRoot?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    accountTypeTag?: EnumAccountTypeTagFieldUpdateOperationsInput | $Enums.AccountTypeTag
    group?: EnumYesNoFieldUpdateOperationsInput | $Enums.YesNo
    plannedBy?: NullableEnumActPlanByFieldUpdateOperationsInput | $Enums.ActPlanBy | null
    actualsBy?: NullableEnumActActualsByFieldUpdateOperationsInput | $Enums.ActActualsBy | null
    displayAs?: EnumActDisplayAsFieldUpdateOperationsInput | $Enums.ActDisplayAs
    containsSalaryInfo?: EnumYesNoFieldUpdateOperationsInput | $Enums.YesNo
    description?: NullableStringFieldUpdateOperationsInput | string | null
    instanceId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    childAccounts?: AccountUncheckedUpdateManyWithoutParentNestedInput
    modelAccounts?: ModelAccountStructureUncheckedUpdateManyWithoutAccountNestedInput
    modelData?: ModelDataUncheckedUpdateManyWithoutAccountNestedInput
    modeldataCalculations?: ModelDataCalculationsUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type AccountAttributeUpsertWithoutAttributeAndValuesInput = {
    update: XOR<AccountAttributeUpdateWithoutAttributeAndValuesInput, AccountAttributeUncheckedUpdateWithoutAttributeAndValuesInput>
    create: XOR<AccountAttributeCreateWithoutAttributeAndValuesInput, AccountAttributeUncheckedCreateWithoutAttributeAndValuesInput>
    where?: AccountAttributeWhereInput
  }

  export type AccountAttributeUpdateToOneWithWhereWithoutAttributeAndValuesInput = {
    where?: AccountAttributeWhereInput
    data: XOR<AccountAttributeUpdateWithoutAttributeAndValuesInput, AccountAttributeUncheckedUpdateWithoutAttributeAndValuesInput>
  }

  export type AccountAttributeUpdateWithoutAttributeAndValuesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    attributeValueDefault?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instance?: InstanceUpdateOneRequiredWithoutAccountAttributesNestedInput
    accountAttributeValues?: AccountAttributeValueUpdateManyWithoutAccountAttributeNestedInput
  }

  export type AccountAttributeUncheckedUpdateWithoutAttributeAndValuesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    attributeValueDefault?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountAttributeValues?: AccountAttributeValueUncheckedUpdateManyWithoutAccountAttributeNestedInput
  }

  export type AccountAttributeValueUpsertWithoutAttributeAndValuesInput = {
    update: XOR<AccountAttributeValueUpdateWithoutAttributeAndValuesInput, AccountAttributeValueUncheckedUpdateWithoutAttributeAndValuesInput>
    create: XOR<AccountAttributeValueCreateWithoutAttributeAndValuesInput, AccountAttributeValueUncheckedCreateWithoutAttributeAndValuesInput>
    where?: AccountAttributeValueWhereInput
  }

  export type AccountAttributeValueUpdateToOneWithWhereWithoutAttributeAndValuesInput = {
    where?: AccountAttributeValueWhereInput
    data: XOR<AccountAttributeValueUpdateWithoutAttributeAndValuesInput, AccountAttributeValueUncheckedUpdateWithoutAttributeAndValuesInput>
  }

  export type AccountAttributeValueUpdateWithoutAttributeAndValuesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parent?: AccountAttributeValueUpdateOneWithoutChildAttributeValuesNestedInput
    childAttributeValues?: AccountAttributeValueUpdateManyWithoutParentNestedInput
    accountAttribute?: AccountAttributeUpdateOneRequiredWithoutAccountAttributeValuesNestedInput
    instance?: InstanceUpdateOneRequiredWithoutAccountAttValuesNestedInput
  }

  export type AccountAttributeValueUncheckedUpdateWithoutAttributeAndValuesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    attributeId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    childAttributeValues?: AccountAttributeValueUncheckedUpdateManyWithoutParentNestedInput
  }

  export type InstanceCreateWithoutAccountsInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    status?: $Enums.instanceStatus
    userIds?: InstanceCreateuserIdsInput | string[]
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    client: ClientCreateNestedOneWithoutInstancesInput
    levels?: LevelCreateNestedManyWithoutInstanceInput
    versions?: VersionCreateNestedManyWithoutInstanceInput
    currencies?: CurrencyCreateNestedManyWithoutInstanceInput
    models?: ModelCreateNestedManyWithoutInstanceInput
    dimensions?: DimensionCreateNestedManyWithoutInstanceInput
    dimensionValues?: DimensionValueCreateNestedManyWithoutInstanceInput
    levelAttributes?: LevelAttributeCreateNestedManyWithoutInstanceInput
    dimensionValueAttributes?: DimensionValueAttributeCreateNestedManyWithoutInstanceInput
    accountAttributes?: AccountAttributeCreateNestedManyWithoutInstanceInput
    levelAttValues?: LevelAttributeValueCreateNestedManyWithoutInstanceInput
    accountAttValues?: AccountAttributeValueCreateNestedManyWithoutInstanceInput
    dimensionValueAttributeValues?: DimensionValueAttributeValueCreateNestedManyWithoutInstanceInput
    modelData?: ModelDataCreateNestedManyWithoutInstanceInput
    modelDataCalculations?: ModelDataCalculationsCreateNestedManyWithoutInstanceInput
    modelAccounts?: ModelAccountStructureCreateNestedManyWithoutInstanceInput
    tables?: TableCreateNestedManyWithoutInstanceInput
    tableData?: TableDataCreateNestedManyWithoutInstanceInput
  }

  export type InstanceUncheckedCreateWithoutAccountsInput = {
    id?: string
    code: string
    name: string
    clientId: string
    description?: string | null
    status?: $Enums.instanceStatus
    userIds?: InstanceCreateuserIdsInput | string[]
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    levels?: LevelUncheckedCreateNestedManyWithoutInstanceInput
    versions?: VersionUncheckedCreateNestedManyWithoutInstanceInput
    currencies?: CurrencyUncheckedCreateNestedManyWithoutInstanceInput
    models?: ModelUncheckedCreateNestedManyWithoutInstanceInput
    dimensions?: DimensionUncheckedCreateNestedManyWithoutInstanceInput
    dimensionValues?: DimensionValueUncheckedCreateNestedManyWithoutInstanceInput
    levelAttributes?: LevelAttributeUncheckedCreateNestedManyWithoutInstanceInput
    dimensionValueAttributes?: DimensionValueAttributeUncheckedCreateNestedManyWithoutInstanceInput
    accountAttributes?: AccountAttributeUncheckedCreateNestedManyWithoutInstanceInput
    levelAttValues?: LevelAttributeValueUncheckedCreateNestedManyWithoutInstanceInput
    accountAttValues?: AccountAttributeValueUncheckedCreateNestedManyWithoutInstanceInput
    dimensionValueAttributeValues?: DimensionValueAttributeValueUncheckedCreateNestedManyWithoutInstanceInput
    modelData?: ModelDataUncheckedCreateNestedManyWithoutInstanceInput
    modelDataCalculations?: ModelDataCalculationsUncheckedCreateNestedManyWithoutInstanceInput
    modelAccounts?: ModelAccountStructureUncheckedCreateNestedManyWithoutInstanceInput
    tables?: TableUncheckedCreateNestedManyWithoutInstanceInput
    tableData?: TableDataUncheckedCreateNestedManyWithoutInstanceInput
  }

  export type InstanceCreateOrConnectWithoutAccountsInput = {
    where: InstanceWhereUniqueInput
    create: XOR<InstanceCreateWithoutAccountsInput, InstanceUncheckedCreateWithoutAccountsInput>
  }

  export type AccountCreateWithoutChildAccountsInput = {
    id?: string
    code: string
    name: string
    isRoot?: boolean
    isModelRoot?: boolean
    accountType: $Enums.AccountType
    accountTypeTag: $Enums.AccountTypeTag
    group?: $Enums.YesNo
    plannedBy?: $Enums.ActPlanBy | null
    actualsBy?: $Enums.ActActualsBy | null
    displayAs?: $Enums.ActDisplayAs
    containsSalaryInfo?: $Enums.YesNo
    description?: string | null
    clientId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    instance: InstanceCreateNestedOneWithoutAccountsInput
    parent?: AccountCreateNestedOneWithoutChildAccountsInput
    AttributeAndValues?: AccountAttributeAndValueCreateNestedManyWithoutAccountInput
    modelAccounts?: ModelAccountStructureCreateNestedManyWithoutAccountInput
    modelData?: ModelDataCreateNestedManyWithoutAccountInput
    modeldataCalculations?: ModelDataCalculationsCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutChildAccountsInput = {
    id?: string
    code: string
    name: string
    isRoot?: boolean
    isModelRoot?: boolean
    accountType: $Enums.AccountType
    accountTypeTag: $Enums.AccountTypeTag
    group?: $Enums.YesNo
    plannedBy?: $Enums.ActPlanBy | null
    actualsBy?: $Enums.ActActualsBy | null
    displayAs?: $Enums.ActDisplayAs
    containsSalaryInfo?: $Enums.YesNo
    description?: string | null
    instanceId: string
    clientId: string
    parentId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    AttributeAndValues?: AccountAttributeAndValueUncheckedCreateNestedManyWithoutAccountInput
    modelAccounts?: ModelAccountStructureUncheckedCreateNestedManyWithoutAccountInput
    modelData?: ModelDataUncheckedCreateNestedManyWithoutAccountInput
    modeldataCalculations?: ModelDataCalculationsUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutChildAccountsInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutChildAccountsInput, AccountUncheckedCreateWithoutChildAccountsInput>
  }

  export type AccountCreateWithoutParentInput = {
    id?: string
    code: string
    name: string
    isRoot?: boolean
    isModelRoot?: boolean
    accountType: $Enums.AccountType
    accountTypeTag: $Enums.AccountTypeTag
    group?: $Enums.YesNo
    plannedBy?: $Enums.ActPlanBy | null
    actualsBy?: $Enums.ActActualsBy | null
    displayAs?: $Enums.ActDisplayAs
    containsSalaryInfo?: $Enums.YesNo
    description?: string | null
    clientId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    instance: InstanceCreateNestedOneWithoutAccountsInput
    childAccounts?: AccountCreateNestedManyWithoutParentInput
    AttributeAndValues?: AccountAttributeAndValueCreateNestedManyWithoutAccountInput
    modelAccounts?: ModelAccountStructureCreateNestedManyWithoutAccountInput
    modelData?: ModelDataCreateNestedManyWithoutAccountInput
    modeldataCalculations?: ModelDataCalculationsCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutParentInput = {
    id?: string
    code: string
    name: string
    isRoot?: boolean
    isModelRoot?: boolean
    accountType: $Enums.AccountType
    accountTypeTag: $Enums.AccountTypeTag
    group?: $Enums.YesNo
    plannedBy?: $Enums.ActPlanBy | null
    actualsBy?: $Enums.ActActualsBy | null
    displayAs?: $Enums.ActDisplayAs
    containsSalaryInfo?: $Enums.YesNo
    description?: string | null
    instanceId: string
    clientId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    childAccounts?: AccountUncheckedCreateNestedManyWithoutParentInput
    AttributeAndValues?: AccountAttributeAndValueUncheckedCreateNestedManyWithoutAccountInput
    modelAccounts?: ModelAccountStructureUncheckedCreateNestedManyWithoutAccountInput
    modelData?: ModelDataUncheckedCreateNestedManyWithoutAccountInput
    modeldataCalculations?: ModelDataCalculationsUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutParentInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutParentInput, AccountUncheckedCreateWithoutParentInput>
  }

  export type AccountCreateManyParentInputEnvelope = {
    data: AccountCreateManyParentInput | AccountCreateManyParentInput[]
  }

  export type AccountAttributeAndValueCreateWithoutAccountInput = {
    id?: string
    clientId: string
    instanceId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    attribute?: AccountAttributeCreateNestedOneWithoutAttributeAndValuesInput
    attributeValue?: AccountAttributeValueCreateNestedOneWithoutAttributeAndValuesInput
  }

  export type AccountAttributeAndValueUncheckedCreateWithoutAccountInput = {
    id?: string
    clientId: string
    instanceId: string
    attributeId: string
    attributeValueId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type AccountAttributeAndValueCreateOrConnectWithoutAccountInput = {
    where: AccountAttributeAndValueWhereUniqueInput
    create: XOR<AccountAttributeAndValueCreateWithoutAccountInput, AccountAttributeAndValueUncheckedCreateWithoutAccountInput>
  }

  export type AccountAttributeAndValueCreateManyAccountInputEnvelope = {
    data: AccountAttributeAndValueCreateManyAccountInput | AccountAttributeAndValueCreateManyAccountInput[]
  }

  export type ModelAccountStructureCreateWithoutAccountInput = {
    id?: string
    isRoot?: boolean
    clientId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    instance: InstanceCreateNestedOneWithoutModelAccountsInput
    model: ModelCreateNestedOneWithoutModelAccountsInput
    modeldataCalculations?: ModelDataCalculationsCreateNestedManyWithoutModelAccountInput
    parentAccount?: ModelAccountStructureCreateNestedOneWithoutChildAccountsInput
    childAccounts?: ModelAccountStructureCreateNestedManyWithoutParentAccountInput
  }

  export type ModelAccountStructureUncheckedCreateWithoutAccountInput = {
    id?: string
    instanceId: string
    isRoot?: boolean
    clientId: string
    parentId?: string | null
    modelId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    modeldataCalculations?: ModelDataCalculationsUncheckedCreateNestedManyWithoutModelAccountInput
    childAccounts?: ModelAccountStructureUncheckedCreateNestedManyWithoutParentAccountInput
  }

  export type ModelAccountStructureCreateOrConnectWithoutAccountInput = {
    where: ModelAccountStructureWhereUniqueInput
    create: XOR<ModelAccountStructureCreateWithoutAccountInput, ModelAccountStructureUncheckedCreateWithoutAccountInput>
  }

  export type ModelAccountStructureCreateManyAccountInputEnvelope = {
    data: ModelAccountStructureCreateManyAccountInput | ModelAccountStructureCreateManyAccountInput[]
  }

  export type ModelDataCreateWithoutAccountInput = {
    id?: string
    clientId: string
    dimensionality?: XOR<ModelDataDimensionalityListCreateEnvelopeInput, ModelDataDimensionalityCreateInput> | ModelDataDimensionalityCreateInput[]
    timespan: InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    model: ModelCreateNestedOneWithoutModelDataInput
    level: LevelCreateNestedOneWithoutModelDataInput
    version: VersionCreateNestedOneWithoutModelDataInput
    instance: InstanceCreateNestedOneWithoutModelDataInput
  }

  export type ModelDataUncheckedCreateWithoutAccountInput = {
    id?: string
    clientId: string
    instanceId: string
    modelId: string
    versionId: string
    levelId: string
    dimensionality?: XOR<ModelDataDimensionalityListCreateEnvelopeInput, ModelDataDimensionalityCreateInput> | ModelDataDimensionalityCreateInput[]
    timespan: InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ModelDataCreateOrConnectWithoutAccountInput = {
    where: ModelDataWhereUniqueInput
    create: XOR<ModelDataCreateWithoutAccountInput, ModelDataUncheckedCreateWithoutAccountInput>
  }

  export type ModelDataCreateManyAccountInputEnvelope = {
    data: ModelDataCreateManyAccountInput | ModelDataCreateManyAccountInput[]
  }

  export type ModelDataCalculationsCreateWithoutAccountInput = {
    id?: string
    clientId: string
    calculations: InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    model: ModelCreateNestedOneWithoutModelDataCalculationsInput
    level: LevelCreateNestedOneWithoutModeldataCalculationsInput
    version: VersionCreateNestedOneWithoutModelDataCalculationsInput
    instance: InstanceCreateNestedOneWithoutModelDataCalculationsInput
    modelAccount: ModelAccountStructureCreateNestedOneWithoutModeldataCalculationsInput
  }

  export type ModelDataCalculationsUncheckedCreateWithoutAccountInput = {
    id?: string
    clientId: string
    instanceId: string
    modelId: string
    versionId: string
    levelId: string
    modelAccountId: string
    calculations: InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ModelDataCalculationsCreateOrConnectWithoutAccountInput = {
    where: ModelDataCalculationsWhereUniqueInput
    create: XOR<ModelDataCalculationsCreateWithoutAccountInput, ModelDataCalculationsUncheckedCreateWithoutAccountInput>
  }

  export type ModelDataCalculationsCreateManyAccountInputEnvelope = {
    data: ModelDataCalculationsCreateManyAccountInput | ModelDataCalculationsCreateManyAccountInput[]
  }

  export type InstanceUpsertWithoutAccountsInput = {
    update: XOR<InstanceUpdateWithoutAccountsInput, InstanceUncheckedUpdateWithoutAccountsInput>
    create: XOR<InstanceCreateWithoutAccountsInput, InstanceUncheckedCreateWithoutAccountsInput>
    where?: InstanceWhereInput
  }

  export type InstanceUpdateToOneWithWhereWithoutAccountsInput = {
    where?: InstanceWhereInput
    data: XOR<InstanceUpdateWithoutAccountsInput, InstanceUncheckedUpdateWithoutAccountsInput>
  }

  export type InstanceUpdateWithoutAccountsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnuminstanceStatusFieldUpdateOperationsInput | $Enums.instanceStatus
    userIds?: InstanceUpdateuserIdsInput | string[]
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    client?: ClientUpdateOneRequiredWithoutInstancesNestedInput
    levels?: LevelUpdateManyWithoutInstanceNestedInput
    versions?: VersionUpdateManyWithoutInstanceNestedInput
    currencies?: CurrencyUpdateManyWithoutInstanceNestedInput
    models?: ModelUpdateManyWithoutInstanceNestedInput
    dimensions?: DimensionUpdateManyWithoutInstanceNestedInput
    dimensionValues?: DimensionValueUpdateManyWithoutInstanceNestedInput
    levelAttributes?: LevelAttributeUpdateManyWithoutInstanceNestedInput
    dimensionValueAttributes?: DimensionValueAttributeUpdateManyWithoutInstanceNestedInput
    accountAttributes?: AccountAttributeUpdateManyWithoutInstanceNestedInput
    levelAttValues?: LevelAttributeValueUpdateManyWithoutInstanceNestedInput
    accountAttValues?: AccountAttributeValueUpdateManyWithoutInstanceNestedInput
    dimensionValueAttributeValues?: DimensionValueAttributeValueUpdateManyWithoutInstanceNestedInput
    modelData?: ModelDataUpdateManyWithoutInstanceNestedInput
    modelDataCalculations?: ModelDataCalculationsUpdateManyWithoutInstanceNestedInput
    modelAccounts?: ModelAccountStructureUpdateManyWithoutInstanceNestedInput
    tables?: TableUpdateManyWithoutInstanceNestedInput
    tableData?: TableDataUpdateManyWithoutInstanceNestedInput
  }

  export type InstanceUncheckedUpdateWithoutAccountsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnuminstanceStatusFieldUpdateOperationsInput | $Enums.instanceStatus
    userIds?: InstanceUpdateuserIdsInput | string[]
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    levels?: LevelUncheckedUpdateManyWithoutInstanceNestedInput
    versions?: VersionUncheckedUpdateManyWithoutInstanceNestedInput
    currencies?: CurrencyUncheckedUpdateManyWithoutInstanceNestedInput
    models?: ModelUncheckedUpdateManyWithoutInstanceNestedInput
    dimensions?: DimensionUncheckedUpdateManyWithoutInstanceNestedInput
    dimensionValues?: DimensionValueUncheckedUpdateManyWithoutInstanceNestedInput
    levelAttributes?: LevelAttributeUncheckedUpdateManyWithoutInstanceNestedInput
    dimensionValueAttributes?: DimensionValueAttributeUncheckedUpdateManyWithoutInstanceNestedInput
    accountAttributes?: AccountAttributeUncheckedUpdateManyWithoutInstanceNestedInput
    levelAttValues?: LevelAttributeValueUncheckedUpdateManyWithoutInstanceNestedInput
    accountAttValues?: AccountAttributeValueUncheckedUpdateManyWithoutInstanceNestedInput
    dimensionValueAttributeValues?: DimensionValueAttributeValueUncheckedUpdateManyWithoutInstanceNestedInput
    modelData?: ModelDataUncheckedUpdateManyWithoutInstanceNestedInput
    modelDataCalculations?: ModelDataCalculationsUncheckedUpdateManyWithoutInstanceNestedInput
    modelAccounts?: ModelAccountStructureUncheckedUpdateManyWithoutInstanceNestedInput
    tables?: TableUncheckedUpdateManyWithoutInstanceNestedInput
    tableData?: TableDataUncheckedUpdateManyWithoutInstanceNestedInput
  }

  export type AccountUpsertWithoutChildAccountsInput = {
    update: XOR<AccountUpdateWithoutChildAccountsInput, AccountUncheckedUpdateWithoutChildAccountsInput>
    create: XOR<AccountCreateWithoutChildAccountsInput, AccountUncheckedCreateWithoutChildAccountsInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutChildAccountsInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutChildAccountsInput, AccountUncheckedUpdateWithoutChildAccountsInput>
  }

  export type AccountUpdateWithoutChildAccountsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isRoot?: BoolFieldUpdateOperationsInput | boolean
    isModelRoot?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    accountTypeTag?: EnumAccountTypeTagFieldUpdateOperationsInput | $Enums.AccountTypeTag
    group?: EnumYesNoFieldUpdateOperationsInput | $Enums.YesNo
    plannedBy?: NullableEnumActPlanByFieldUpdateOperationsInput | $Enums.ActPlanBy | null
    actualsBy?: NullableEnumActActualsByFieldUpdateOperationsInput | $Enums.ActActualsBy | null
    displayAs?: EnumActDisplayAsFieldUpdateOperationsInput | $Enums.ActDisplayAs
    containsSalaryInfo?: EnumYesNoFieldUpdateOperationsInput | $Enums.YesNo
    description?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instance?: InstanceUpdateOneRequiredWithoutAccountsNestedInput
    parent?: AccountUpdateOneWithoutChildAccountsNestedInput
    AttributeAndValues?: AccountAttributeAndValueUpdateManyWithoutAccountNestedInput
    modelAccounts?: ModelAccountStructureUpdateManyWithoutAccountNestedInput
    modelData?: ModelDataUpdateManyWithoutAccountNestedInput
    modeldataCalculations?: ModelDataCalculationsUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutChildAccountsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isRoot?: BoolFieldUpdateOperationsInput | boolean
    isModelRoot?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    accountTypeTag?: EnumAccountTypeTagFieldUpdateOperationsInput | $Enums.AccountTypeTag
    group?: EnumYesNoFieldUpdateOperationsInput | $Enums.YesNo
    plannedBy?: NullableEnumActPlanByFieldUpdateOperationsInput | $Enums.ActPlanBy | null
    actualsBy?: NullableEnumActActualsByFieldUpdateOperationsInput | $Enums.ActActualsBy | null
    displayAs?: EnumActDisplayAsFieldUpdateOperationsInput | $Enums.ActDisplayAs
    containsSalaryInfo?: EnumYesNoFieldUpdateOperationsInput | $Enums.YesNo
    description?: NullableStringFieldUpdateOperationsInput | string | null
    instanceId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    AttributeAndValues?: AccountAttributeAndValueUncheckedUpdateManyWithoutAccountNestedInput
    modelAccounts?: ModelAccountStructureUncheckedUpdateManyWithoutAccountNestedInput
    modelData?: ModelDataUncheckedUpdateManyWithoutAccountNestedInput
    modeldataCalculations?: ModelDataCalculationsUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type AccountUpsertWithWhereUniqueWithoutParentInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutParentInput, AccountUncheckedUpdateWithoutParentInput>
    create: XOR<AccountCreateWithoutParentInput, AccountUncheckedCreateWithoutParentInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutParentInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutParentInput, AccountUncheckedUpdateWithoutParentInput>
  }

  export type AccountUpdateManyWithWhereWithoutParentInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutParentInput>
  }

  export type AccountAttributeAndValueUpsertWithWhereUniqueWithoutAccountInput = {
    where: AccountAttributeAndValueWhereUniqueInput
    update: XOR<AccountAttributeAndValueUpdateWithoutAccountInput, AccountAttributeAndValueUncheckedUpdateWithoutAccountInput>
    create: XOR<AccountAttributeAndValueCreateWithoutAccountInput, AccountAttributeAndValueUncheckedCreateWithoutAccountInput>
  }

  export type AccountAttributeAndValueUpdateWithWhereUniqueWithoutAccountInput = {
    where: AccountAttributeAndValueWhereUniqueInput
    data: XOR<AccountAttributeAndValueUpdateWithoutAccountInput, AccountAttributeAndValueUncheckedUpdateWithoutAccountInput>
  }

  export type AccountAttributeAndValueUpdateManyWithWhereWithoutAccountInput = {
    where: AccountAttributeAndValueScalarWhereInput
    data: XOR<AccountAttributeAndValueUpdateManyMutationInput, AccountAttributeAndValueUncheckedUpdateManyWithoutAccountInput>
  }

  export type ModelAccountStructureUpsertWithWhereUniqueWithoutAccountInput = {
    where: ModelAccountStructureWhereUniqueInput
    update: XOR<ModelAccountStructureUpdateWithoutAccountInput, ModelAccountStructureUncheckedUpdateWithoutAccountInput>
    create: XOR<ModelAccountStructureCreateWithoutAccountInput, ModelAccountStructureUncheckedCreateWithoutAccountInput>
  }

  export type ModelAccountStructureUpdateWithWhereUniqueWithoutAccountInput = {
    where: ModelAccountStructureWhereUniqueInput
    data: XOR<ModelAccountStructureUpdateWithoutAccountInput, ModelAccountStructureUncheckedUpdateWithoutAccountInput>
  }

  export type ModelAccountStructureUpdateManyWithWhereWithoutAccountInput = {
    where: ModelAccountStructureScalarWhereInput
    data: XOR<ModelAccountStructureUpdateManyMutationInput, ModelAccountStructureUncheckedUpdateManyWithoutAccountInput>
  }

  export type ModelDataUpsertWithWhereUniqueWithoutAccountInput = {
    where: ModelDataWhereUniqueInput
    update: XOR<ModelDataUpdateWithoutAccountInput, ModelDataUncheckedUpdateWithoutAccountInput>
    create: XOR<ModelDataCreateWithoutAccountInput, ModelDataUncheckedCreateWithoutAccountInput>
  }

  export type ModelDataUpdateWithWhereUniqueWithoutAccountInput = {
    where: ModelDataWhereUniqueInput
    data: XOR<ModelDataUpdateWithoutAccountInput, ModelDataUncheckedUpdateWithoutAccountInput>
  }

  export type ModelDataUpdateManyWithWhereWithoutAccountInput = {
    where: ModelDataScalarWhereInput
    data: XOR<ModelDataUpdateManyMutationInput, ModelDataUncheckedUpdateManyWithoutAccountInput>
  }

  export type ModelDataCalculationsUpsertWithWhereUniqueWithoutAccountInput = {
    where: ModelDataCalculationsWhereUniqueInput
    update: XOR<ModelDataCalculationsUpdateWithoutAccountInput, ModelDataCalculationsUncheckedUpdateWithoutAccountInput>
    create: XOR<ModelDataCalculationsCreateWithoutAccountInput, ModelDataCalculationsUncheckedCreateWithoutAccountInput>
  }

  export type ModelDataCalculationsUpdateWithWhereUniqueWithoutAccountInput = {
    where: ModelDataCalculationsWhereUniqueInput
    data: XOR<ModelDataCalculationsUpdateWithoutAccountInput, ModelDataCalculationsUncheckedUpdateWithoutAccountInput>
  }

  export type ModelDataCalculationsUpdateManyWithWhereWithoutAccountInput = {
    where: ModelDataCalculationsScalarWhereInput
    data: XOR<ModelDataCalculationsUpdateManyMutationInput, ModelDataCalculationsUncheckedUpdateManyWithoutAccountInput>
  }

  export type InstanceCreateWithoutDimensionsInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    status?: $Enums.instanceStatus
    userIds?: InstanceCreateuserIdsInput | string[]
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    client: ClientCreateNestedOneWithoutInstancesInput
    levels?: LevelCreateNestedManyWithoutInstanceInput
    versions?: VersionCreateNestedManyWithoutInstanceInput
    currencies?: CurrencyCreateNestedManyWithoutInstanceInput
    accounts?: AccountCreateNestedManyWithoutInstanceInput
    models?: ModelCreateNestedManyWithoutInstanceInput
    dimensionValues?: DimensionValueCreateNestedManyWithoutInstanceInput
    levelAttributes?: LevelAttributeCreateNestedManyWithoutInstanceInput
    dimensionValueAttributes?: DimensionValueAttributeCreateNestedManyWithoutInstanceInput
    accountAttributes?: AccountAttributeCreateNestedManyWithoutInstanceInput
    levelAttValues?: LevelAttributeValueCreateNestedManyWithoutInstanceInput
    accountAttValues?: AccountAttributeValueCreateNestedManyWithoutInstanceInput
    dimensionValueAttributeValues?: DimensionValueAttributeValueCreateNestedManyWithoutInstanceInput
    modelData?: ModelDataCreateNestedManyWithoutInstanceInput
    modelDataCalculations?: ModelDataCalculationsCreateNestedManyWithoutInstanceInput
    modelAccounts?: ModelAccountStructureCreateNestedManyWithoutInstanceInput
    tables?: TableCreateNestedManyWithoutInstanceInput
    tableData?: TableDataCreateNestedManyWithoutInstanceInput
  }

  export type InstanceUncheckedCreateWithoutDimensionsInput = {
    id?: string
    code: string
    name: string
    clientId: string
    description?: string | null
    status?: $Enums.instanceStatus
    userIds?: InstanceCreateuserIdsInput | string[]
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    levels?: LevelUncheckedCreateNestedManyWithoutInstanceInput
    versions?: VersionUncheckedCreateNestedManyWithoutInstanceInput
    currencies?: CurrencyUncheckedCreateNestedManyWithoutInstanceInput
    accounts?: AccountUncheckedCreateNestedManyWithoutInstanceInput
    models?: ModelUncheckedCreateNestedManyWithoutInstanceInput
    dimensionValues?: DimensionValueUncheckedCreateNestedManyWithoutInstanceInput
    levelAttributes?: LevelAttributeUncheckedCreateNestedManyWithoutInstanceInput
    dimensionValueAttributes?: DimensionValueAttributeUncheckedCreateNestedManyWithoutInstanceInput
    accountAttributes?: AccountAttributeUncheckedCreateNestedManyWithoutInstanceInput
    levelAttValues?: LevelAttributeValueUncheckedCreateNestedManyWithoutInstanceInput
    accountAttValues?: AccountAttributeValueUncheckedCreateNestedManyWithoutInstanceInput
    dimensionValueAttributeValues?: DimensionValueAttributeValueUncheckedCreateNestedManyWithoutInstanceInput
    modelData?: ModelDataUncheckedCreateNestedManyWithoutInstanceInput
    modelDataCalculations?: ModelDataCalculationsUncheckedCreateNestedManyWithoutInstanceInput
    modelAccounts?: ModelAccountStructureUncheckedCreateNestedManyWithoutInstanceInput
    tables?: TableUncheckedCreateNestedManyWithoutInstanceInput
    tableData?: TableDataUncheckedCreateNestedManyWithoutInstanceInput
  }

  export type InstanceCreateOrConnectWithoutDimensionsInput = {
    where: InstanceWhereUniqueInput
    create: XOR<InstanceCreateWithoutDimensionsInput, InstanceUncheckedCreateWithoutDimensionsInput>
  }

  export type DimensionValueCreateWithoutDimensionInput = {
    id?: string
    code: string
    name: string
    clientId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    parent?: DimensionValueCreateNestedOneWithoutChildDimensionValuesInput
    childDimensionValues?: DimensionValueCreateNestedManyWithoutParentInput
    AttributeAndValues?: DimensionValueAttributeAndValueCreateNestedManyWithoutDimensionValueInput
    instance: InstanceCreateNestedOneWithoutDimensionValuesInput
  }

  export type DimensionValueUncheckedCreateWithoutDimensionInput = {
    id?: string
    code: string
    name: string
    parentId?: string | null
    clientId: string
    instanceId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    childDimensionValues?: DimensionValueUncheckedCreateNestedManyWithoutParentInput
    AttributeAndValues?: DimensionValueAttributeAndValueUncheckedCreateNestedManyWithoutDimensionValueInput
  }

  export type DimensionValueCreateOrConnectWithoutDimensionInput = {
    where: DimensionValueWhereUniqueInput
    create: XOR<DimensionValueCreateWithoutDimensionInput, DimensionValueUncheckedCreateWithoutDimensionInput>
  }

  export type DimensionValueCreateManyDimensionInputEnvelope = {
    data: DimensionValueCreateManyDimensionInput | DimensionValueCreateManyDimensionInput[]
  }

  export type InstanceUpsertWithoutDimensionsInput = {
    update: XOR<InstanceUpdateWithoutDimensionsInput, InstanceUncheckedUpdateWithoutDimensionsInput>
    create: XOR<InstanceCreateWithoutDimensionsInput, InstanceUncheckedCreateWithoutDimensionsInput>
    where?: InstanceWhereInput
  }

  export type InstanceUpdateToOneWithWhereWithoutDimensionsInput = {
    where?: InstanceWhereInput
    data: XOR<InstanceUpdateWithoutDimensionsInput, InstanceUncheckedUpdateWithoutDimensionsInput>
  }

  export type InstanceUpdateWithoutDimensionsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnuminstanceStatusFieldUpdateOperationsInput | $Enums.instanceStatus
    userIds?: InstanceUpdateuserIdsInput | string[]
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    client?: ClientUpdateOneRequiredWithoutInstancesNestedInput
    levels?: LevelUpdateManyWithoutInstanceNestedInput
    versions?: VersionUpdateManyWithoutInstanceNestedInput
    currencies?: CurrencyUpdateManyWithoutInstanceNestedInput
    accounts?: AccountUpdateManyWithoutInstanceNestedInput
    models?: ModelUpdateManyWithoutInstanceNestedInput
    dimensionValues?: DimensionValueUpdateManyWithoutInstanceNestedInput
    levelAttributes?: LevelAttributeUpdateManyWithoutInstanceNestedInput
    dimensionValueAttributes?: DimensionValueAttributeUpdateManyWithoutInstanceNestedInput
    accountAttributes?: AccountAttributeUpdateManyWithoutInstanceNestedInput
    levelAttValues?: LevelAttributeValueUpdateManyWithoutInstanceNestedInput
    accountAttValues?: AccountAttributeValueUpdateManyWithoutInstanceNestedInput
    dimensionValueAttributeValues?: DimensionValueAttributeValueUpdateManyWithoutInstanceNestedInput
    modelData?: ModelDataUpdateManyWithoutInstanceNestedInput
    modelDataCalculations?: ModelDataCalculationsUpdateManyWithoutInstanceNestedInput
    modelAccounts?: ModelAccountStructureUpdateManyWithoutInstanceNestedInput
    tables?: TableUpdateManyWithoutInstanceNestedInput
    tableData?: TableDataUpdateManyWithoutInstanceNestedInput
  }

  export type InstanceUncheckedUpdateWithoutDimensionsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnuminstanceStatusFieldUpdateOperationsInput | $Enums.instanceStatus
    userIds?: InstanceUpdateuserIdsInput | string[]
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    levels?: LevelUncheckedUpdateManyWithoutInstanceNestedInput
    versions?: VersionUncheckedUpdateManyWithoutInstanceNestedInput
    currencies?: CurrencyUncheckedUpdateManyWithoutInstanceNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutInstanceNestedInput
    models?: ModelUncheckedUpdateManyWithoutInstanceNestedInput
    dimensionValues?: DimensionValueUncheckedUpdateManyWithoutInstanceNestedInput
    levelAttributes?: LevelAttributeUncheckedUpdateManyWithoutInstanceNestedInput
    dimensionValueAttributes?: DimensionValueAttributeUncheckedUpdateManyWithoutInstanceNestedInput
    accountAttributes?: AccountAttributeUncheckedUpdateManyWithoutInstanceNestedInput
    levelAttValues?: LevelAttributeValueUncheckedUpdateManyWithoutInstanceNestedInput
    accountAttValues?: AccountAttributeValueUncheckedUpdateManyWithoutInstanceNestedInput
    dimensionValueAttributeValues?: DimensionValueAttributeValueUncheckedUpdateManyWithoutInstanceNestedInput
    modelData?: ModelDataUncheckedUpdateManyWithoutInstanceNestedInput
    modelDataCalculations?: ModelDataCalculationsUncheckedUpdateManyWithoutInstanceNestedInput
    modelAccounts?: ModelAccountStructureUncheckedUpdateManyWithoutInstanceNestedInput
    tables?: TableUncheckedUpdateManyWithoutInstanceNestedInput
    tableData?: TableDataUncheckedUpdateManyWithoutInstanceNestedInput
  }

  export type DimensionValueUpsertWithWhereUniqueWithoutDimensionInput = {
    where: DimensionValueWhereUniqueInput
    update: XOR<DimensionValueUpdateWithoutDimensionInput, DimensionValueUncheckedUpdateWithoutDimensionInput>
    create: XOR<DimensionValueCreateWithoutDimensionInput, DimensionValueUncheckedCreateWithoutDimensionInput>
  }

  export type DimensionValueUpdateWithWhereUniqueWithoutDimensionInput = {
    where: DimensionValueWhereUniqueInput
    data: XOR<DimensionValueUpdateWithoutDimensionInput, DimensionValueUncheckedUpdateWithoutDimensionInput>
  }

  export type DimensionValueUpdateManyWithWhereWithoutDimensionInput = {
    where: DimensionValueScalarWhereInput
    data: XOR<DimensionValueUpdateManyMutationInput, DimensionValueUncheckedUpdateManyWithoutDimensionInput>
  }

  export type DimensionValueCreateWithoutChildDimensionValuesInput = {
    id?: string
    code: string
    name: string
    clientId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    parent?: DimensionValueCreateNestedOneWithoutChildDimensionValuesInput
    AttributeAndValues?: DimensionValueAttributeAndValueCreateNestedManyWithoutDimensionValueInput
    instance: InstanceCreateNestedOneWithoutDimensionValuesInput
    dimension: DimensionCreateNestedOneWithoutDimensionValuesInput
  }

  export type DimensionValueUncheckedCreateWithoutChildDimensionValuesInput = {
    id?: string
    code: string
    name: string
    parentId?: string | null
    clientId: string
    instanceId: string
    dimensionId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    AttributeAndValues?: DimensionValueAttributeAndValueUncheckedCreateNestedManyWithoutDimensionValueInput
  }

  export type DimensionValueCreateOrConnectWithoutChildDimensionValuesInput = {
    where: DimensionValueWhereUniqueInput
    create: XOR<DimensionValueCreateWithoutChildDimensionValuesInput, DimensionValueUncheckedCreateWithoutChildDimensionValuesInput>
  }

  export type DimensionValueCreateWithoutParentInput = {
    id?: string
    code: string
    name: string
    clientId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    childDimensionValues?: DimensionValueCreateNestedManyWithoutParentInput
    AttributeAndValues?: DimensionValueAttributeAndValueCreateNestedManyWithoutDimensionValueInput
    instance: InstanceCreateNestedOneWithoutDimensionValuesInput
    dimension: DimensionCreateNestedOneWithoutDimensionValuesInput
  }

  export type DimensionValueUncheckedCreateWithoutParentInput = {
    id?: string
    code: string
    name: string
    clientId: string
    instanceId: string
    dimensionId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    childDimensionValues?: DimensionValueUncheckedCreateNestedManyWithoutParentInput
    AttributeAndValues?: DimensionValueAttributeAndValueUncheckedCreateNestedManyWithoutDimensionValueInput
  }

  export type DimensionValueCreateOrConnectWithoutParentInput = {
    where: DimensionValueWhereUniqueInput
    create: XOR<DimensionValueCreateWithoutParentInput, DimensionValueUncheckedCreateWithoutParentInput>
  }

  export type DimensionValueCreateManyParentInputEnvelope = {
    data: DimensionValueCreateManyParentInput | DimensionValueCreateManyParentInput[]
  }

  export type DimensionValueAttributeAndValueCreateWithoutDimensionValueInput = {
    id?: string
    clientId: string
    instanceId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    attribute?: DimensionValueAttributeCreateNestedOneWithoutAttributeAndValuesInput
    attributeValue?: DimensionValueAttributeValueCreateNestedOneWithoutDimensionAttributeAndValuesInput
  }

  export type DimensionValueAttributeAndValueUncheckedCreateWithoutDimensionValueInput = {
    id?: string
    clientId: string
    instanceId: string
    attributeId: string
    attributeValueId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type DimensionValueAttributeAndValueCreateOrConnectWithoutDimensionValueInput = {
    where: DimensionValueAttributeAndValueWhereUniqueInput
    create: XOR<DimensionValueAttributeAndValueCreateWithoutDimensionValueInput, DimensionValueAttributeAndValueUncheckedCreateWithoutDimensionValueInput>
  }

  export type DimensionValueAttributeAndValueCreateManyDimensionValueInputEnvelope = {
    data: DimensionValueAttributeAndValueCreateManyDimensionValueInput | DimensionValueAttributeAndValueCreateManyDimensionValueInput[]
  }

  export type InstanceCreateWithoutDimensionValuesInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    status?: $Enums.instanceStatus
    userIds?: InstanceCreateuserIdsInput | string[]
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    client: ClientCreateNestedOneWithoutInstancesInput
    levels?: LevelCreateNestedManyWithoutInstanceInput
    versions?: VersionCreateNestedManyWithoutInstanceInput
    currencies?: CurrencyCreateNestedManyWithoutInstanceInput
    accounts?: AccountCreateNestedManyWithoutInstanceInput
    models?: ModelCreateNestedManyWithoutInstanceInput
    dimensions?: DimensionCreateNestedManyWithoutInstanceInput
    levelAttributes?: LevelAttributeCreateNestedManyWithoutInstanceInput
    dimensionValueAttributes?: DimensionValueAttributeCreateNestedManyWithoutInstanceInput
    accountAttributes?: AccountAttributeCreateNestedManyWithoutInstanceInput
    levelAttValues?: LevelAttributeValueCreateNestedManyWithoutInstanceInput
    accountAttValues?: AccountAttributeValueCreateNestedManyWithoutInstanceInput
    dimensionValueAttributeValues?: DimensionValueAttributeValueCreateNestedManyWithoutInstanceInput
    modelData?: ModelDataCreateNestedManyWithoutInstanceInput
    modelDataCalculations?: ModelDataCalculationsCreateNestedManyWithoutInstanceInput
    modelAccounts?: ModelAccountStructureCreateNestedManyWithoutInstanceInput
    tables?: TableCreateNestedManyWithoutInstanceInput
    tableData?: TableDataCreateNestedManyWithoutInstanceInput
  }

  export type InstanceUncheckedCreateWithoutDimensionValuesInput = {
    id?: string
    code: string
    name: string
    clientId: string
    description?: string | null
    status?: $Enums.instanceStatus
    userIds?: InstanceCreateuserIdsInput | string[]
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    levels?: LevelUncheckedCreateNestedManyWithoutInstanceInput
    versions?: VersionUncheckedCreateNestedManyWithoutInstanceInput
    currencies?: CurrencyUncheckedCreateNestedManyWithoutInstanceInput
    accounts?: AccountUncheckedCreateNestedManyWithoutInstanceInput
    models?: ModelUncheckedCreateNestedManyWithoutInstanceInput
    dimensions?: DimensionUncheckedCreateNestedManyWithoutInstanceInput
    levelAttributes?: LevelAttributeUncheckedCreateNestedManyWithoutInstanceInput
    dimensionValueAttributes?: DimensionValueAttributeUncheckedCreateNestedManyWithoutInstanceInput
    accountAttributes?: AccountAttributeUncheckedCreateNestedManyWithoutInstanceInput
    levelAttValues?: LevelAttributeValueUncheckedCreateNestedManyWithoutInstanceInput
    accountAttValues?: AccountAttributeValueUncheckedCreateNestedManyWithoutInstanceInput
    dimensionValueAttributeValues?: DimensionValueAttributeValueUncheckedCreateNestedManyWithoutInstanceInput
    modelData?: ModelDataUncheckedCreateNestedManyWithoutInstanceInput
    modelDataCalculations?: ModelDataCalculationsUncheckedCreateNestedManyWithoutInstanceInput
    modelAccounts?: ModelAccountStructureUncheckedCreateNestedManyWithoutInstanceInput
    tables?: TableUncheckedCreateNestedManyWithoutInstanceInput
    tableData?: TableDataUncheckedCreateNestedManyWithoutInstanceInput
  }

  export type InstanceCreateOrConnectWithoutDimensionValuesInput = {
    where: InstanceWhereUniqueInput
    create: XOR<InstanceCreateWithoutDimensionValuesInput, InstanceUncheckedCreateWithoutDimensionValuesInput>
  }

  export type DimensionCreateWithoutDimensionValuesInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    dimensionValueDefault?: string | null
    clientId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    instance: InstanceCreateNestedOneWithoutDimensionsInput
  }

  export type DimensionUncheckedCreateWithoutDimensionValuesInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    dimensionValueDefault?: string | null
    clientId: string
    instanceId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type DimensionCreateOrConnectWithoutDimensionValuesInput = {
    where: DimensionWhereUniqueInput
    create: XOR<DimensionCreateWithoutDimensionValuesInput, DimensionUncheckedCreateWithoutDimensionValuesInput>
  }

  export type DimensionValueUpsertWithoutChildDimensionValuesInput = {
    update: XOR<DimensionValueUpdateWithoutChildDimensionValuesInput, DimensionValueUncheckedUpdateWithoutChildDimensionValuesInput>
    create: XOR<DimensionValueCreateWithoutChildDimensionValuesInput, DimensionValueUncheckedCreateWithoutChildDimensionValuesInput>
    where?: DimensionValueWhereInput
  }

  export type DimensionValueUpdateToOneWithWhereWithoutChildDimensionValuesInput = {
    where?: DimensionValueWhereInput
    data: XOR<DimensionValueUpdateWithoutChildDimensionValuesInput, DimensionValueUncheckedUpdateWithoutChildDimensionValuesInput>
  }

  export type DimensionValueUpdateWithoutChildDimensionValuesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parent?: DimensionValueUpdateOneWithoutChildDimensionValuesNestedInput
    AttributeAndValues?: DimensionValueAttributeAndValueUpdateManyWithoutDimensionValueNestedInput
    instance?: InstanceUpdateOneRequiredWithoutDimensionValuesNestedInput
    dimension?: DimensionUpdateOneRequiredWithoutDimensionValuesNestedInput
  }

  export type DimensionValueUncheckedUpdateWithoutChildDimensionValuesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    dimensionId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    AttributeAndValues?: DimensionValueAttributeAndValueUncheckedUpdateManyWithoutDimensionValueNestedInput
  }

  export type DimensionValueUpsertWithWhereUniqueWithoutParentInput = {
    where: DimensionValueWhereUniqueInput
    update: XOR<DimensionValueUpdateWithoutParentInput, DimensionValueUncheckedUpdateWithoutParentInput>
    create: XOR<DimensionValueCreateWithoutParentInput, DimensionValueUncheckedCreateWithoutParentInput>
  }

  export type DimensionValueUpdateWithWhereUniqueWithoutParentInput = {
    where: DimensionValueWhereUniqueInput
    data: XOR<DimensionValueUpdateWithoutParentInput, DimensionValueUncheckedUpdateWithoutParentInput>
  }

  export type DimensionValueUpdateManyWithWhereWithoutParentInput = {
    where: DimensionValueScalarWhereInput
    data: XOR<DimensionValueUpdateManyMutationInput, DimensionValueUncheckedUpdateManyWithoutParentInput>
  }

  export type DimensionValueAttributeAndValueUpsertWithWhereUniqueWithoutDimensionValueInput = {
    where: DimensionValueAttributeAndValueWhereUniqueInput
    update: XOR<DimensionValueAttributeAndValueUpdateWithoutDimensionValueInput, DimensionValueAttributeAndValueUncheckedUpdateWithoutDimensionValueInput>
    create: XOR<DimensionValueAttributeAndValueCreateWithoutDimensionValueInput, DimensionValueAttributeAndValueUncheckedCreateWithoutDimensionValueInput>
  }

  export type DimensionValueAttributeAndValueUpdateWithWhereUniqueWithoutDimensionValueInput = {
    where: DimensionValueAttributeAndValueWhereUniqueInput
    data: XOR<DimensionValueAttributeAndValueUpdateWithoutDimensionValueInput, DimensionValueAttributeAndValueUncheckedUpdateWithoutDimensionValueInput>
  }

  export type DimensionValueAttributeAndValueUpdateManyWithWhereWithoutDimensionValueInput = {
    where: DimensionValueAttributeAndValueScalarWhereInput
    data: XOR<DimensionValueAttributeAndValueUpdateManyMutationInput, DimensionValueAttributeAndValueUncheckedUpdateManyWithoutDimensionValueInput>
  }

  export type DimensionValueAttributeAndValueScalarWhereInput = {
    AND?: DimensionValueAttributeAndValueScalarWhereInput | DimensionValueAttributeAndValueScalarWhereInput[]
    OR?: DimensionValueAttributeAndValueScalarWhereInput[]
    NOT?: DimensionValueAttributeAndValueScalarWhereInput | DimensionValueAttributeAndValueScalarWhereInput[]
    id?: StringFilter<"DimensionValueAttributeAndValue"> | string
    clientId?: StringFilter<"DimensionValueAttributeAndValue"> | string
    instanceId?: StringFilter<"DimensionValueAttributeAndValue"> | string
    attributeId?: StringFilter<"DimensionValueAttributeAndValue"> | string
    attributeValueId?: StringFilter<"DimensionValueAttributeAndValue"> | string
    dimensionValueId?: StringFilter<"DimensionValueAttributeAndValue"> | string
    createdAt?: DateTimeNullableFilter<"DimensionValueAttributeAndValue"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"DimensionValueAttributeAndValue"> | Date | string | null
  }

  export type InstanceUpsertWithoutDimensionValuesInput = {
    update: XOR<InstanceUpdateWithoutDimensionValuesInput, InstanceUncheckedUpdateWithoutDimensionValuesInput>
    create: XOR<InstanceCreateWithoutDimensionValuesInput, InstanceUncheckedCreateWithoutDimensionValuesInput>
    where?: InstanceWhereInput
  }

  export type InstanceUpdateToOneWithWhereWithoutDimensionValuesInput = {
    where?: InstanceWhereInput
    data: XOR<InstanceUpdateWithoutDimensionValuesInput, InstanceUncheckedUpdateWithoutDimensionValuesInput>
  }

  export type InstanceUpdateWithoutDimensionValuesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnuminstanceStatusFieldUpdateOperationsInput | $Enums.instanceStatus
    userIds?: InstanceUpdateuserIdsInput | string[]
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    client?: ClientUpdateOneRequiredWithoutInstancesNestedInput
    levels?: LevelUpdateManyWithoutInstanceNestedInput
    versions?: VersionUpdateManyWithoutInstanceNestedInput
    currencies?: CurrencyUpdateManyWithoutInstanceNestedInput
    accounts?: AccountUpdateManyWithoutInstanceNestedInput
    models?: ModelUpdateManyWithoutInstanceNestedInput
    dimensions?: DimensionUpdateManyWithoutInstanceNestedInput
    levelAttributes?: LevelAttributeUpdateManyWithoutInstanceNestedInput
    dimensionValueAttributes?: DimensionValueAttributeUpdateManyWithoutInstanceNestedInput
    accountAttributes?: AccountAttributeUpdateManyWithoutInstanceNestedInput
    levelAttValues?: LevelAttributeValueUpdateManyWithoutInstanceNestedInput
    accountAttValues?: AccountAttributeValueUpdateManyWithoutInstanceNestedInput
    dimensionValueAttributeValues?: DimensionValueAttributeValueUpdateManyWithoutInstanceNestedInput
    modelData?: ModelDataUpdateManyWithoutInstanceNestedInput
    modelDataCalculations?: ModelDataCalculationsUpdateManyWithoutInstanceNestedInput
    modelAccounts?: ModelAccountStructureUpdateManyWithoutInstanceNestedInput
    tables?: TableUpdateManyWithoutInstanceNestedInput
    tableData?: TableDataUpdateManyWithoutInstanceNestedInput
  }

  export type InstanceUncheckedUpdateWithoutDimensionValuesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnuminstanceStatusFieldUpdateOperationsInput | $Enums.instanceStatus
    userIds?: InstanceUpdateuserIdsInput | string[]
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    levels?: LevelUncheckedUpdateManyWithoutInstanceNestedInput
    versions?: VersionUncheckedUpdateManyWithoutInstanceNestedInput
    currencies?: CurrencyUncheckedUpdateManyWithoutInstanceNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutInstanceNestedInput
    models?: ModelUncheckedUpdateManyWithoutInstanceNestedInput
    dimensions?: DimensionUncheckedUpdateManyWithoutInstanceNestedInput
    levelAttributes?: LevelAttributeUncheckedUpdateManyWithoutInstanceNestedInput
    dimensionValueAttributes?: DimensionValueAttributeUncheckedUpdateManyWithoutInstanceNestedInput
    accountAttributes?: AccountAttributeUncheckedUpdateManyWithoutInstanceNestedInput
    levelAttValues?: LevelAttributeValueUncheckedUpdateManyWithoutInstanceNestedInput
    accountAttValues?: AccountAttributeValueUncheckedUpdateManyWithoutInstanceNestedInput
    dimensionValueAttributeValues?: DimensionValueAttributeValueUncheckedUpdateManyWithoutInstanceNestedInput
    modelData?: ModelDataUncheckedUpdateManyWithoutInstanceNestedInput
    modelDataCalculations?: ModelDataCalculationsUncheckedUpdateManyWithoutInstanceNestedInput
    modelAccounts?: ModelAccountStructureUncheckedUpdateManyWithoutInstanceNestedInput
    tables?: TableUncheckedUpdateManyWithoutInstanceNestedInput
    tableData?: TableDataUncheckedUpdateManyWithoutInstanceNestedInput
  }

  export type DimensionUpsertWithoutDimensionValuesInput = {
    update: XOR<DimensionUpdateWithoutDimensionValuesInput, DimensionUncheckedUpdateWithoutDimensionValuesInput>
    create: XOR<DimensionCreateWithoutDimensionValuesInput, DimensionUncheckedCreateWithoutDimensionValuesInput>
    where?: DimensionWhereInput
  }

  export type DimensionUpdateToOneWithWhereWithoutDimensionValuesInput = {
    where?: DimensionWhereInput
    data: XOR<DimensionUpdateWithoutDimensionValuesInput, DimensionUncheckedUpdateWithoutDimensionValuesInput>
  }

  export type DimensionUpdateWithoutDimensionValuesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dimensionValueDefault?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instance?: InstanceUpdateOneRequiredWithoutDimensionsNestedInput
  }

  export type DimensionUncheckedUpdateWithoutDimensionValuesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dimensionValueDefault?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InstanceCreateWithoutDimensionValueAttributesInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    status?: $Enums.instanceStatus
    userIds?: InstanceCreateuserIdsInput | string[]
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    client: ClientCreateNestedOneWithoutInstancesInput
    levels?: LevelCreateNestedManyWithoutInstanceInput
    versions?: VersionCreateNestedManyWithoutInstanceInput
    currencies?: CurrencyCreateNestedManyWithoutInstanceInput
    accounts?: AccountCreateNestedManyWithoutInstanceInput
    models?: ModelCreateNestedManyWithoutInstanceInput
    dimensions?: DimensionCreateNestedManyWithoutInstanceInput
    dimensionValues?: DimensionValueCreateNestedManyWithoutInstanceInput
    levelAttributes?: LevelAttributeCreateNestedManyWithoutInstanceInput
    accountAttributes?: AccountAttributeCreateNestedManyWithoutInstanceInput
    levelAttValues?: LevelAttributeValueCreateNestedManyWithoutInstanceInput
    accountAttValues?: AccountAttributeValueCreateNestedManyWithoutInstanceInput
    dimensionValueAttributeValues?: DimensionValueAttributeValueCreateNestedManyWithoutInstanceInput
    modelData?: ModelDataCreateNestedManyWithoutInstanceInput
    modelDataCalculations?: ModelDataCalculationsCreateNestedManyWithoutInstanceInput
    modelAccounts?: ModelAccountStructureCreateNestedManyWithoutInstanceInput
    tables?: TableCreateNestedManyWithoutInstanceInput
    tableData?: TableDataCreateNestedManyWithoutInstanceInput
  }

  export type InstanceUncheckedCreateWithoutDimensionValueAttributesInput = {
    id?: string
    code: string
    name: string
    clientId: string
    description?: string | null
    status?: $Enums.instanceStatus
    userIds?: InstanceCreateuserIdsInput | string[]
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    levels?: LevelUncheckedCreateNestedManyWithoutInstanceInput
    versions?: VersionUncheckedCreateNestedManyWithoutInstanceInput
    currencies?: CurrencyUncheckedCreateNestedManyWithoutInstanceInput
    accounts?: AccountUncheckedCreateNestedManyWithoutInstanceInput
    models?: ModelUncheckedCreateNestedManyWithoutInstanceInput
    dimensions?: DimensionUncheckedCreateNestedManyWithoutInstanceInput
    dimensionValues?: DimensionValueUncheckedCreateNestedManyWithoutInstanceInput
    levelAttributes?: LevelAttributeUncheckedCreateNestedManyWithoutInstanceInput
    accountAttributes?: AccountAttributeUncheckedCreateNestedManyWithoutInstanceInput
    levelAttValues?: LevelAttributeValueUncheckedCreateNestedManyWithoutInstanceInput
    accountAttValues?: AccountAttributeValueUncheckedCreateNestedManyWithoutInstanceInput
    dimensionValueAttributeValues?: DimensionValueAttributeValueUncheckedCreateNestedManyWithoutInstanceInput
    modelData?: ModelDataUncheckedCreateNestedManyWithoutInstanceInput
    modelDataCalculations?: ModelDataCalculationsUncheckedCreateNestedManyWithoutInstanceInput
    modelAccounts?: ModelAccountStructureUncheckedCreateNestedManyWithoutInstanceInput
    tables?: TableUncheckedCreateNestedManyWithoutInstanceInput
    tableData?: TableDataUncheckedCreateNestedManyWithoutInstanceInput
  }

  export type InstanceCreateOrConnectWithoutDimensionValueAttributesInput = {
    where: InstanceWhereUniqueInput
    create: XOR<InstanceCreateWithoutDimensionValueAttributesInput, InstanceUncheckedCreateWithoutDimensionValueAttributesInput>
  }

  export type DimensionValueAttributeValueCreateWithoutDimensionValueAttributeInput = {
    id?: string
    code: string
    name: string
    clientId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    instance: InstanceCreateNestedOneWithoutDimensionValueAttributeValuesInput
    parent?: DimensionValueAttributeValueCreateNestedOneWithoutChildAttributeValuesInput
    childAttributeValues?: DimensionValueAttributeValueCreateNestedManyWithoutParentInput
    dimensionAttributeAndValues?: DimensionValueAttributeAndValueCreateNestedManyWithoutAttributeValueInput
  }

  export type DimensionValueAttributeValueUncheckedCreateWithoutDimensionValueAttributeInput = {
    id?: string
    code: string
    name: string
    clientId: string
    parentId?: string | null
    instanceId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    childAttributeValues?: DimensionValueAttributeValueUncheckedCreateNestedManyWithoutParentInput
    dimensionAttributeAndValues?: DimensionValueAttributeAndValueUncheckedCreateNestedManyWithoutAttributeValueInput
  }

  export type DimensionValueAttributeValueCreateOrConnectWithoutDimensionValueAttributeInput = {
    where: DimensionValueAttributeValueWhereUniqueInput
    create: XOR<DimensionValueAttributeValueCreateWithoutDimensionValueAttributeInput, DimensionValueAttributeValueUncheckedCreateWithoutDimensionValueAttributeInput>
  }

  export type DimensionValueAttributeValueCreateManyDimensionValueAttributeInputEnvelope = {
    data: DimensionValueAttributeValueCreateManyDimensionValueAttributeInput | DimensionValueAttributeValueCreateManyDimensionValueAttributeInput[]
  }

  export type DimensionValueAttributeAndValueCreateWithoutAttributeInput = {
    id?: string
    clientId: string
    instanceId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    dimensionValue?: DimensionValueCreateNestedOneWithoutAttributeAndValuesInput
    attributeValue?: DimensionValueAttributeValueCreateNestedOneWithoutDimensionAttributeAndValuesInput
  }

  export type DimensionValueAttributeAndValueUncheckedCreateWithoutAttributeInput = {
    id?: string
    clientId: string
    instanceId: string
    attributeValueId: string
    dimensionValueId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type DimensionValueAttributeAndValueCreateOrConnectWithoutAttributeInput = {
    where: DimensionValueAttributeAndValueWhereUniqueInput
    create: XOR<DimensionValueAttributeAndValueCreateWithoutAttributeInput, DimensionValueAttributeAndValueUncheckedCreateWithoutAttributeInput>
  }

  export type DimensionValueAttributeAndValueCreateManyAttributeInputEnvelope = {
    data: DimensionValueAttributeAndValueCreateManyAttributeInput | DimensionValueAttributeAndValueCreateManyAttributeInput[]
  }

  export type InstanceUpsertWithoutDimensionValueAttributesInput = {
    update: XOR<InstanceUpdateWithoutDimensionValueAttributesInput, InstanceUncheckedUpdateWithoutDimensionValueAttributesInput>
    create: XOR<InstanceCreateWithoutDimensionValueAttributesInput, InstanceUncheckedCreateWithoutDimensionValueAttributesInput>
    where?: InstanceWhereInput
  }

  export type InstanceUpdateToOneWithWhereWithoutDimensionValueAttributesInput = {
    where?: InstanceWhereInput
    data: XOR<InstanceUpdateWithoutDimensionValueAttributesInput, InstanceUncheckedUpdateWithoutDimensionValueAttributesInput>
  }

  export type InstanceUpdateWithoutDimensionValueAttributesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnuminstanceStatusFieldUpdateOperationsInput | $Enums.instanceStatus
    userIds?: InstanceUpdateuserIdsInput | string[]
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    client?: ClientUpdateOneRequiredWithoutInstancesNestedInput
    levels?: LevelUpdateManyWithoutInstanceNestedInput
    versions?: VersionUpdateManyWithoutInstanceNestedInput
    currencies?: CurrencyUpdateManyWithoutInstanceNestedInput
    accounts?: AccountUpdateManyWithoutInstanceNestedInput
    models?: ModelUpdateManyWithoutInstanceNestedInput
    dimensions?: DimensionUpdateManyWithoutInstanceNestedInput
    dimensionValues?: DimensionValueUpdateManyWithoutInstanceNestedInput
    levelAttributes?: LevelAttributeUpdateManyWithoutInstanceNestedInput
    accountAttributes?: AccountAttributeUpdateManyWithoutInstanceNestedInput
    levelAttValues?: LevelAttributeValueUpdateManyWithoutInstanceNestedInput
    accountAttValues?: AccountAttributeValueUpdateManyWithoutInstanceNestedInput
    dimensionValueAttributeValues?: DimensionValueAttributeValueUpdateManyWithoutInstanceNestedInput
    modelData?: ModelDataUpdateManyWithoutInstanceNestedInput
    modelDataCalculations?: ModelDataCalculationsUpdateManyWithoutInstanceNestedInput
    modelAccounts?: ModelAccountStructureUpdateManyWithoutInstanceNestedInput
    tables?: TableUpdateManyWithoutInstanceNestedInput
    tableData?: TableDataUpdateManyWithoutInstanceNestedInput
  }

  export type InstanceUncheckedUpdateWithoutDimensionValueAttributesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnuminstanceStatusFieldUpdateOperationsInput | $Enums.instanceStatus
    userIds?: InstanceUpdateuserIdsInput | string[]
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    levels?: LevelUncheckedUpdateManyWithoutInstanceNestedInput
    versions?: VersionUncheckedUpdateManyWithoutInstanceNestedInput
    currencies?: CurrencyUncheckedUpdateManyWithoutInstanceNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutInstanceNestedInput
    models?: ModelUncheckedUpdateManyWithoutInstanceNestedInput
    dimensions?: DimensionUncheckedUpdateManyWithoutInstanceNestedInput
    dimensionValues?: DimensionValueUncheckedUpdateManyWithoutInstanceNestedInput
    levelAttributes?: LevelAttributeUncheckedUpdateManyWithoutInstanceNestedInput
    accountAttributes?: AccountAttributeUncheckedUpdateManyWithoutInstanceNestedInput
    levelAttValues?: LevelAttributeValueUncheckedUpdateManyWithoutInstanceNestedInput
    accountAttValues?: AccountAttributeValueUncheckedUpdateManyWithoutInstanceNestedInput
    dimensionValueAttributeValues?: DimensionValueAttributeValueUncheckedUpdateManyWithoutInstanceNestedInput
    modelData?: ModelDataUncheckedUpdateManyWithoutInstanceNestedInput
    modelDataCalculations?: ModelDataCalculationsUncheckedUpdateManyWithoutInstanceNestedInput
    modelAccounts?: ModelAccountStructureUncheckedUpdateManyWithoutInstanceNestedInput
    tables?: TableUncheckedUpdateManyWithoutInstanceNestedInput
    tableData?: TableDataUncheckedUpdateManyWithoutInstanceNestedInput
  }

  export type DimensionValueAttributeValueUpsertWithWhereUniqueWithoutDimensionValueAttributeInput = {
    where: DimensionValueAttributeValueWhereUniqueInput
    update: XOR<DimensionValueAttributeValueUpdateWithoutDimensionValueAttributeInput, DimensionValueAttributeValueUncheckedUpdateWithoutDimensionValueAttributeInput>
    create: XOR<DimensionValueAttributeValueCreateWithoutDimensionValueAttributeInput, DimensionValueAttributeValueUncheckedCreateWithoutDimensionValueAttributeInput>
  }

  export type DimensionValueAttributeValueUpdateWithWhereUniqueWithoutDimensionValueAttributeInput = {
    where: DimensionValueAttributeValueWhereUniqueInput
    data: XOR<DimensionValueAttributeValueUpdateWithoutDimensionValueAttributeInput, DimensionValueAttributeValueUncheckedUpdateWithoutDimensionValueAttributeInput>
  }

  export type DimensionValueAttributeValueUpdateManyWithWhereWithoutDimensionValueAttributeInput = {
    where: DimensionValueAttributeValueScalarWhereInput
    data: XOR<DimensionValueAttributeValueUpdateManyMutationInput, DimensionValueAttributeValueUncheckedUpdateManyWithoutDimensionValueAttributeInput>
  }

  export type DimensionValueAttributeAndValueUpsertWithWhereUniqueWithoutAttributeInput = {
    where: DimensionValueAttributeAndValueWhereUniqueInput
    update: XOR<DimensionValueAttributeAndValueUpdateWithoutAttributeInput, DimensionValueAttributeAndValueUncheckedUpdateWithoutAttributeInput>
    create: XOR<DimensionValueAttributeAndValueCreateWithoutAttributeInput, DimensionValueAttributeAndValueUncheckedCreateWithoutAttributeInput>
  }

  export type DimensionValueAttributeAndValueUpdateWithWhereUniqueWithoutAttributeInput = {
    where: DimensionValueAttributeAndValueWhereUniqueInput
    data: XOR<DimensionValueAttributeAndValueUpdateWithoutAttributeInput, DimensionValueAttributeAndValueUncheckedUpdateWithoutAttributeInput>
  }

  export type DimensionValueAttributeAndValueUpdateManyWithWhereWithoutAttributeInput = {
    where: DimensionValueAttributeAndValueScalarWhereInput
    data: XOR<DimensionValueAttributeAndValueUpdateManyMutationInput, DimensionValueAttributeAndValueUncheckedUpdateManyWithoutAttributeInput>
  }

  export type InstanceCreateWithoutDimensionValueAttributeValuesInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    status?: $Enums.instanceStatus
    userIds?: InstanceCreateuserIdsInput | string[]
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    client: ClientCreateNestedOneWithoutInstancesInput
    levels?: LevelCreateNestedManyWithoutInstanceInput
    versions?: VersionCreateNestedManyWithoutInstanceInput
    currencies?: CurrencyCreateNestedManyWithoutInstanceInput
    accounts?: AccountCreateNestedManyWithoutInstanceInput
    models?: ModelCreateNestedManyWithoutInstanceInput
    dimensions?: DimensionCreateNestedManyWithoutInstanceInput
    dimensionValues?: DimensionValueCreateNestedManyWithoutInstanceInput
    levelAttributes?: LevelAttributeCreateNestedManyWithoutInstanceInput
    dimensionValueAttributes?: DimensionValueAttributeCreateNestedManyWithoutInstanceInput
    accountAttributes?: AccountAttributeCreateNestedManyWithoutInstanceInput
    levelAttValues?: LevelAttributeValueCreateNestedManyWithoutInstanceInput
    accountAttValues?: AccountAttributeValueCreateNestedManyWithoutInstanceInput
    modelData?: ModelDataCreateNestedManyWithoutInstanceInput
    modelDataCalculations?: ModelDataCalculationsCreateNestedManyWithoutInstanceInput
    modelAccounts?: ModelAccountStructureCreateNestedManyWithoutInstanceInput
    tables?: TableCreateNestedManyWithoutInstanceInput
    tableData?: TableDataCreateNestedManyWithoutInstanceInput
  }

  export type InstanceUncheckedCreateWithoutDimensionValueAttributeValuesInput = {
    id?: string
    code: string
    name: string
    clientId: string
    description?: string | null
    status?: $Enums.instanceStatus
    userIds?: InstanceCreateuserIdsInput | string[]
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    levels?: LevelUncheckedCreateNestedManyWithoutInstanceInput
    versions?: VersionUncheckedCreateNestedManyWithoutInstanceInput
    currencies?: CurrencyUncheckedCreateNestedManyWithoutInstanceInput
    accounts?: AccountUncheckedCreateNestedManyWithoutInstanceInput
    models?: ModelUncheckedCreateNestedManyWithoutInstanceInput
    dimensions?: DimensionUncheckedCreateNestedManyWithoutInstanceInput
    dimensionValues?: DimensionValueUncheckedCreateNestedManyWithoutInstanceInput
    levelAttributes?: LevelAttributeUncheckedCreateNestedManyWithoutInstanceInput
    dimensionValueAttributes?: DimensionValueAttributeUncheckedCreateNestedManyWithoutInstanceInput
    accountAttributes?: AccountAttributeUncheckedCreateNestedManyWithoutInstanceInput
    levelAttValues?: LevelAttributeValueUncheckedCreateNestedManyWithoutInstanceInput
    accountAttValues?: AccountAttributeValueUncheckedCreateNestedManyWithoutInstanceInput
    modelData?: ModelDataUncheckedCreateNestedManyWithoutInstanceInput
    modelDataCalculations?: ModelDataCalculationsUncheckedCreateNestedManyWithoutInstanceInput
    modelAccounts?: ModelAccountStructureUncheckedCreateNestedManyWithoutInstanceInput
    tables?: TableUncheckedCreateNestedManyWithoutInstanceInput
    tableData?: TableDataUncheckedCreateNestedManyWithoutInstanceInput
  }

  export type InstanceCreateOrConnectWithoutDimensionValueAttributeValuesInput = {
    where: InstanceWhereUniqueInput
    create: XOR<InstanceCreateWithoutDimensionValueAttributeValuesInput, InstanceUncheckedCreateWithoutDimensionValueAttributeValuesInput>
  }

  export type DimensionValueAttributeValueCreateWithoutChildAttributeValuesInput = {
    id?: string
    code: string
    name: string
    clientId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    instance: InstanceCreateNestedOneWithoutDimensionValueAttributeValuesInput
    parent?: DimensionValueAttributeValueCreateNestedOneWithoutChildAttributeValuesInput
    dimensionValueAttribute: DimensionValueAttributeCreateNestedOneWithoutAttributeValuesInput
    dimensionAttributeAndValues?: DimensionValueAttributeAndValueCreateNestedManyWithoutAttributeValueInput
  }

  export type DimensionValueAttributeValueUncheckedCreateWithoutChildAttributeValuesInput = {
    id?: string
    code: string
    name: string
    attributeId: string
    clientId: string
    parentId?: string | null
    instanceId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    dimensionAttributeAndValues?: DimensionValueAttributeAndValueUncheckedCreateNestedManyWithoutAttributeValueInput
  }

  export type DimensionValueAttributeValueCreateOrConnectWithoutChildAttributeValuesInput = {
    where: DimensionValueAttributeValueWhereUniqueInput
    create: XOR<DimensionValueAttributeValueCreateWithoutChildAttributeValuesInput, DimensionValueAttributeValueUncheckedCreateWithoutChildAttributeValuesInput>
  }

  export type DimensionValueAttributeValueCreateWithoutParentInput = {
    id?: string
    code: string
    name: string
    clientId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    instance: InstanceCreateNestedOneWithoutDimensionValueAttributeValuesInput
    childAttributeValues?: DimensionValueAttributeValueCreateNestedManyWithoutParentInput
    dimensionValueAttribute: DimensionValueAttributeCreateNestedOneWithoutAttributeValuesInput
    dimensionAttributeAndValues?: DimensionValueAttributeAndValueCreateNestedManyWithoutAttributeValueInput
  }

  export type DimensionValueAttributeValueUncheckedCreateWithoutParentInput = {
    id?: string
    code: string
    name: string
    attributeId: string
    clientId: string
    instanceId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    childAttributeValues?: DimensionValueAttributeValueUncheckedCreateNestedManyWithoutParentInput
    dimensionAttributeAndValues?: DimensionValueAttributeAndValueUncheckedCreateNestedManyWithoutAttributeValueInput
  }

  export type DimensionValueAttributeValueCreateOrConnectWithoutParentInput = {
    where: DimensionValueAttributeValueWhereUniqueInput
    create: XOR<DimensionValueAttributeValueCreateWithoutParentInput, DimensionValueAttributeValueUncheckedCreateWithoutParentInput>
  }

  export type DimensionValueAttributeValueCreateManyParentInputEnvelope = {
    data: DimensionValueAttributeValueCreateManyParentInput | DimensionValueAttributeValueCreateManyParentInput[]
  }

  export type DimensionValueAttributeCreateWithoutAttributeValuesInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    clientId: string
    updatedAt?: Date | string | null
    createdAt?: Date | string | null
    instance: InstanceCreateNestedOneWithoutDimensionValueAttributesInput
    AttributeAndValues?: DimensionValueAttributeAndValueCreateNestedManyWithoutAttributeInput
  }

  export type DimensionValueAttributeUncheckedCreateWithoutAttributeValuesInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    clientId: string
    instanceId: string
    updatedAt?: Date | string | null
    createdAt?: Date | string | null
    AttributeAndValues?: DimensionValueAttributeAndValueUncheckedCreateNestedManyWithoutAttributeInput
  }

  export type DimensionValueAttributeCreateOrConnectWithoutAttributeValuesInput = {
    where: DimensionValueAttributeWhereUniqueInput
    create: XOR<DimensionValueAttributeCreateWithoutAttributeValuesInput, DimensionValueAttributeUncheckedCreateWithoutAttributeValuesInput>
  }

  export type DimensionValueAttributeAndValueCreateWithoutAttributeValueInput = {
    id?: string
    clientId: string
    instanceId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    dimensionValue?: DimensionValueCreateNestedOneWithoutAttributeAndValuesInput
    attribute?: DimensionValueAttributeCreateNestedOneWithoutAttributeAndValuesInput
  }

  export type DimensionValueAttributeAndValueUncheckedCreateWithoutAttributeValueInput = {
    id?: string
    clientId: string
    instanceId: string
    attributeId: string
    dimensionValueId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type DimensionValueAttributeAndValueCreateOrConnectWithoutAttributeValueInput = {
    where: DimensionValueAttributeAndValueWhereUniqueInput
    create: XOR<DimensionValueAttributeAndValueCreateWithoutAttributeValueInput, DimensionValueAttributeAndValueUncheckedCreateWithoutAttributeValueInput>
  }

  export type DimensionValueAttributeAndValueCreateManyAttributeValueInputEnvelope = {
    data: DimensionValueAttributeAndValueCreateManyAttributeValueInput | DimensionValueAttributeAndValueCreateManyAttributeValueInput[]
  }

  export type InstanceUpsertWithoutDimensionValueAttributeValuesInput = {
    update: XOR<InstanceUpdateWithoutDimensionValueAttributeValuesInput, InstanceUncheckedUpdateWithoutDimensionValueAttributeValuesInput>
    create: XOR<InstanceCreateWithoutDimensionValueAttributeValuesInput, InstanceUncheckedCreateWithoutDimensionValueAttributeValuesInput>
    where?: InstanceWhereInput
  }

  export type InstanceUpdateToOneWithWhereWithoutDimensionValueAttributeValuesInput = {
    where?: InstanceWhereInput
    data: XOR<InstanceUpdateWithoutDimensionValueAttributeValuesInput, InstanceUncheckedUpdateWithoutDimensionValueAttributeValuesInput>
  }

  export type InstanceUpdateWithoutDimensionValueAttributeValuesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnuminstanceStatusFieldUpdateOperationsInput | $Enums.instanceStatus
    userIds?: InstanceUpdateuserIdsInput | string[]
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    client?: ClientUpdateOneRequiredWithoutInstancesNestedInput
    levels?: LevelUpdateManyWithoutInstanceNestedInput
    versions?: VersionUpdateManyWithoutInstanceNestedInput
    currencies?: CurrencyUpdateManyWithoutInstanceNestedInput
    accounts?: AccountUpdateManyWithoutInstanceNestedInput
    models?: ModelUpdateManyWithoutInstanceNestedInput
    dimensions?: DimensionUpdateManyWithoutInstanceNestedInput
    dimensionValues?: DimensionValueUpdateManyWithoutInstanceNestedInput
    levelAttributes?: LevelAttributeUpdateManyWithoutInstanceNestedInput
    dimensionValueAttributes?: DimensionValueAttributeUpdateManyWithoutInstanceNestedInput
    accountAttributes?: AccountAttributeUpdateManyWithoutInstanceNestedInput
    levelAttValues?: LevelAttributeValueUpdateManyWithoutInstanceNestedInput
    accountAttValues?: AccountAttributeValueUpdateManyWithoutInstanceNestedInput
    modelData?: ModelDataUpdateManyWithoutInstanceNestedInput
    modelDataCalculations?: ModelDataCalculationsUpdateManyWithoutInstanceNestedInput
    modelAccounts?: ModelAccountStructureUpdateManyWithoutInstanceNestedInput
    tables?: TableUpdateManyWithoutInstanceNestedInput
    tableData?: TableDataUpdateManyWithoutInstanceNestedInput
  }

  export type InstanceUncheckedUpdateWithoutDimensionValueAttributeValuesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnuminstanceStatusFieldUpdateOperationsInput | $Enums.instanceStatus
    userIds?: InstanceUpdateuserIdsInput | string[]
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    levels?: LevelUncheckedUpdateManyWithoutInstanceNestedInput
    versions?: VersionUncheckedUpdateManyWithoutInstanceNestedInput
    currencies?: CurrencyUncheckedUpdateManyWithoutInstanceNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutInstanceNestedInput
    models?: ModelUncheckedUpdateManyWithoutInstanceNestedInput
    dimensions?: DimensionUncheckedUpdateManyWithoutInstanceNestedInput
    dimensionValues?: DimensionValueUncheckedUpdateManyWithoutInstanceNestedInput
    levelAttributes?: LevelAttributeUncheckedUpdateManyWithoutInstanceNestedInput
    dimensionValueAttributes?: DimensionValueAttributeUncheckedUpdateManyWithoutInstanceNestedInput
    accountAttributes?: AccountAttributeUncheckedUpdateManyWithoutInstanceNestedInput
    levelAttValues?: LevelAttributeValueUncheckedUpdateManyWithoutInstanceNestedInput
    accountAttValues?: AccountAttributeValueUncheckedUpdateManyWithoutInstanceNestedInput
    modelData?: ModelDataUncheckedUpdateManyWithoutInstanceNestedInput
    modelDataCalculations?: ModelDataCalculationsUncheckedUpdateManyWithoutInstanceNestedInput
    modelAccounts?: ModelAccountStructureUncheckedUpdateManyWithoutInstanceNestedInput
    tables?: TableUncheckedUpdateManyWithoutInstanceNestedInput
    tableData?: TableDataUncheckedUpdateManyWithoutInstanceNestedInput
  }

  export type DimensionValueAttributeValueUpsertWithoutChildAttributeValuesInput = {
    update: XOR<DimensionValueAttributeValueUpdateWithoutChildAttributeValuesInput, DimensionValueAttributeValueUncheckedUpdateWithoutChildAttributeValuesInput>
    create: XOR<DimensionValueAttributeValueCreateWithoutChildAttributeValuesInput, DimensionValueAttributeValueUncheckedCreateWithoutChildAttributeValuesInput>
    where?: DimensionValueAttributeValueWhereInput
  }

  export type DimensionValueAttributeValueUpdateToOneWithWhereWithoutChildAttributeValuesInput = {
    where?: DimensionValueAttributeValueWhereInput
    data: XOR<DimensionValueAttributeValueUpdateWithoutChildAttributeValuesInput, DimensionValueAttributeValueUncheckedUpdateWithoutChildAttributeValuesInput>
  }

  export type DimensionValueAttributeValueUpdateWithoutChildAttributeValuesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instance?: InstanceUpdateOneRequiredWithoutDimensionValueAttributeValuesNestedInput
    parent?: DimensionValueAttributeValueUpdateOneWithoutChildAttributeValuesNestedInput
    dimensionValueAttribute?: DimensionValueAttributeUpdateOneRequiredWithoutAttributeValuesNestedInput
    dimensionAttributeAndValues?: DimensionValueAttributeAndValueUpdateManyWithoutAttributeValueNestedInput
  }

  export type DimensionValueAttributeValueUncheckedUpdateWithoutChildAttributeValuesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    attributeId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    instanceId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dimensionAttributeAndValues?: DimensionValueAttributeAndValueUncheckedUpdateManyWithoutAttributeValueNestedInput
  }

  export type DimensionValueAttributeValueUpsertWithWhereUniqueWithoutParentInput = {
    where: DimensionValueAttributeValueWhereUniqueInput
    update: XOR<DimensionValueAttributeValueUpdateWithoutParentInput, DimensionValueAttributeValueUncheckedUpdateWithoutParentInput>
    create: XOR<DimensionValueAttributeValueCreateWithoutParentInput, DimensionValueAttributeValueUncheckedCreateWithoutParentInput>
  }

  export type DimensionValueAttributeValueUpdateWithWhereUniqueWithoutParentInput = {
    where: DimensionValueAttributeValueWhereUniqueInput
    data: XOR<DimensionValueAttributeValueUpdateWithoutParentInput, DimensionValueAttributeValueUncheckedUpdateWithoutParentInput>
  }

  export type DimensionValueAttributeValueUpdateManyWithWhereWithoutParentInput = {
    where: DimensionValueAttributeValueScalarWhereInput
    data: XOR<DimensionValueAttributeValueUpdateManyMutationInput, DimensionValueAttributeValueUncheckedUpdateManyWithoutParentInput>
  }

  export type DimensionValueAttributeUpsertWithoutAttributeValuesInput = {
    update: XOR<DimensionValueAttributeUpdateWithoutAttributeValuesInput, DimensionValueAttributeUncheckedUpdateWithoutAttributeValuesInput>
    create: XOR<DimensionValueAttributeCreateWithoutAttributeValuesInput, DimensionValueAttributeUncheckedCreateWithoutAttributeValuesInput>
    where?: DimensionValueAttributeWhereInput
  }

  export type DimensionValueAttributeUpdateToOneWithWhereWithoutAttributeValuesInput = {
    where?: DimensionValueAttributeWhereInput
    data: XOR<DimensionValueAttributeUpdateWithoutAttributeValuesInput, DimensionValueAttributeUncheckedUpdateWithoutAttributeValuesInput>
  }

  export type DimensionValueAttributeUpdateWithoutAttributeValuesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instance?: InstanceUpdateOneRequiredWithoutDimensionValueAttributesNestedInput
    AttributeAndValues?: DimensionValueAttributeAndValueUpdateManyWithoutAttributeNestedInput
  }

  export type DimensionValueAttributeUncheckedUpdateWithoutAttributeValuesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    AttributeAndValues?: DimensionValueAttributeAndValueUncheckedUpdateManyWithoutAttributeNestedInput
  }

  export type DimensionValueAttributeAndValueUpsertWithWhereUniqueWithoutAttributeValueInput = {
    where: DimensionValueAttributeAndValueWhereUniqueInput
    update: XOR<DimensionValueAttributeAndValueUpdateWithoutAttributeValueInput, DimensionValueAttributeAndValueUncheckedUpdateWithoutAttributeValueInput>
    create: XOR<DimensionValueAttributeAndValueCreateWithoutAttributeValueInput, DimensionValueAttributeAndValueUncheckedCreateWithoutAttributeValueInput>
  }

  export type DimensionValueAttributeAndValueUpdateWithWhereUniqueWithoutAttributeValueInput = {
    where: DimensionValueAttributeAndValueWhereUniqueInput
    data: XOR<DimensionValueAttributeAndValueUpdateWithoutAttributeValueInput, DimensionValueAttributeAndValueUncheckedUpdateWithoutAttributeValueInput>
  }

  export type DimensionValueAttributeAndValueUpdateManyWithWhereWithoutAttributeValueInput = {
    where: DimensionValueAttributeAndValueScalarWhereInput
    data: XOR<DimensionValueAttributeAndValueUpdateManyMutationInput, DimensionValueAttributeAndValueUncheckedUpdateManyWithoutAttributeValueInput>
  }

  export type DimensionValueCreateWithoutAttributeAndValuesInput = {
    id?: string
    code: string
    name: string
    clientId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    parent?: DimensionValueCreateNestedOneWithoutChildDimensionValuesInput
    childDimensionValues?: DimensionValueCreateNestedManyWithoutParentInput
    instance: InstanceCreateNestedOneWithoutDimensionValuesInput
    dimension: DimensionCreateNestedOneWithoutDimensionValuesInput
  }

  export type DimensionValueUncheckedCreateWithoutAttributeAndValuesInput = {
    id?: string
    code: string
    name: string
    parentId?: string | null
    clientId: string
    instanceId: string
    dimensionId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    childDimensionValues?: DimensionValueUncheckedCreateNestedManyWithoutParentInput
  }

  export type DimensionValueCreateOrConnectWithoutAttributeAndValuesInput = {
    where: DimensionValueWhereUniqueInput
    create: XOR<DimensionValueCreateWithoutAttributeAndValuesInput, DimensionValueUncheckedCreateWithoutAttributeAndValuesInput>
  }

  export type DimensionValueAttributeCreateWithoutAttributeAndValuesInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    clientId: string
    updatedAt?: Date | string | null
    createdAt?: Date | string | null
    instance: InstanceCreateNestedOneWithoutDimensionValueAttributesInput
    AttributeValues?: DimensionValueAttributeValueCreateNestedManyWithoutDimensionValueAttributeInput
  }

  export type DimensionValueAttributeUncheckedCreateWithoutAttributeAndValuesInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    clientId: string
    instanceId: string
    updatedAt?: Date | string | null
    createdAt?: Date | string | null
    AttributeValues?: DimensionValueAttributeValueUncheckedCreateNestedManyWithoutDimensionValueAttributeInput
  }

  export type DimensionValueAttributeCreateOrConnectWithoutAttributeAndValuesInput = {
    where: DimensionValueAttributeWhereUniqueInput
    create: XOR<DimensionValueAttributeCreateWithoutAttributeAndValuesInput, DimensionValueAttributeUncheckedCreateWithoutAttributeAndValuesInput>
  }

  export type DimensionValueAttributeValueCreateWithoutDimensionAttributeAndValuesInput = {
    id?: string
    code: string
    name: string
    clientId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    instance: InstanceCreateNestedOneWithoutDimensionValueAttributeValuesInput
    parent?: DimensionValueAttributeValueCreateNestedOneWithoutChildAttributeValuesInput
    childAttributeValues?: DimensionValueAttributeValueCreateNestedManyWithoutParentInput
    dimensionValueAttribute: DimensionValueAttributeCreateNestedOneWithoutAttributeValuesInput
  }

  export type DimensionValueAttributeValueUncheckedCreateWithoutDimensionAttributeAndValuesInput = {
    id?: string
    code: string
    name: string
    attributeId: string
    clientId: string
    parentId?: string | null
    instanceId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    childAttributeValues?: DimensionValueAttributeValueUncheckedCreateNestedManyWithoutParentInput
  }

  export type DimensionValueAttributeValueCreateOrConnectWithoutDimensionAttributeAndValuesInput = {
    where: DimensionValueAttributeValueWhereUniqueInput
    create: XOR<DimensionValueAttributeValueCreateWithoutDimensionAttributeAndValuesInput, DimensionValueAttributeValueUncheckedCreateWithoutDimensionAttributeAndValuesInput>
  }

  export type DimensionValueUpsertWithoutAttributeAndValuesInput = {
    update: XOR<DimensionValueUpdateWithoutAttributeAndValuesInput, DimensionValueUncheckedUpdateWithoutAttributeAndValuesInput>
    create: XOR<DimensionValueCreateWithoutAttributeAndValuesInput, DimensionValueUncheckedCreateWithoutAttributeAndValuesInput>
    where?: DimensionValueWhereInput
  }

  export type DimensionValueUpdateToOneWithWhereWithoutAttributeAndValuesInput = {
    where?: DimensionValueWhereInput
    data: XOR<DimensionValueUpdateWithoutAttributeAndValuesInput, DimensionValueUncheckedUpdateWithoutAttributeAndValuesInput>
  }

  export type DimensionValueUpdateWithoutAttributeAndValuesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parent?: DimensionValueUpdateOneWithoutChildDimensionValuesNestedInput
    childDimensionValues?: DimensionValueUpdateManyWithoutParentNestedInput
    instance?: InstanceUpdateOneRequiredWithoutDimensionValuesNestedInput
    dimension?: DimensionUpdateOneRequiredWithoutDimensionValuesNestedInput
  }

  export type DimensionValueUncheckedUpdateWithoutAttributeAndValuesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    dimensionId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    childDimensionValues?: DimensionValueUncheckedUpdateManyWithoutParentNestedInput
  }

  export type DimensionValueAttributeUpsertWithoutAttributeAndValuesInput = {
    update: XOR<DimensionValueAttributeUpdateWithoutAttributeAndValuesInput, DimensionValueAttributeUncheckedUpdateWithoutAttributeAndValuesInput>
    create: XOR<DimensionValueAttributeCreateWithoutAttributeAndValuesInput, DimensionValueAttributeUncheckedCreateWithoutAttributeAndValuesInput>
    where?: DimensionValueAttributeWhereInput
  }

  export type DimensionValueAttributeUpdateToOneWithWhereWithoutAttributeAndValuesInput = {
    where?: DimensionValueAttributeWhereInput
    data: XOR<DimensionValueAttributeUpdateWithoutAttributeAndValuesInput, DimensionValueAttributeUncheckedUpdateWithoutAttributeAndValuesInput>
  }

  export type DimensionValueAttributeUpdateWithoutAttributeAndValuesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instance?: InstanceUpdateOneRequiredWithoutDimensionValueAttributesNestedInput
    AttributeValues?: DimensionValueAttributeValueUpdateManyWithoutDimensionValueAttributeNestedInput
  }

  export type DimensionValueAttributeUncheckedUpdateWithoutAttributeAndValuesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    AttributeValues?: DimensionValueAttributeValueUncheckedUpdateManyWithoutDimensionValueAttributeNestedInput
  }

  export type DimensionValueAttributeValueUpsertWithoutDimensionAttributeAndValuesInput = {
    update: XOR<DimensionValueAttributeValueUpdateWithoutDimensionAttributeAndValuesInput, DimensionValueAttributeValueUncheckedUpdateWithoutDimensionAttributeAndValuesInput>
    create: XOR<DimensionValueAttributeValueCreateWithoutDimensionAttributeAndValuesInput, DimensionValueAttributeValueUncheckedCreateWithoutDimensionAttributeAndValuesInput>
    where?: DimensionValueAttributeValueWhereInput
  }

  export type DimensionValueAttributeValueUpdateToOneWithWhereWithoutDimensionAttributeAndValuesInput = {
    where?: DimensionValueAttributeValueWhereInput
    data: XOR<DimensionValueAttributeValueUpdateWithoutDimensionAttributeAndValuesInput, DimensionValueAttributeValueUncheckedUpdateWithoutDimensionAttributeAndValuesInput>
  }

  export type DimensionValueAttributeValueUpdateWithoutDimensionAttributeAndValuesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instance?: InstanceUpdateOneRequiredWithoutDimensionValueAttributeValuesNestedInput
    parent?: DimensionValueAttributeValueUpdateOneWithoutChildAttributeValuesNestedInput
    childAttributeValues?: DimensionValueAttributeValueUpdateManyWithoutParentNestedInput
    dimensionValueAttribute?: DimensionValueAttributeUpdateOneRequiredWithoutAttributeValuesNestedInput
  }

  export type DimensionValueAttributeValueUncheckedUpdateWithoutDimensionAttributeAndValuesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    attributeId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    instanceId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    childAttributeValues?: DimensionValueAttributeValueUncheckedUpdateManyWithoutParentNestedInput
  }

  export type InstanceCreateWithoutModelsInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    status?: $Enums.instanceStatus
    userIds?: InstanceCreateuserIdsInput | string[]
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    client: ClientCreateNestedOneWithoutInstancesInput
    levels?: LevelCreateNestedManyWithoutInstanceInput
    versions?: VersionCreateNestedManyWithoutInstanceInput
    currencies?: CurrencyCreateNestedManyWithoutInstanceInput
    accounts?: AccountCreateNestedManyWithoutInstanceInput
    dimensions?: DimensionCreateNestedManyWithoutInstanceInput
    dimensionValues?: DimensionValueCreateNestedManyWithoutInstanceInput
    levelAttributes?: LevelAttributeCreateNestedManyWithoutInstanceInput
    dimensionValueAttributes?: DimensionValueAttributeCreateNestedManyWithoutInstanceInput
    accountAttributes?: AccountAttributeCreateNestedManyWithoutInstanceInput
    levelAttValues?: LevelAttributeValueCreateNestedManyWithoutInstanceInput
    accountAttValues?: AccountAttributeValueCreateNestedManyWithoutInstanceInput
    dimensionValueAttributeValues?: DimensionValueAttributeValueCreateNestedManyWithoutInstanceInput
    modelData?: ModelDataCreateNestedManyWithoutInstanceInput
    modelDataCalculations?: ModelDataCalculationsCreateNestedManyWithoutInstanceInput
    modelAccounts?: ModelAccountStructureCreateNestedManyWithoutInstanceInput
    tables?: TableCreateNestedManyWithoutInstanceInput
    tableData?: TableDataCreateNestedManyWithoutInstanceInput
  }

  export type InstanceUncheckedCreateWithoutModelsInput = {
    id?: string
    code: string
    name: string
    clientId: string
    description?: string | null
    status?: $Enums.instanceStatus
    userIds?: InstanceCreateuserIdsInput | string[]
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    levels?: LevelUncheckedCreateNestedManyWithoutInstanceInput
    versions?: VersionUncheckedCreateNestedManyWithoutInstanceInput
    currencies?: CurrencyUncheckedCreateNestedManyWithoutInstanceInput
    accounts?: AccountUncheckedCreateNestedManyWithoutInstanceInput
    dimensions?: DimensionUncheckedCreateNestedManyWithoutInstanceInput
    dimensionValues?: DimensionValueUncheckedCreateNestedManyWithoutInstanceInput
    levelAttributes?: LevelAttributeUncheckedCreateNestedManyWithoutInstanceInput
    dimensionValueAttributes?: DimensionValueAttributeUncheckedCreateNestedManyWithoutInstanceInput
    accountAttributes?: AccountAttributeUncheckedCreateNestedManyWithoutInstanceInput
    levelAttValues?: LevelAttributeValueUncheckedCreateNestedManyWithoutInstanceInput
    accountAttValues?: AccountAttributeValueUncheckedCreateNestedManyWithoutInstanceInput
    dimensionValueAttributeValues?: DimensionValueAttributeValueUncheckedCreateNestedManyWithoutInstanceInput
    modelData?: ModelDataUncheckedCreateNestedManyWithoutInstanceInput
    modelDataCalculations?: ModelDataCalculationsUncheckedCreateNestedManyWithoutInstanceInput
    modelAccounts?: ModelAccountStructureUncheckedCreateNestedManyWithoutInstanceInput
    tables?: TableUncheckedCreateNestedManyWithoutInstanceInput
    tableData?: TableDataUncheckedCreateNestedManyWithoutInstanceInput
  }

  export type InstanceCreateOrConnectWithoutModelsInput = {
    where: InstanceWhereUniqueInput
    create: XOR<InstanceCreateWithoutModelsInput, InstanceUncheckedCreateWithoutModelsInput>
  }

  export type ModelDataCreateWithoutModelInput = {
    id?: string
    clientId: string
    dimensionality?: XOR<ModelDataDimensionalityListCreateEnvelopeInput, ModelDataDimensionalityCreateInput> | ModelDataDimensionalityCreateInput[]
    timespan: InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    level: LevelCreateNestedOneWithoutModelDataInput
    account: AccountCreateNestedOneWithoutModelDataInput
    version: VersionCreateNestedOneWithoutModelDataInput
    instance: InstanceCreateNestedOneWithoutModelDataInput
  }

  export type ModelDataUncheckedCreateWithoutModelInput = {
    id?: string
    clientId: string
    instanceId: string
    versionId: string
    levelId: string
    accountId: string
    dimensionality?: XOR<ModelDataDimensionalityListCreateEnvelopeInput, ModelDataDimensionalityCreateInput> | ModelDataDimensionalityCreateInput[]
    timespan: InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ModelDataCreateOrConnectWithoutModelInput = {
    where: ModelDataWhereUniqueInput
    create: XOR<ModelDataCreateWithoutModelInput, ModelDataUncheckedCreateWithoutModelInput>
  }

  export type ModelDataCreateManyModelInputEnvelope = {
    data: ModelDataCreateManyModelInput | ModelDataCreateManyModelInput[]
  }

  export type ModelAccountStructureCreateWithoutModelInput = {
    id?: string
    isRoot?: boolean
    clientId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    instance: InstanceCreateNestedOneWithoutModelAccountsInput
    account: AccountCreateNestedOneWithoutModelAccountsInput
    modeldataCalculations?: ModelDataCalculationsCreateNestedManyWithoutModelAccountInput
    parentAccount?: ModelAccountStructureCreateNestedOneWithoutChildAccountsInput
    childAccounts?: ModelAccountStructureCreateNestedManyWithoutParentAccountInput
  }

  export type ModelAccountStructureUncheckedCreateWithoutModelInput = {
    id?: string
    instanceId: string
    isRoot?: boolean
    clientId: string
    parentId?: string | null
    accountId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    modeldataCalculations?: ModelDataCalculationsUncheckedCreateNestedManyWithoutModelAccountInput
    childAccounts?: ModelAccountStructureUncheckedCreateNestedManyWithoutParentAccountInput
  }

  export type ModelAccountStructureCreateOrConnectWithoutModelInput = {
    where: ModelAccountStructureWhereUniqueInput
    create: XOR<ModelAccountStructureCreateWithoutModelInput, ModelAccountStructureUncheckedCreateWithoutModelInput>
  }

  export type ModelAccountStructureCreateManyModelInputEnvelope = {
    data: ModelAccountStructureCreateManyModelInput | ModelAccountStructureCreateManyModelInput[]
  }

  export type ModelDataCalculationsCreateWithoutModelInput = {
    id?: string
    clientId: string
    calculations: InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    level: LevelCreateNestedOneWithoutModeldataCalculationsInput
    account: AccountCreateNestedOneWithoutModeldataCalculationsInput
    version: VersionCreateNestedOneWithoutModelDataCalculationsInput
    instance: InstanceCreateNestedOneWithoutModelDataCalculationsInput
    modelAccount: ModelAccountStructureCreateNestedOneWithoutModeldataCalculationsInput
  }

  export type ModelDataCalculationsUncheckedCreateWithoutModelInput = {
    id?: string
    clientId: string
    instanceId: string
    versionId: string
    levelId: string
    accountId: string
    modelAccountId: string
    calculations: InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ModelDataCalculationsCreateOrConnectWithoutModelInput = {
    where: ModelDataCalculationsWhereUniqueInput
    create: XOR<ModelDataCalculationsCreateWithoutModelInput, ModelDataCalculationsUncheckedCreateWithoutModelInput>
  }

  export type ModelDataCalculationsCreateManyModelInputEnvelope = {
    data: ModelDataCalculationsCreateManyModelInput | ModelDataCalculationsCreateManyModelInput[]
  }

  export type InstanceUpsertWithoutModelsInput = {
    update: XOR<InstanceUpdateWithoutModelsInput, InstanceUncheckedUpdateWithoutModelsInput>
    create: XOR<InstanceCreateWithoutModelsInput, InstanceUncheckedCreateWithoutModelsInput>
    where?: InstanceWhereInput
  }

  export type InstanceUpdateToOneWithWhereWithoutModelsInput = {
    where?: InstanceWhereInput
    data: XOR<InstanceUpdateWithoutModelsInput, InstanceUncheckedUpdateWithoutModelsInput>
  }

  export type InstanceUpdateWithoutModelsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnuminstanceStatusFieldUpdateOperationsInput | $Enums.instanceStatus
    userIds?: InstanceUpdateuserIdsInput | string[]
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    client?: ClientUpdateOneRequiredWithoutInstancesNestedInput
    levels?: LevelUpdateManyWithoutInstanceNestedInput
    versions?: VersionUpdateManyWithoutInstanceNestedInput
    currencies?: CurrencyUpdateManyWithoutInstanceNestedInput
    accounts?: AccountUpdateManyWithoutInstanceNestedInput
    dimensions?: DimensionUpdateManyWithoutInstanceNestedInput
    dimensionValues?: DimensionValueUpdateManyWithoutInstanceNestedInput
    levelAttributes?: LevelAttributeUpdateManyWithoutInstanceNestedInput
    dimensionValueAttributes?: DimensionValueAttributeUpdateManyWithoutInstanceNestedInput
    accountAttributes?: AccountAttributeUpdateManyWithoutInstanceNestedInput
    levelAttValues?: LevelAttributeValueUpdateManyWithoutInstanceNestedInput
    accountAttValues?: AccountAttributeValueUpdateManyWithoutInstanceNestedInput
    dimensionValueAttributeValues?: DimensionValueAttributeValueUpdateManyWithoutInstanceNestedInput
    modelData?: ModelDataUpdateManyWithoutInstanceNestedInput
    modelDataCalculations?: ModelDataCalculationsUpdateManyWithoutInstanceNestedInput
    modelAccounts?: ModelAccountStructureUpdateManyWithoutInstanceNestedInput
    tables?: TableUpdateManyWithoutInstanceNestedInput
    tableData?: TableDataUpdateManyWithoutInstanceNestedInput
  }

  export type InstanceUncheckedUpdateWithoutModelsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnuminstanceStatusFieldUpdateOperationsInput | $Enums.instanceStatus
    userIds?: InstanceUpdateuserIdsInput | string[]
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    levels?: LevelUncheckedUpdateManyWithoutInstanceNestedInput
    versions?: VersionUncheckedUpdateManyWithoutInstanceNestedInput
    currencies?: CurrencyUncheckedUpdateManyWithoutInstanceNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutInstanceNestedInput
    dimensions?: DimensionUncheckedUpdateManyWithoutInstanceNestedInput
    dimensionValues?: DimensionValueUncheckedUpdateManyWithoutInstanceNestedInput
    levelAttributes?: LevelAttributeUncheckedUpdateManyWithoutInstanceNestedInput
    dimensionValueAttributes?: DimensionValueAttributeUncheckedUpdateManyWithoutInstanceNestedInput
    accountAttributes?: AccountAttributeUncheckedUpdateManyWithoutInstanceNestedInput
    levelAttValues?: LevelAttributeValueUncheckedUpdateManyWithoutInstanceNestedInput
    accountAttValues?: AccountAttributeValueUncheckedUpdateManyWithoutInstanceNestedInput
    dimensionValueAttributeValues?: DimensionValueAttributeValueUncheckedUpdateManyWithoutInstanceNestedInput
    modelData?: ModelDataUncheckedUpdateManyWithoutInstanceNestedInput
    modelDataCalculations?: ModelDataCalculationsUncheckedUpdateManyWithoutInstanceNestedInput
    modelAccounts?: ModelAccountStructureUncheckedUpdateManyWithoutInstanceNestedInput
    tables?: TableUncheckedUpdateManyWithoutInstanceNestedInput
    tableData?: TableDataUncheckedUpdateManyWithoutInstanceNestedInput
  }

  export type ModelDataUpsertWithWhereUniqueWithoutModelInput = {
    where: ModelDataWhereUniqueInput
    update: XOR<ModelDataUpdateWithoutModelInput, ModelDataUncheckedUpdateWithoutModelInput>
    create: XOR<ModelDataCreateWithoutModelInput, ModelDataUncheckedCreateWithoutModelInput>
  }

  export type ModelDataUpdateWithWhereUniqueWithoutModelInput = {
    where: ModelDataWhereUniqueInput
    data: XOR<ModelDataUpdateWithoutModelInput, ModelDataUncheckedUpdateWithoutModelInput>
  }

  export type ModelDataUpdateManyWithWhereWithoutModelInput = {
    where: ModelDataScalarWhereInput
    data: XOR<ModelDataUpdateManyMutationInput, ModelDataUncheckedUpdateManyWithoutModelInput>
  }

  export type ModelAccountStructureUpsertWithWhereUniqueWithoutModelInput = {
    where: ModelAccountStructureWhereUniqueInput
    update: XOR<ModelAccountStructureUpdateWithoutModelInput, ModelAccountStructureUncheckedUpdateWithoutModelInput>
    create: XOR<ModelAccountStructureCreateWithoutModelInput, ModelAccountStructureUncheckedCreateWithoutModelInput>
  }

  export type ModelAccountStructureUpdateWithWhereUniqueWithoutModelInput = {
    where: ModelAccountStructureWhereUniqueInput
    data: XOR<ModelAccountStructureUpdateWithoutModelInput, ModelAccountStructureUncheckedUpdateWithoutModelInput>
  }

  export type ModelAccountStructureUpdateManyWithWhereWithoutModelInput = {
    where: ModelAccountStructureScalarWhereInput
    data: XOR<ModelAccountStructureUpdateManyMutationInput, ModelAccountStructureUncheckedUpdateManyWithoutModelInput>
  }

  export type ModelDataCalculationsUpsertWithWhereUniqueWithoutModelInput = {
    where: ModelDataCalculationsWhereUniqueInput
    update: XOR<ModelDataCalculationsUpdateWithoutModelInput, ModelDataCalculationsUncheckedUpdateWithoutModelInput>
    create: XOR<ModelDataCalculationsCreateWithoutModelInput, ModelDataCalculationsUncheckedCreateWithoutModelInput>
  }

  export type ModelDataCalculationsUpdateWithWhereUniqueWithoutModelInput = {
    where: ModelDataCalculationsWhereUniqueInput
    data: XOR<ModelDataCalculationsUpdateWithoutModelInput, ModelDataCalculationsUncheckedUpdateWithoutModelInput>
  }

  export type ModelDataCalculationsUpdateManyWithWhereWithoutModelInput = {
    where: ModelDataCalculationsScalarWhereInput
    data: XOR<ModelDataCalculationsUpdateManyMutationInput, ModelDataCalculationsUncheckedUpdateManyWithoutModelInput>
  }

  export type InstanceCreateWithoutModelAccountsInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    status?: $Enums.instanceStatus
    userIds?: InstanceCreateuserIdsInput | string[]
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    client: ClientCreateNestedOneWithoutInstancesInput
    levels?: LevelCreateNestedManyWithoutInstanceInput
    versions?: VersionCreateNestedManyWithoutInstanceInput
    currencies?: CurrencyCreateNestedManyWithoutInstanceInput
    accounts?: AccountCreateNestedManyWithoutInstanceInput
    models?: ModelCreateNestedManyWithoutInstanceInput
    dimensions?: DimensionCreateNestedManyWithoutInstanceInput
    dimensionValues?: DimensionValueCreateNestedManyWithoutInstanceInput
    levelAttributes?: LevelAttributeCreateNestedManyWithoutInstanceInput
    dimensionValueAttributes?: DimensionValueAttributeCreateNestedManyWithoutInstanceInput
    accountAttributes?: AccountAttributeCreateNestedManyWithoutInstanceInput
    levelAttValues?: LevelAttributeValueCreateNestedManyWithoutInstanceInput
    accountAttValues?: AccountAttributeValueCreateNestedManyWithoutInstanceInput
    dimensionValueAttributeValues?: DimensionValueAttributeValueCreateNestedManyWithoutInstanceInput
    modelData?: ModelDataCreateNestedManyWithoutInstanceInput
    modelDataCalculations?: ModelDataCalculationsCreateNestedManyWithoutInstanceInput
    tables?: TableCreateNestedManyWithoutInstanceInput
    tableData?: TableDataCreateNestedManyWithoutInstanceInput
  }

  export type InstanceUncheckedCreateWithoutModelAccountsInput = {
    id?: string
    code: string
    name: string
    clientId: string
    description?: string | null
    status?: $Enums.instanceStatus
    userIds?: InstanceCreateuserIdsInput | string[]
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    levels?: LevelUncheckedCreateNestedManyWithoutInstanceInput
    versions?: VersionUncheckedCreateNestedManyWithoutInstanceInput
    currencies?: CurrencyUncheckedCreateNestedManyWithoutInstanceInput
    accounts?: AccountUncheckedCreateNestedManyWithoutInstanceInput
    models?: ModelUncheckedCreateNestedManyWithoutInstanceInput
    dimensions?: DimensionUncheckedCreateNestedManyWithoutInstanceInput
    dimensionValues?: DimensionValueUncheckedCreateNestedManyWithoutInstanceInput
    levelAttributes?: LevelAttributeUncheckedCreateNestedManyWithoutInstanceInput
    dimensionValueAttributes?: DimensionValueAttributeUncheckedCreateNestedManyWithoutInstanceInput
    accountAttributes?: AccountAttributeUncheckedCreateNestedManyWithoutInstanceInput
    levelAttValues?: LevelAttributeValueUncheckedCreateNestedManyWithoutInstanceInput
    accountAttValues?: AccountAttributeValueUncheckedCreateNestedManyWithoutInstanceInput
    dimensionValueAttributeValues?: DimensionValueAttributeValueUncheckedCreateNestedManyWithoutInstanceInput
    modelData?: ModelDataUncheckedCreateNestedManyWithoutInstanceInput
    modelDataCalculations?: ModelDataCalculationsUncheckedCreateNestedManyWithoutInstanceInput
    tables?: TableUncheckedCreateNestedManyWithoutInstanceInput
    tableData?: TableDataUncheckedCreateNestedManyWithoutInstanceInput
  }

  export type InstanceCreateOrConnectWithoutModelAccountsInput = {
    where: InstanceWhereUniqueInput
    create: XOR<InstanceCreateWithoutModelAccountsInput, InstanceUncheckedCreateWithoutModelAccountsInput>
  }

  export type ModelCreateWithoutModelAccountsInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    dimensionality?: ModelCreatedimensionalityInput | string[]
    status?: $Enums.ModelStatus
    isDefault?: boolean
    clientId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    rootAccountId: string
    instance: InstanceCreateNestedOneWithoutModelsInput
    modelData?: ModelDataCreateNestedManyWithoutModelInput
    modelDataCalculations?: ModelDataCalculationsCreateNestedManyWithoutModelInput
  }

  export type ModelUncheckedCreateWithoutModelAccountsInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    dimensionality?: ModelCreatedimensionalityInput | string[]
    status?: $Enums.ModelStatus
    isDefault?: boolean
    instanceId: string
    clientId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    rootAccountId: string
    modelData?: ModelDataUncheckedCreateNestedManyWithoutModelInput
    modelDataCalculations?: ModelDataCalculationsUncheckedCreateNestedManyWithoutModelInput
  }

  export type ModelCreateOrConnectWithoutModelAccountsInput = {
    where: ModelWhereUniqueInput
    create: XOR<ModelCreateWithoutModelAccountsInput, ModelUncheckedCreateWithoutModelAccountsInput>
  }

  export type AccountCreateWithoutModelAccountsInput = {
    id?: string
    code: string
    name: string
    isRoot?: boolean
    isModelRoot?: boolean
    accountType: $Enums.AccountType
    accountTypeTag: $Enums.AccountTypeTag
    group?: $Enums.YesNo
    plannedBy?: $Enums.ActPlanBy | null
    actualsBy?: $Enums.ActActualsBy | null
    displayAs?: $Enums.ActDisplayAs
    containsSalaryInfo?: $Enums.YesNo
    description?: string | null
    clientId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    instance: InstanceCreateNestedOneWithoutAccountsInput
    parent?: AccountCreateNestedOneWithoutChildAccountsInput
    childAccounts?: AccountCreateNestedManyWithoutParentInput
    AttributeAndValues?: AccountAttributeAndValueCreateNestedManyWithoutAccountInput
    modelData?: ModelDataCreateNestedManyWithoutAccountInput
    modeldataCalculations?: ModelDataCalculationsCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutModelAccountsInput = {
    id?: string
    code: string
    name: string
    isRoot?: boolean
    isModelRoot?: boolean
    accountType: $Enums.AccountType
    accountTypeTag: $Enums.AccountTypeTag
    group?: $Enums.YesNo
    plannedBy?: $Enums.ActPlanBy | null
    actualsBy?: $Enums.ActActualsBy | null
    displayAs?: $Enums.ActDisplayAs
    containsSalaryInfo?: $Enums.YesNo
    description?: string | null
    instanceId: string
    clientId: string
    parentId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    childAccounts?: AccountUncheckedCreateNestedManyWithoutParentInput
    AttributeAndValues?: AccountAttributeAndValueUncheckedCreateNestedManyWithoutAccountInput
    modelData?: ModelDataUncheckedCreateNestedManyWithoutAccountInput
    modeldataCalculations?: ModelDataCalculationsUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutModelAccountsInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutModelAccountsInput, AccountUncheckedCreateWithoutModelAccountsInput>
  }

  export type ModelDataCalculationsCreateWithoutModelAccountInput = {
    id?: string
    clientId: string
    calculations: InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    model: ModelCreateNestedOneWithoutModelDataCalculationsInput
    level: LevelCreateNestedOneWithoutModeldataCalculationsInput
    account: AccountCreateNestedOneWithoutModeldataCalculationsInput
    version: VersionCreateNestedOneWithoutModelDataCalculationsInput
    instance: InstanceCreateNestedOneWithoutModelDataCalculationsInput
  }

  export type ModelDataCalculationsUncheckedCreateWithoutModelAccountInput = {
    id?: string
    clientId: string
    instanceId: string
    modelId: string
    versionId: string
    levelId: string
    accountId: string
    calculations: InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ModelDataCalculationsCreateOrConnectWithoutModelAccountInput = {
    where: ModelDataCalculationsWhereUniqueInput
    create: XOR<ModelDataCalculationsCreateWithoutModelAccountInput, ModelDataCalculationsUncheckedCreateWithoutModelAccountInput>
  }

  export type ModelDataCalculationsCreateManyModelAccountInputEnvelope = {
    data: ModelDataCalculationsCreateManyModelAccountInput | ModelDataCalculationsCreateManyModelAccountInput[]
  }

  export type ModelAccountStructureCreateWithoutChildAccountsInput = {
    id?: string
    isRoot?: boolean
    clientId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    instance: InstanceCreateNestedOneWithoutModelAccountsInput
    model: ModelCreateNestedOneWithoutModelAccountsInput
    account: AccountCreateNestedOneWithoutModelAccountsInput
    modeldataCalculations?: ModelDataCalculationsCreateNestedManyWithoutModelAccountInput
    parentAccount?: ModelAccountStructureCreateNestedOneWithoutChildAccountsInput
  }

  export type ModelAccountStructureUncheckedCreateWithoutChildAccountsInput = {
    id?: string
    instanceId: string
    isRoot?: boolean
    clientId: string
    parentId?: string | null
    modelId: string
    accountId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    modeldataCalculations?: ModelDataCalculationsUncheckedCreateNestedManyWithoutModelAccountInput
  }

  export type ModelAccountStructureCreateOrConnectWithoutChildAccountsInput = {
    where: ModelAccountStructureWhereUniqueInput
    create: XOR<ModelAccountStructureCreateWithoutChildAccountsInput, ModelAccountStructureUncheckedCreateWithoutChildAccountsInput>
  }

  export type ModelAccountStructureCreateWithoutParentAccountInput = {
    id?: string
    isRoot?: boolean
    clientId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    instance: InstanceCreateNestedOneWithoutModelAccountsInput
    model: ModelCreateNestedOneWithoutModelAccountsInput
    account: AccountCreateNestedOneWithoutModelAccountsInput
    modeldataCalculations?: ModelDataCalculationsCreateNestedManyWithoutModelAccountInput
    childAccounts?: ModelAccountStructureCreateNestedManyWithoutParentAccountInput
  }

  export type ModelAccountStructureUncheckedCreateWithoutParentAccountInput = {
    id?: string
    instanceId: string
    isRoot?: boolean
    clientId: string
    modelId: string
    accountId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    modeldataCalculations?: ModelDataCalculationsUncheckedCreateNestedManyWithoutModelAccountInput
    childAccounts?: ModelAccountStructureUncheckedCreateNestedManyWithoutParentAccountInput
  }

  export type ModelAccountStructureCreateOrConnectWithoutParentAccountInput = {
    where: ModelAccountStructureWhereUniqueInput
    create: XOR<ModelAccountStructureCreateWithoutParentAccountInput, ModelAccountStructureUncheckedCreateWithoutParentAccountInput>
  }

  export type ModelAccountStructureCreateManyParentAccountInputEnvelope = {
    data: ModelAccountStructureCreateManyParentAccountInput | ModelAccountStructureCreateManyParentAccountInput[]
  }

  export type InstanceUpsertWithoutModelAccountsInput = {
    update: XOR<InstanceUpdateWithoutModelAccountsInput, InstanceUncheckedUpdateWithoutModelAccountsInput>
    create: XOR<InstanceCreateWithoutModelAccountsInput, InstanceUncheckedCreateWithoutModelAccountsInput>
    where?: InstanceWhereInput
  }

  export type InstanceUpdateToOneWithWhereWithoutModelAccountsInput = {
    where?: InstanceWhereInput
    data: XOR<InstanceUpdateWithoutModelAccountsInput, InstanceUncheckedUpdateWithoutModelAccountsInput>
  }

  export type InstanceUpdateWithoutModelAccountsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnuminstanceStatusFieldUpdateOperationsInput | $Enums.instanceStatus
    userIds?: InstanceUpdateuserIdsInput | string[]
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    client?: ClientUpdateOneRequiredWithoutInstancesNestedInput
    levels?: LevelUpdateManyWithoutInstanceNestedInput
    versions?: VersionUpdateManyWithoutInstanceNestedInput
    currencies?: CurrencyUpdateManyWithoutInstanceNestedInput
    accounts?: AccountUpdateManyWithoutInstanceNestedInput
    models?: ModelUpdateManyWithoutInstanceNestedInput
    dimensions?: DimensionUpdateManyWithoutInstanceNestedInput
    dimensionValues?: DimensionValueUpdateManyWithoutInstanceNestedInput
    levelAttributes?: LevelAttributeUpdateManyWithoutInstanceNestedInput
    dimensionValueAttributes?: DimensionValueAttributeUpdateManyWithoutInstanceNestedInput
    accountAttributes?: AccountAttributeUpdateManyWithoutInstanceNestedInput
    levelAttValues?: LevelAttributeValueUpdateManyWithoutInstanceNestedInput
    accountAttValues?: AccountAttributeValueUpdateManyWithoutInstanceNestedInput
    dimensionValueAttributeValues?: DimensionValueAttributeValueUpdateManyWithoutInstanceNestedInput
    modelData?: ModelDataUpdateManyWithoutInstanceNestedInput
    modelDataCalculations?: ModelDataCalculationsUpdateManyWithoutInstanceNestedInput
    tables?: TableUpdateManyWithoutInstanceNestedInput
    tableData?: TableDataUpdateManyWithoutInstanceNestedInput
  }

  export type InstanceUncheckedUpdateWithoutModelAccountsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnuminstanceStatusFieldUpdateOperationsInput | $Enums.instanceStatus
    userIds?: InstanceUpdateuserIdsInput | string[]
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    levels?: LevelUncheckedUpdateManyWithoutInstanceNestedInput
    versions?: VersionUncheckedUpdateManyWithoutInstanceNestedInput
    currencies?: CurrencyUncheckedUpdateManyWithoutInstanceNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutInstanceNestedInput
    models?: ModelUncheckedUpdateManyWithoutInstanceNestedInput
    dimensions?: DimensionUncheckedUpdateManyWithoutInstanceNestedInput
    dimensionValues?: DimensionValueUncheckedUpdateManyWithoutInstanceNestedInput
    levelAttributes?: LevelAttributeUncheckedUpdateManyWithoutInstanceNestedInput
    dimensionValueAttributes?: DimensionValueAttributeUncheckedUpdateManyWithoutInstanceNestedInput
    accountAttributes?: AccountAttributeUncheckedUpdateManyWithoutInstanceNestedInput
    levelAttValues?: LevelAttributeValueUncheckedUpdateManyWithoutInstanceNestedInput
    accountAttValues?: AccountAttributeValueUncheckedUpdateManyWithoutInstanceNestedInput
    dimensionValueAttributeValues?: DimensionValueAttributeValueUncheckedUpdateManyWithoutInstanceNestedInput
    modelData?: ModelDataUncheckedUpdateManyWithoutInstanceNestedInput
    modelDataCalculations?: ModelDataCalculationsUncheckedUpdateManyWithoutInstanceNestedInput
    tables?: TableUncheckedUpdateManyWithoutInstanceNestedInput
    tableData?: TableDataUncheckedUpdateManyWithoutInstanceNestedInput
  }

  export type ModelUpsertWithoutModelAccountsInput = {
    update: XOR<ModelUpdateWithoutModelAccountsInput, ModelUncheckedUpdateWithoutModelAccountsInput>
    create: XOR<ModelCreateWithoutModelAccountsInput, ModelUncheckedCreateWithoutModelAccountsInput>
    where?: ModelWhereInput
  }

  export type ModelUpdateToOneWithWhereWithoutModelAccountsInput = {
    where?: ModelWhereInput
    data: XOR<ModelUpdateWithoutModelAccountsInput, ModelUncheckedUpdateWithoutModelAccountsInput>
  }

  export type ModelUpdateWithoutModelAccountsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dimensionality?: ModelUpdatedimensionalityInput | string[]
    status?: EnumModelStatusFieldUpdateOperationsInput | $Enums.ModelStatus
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rootAccountId?: StringFieldUpdateOperationsInput | string
    instance?: InstanceUpdateOneRequiredWithoutModelsNestedInput
    modelData?: ModelDataUpdateManyWithoutModelNestedInput
    modelDataCalculations?: ModelDataCalculationsUpdateManyWithoutModelNestedInput
  }

  export type ModelUncheckedUpdateWithoutModelAccountsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dimensionality?: ModelUpdatedimensionalityInput | string[]
    status?: EnumModelStatusFieldUpdateOperationsInput | $Enums.ModelStatus
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    instanceId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rootAccountId?: StringFieldUpdateOperationsInput | string
    modelData?: ModelDataUncheckedUpdateManyWithoutModelNestedInput
    modelDataCalculations?: ModelDataCalculationsUncheckedUpdateManyWithoutModelNestedInput
  }

  export type AccountUpsertWithoutModelAccountsInput = {
    update: XOR<AccountUpdateWithoutModelAccountsInput, AccountUncheckedUpdateWithoutModelAccountsInput>
    create: XOR<AccountCreateWithoutModelAccountsInput, AccountUncheckedCreateWithoutModelAccountsInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutModelAccountsInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutModelAccountsInput, AccountUncheckedUpdateWithoutModelAccountsInput>
  }

  export type AccountUpdateWithoutModelAccountsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isRoot?: BoolFieldUpdateOperationsInput | boolean
    isModelRoot?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    accountTypeTag?: EnumAccountTypeTagFieldUpdateOperationsInput | $Enums.AccountTypeTag
    group?: EnumYesNoFieldUpdateOperationsInput | $Enums.YesNo
    plannedBy?: NullableEnumActPlanByFieldUpdateOperationsInput | $Enums.ActPlanBy | null
    actualsBy?: NullableEnumActActualsByFieldUpdateOperationsInput | $Enums.ActActualsBy | null
    displayAs?: EnumActDisplayAsFieldUpdateOperationsInput | $Enums.ActDisplayAs
    containsSalaryInfo?: EnumYesNoFieldUpdateOperationsInput | $Enums.YesNo
    description?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instance?: InstanceUpdateOneRequiredWithoutAccountsNestedInput
    parent?: AccountUpdateOneWithoutChildAccountsNestedInput
    childAccounts?: AccountUpdateManyWithoutParentNestedInput
    AttributeAndValues?: AccountAttributeAndValueUpdateManyWithoutAccountNestedInput
    modelData?: ModelDataUpdateManyWithoutAccountNestedInput
    modeldataCalculations?: ModelDataCalculationsUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutModelAccountsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isRoot?: BoolFieldUpdateOperationsInput | boolean
    isModelRoot?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    accountTypeTag?: EnumAccountTypeTagFieldUpdateOperationsInput | $Enums.AccountTypeTag
    group?: EnumYesNoFieldUpdateOperationsInput | $Enums.YesNo
    plannedBy?: NullableEnumActPlanByFieldUpdateOperationsInput | $Enums.ActPlanBy | null
    actualsBy?: NullableEnumActActualsByFieldUpdateOperationsInput | $Enums.ActActualsBy | null
    displayAs?: EnumActDisplayAsFieldUpdateOperationsInput | $Enums.ActDisplayAs
    containsSalaryInfo?: EnumYesNoFieldUpdateOperationsInput | $Enums.YesNo
    description?: NullableStringFieldUpdateOperationsInput | string | null
    instanceId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    childAccounts?: AccountUncheckedUpdateManyWithoutParentNestedInput
    AttributeAndValues?: AccountAttributeAndValueUncheckedUpdateManyWithoutAccountNestedInput
    modelData?: ModelDataUncheckedUpdateManyWithoutAccountNestedInput
    modeldataCalculations?: ModelDataCalculationsUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type ModelDataCalculationsUpsertWithWhereUniqueWithoutModelAccountInput = {
    where: ModelDataCalculationsWhereUniqueInput
    update: XOR<ModelDataCalculationsUpdateWithoutModelAccountInput, ModelDataCalculationsUncheckedUpdateWithoutModelAccountInput>
    create: XOR<ModelDataCalculationsCreateWithoutModelAccountInput, ModelDataCalculationsUncheckedCreateWithoutModelAccountInput>
  }

  export type ModelDataCalculationsUpdateWithWhereUniqueWithoutModelAccountInput = {
    where: ModelDataCalculationsWhereUniqueInput
    data: XOR<ModelDataCalculationsUpdateWithoutModelAccountInput, ModelDataCalculationsUncheckedUpdateWithoutModelAccountInput>
  }

  export type ModelDataCalculationsUpdateManyWithWhereWithoutModelAccountInput = {
    where: ModelDataCalculationsScalarWhereInput
    data: XOR<ModelDataCalculationsUpdateManyMutationInput, ModelDataCalculationsUncheckedUpdateManyWithoutModelAccountInput>
  }

  export type ModelAccountStructureUpsertWithoutChildAccountsInput = {
    update: XOR<ModelAccountStructureUpdateWithoutChildAccountsInput, ModelAccountStructureUncheckedUpdateWithoutChildAccountsInput>
    create: XOR<ModelAccountStructureCreateWithoutChildAccountsInput, ModelAccountStructureUncheckedCreateWithoutChildAccountsInput>
    where?: ModelAccountStructureWhereInput
  }

  export type ModelAccountStructureUpdateToOneWithWhereWithoutChildAccountsInput = {
    where?: ModelAccountStructureWhereInput
    data: XOR<ModelAccountStructureUpdateWithoutChildAccountsInput, ModelAccountStructureUncheckedUpdateWithoutChildAccountsInput>
  }

  export type ModelAccountStructureUpdateWithoutChildAccountsInput = {
    isRoot?: BoolFieldUpdateOperationsInput | boolean
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instance?: InstanceUpdateOneRequiredWithoutModelAccountsNestedInput
    model?: ModelUpdateOneRequiredWithoutModelAccountsNestedInput
    account?: AccountUpdateOneRequiredWithoutModelAccountsNestedInput
    modeldataCalculations?: ModelDataCalculationsUpdateManyWithoutModelAccountNestedInput
    parentAccount?: ModelAccountStructureUpdateOneWithoutChildAccountsNestedInput
  }

  export type ModelAccountStructureUncheckedUpdateWithoutChildAccountsInput = {
    instanceId?: StringFieldUpdateOperationsInput | string
    isRoot?: BoolFieldUpdateOperationsInput | boolean
    clientId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    modelId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modeldataCalculations?: ModelDataCalculationsUncheckedUpdateManyWithoutModelAccountNestedInput
  }

  export type ModelAccountStructureUpsertWithWhereUniqueWithoutParentAccountInput = {
    where: ModelAccountStructureWhereUniqueInput
    update: XOR<ModelAccountStructureUpdateWithoutParentAccountInput, ModelAccountStructureUncheckedUpdateWithoutParentAccountInput>
    create: XOR<ModelAccountStructureCreateWithoutParentAccountInput, ModelAccountStructureUncheckedCreateWithoutParentAccountInput>
  }

  export type ModelAccountStructureUpdateWithWhereUniqueWithoutParentAccountInput = {
    where: ModelAccountStructureWhereUniqueInput
    data: XOR<ModelAccountStructureUpdateWithoutParentAccountInput, ModelAccountStructureUncheckedUpdateWithoutParentAccountInput>
  }

  export type ModelAccountStructureUpdateManyWithWhereWithoutParentAccountInput = {
    where: ModelAccountStructureScalarWhereInput
    data: XOR<ModelAccountStructureUpdateManyMutationInput, ModelAccountStructureUncheckedUpdateManyWithoutParentAccountInput>
  }

  export type ModelCreateWithoutModelDataInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    dimensionality?: ModelCreatedimensionalityInput | string[]
    status?: $Enums.ModelStatus
    isDefault?: boolean
    clientId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    rootAccountId: string
    instance: InstanceCreateNestedOneWithoutModelsInput
    modelAccounts?: ModelAccountStructureCreateNestedManyWithoutModelInput
    modelDataCalculations?: ModelDataCalculationsCreateNestedManyWithoutModelInput
  }

  export type ModelUncheckedCreateWithoutModelDataInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    dimensionality?: ModelCreatedimensionalityInput | string[]
    status?: $Enums.ModelStatus
    isDefault?: boolean
    instanceId: string
    clientId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    rootAccountId: string
    modelAccounts?: ModelAccountStructureUncheckedCreateNestedManyWithoutModelInput
    modelDataCalculations?: ModelDataCalculationsUncheckedCreateNestedManyWithoutModelInput
  }

  export type ModelCreateOrConnectWithoutModelDataInput = {
    where: ModelWhereUniqueInput
    create: XOR<ModelCreateWithoutModelDataInput, ModelUncheckedCreateWithoutModelDataInput>
  }

  export type LevelCreateWithoutModelDataInput = {
    id?: string
    code: string
    name: string
    isRoot?: boolean
    description?: string | null
    clientId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    AttributeAndValues?: LevelAttributeAndValueCreateNestedManyWithoutLevelInput
    parent?: LevelCreateNestedOneWithoutChildLevelsInput
    instance: InstanceCreateNestedOneWithoutLevelsInput
    currency: CurrencyCreateNestedOneWithoutLevelsInput
    childLevels?: LevelCreateNestedManyWithoutParentInput
    modeldataCalculations?: ModelDataCalculationsCreateNestedManyWithoutLevelInput
  }

  export type LevelUncheckedCreateWithoutModelDataInput = {
    id?: string
    code: string
    name: string
    isRoot?: boolean
    description?: string | null
    parentId?: string | null
    clientId: string
    instanceId: string
    currencyId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    AttributeAndValues?: LevelAttributeAndValueUncheckedCreateNestedManyWithoutLevelInput
    childLevels?: LevelUncheckedCreateNestedManyWithoutParentInput
    modeldataCalculations?: ModelDataCalculationsUncheckedCreateNestedManyWithoutLevelInput
  }

  export type LevelCreateOrConnectWithoutModelDataInput = {
    where: LevelWhereUniqueInput
    create: XOR<LevelCreateWithoutModelDataInput, LevelUncheckedCreateWithoutModelDataInput>
  }

  export type AccountCreateWithoutModelDataInput = {
    id?: string
    code: string
    name: string
    isRoot?: boolean
    isModelRoot?: boolean
    accountType: $Enums.AccountType
    accountTypeTag: $Enums.AccountTypeTag
    group?: $Enums.YesNo
    plannedBy?: $Enums.ActPlanBy | null
    actualsBy?: $Enums.ActActualsBy | null
    displayAs?: $Enums.ActDisplayAs
    containsSalaryInfo?: $Enums.YesNo
    description?: string | null
    clientId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    instance: InstanceCreateNestedOneWithoutAccountsInput
    parent?: AccountCreateNestedOneWithoutChildAccountsInput
    childAccounts?: AccountCreateNestedManyWithoutParentInput
    AttributeAndValues?: AccountAttributeAndValueCreateNestedManyWithoutAccountInput
    modelAccounts?: ModelAccountStructureCreateNestedManyWithoutAccountInput
    modeldataCalculations?: ModelDataCalculationsCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutModelDataInput = {
    id?: string
    code: string
    name: string
    isRoot?: boolean
    isModelRoot?: boolean
    accountType: $Enums.AccountType
    accountTypeTag: $Enums.AccountTypeTag
    group?: $Enums.YesNo
    plannedBy?: $Enums.ActPlanBy | null
    actualsBy?: $Enums.ActActualsBy | null
    displayAs?: $Enums.ActDisplayAs
    containsSalaryInfo?: $Enums.YesNo
    description?: string | null
    instanceId: string
    clientId: string
    parentId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    childAccounts?: AccountUncheckedCreateNestedManyWithoutParentInput
    AttributeAndValues?: AccountAttributeAndValueUncheckedCreateNestedManyWithoutAccountInput
    modelAccounts?: ModelAccountStructureUncheckedCreateNestedManyWithoutAccountInput
    modeldataCalculations?: ModelDataCalculationsUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutModelDataInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutModelDataInput, AccountUncheckedCreateWithoutModelDataInput>
  }

  export type VersionCreateWithoutModelDataInput = {
    id?: string
    code: string
    name: string
    begin: Date | string
    end: Date | string
    startOfPlan: Date | string
    description?: string | null
    isDefault?: boolean
    isActuals?: boolean
    status?: $Enums.versionStatus
    clientId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    instance: InstanceCreateNestedOneWithoutVersionsInput
    modelDataCalculations?: ModelDataCalculationsCreateNestedManyWithoutVersionInput
  }

  export type VersionUncheckedCreateWithoutModelDataInput = {
    id?: string
    code: string
    name: string
    begin: Date | string
    end: Date | string
    startOfPlan: Date | string
    description?: string | null
    isDefault?: boolean
    isActuals?: boolean
    status?: $Enums.versionStatus
    clientId: string
    instanceId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    modelDataCalculations?: ModelDataCalculationsUncheckedCreateNestedManyWithoutVersionInput
  }

  export type VersionCreateOrConnectWithoutModelDataInput = {
    where: VersionWhereUniqueInput
    create: XOR<VersionCreateWithoutModelDataInput, VersionUncheckedCreateWithoutModelDataInput>
  }

  export type InstanceCreateWithoutModelDataInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    status?: $Enums.instanceStatus
    userIds?: InstanceCreateuserIdsInput | string[]
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    client: ClientCreateNestedOneWithoutInstancesInput
    levels?: LevelCreateNestedManyWithoutInstanceInput
    versions?: VersionCreateNestedManyWithoutInstanceInput
    currencies?: CurrencyCreateNestedManyWithoutInstanceInput
    accounts?: AccountCreateNestedManyWithoutInstanceInput
    models?: ModelCreateNestedManyWithoutInstanceInput
    dimensions?: DimensionCreateNestedManyWithoutInstanceInput
    dimensionValues?: DimensionValueCreateNestedManyWithoutInstanceInput
    levelAttributes?: LevelAttributeCreateNestedManyWithoutInstanceInput
    dimensionValueAttributes?: DimensionValueAttributeCreateNestedManyWithoutInstanceInput
    accountAttributes?: AccountAttributeCreateNestedManyWithoutInstanceInput
    levelAttValues?: LevelAttributeValueCreateNestedManyWithoutInstanceInput
    accountAttValues?: AccountAttributeValueCreateNestedManyWithoutInstanceInput
    dimensionValueAttributeValues?: DimensionValueAttributeValueCreateNestedManyWithoutInstanceInput
    modelDataCalculations?: ModelDataCalculationsCreateNestedManyWithoutInstanceInput
    modelAccounts?: ModelAccountStructureCreateNestedManyWithoutInstanceInput
    tables?: TableCreateNestedManyWithoutInstanceInput
    tableData?: TableDataCreateNestedManyWithoutInstanceInput
  }

  export type InstanceUncheckedCreateWithoutModelDataInput = {
    id?: string
    code: string
    name: string
    clientId: string
    description?: string | null
    status?: $Enums.instanceStatus
    userIds?: InstanceCreateuserIdsInput | string[]
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    levels?: LevelUncheckedCreateNestedManyWithoutInstanceInput
    versions?: VersionUncheckedCreateNestedManyWithoutInstanceInput
    currencies?: CurrencyUncheckedCreateNestedManyWithoutInstanceInput
    accounts?: AccountUncheckedCreateNestedManyWithoutInstanceInput
    models?: ModelUncheckedCreateNestedManyWithoutInstanceInput
    dimensions?: DimensionUncheckedCreateNestedManyWithoutInstanceInput
    dimensionValues?: DimensionValueUncheckedCreateNestedManyWithoutInstanceInput
    levelAttributes?: LevelAttributeUncheckedCreateNestedManyWithoutInstanceInput
    dimensionValueAttributes?: DimensionValueAttributeUncheckedCreateNestedManyWithoutInstanceInput
    accountAttributes?: AccountAttributeUncheckedCreateNestedManyWithoutInstanceInput
    levelAttValues?: LevelAttributeValueUncheckedCreateNestedManyWithoutInstanceInput
    accountAttValues?: AccountAttributeValueUncheckedCreateNestedManyWithoutInstanceInput
    dimensionValueAttributeValues?: DimensionValueAttributeValueUncheckedCreateNestedManyWithoutInstanceInput
    modelDataCalculations?: ModelDataCalculationsUncheckedCreateNestedManyWithoutInstanceInput
    modelAccounts?: ModelAccountStructureUncheckedCreateNestedManyWithoutInstanceInput
    tables?: TableUncheckedCreateNestedManyWithoutInstanceInput
    tableData?: TableDataUncheckedCreateNestedManyWithoutInstanceInput
  }

  export type InstanceCreateOrConnectWithoutModelDataInput = {
    where: InstanceWhereUniqueInput
    create: XOR<InstanceCreateWithoutModelDataInput, InstanceUncheckedCreateWithoutModelDataInput>
  }

  export type ModelDataDimensionalityUpdateManyInput = {
    where: ModelDataDimensionalityWhereInput
    data: ModelDataDimensionalityUpdateInput
  }

  export type ModelDataDimensionalityDeleteManyInput = {
    where: ModelDataDimensionalityWhereInput
  }

  export type ModelUpsertWithoutModelDataInput = {
    update: XOR<ModelUpdateWithoutModelDataInput, ModelUncheckedUpdateWithoutModelDataInput>
    create: XOR<ModelCreateWithoutModelDataInput, ModelUncheckedCreateWithoutModelDataInput>
    where?: ModelWhereInput
  }

  export type ModelUpdateToOneWithWhereWithoutModelDataInput = {
    where?: ModelWhereInput
    data: XOR<ModelUpdateWithoutModelDataInput, ModelUncheckedUpdateWithoutModelDataInput>
  }

  export type ModelUpdateWithoutModelDataInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dimensionality?: ModelUpdatedimensionalityInput | string[]
    status?: EnumModelStatusFieldUpdateOperationsInput | $Enums.ModelStatus
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rootAccountId?: StringFieldUpdateOperationsInput | string
    instance?: InstanceUpdateOneRequiredWithoutModelsNestedInput
    modelAccounts?: ModelAccountStructureUpdateManyWithoutModelNestedInput
    modelDataCalculations?: ModelDataCalculationsUpdateManyWithoutModelNestedInput
  }

  export type ModelUncheckedUpdateWithoutModelDataInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dimensionality?: ModelUpdatedimensionalityInput | string[]
    status?: EnumModelStatusFieldUpdateOperationsInput | $Enums.ModelStatus
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    instanceId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rootAccountId?: StringFieldUpdateOperationsInput | string
    modelAccounts?: ModelAccountStructureUncheckedUpdateManyWithoutModelNestedInput
    modelDataCalculations?: ModelDataCalculationsUncheckedUpdateManyWithoutModelNestedInput
  }

  export type LevelUpsertWithoutModelDataInput = {
    update: XOR<LevelUpdateWithoutModelDataInput, LevelUncheckedUpdateWithoutModelDataInput>
    create: XOR<LevelCreateWithoutModelDataInput, LevelUncheckedCreateWithoutModelDataInput>
    where?: LevelWhereInput
  }

  export type LevelUpdateToOneWithWhereWithoutModelDataInput = {
    where?: LevelWhereInput
    data: XOR<LevelUpdateWithoutModelDataInput, LevelUncheckedUpdateWithoutModelDataInput>
  }

  export type LevelUpdateWithoutModelDataInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isRoot?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    AttributeAndValues?: LevelAttributeAndValueUpdateManyWithoutLevelNestedInput
    parent?: LevelUpdateOneWithoutChildLevelsNestedInput
    instance?: InstanceUpdateOneRequiredWithoutLevelsNestedInput
    currency?: CurrencyUpdateOneRequiredWithoutLevelsNestedInput
    childLevels?: LevelUpdateManyWithoutParentNestedInput
    modeldataCalculations?: ModelDataCalculationsUpdateManyWithoutLevelNestedInput
  }

  export type LevelUncheckedUpdateWithoutModelDataInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isRoot?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    currencyId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    AttributeAndValues?: LevelAttributeAndValueUncheckedUpdateManyWithoutLevelNestedInput
    childLevels?: LevelUncheckedUpdateManyWithoutParentNestedInput
    modeldataCalculations?: ModelDataCalculationsUncheckedUpdateManyWithoutLevelNestedInput
  }

  export type AccountUpsertWithoutModelDataInput = {
    update: XOR<AccountUpdateWithoutModelDataInput, AccountUncheckedUpdateWithoutModelDataInput>
    create: XOR<AccountCreateWithoutModelDataInput, AccountUncheckedCreateWithoutModelDataInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutModelDataInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutModelDataInput, AccountUncheckedUpdateWithoutModelDataInput>
  }

  export type AccountUpdateWithoutModelDataInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isRoot?: BoolFieldUpdateOperationsInput | boolean
    isModelRoot?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    accountTypeTag?: EnumAccountTypeTagFieldUpdateOperationsInput | $Enums.AccountTypeTag
    group?: EnumYesNoFieldUpdateOperationsInput | $Enums.YesNo
    plannedBy?: NullableEnumActPlanByFieldUpdateOperationsInput | $Enums.ActPlanBy | null
    actualsBy?: NullableEnumActActualsByFieldUpdateOperationsInput | $Enums.ActActualsBy | null
    displayAs?: EnumActDisplayAsFieldUpdateOperationsInput | $Enums.ActDisplayAs
    containsSalaryInfo?: EnumYesNoFieldUpdateOperationsInput | $Enums.YesNo
    description?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instance?: InstanceUpdateOneRequiredWithoutAccountsNestedInput
    parent?: AccountUpdateOneWithoutChildAccountsNestedInput
    childAccounts?: AccountUpdateManyWithoutParentNestedInput
    AttributeAndValues?: AccountAttributeAndValueUpdateManyWithoutAccountNestedInput
    modelAccounts?: ModelAccountStructureUpdateManyWithoutAccountNestedInput
    modeldataCalculations?: ModelDataCalculationsUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutModelDataInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isRoot?: BoolFieldUpdateOperationsInput | boolean
    isModelRoot?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    accountTypeTag?: EnumAccountTypeTagFieldUpdateOperationsInput | $Enums.AccountTypeTag
    group?: EnumYesNoFieldUpdateOperationsInput | $Enums.YesNo
    plannedBy?: NullableEnumActPlanByFieldUpdateOperationsInput | $Enums.ActPlanBy | null
    actualsBy?: NullableEnumActActualsByFieldUpdateOperationsInput | $Enums.ActActualsBy | null
    displayAs?: EnumActDisplayAsFieldUpdateOperationsInput | $Enums.ActDisplayAs
    containsSalaryInfo?: EnumYesNoFieldUpdateOperationsInput | $Enums.YesNo
    description?: NullableStringFieldUpdateOperationsInput | string | null
    instanceId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    childAccounts?: AccountUncheckedUpdateManyWithoutParentNestedInput
    AttributeAndValues?: AccountAttributeAndValueUncheckedUpdateManyWithoutAccountNestedInput
    modelAccounts?: ModelAccountStructureUncheckedUpdateManyWithoutAccountNestedInput
    modeldataCalculations?: ModelDataCalculationsUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type VersionUpsertWithoutModelDataInput = {
    update: XOR<VersionUpdateWithoutModelDataInput, VersionUncheckedUpdateWithoutModelDataInput>
    create: XOR<VersionCreateWithoutModelDataInput, VersionUncheckedCreateWithoutModelDataInput>
    where?: VersionWhereInput
  }

  export type VersionUpdateToOneWithWhereWithoutModelDataInput = {
    where?: VersionWhereInput
    data: XOR<VersionUpdateWithoutModelDataInput, VersionUncheckedUpdateWithoutModelDataInput>
  }

  export type VersionUpdateWithoutModelDataInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    begin?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    startOfPlan?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isActuals?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumversionStatusFieldUpdateOperationsInput | $Enums.versionStatus
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instance?: InstanceUpdateOneRequiredWithoutVersionsNestedInput
    modelDataCalculations?: ModelDataCalculationsUpdateManyWithoutVersionNestedInput
  }

  export type VersionUncheckedUpdateWithoutModelDataInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    begin?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    startOfPlan?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isActuals?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumversionStatusFieldUpdateOperationsInput | $Enums.versionStatus
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modelDataCalculations?: ModelDataCalculationsUncheckedUpdateManyWithoutVersionNestedInput
  }

  export type InstanceUpsertWithoutModelDataInput = {
    update: XOR<InstanceUpdateWithoutModelDataInput, InstanceUncheckedUpdateWithoutModelDataInput>
    create: XOR<InstanceCreateWithoutModelDataInput, InstanceUncheckedCreateWithoutModelDataInput>
    where?: InstanceWhereInput
  }

  export type InstanceUpdateToOneWithWhereWithoutModelDataInput = {
    where?: InstanceWhereInput
    data: XOR<InstanceUpdateWithoutModelDataInput, InstanceUncheckedUpdateWithoutModelDataInput>
  }

  export type InstanceUpdateWithoutModelDataInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnuminstanceStatusFieldUpdateOperationsInput | $Enums.instanceStatus
    userIds?: InstanceUpdateuserIdsInput | string[]
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    client?: ClientUpdateOneRequiredWithoutInstancesNestedInput
    levels?: LevelUpdateManyWithoutInstanceNestedInput
    versions?: VersionUpdateManyWithoutInstanceNestedInput
    currencies?: CurrencyUpdateManyWithoutInstanceNestedInput
    accounts?: AccountUpdateManyWithoutInstanceNestedInput
    models?: ModelUpdateManyWithoutInstanceNestedInput
    dimensions?: DimensionUpdateManyWithoutInstanceNestedInput
    dimensionValues?: DimensionValueUpdateManyWithoutInstanceNestedInput
    levelAttributes?: LevelAttributeUpdateManyWithoutInstanceNestedInput
    dimensionValueAttributes?: DimensionValueAttributeUpdateManyWithoutInstanceNestedInput
    accountAttributes?: AccountAttributeUpdateManyWithoutInstanceNestedInput
    levelAttValues?: LevelAttributeValueUpdateManyWithoutInstanceNestedInput
    accountAttValues?: AccountAttributeValueUpdateManyWithoutInstanceNestedInput
    dimensionValueAttributeValues?: DimensionValueAttributeValueUpdateManyWithoutInstanceNestedInput
    modelDataCalculations?: ModelDataCalculationsUpdateManyWithoutInstanceNestedInput
    modelAccounts?: ModelAccountStructureUpdateManyWithoutInstanceNestedInput
    tables?: TableUpdateManyWithoutInstanceNestedInput
    tableData?: TableDataUpdateManyWithoutInstanceNestedInput
  }

  export type InstanceUncheckedUpdateWithoutModelDataInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnuminstanceStatusFieldUpdateOperationsInput | $Enums.instanceStatus
    userIds?: InstanceUpdateuserIdsInput | string[]
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    levels?: LevelUncheckedUpdateManyWithoutInstanceNestedInput
    versions?: VersionUncheckedUpdateManyWithoutInstanceNestedInput
    currencies?: CurrencyUncheckedUpdateManyWithoutInstanceNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutInstanceNestedInput
    models?: ModelUncheckedUpdateManyWithoutInstanceNestedInput
    dimensions?: DimensionUncheckedUpdateManyWithoutInstanceNestedInput
    dimensionValues?: DimensionValueUncheckedUpdateManyWithoutInstanceNestedInput
    levelAttributes?: LevelAttributeUncheckedUpdateManyWithoutInstanceNestedInput
    dimensionValueAttributes?: DimensionValueAttributeUncheckedUpdateManyWithoutInstanceNestedInput
    accountAttributes?: AccountAttributeUncheckedUpdateManyWithoutInstanceNestedInput
    levelAttValues?: LevelAttributeValueUncheckedUpdateManyWithoutInstanceNestedInput
    accountAttValues?: AccountAttributeValueUncheckedUpdateManyWithoutInstanceNestedInput
    dimensionValueAttributeValues?: DimensionValueAttributeValueUncheckedUpdateManyWithoutInstanceNestedInput
    modelDataCalculations?: ModelDataCalculationsUncheckedUpdateManyWithoutInstanceNestedInput
    modelAccounts?: ModelAccountStructureUncheckedUpdateManyWithoutInstanceNestedInput
    tables?: TableUncheckedUpdateManyWithoutInstanceNestedInput
    tableData?: TableDataUncheckedUpdateManyWithoutInstanceNestedInput
  }

  export type ModelCreateWithoutModelDataCalculationsInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    dimensionality?: ModelCreatedimensionalityInput | string[]
    status?: $Enums.ModelStatus
    isDefault?: boolean
    clientId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    rootAccountId: string
    instance: InstanceCreateNestedOneWithoutModelsInput
    modelData?: ModelDataCreateNestedManyWithoutModelInput
    modelAccounts?: ModelAccountStructureCreateNestedManyWithoutModelInput
  }

  export type ModelUncheckedCreateWithoutModelDataCalculationsInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    dimensionality?: ModelCreatedimensionalityInput | string[]
    status?: $Enums.ModelStatus
    isDefault?: boolean
    instanceId: string
    clientId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    rootAccountId: string
    modelData?: ModelDataUncheckedCreateNestedManyWithoutModelInput
    modelAccounts?: ModelAccountStructureUncheckedCreateNestedManyWithoutModelInput
  }

  export type ModelCreateOrConnectWithoutModelDataCalculationsInput = {
    where: ModelWhereUniqueInput
    create: XOR<ModelCreateWithoutModelDataCalculationsInput, ModelUncheckedCreateWithoutModelDataCalculationsInput>
  }

  export type LevelCreateWithoutModeldataCalculationsInput = {
    id?: string
    code: string
    name: string
    isRoot?: boolean
    description?: string | null
    clientId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    AttributeAndValues?: LevelAttributeAndValueCreateNestedManyWithoutLevelInput
    parent?: LevelCreateNestedOneWithoutChildLevelsInput
    instance: InstanceCreateNestedOneWithoutLevelsInput
    currency: CurrencyCreateNestedOneWithoutLevelsInput
    childLevels?: LevelCreateNestedManyWithoutParentInput
    modelData?: ModelDataCreateNestedManyWithoutLevelInput
  }

  export type LevelUncheckedCreateWithoutModeldataCalculationsInput = {
    id?: string
    code: string
    name: string
    isRoot?: boolean
    description?: string | null
    parentId?: string | null
    clientId: string
    instanceId: string
    currencyId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    AttributeAndValues?: LevelAttributeAndValueUncheckedCreateNestedManyWithoutLevelInput
    childLevels?: LevelUncheckedCreateNestedManyWithoutParentInput
    modelData?: ModelDataUncheckedCreateNestedManyWithoutLevelInput
  }

  export type LevelCreateOrConnectWithoutModeldataCalculationsInput = {
    where: LevelWhereUniqueInput
    create: XOR<LevelCreateWithoutModeldataCalculationsInput, LevelUncheckedCreateWithoutModeldataCalculationsInput>
  }

  export type AccountCreateWithoutModeldataCalculationsInput = {
    id?: string
    code: string
    name: string
    isRoot?: boolean
    isModelRoot?: boolean
    accountType: $Enums.AccountType
    accountTypeTag: $Enums.AccountTypeTag
    group?: $Enums.YesNo
    plannedBy?: $Enums.ActPlanBy | null
    actualsBy?: $Enums.ActActualsBy | null
    displayAs?: $Enums.ActDisplayAs
    containsSalaryInfo?: $Enums.YesNo
    description?: string | null
    clientId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    instance: InstanceCreateNestedOneWithoutAccountsInput
    parent?: AccountCreateNestedOneWithoutChildAccountsInput
    childAccounts?: AccountCreateNestedManyWithoutParentInput
    AttributeAndValues?: AccountAttributeAndValueCreateNestedManyWithoutAccountInput
    modelAccounts?: ModelAccountStructureCreateNestedManyWithoutAccountInput
    modelData?: ModelDataCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutModeldataCalculationsInput = {
    id?: string
    code: string
    name: string
    isRoot?: boolean
    isModelRoot?: boolean
    accountType: $Enums.AccountType
    accountTypeTag: $Enums.AccountTypeTag
    group?: $Enums.YesNo
    plannedBy?: $Enums.ActPlanBy | null
    actualsBy?: $Enums.ActActualsBy | null
    displayAs?: $Enums.ActDisplayAs
    containsSalaryInfo?: $Enums.YesNo
    description?: string | null
    instanceId: string
    clientId: string
    parentId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    childAccounts?: AccountUncheckedCreateNestedManyWithoutParentInput
    AttributeAndValues?: AccountAttributeAndValueUncheckedCreateNestedManyWithoutAccountInput
    modelAccounts?: ModelAccountStructureUncheckedCreateNestedManyWithoutAccountInput
    modelData?: ModelDataUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutModeldataCalculationsInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutModeldataCalculationsInput, AccountUncheckedCreateWithoutModeldataCalculationsInput>
  }

  export type VersionCreateWithoutModelDataCalculationsInput = {
    id?: string
    code: string
    name: string
    begin: Date | string
    end: Date | string
    startOfPlan: Date | string
    description?: string | null
    isDefault?: boolean
    isActuals?: boolean
    status?: $Enums.versionStatus
    clientId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    instance: InstanceCreateNestedOneWithoutVersionsInput
    modelData?: ModelDataCreateNestedManyWithoutVersionInput
  }

  export type VersionUncheckedCreateWithoutModelDataCalculationsInput = {
    id?: string
    code: string
    name: string
    begin: Date | string
    end: Date | string
    startOfPlan: Date | string
    description?: string | null
    isDefault?: boolean
    isActuals?: boolean
    status?: $Enums.versionStatus
    clientId: string
    instanceId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    modelData?: ModelDataUncheckedCreateNestedManyWithoutVersionInput
  }

  export type VersionCreateOrConnectWithoutModelDataCalculationsInput = {
    where: VersionWhereUniqueInput
    create: XOR<VersionCreateWithoutModelDataCalculationsInput, VersionUncheckedCreateWithoutModelDataCalculationsInput>
  }

  export type InstanceCreateWithoutModelDataCalculationsInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    status?: $Enums.instanceStatus
    userIds?: InstanceCreateuserIdsInput | string[]
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    client: ClientCreateNestedOneWithoutInstancesInput
    levels?: LevelCreateNestedManyWithoutInstanceInput
    versions?: VersionCreateNestedManyWithoutInstanceInput
    currencies?: CurrencyCreateNestedManyWithoutInstanceInput
    accounts?: AccountCreateNestedManyWithoutInstanceInput
    models?: ModelCreateNestedManyWithoutInstanceInput
    dimensions?: DimensionCreateNestedManyWithoutInstanceInput
    dimensionValues?: DimensionValueCreateNestedManyWithoutInstanceInput
    levelAttributes?: LevelAttributeCreateNestedManyWithoutInstanceInput
    dimensionValueAttributes?: DimensionValueAttributeCreateNestedManyWithoutInstanceInput
    accountAttributes?: AccountAttributeCreateNestedManyWithoutInstanceInput
    levelAttValues?: LevelAttributeValueCreateNestedManyWithoutInstanceInput
    accountAttValues?: AccountAttributeValueCreateNestedManyWithoutInstanceInput
    dimensionValueAttributeValues?: DimensionValueAttributeValueCreateNestedManyWithoutInstanceInput
    modelData?: ModelDataCreateNestedManyWithoutInstanceInput
    modelAccounts?: ModelAccountStructureCreateNestedManyWithoutInstanceInput
    tables?: TableCreateNestedManyWithoutInstanceInput
    tableData?: TableDataCreateNestedManyWithoutInstanceInput
  }

  export type InstanceUncheckedCreateWithoutModelDataCalculationsInput = {
    id?: string
    code: string
    name: string
    clientId: string
    description?: string | null
    status?: $Enums.instanceStatus
    userIds?: InstanceCreateuserIdsInput | string[]
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    levels?: LevelUncheckedCreateNestedManyWithoutInstanceInput
    versions?: VersionUncheckedCreateNestedManyWithoutInstanceInput
    currencies?: CurrencyUncheckedCreateNestedManyWithoutInstanceInput
    accounts?: AccountUncheckedCreateNestedManyWithoutInstanceInput
    models?: ModelUncheckedCreateNestedManyWithoutInstanceInput
    dimensions?: DimensionUncheckedCreateNestedManyWithoutInstanceInput
    dimensionValues?: DimensionValueUncheckedCreateNestedManyWithoutInstanceInput
    levelAttributes?: LevelAttributeUncheckedCreateNestedManyWithoutInstanceInput
    dimensionValueAttributes?: DimensionValueAttributeUncheckedCreateNestedManyWithoutInstanceInput
    accountAttributes?: AccountAttributeUncheckedCreateNestedManyWithoutInstanceInput
    levelAttValues?: LevelAttributeValueUncheckedCreateNestedManyWithoutInstanceInput
    accountAttValues?: AccountAttributeValueUncheckedCreateNestedManyWithoutInstanceInput
    dimensionValueAttributeValues?: DimensionValueAttributeValueUncheckedCreateNestedManyWithoutInstanceInput
    modelData?: ModelDataUncheckedCreateNestedManyWithoutInstanceInput
    modelAccounts?: ModelAccountStructureUncheckedCreateNestedManyWithoutInstanceInput
    tables?: TableUncheckedCreateNestedManyWithoutInstanceInput
    tableData?: TableDataUncheckedCreateNestedManyWithoutInstanceInput
  }

  export type InstanceCreateOrConnectWithoutModelDataCalculationsInput = {
    where: InstanceWhereUniqueInput
    create: XOR<InstanceCreateWithoutModelDataCalculationsInput, InstanceUncheckedCreateWithoutModelDataCalculationsInput>
  }

  export type ModelAccountStructureCreateWithoutModeldataCalculationsInput = {
    id?: string
    isRoot?: boolean
    clientId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    instance: InstanceCreateNestedOneWithoutModelAccountsInput
    model: ModelCreateNestedOneWithoutModelAccountsInput
    account: AccountCreateNestedOneWithoutModelAccountsInput
    parentAccount?: ModelAccountStructureCreateNestedOneWithoutChildAccountsInput
    childAccounts?: ModelAccountStructureCreateNestedManyWithoutParentAccountInput
  }

  export type ModelAccountStructureUncheckedCreateWithoutModeldataCalculationsInput = {
    id?: string
    instanceId: string
    isRoot?: boolean
    clientId: string
    parentId?: string | null
    modelId: string
    accountId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    childAccounts?: ModelAccountStructureUncheckedCreateNestedManyWithoutParentAccountInput
  }

  export type ModelAccountStructureCreateOrConnectWithoutModeldataCalculationsInput = {
    where: ModelAccountStructureWhereUniqueInput
    create: XOR<ModelAccountStructureCreateWithoutModeldataCalculationsInput, ModelAccountStructureUncheckedCreateWithoutModeldataCalculationsInput>
  }

  export type ModelUpsertWithoutModelDataCalculationsInput = {
    update: XOR<ModelUpdateWithoutModelDataCalculationsInput, ModelUncheckedUpdateWithoutModelDataCalculationsInput>
    create: XOR<ModelCreateWithoutModelDataCalculationsInput, ModelUncheckedCreateWithoutModelDataCalculationsInput>
    where?: ModelWhereInput
  }

  export type ModelUpdateToOneWithWhereWithoutModelDataCalculationsInput = {
    where?: ModelWhereInput
    data: XOR<ModelUpdateWithoutModelDataCalculationsInput, ModelUncheckedUpdateWithoutModelDataCalculationsInput>
  }

  export type ModelUpdateWithoutModelDataCalculationsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dimensionality?: ModelUpdatedimensionalityInput | string[]
    status?: EnumModelStatusFieldUpdateOperationsInput | $Enums.ModelStatus
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rootAccountId?: StringFieldUpdateOperationsInput | string
    instance?: InstanceUpdateOneRequiredWithoutModelsNestedInput
    modelData?: ModelDataUpdateManyWithoutModelNestedInput
    modelAccounts?: ModelAccountStructureUpdateManyWithoutModelNestedInput
  }

  export type ModelUncheckedUpdateWithoutModelDataCalculationsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dimensionality?: ModelUpdatedimensionalityInput | string[]
    status?: EnumModelStatusFieldUpdateOperationsInput | $Enums.ModelStatus
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    instanceId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rootAccountId?: StringFieldUpdateOperationsInput | string
    modelData?: ModelDataUncheckedUpdateManyWithoutModelNestedInput
    modelAccounts?: ModelAccountStructureUncheckedUpdateManyWithoutModelNestedInput
  }

  export type LevelUpsertWithoutModeldataCalculationsInput = {
    update: XOR<LevelUpdateWithoutModeldataCalculationsInput, LevelUncheckedUpdateWithoutModeldataCalculationsInput>
    create: XOR<LevelCreateWithoutModeldataCalculationsInput, LevelUncheckedCreateWithoutModeldataCalculationsInput>
    where?: LevelWhereInput
  }

  export type LevelUpdateToOneWithWhereWithoutModeldataCalculationsInput = {
    where?: LevelWhereInput
    data: XOR<LevelUpdateWithoutModeldataCalculationsInput, LevelUncheckedUpdateWithoutModeldataCalculationsInput>
  }

  export type LevelUpdateWithoutModeldataCalculationsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isRoot?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    AttributeAndValues?: LevelAttributeAndValueUpdateManyWithoutLevelNestedInput
    parent?: LevelUpdateOneWithoutChildLevelsNestedInput
    instance?: InstanceUpdateOneRequiredWithoutLevelsNestedInput
    currency?: CurrencyUpdateOneRequiredWithoutLevelsNestedInput
    childLevels?: LevelUpdateManyWithoutParentNestedInput
    modelData?: ModelDataUpdateManyWithoutLevelNestedInput
  }

  export type LevelUncheckedUpdateWithoutModeldataCalculationsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isRoot?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    currencyId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    AttributeAndValues?: LevelAttributeAndValueUncheckedUpdateManyWithoutLevelNestedInput
    childLevels?: LevelUncheckedUpdateManyWithoutParentNestedInput
    modelData?: ModelDataUncheckedUpdateManyWithoutLevelNestedInput
  }

  export type AccountUpsertWithoutModeldataCalculationsInput = {
    update: XOR<AccountUpdateWithoutModeldataCalculationsInput, AccountUncheckedUpdateWithoutModeldataCalculationsInput>
    create: XOR<AccountCreateWithoutModeldataCalculationsInput, AccountUncheckedCreateWithoutModeldataCalculationsInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutModeldataCalculationsInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutModeldataCalculationsInput, AccountUncheckedUpdateWithoutModeldataCalculationsInput>
  }

  export type AccountUpdateWithoutModeldataCalculationsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isRoot?: BoolFieldUpdateOperationsInput | boolean
    isModelRoot?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    accountTypeTag?: EnumAccountTypeTagFieldUpdateOperationsInput | $Enums.AccountTypeTag
    group?: EnumYesNoFieldUpdateOperationsInput | $Enums.YesNo
    plannedBy?: NullableEnumActPlanByFieldUpdateOperationsInput | $Enums.ActPlanBy | null
    actualsBy?: NullableEnumActActualsByFieldUpdateOperationsInput | $Enums.ActActualsBy | null
    displayAs?: EnumActDisplayAsFieldUpdateOperationsInput | $Enums.ActDisplayAs
    containsSalaryInfo?: EnumYesNoFieldUpdateOperationsInput | $Enums.YesNo
    description?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instance?: InstanceUpdateOneRequiredWithoutAccountsNestedInput
    parent?: AccountUpdateOneWithoutChildAccountsNestedInput
    childAccounts?: AccountUpdateManyWithoutParentNestedInput
    AttributeAndValues?: AccountAttributeAndValueUpdateManyWithoutAccountNestedInput
    modelAccounts?: ModelAccountStructureUpdateManyWithoutAccountNestedInput
    modelData?: ModelDataUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutModeldataCalculationsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isRoot?: BoolFieldUpdateOperationsInput | boolean
    isModelRoot?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    accountTypeTag?: EnumAccountTypeTagFieldUpdateOperationsInput | $Enums.AccountTypeTag
    group?: EnumYesNoFieldUpdateOperationsInput | $Enums.YesNo
    plannedBy?: NullableEnumActPlanByFieldUpdateOperationsInput | $Enums.ActPlanBy | null
    actualsBy?: NullableEnumActActualsByFieldUpdateOperationsInput | $Enums.ActActualsBy | null
    displayAs?: EnumActDisplayAsFieldUpdateOperationsInput | $Enums.ActDisplayAs
    containsSalaryInfo?: EnumYesNoFieldUpdateOperationsInput | $Enums.YesNo
    description?: NullableStringFieldUpdateOperationsInput | string | null
    instanceId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    childAccounts?: AccountUncheckedUpdateManyWithoutParentNestedInput
    AttributeAndValues?: AccountAttributeAndValueUncheckedUpdateManyWithoutAccountNestedInput
    modelAccounts?: ModelAccountStructureUncheckedUpdateManyWithoutAccountNestedInput
    modelData?: ModelDataUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type VersionUpsertWithoutModelDataCalculationsInput = {
    update: XOR<VersionUpdateWithoutModelDataCalculationsInput, VersionUncheckedUpdateWithoutModelDataCalculationsInput>
    create: XOR<VersionCreateWithoutModelDataCalculationsInput, VersionUncheckedCreateWithoutModelDataCalculationsInput>
    where?: VersionWhereInput
  }

  export type VersionUpdateToOneWithWhereWithoutModelDataCalculationsInput = {
    where?: VersionWhereInput
    data: XOR<VersionUpdateWithoutModelDataCalculationsInput, VersionUncheckedUpdateWithoutModelDataCalculationsInput>
  }

  export type VersionUpdateWithoutModelDataCalculationsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    begin?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    startOfPlan?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isActuals?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumversionStatusFieldUpdateOperationsInput | $Enums.versionStatus
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instance?: InstanceUpdateOneRequiredWithoutVersionsNestedInput
    modelData?: ModelDataUpdateManyWithoutVersionNestedInput
  }

  export type VersionUncheckedUpdateWithoutModelDataCalculationsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    begin?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    startOfPlan?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isActuals?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumversionStatusFieldUpdateOperationsInput | $Enums.versionStatus
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modelData?: ModelDataUncheckedUpdateManyWithoutVersionNestedInput
  }

  export type InstanceUpsertWithoutModelDataCalculationsInput = {
    update: XOR<InstanceUpdateWithoutModelDataCalculationsInput, InstanceUncheckedUpdateWithoutModelDataCalculationsInput>
    create: XOR<InstanceCreateWithoutModelDataCalculationsInput, InstanceUncheckedCreateWithoutModelDataCalculationsInput>
    where?: InstanceWhereInput
  }

  export type InstanceUpdateToOneWithWhereWithoutModelDataCalculationsInput = {
    where?: InstanceWhereInput
    data: XOR<InstanceUpdateWithoutModelDataCalculationsInput, InstanceUncheckedUpdateWithoutModelDataCalculationsInput>
  }

  export type InstanceUpdateWithoutModelDataCalculationsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnuminstanceStatusFieldUpdateOperationsInput | $Enums.instanceStatus
    userIds?: InstanceUpdateuserIdsInput | string[]
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    client?: ClientUpdateOneRequiredWithoutInstancesNestedInput
    levels?: LevelUpdateManyWithoutInstanceNestedInput
    versions?: VersionUpdateManyWithoutInstanceNestedInput
    currencies?: CurrencyUpdateManyWithoutInstanceNestedInput
    accounts?: AccountUpdateManyWithoutInstanceNestedInput
    models?: ModelUpdateManyWithoutInstanceNestedInput
    dimensions?: DimensionUpdateManyWithoutInstanceNestedInput
    dimensionValues?: DimensionValueUpdateManyWithoutInstanceNestedInput
    levelAttributes?: LevelAttributeUpdateManyWithoutInstanceNestedInput
    dimensionValueAttributes?: DimensionValueAttributeUpdateManyWithoutInstanceNestedInput
    accountAttributes?: AccountAttributeUpdateManyWithoutInstanceNestedInput
    levelAttValues?: LevelAttributeValueUpdateManyWithoutInstanceNestedInput
    accountAttValues?: AccountAttributeValueUpdateManyWithoutInstanceNestedInput
    dimensionValueAttributeValues?: DimensionValueAttributeValueUpdateManyWithoutInstanceNestedInput
    modelData?: ModelDataUpdateManyWithoutInstanceNestedInput
    modelAccounts?: ModelAccountStructureUpdateManyWithoutInstanceNestedInput
    tables?: TableUpdateManyWithoutInstanceNestedInput
    tableData?: TableDataUpdateManyWithoutInstanceNestedInput
  }

  export type InstanceUncheckedUpdateWithoutModelDataCalculationsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnuminstanceStatusFieldUpdateOperationsInput | $Enums.instanceStatus
    userIds?: InstanceUpdateuserIdsInput | string[]
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    levels?: LevelUncheckedUpdateManyWithoutInstanceNestedInput
    versions?: VersionUncheckedUpdateManyWithoutInstanceNestedInput
    currencies?: CurrencyUncheckedUpdateManyWithoutInstanceNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutInstanceNestedInput
    models?: ModelUncheckedUpdateManyWithoutInstanceNestedInput
    dimensions?: DimensionUncheckedUpdateManyWithoutInstanceNestedInput
    dimensionValues?: DimensionValueUncheckedUpdateManyWithoutInstanceNestedInput
    levelAttributes?: LevelAttributeUncheckedUpdateManyWithoutInstanceNestedInput
    dimensionValueAttributes?: DimensionValueAttributeUncheckedUpdateManyWithoutInstanceNestedInput
    accountAttributes?: AccountAttributeUncheckedUpdateManyWithoutInstanceNestedInput
    levelAttValues?: LevelAttributeValueUncheckedUpdateManyWithoutInstanceNestedInput
    accountAttValues?: AccountAttributeValueUncheckedUpdateManyWithoutInstanceNestedInput
    dimensionValueAttributeValues?: DimensionValueAttributeValueUncheckedUpdateManyWithoutInstanceNestedInput
    modelData?: ModelDataUncheckedUpdateManyWithoutInstanceNestedInput
    modelAccounts?: ModelAccountStructureUncheckedUpdateManyWithoutInstanceNestedInput
    tables?: TableUncheckedUpdateManyWithoutInstanceNestedInput
    tableData?: TableDataUncheckedUpdateManyWithoutInstanceNestedInput
  }

  export type ModelAccountStructureUpsertWithoutModeldataCalculationsInput = {
    update: XOR<ModelAccountStructureUpdateWithoutModeldataCalculationsInput, ModelAccountStructureUncheckedUpdateWithoutModeldataCalculationsInput>
    create: XOR<ModelAccountStructureCreateWithoutModeldataCalculationsInput, ModelAccountStructureUncheckedCreateWithoutModeldataCalculationsInput>
    where?: ModelAccountStructureWhereInput
  }

  export type ModelAccountStructureUpdateToOneWithWhereWithoutModeldataCalculationsInput = {
    where?: ModelAccountStructureWhereInput
    data: XOR<ModelAccountStructureUpdateWithoutModeldataCalculationsInput, ModelAccountStructureUncheckedUpdateWithoutModeldataCalculationsInput>
  }

  export type ModelAccountStructureUpdateWithoutModeldataCalculationsInput = {
    isRoot?: BoolFieldUpdateOperationsInput | boolean
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instance?: InstanceUpdateOneRequiredWithoutModelAccountsNestedInput
    model?: ModelUpdateOneRequiredWithoutModelAccountsNestedInput
    account?: AccountUpdateOneRequiredWithoutModelAccountsNestedInput
    parentAccount?: ModelAccountStructureUpdateOneWithoutChildAccountsNestedInput
    childAccounts?: ModelAccountStructureUpdateManyWithoutParentAccountNestedInput
  }

  export type ModelAccountStructureUncheckedUpdateWithoutModeldataCalculationsInput = {
    instanceId?: StringFieldUpdateOperationsInput | string
    isRoot?: BoolFieldUpdateOperationsInput | boolean
    clientId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    modelId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    childAccounts?: ModelAccountStructureUncheckedUpdateManyWithoutParentAccountNestedInput
  }

  export type InstanceCreateWithoutTablesInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    status?: $Enums.instanceStatus
    userIds?: InstanceCreateuserIdsInput | string[]
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    client: ClientCreateNestedOneWithoutInstancesInput
    levels?: LevelCreateNestedManyWithoutInstanceInput
    versions?: VersionCreateNestedManyWithoutInstanceInput
    currencies?: CurrencyCreateNestedManyWithoutInstanceInput
    accounts?: AccountCreateNestedManyWithoutInstanceInput
    models?: ModelCreateNestedManyWithoutInstanceInput
    dimensions?: DimensionCreateNestedManyWithoutInstanceInput
    dimensionValues?: DimensionValueCreateNestedManyWithoutInstanceInput
    levelAttributes?: LevelAttributeCreateNestedManyWithoutInstanceInput
    dimensionValueAttributes?: DimensionValueAttributeCreateNestedManyWithoutInstanceInput
    accountAttributes?: AccountAttributeCreateNestedManyWithoutInstanceInput
    levelAttValues?: LevelAttributeValueCreateNestedManyWithoutInstanceInput
    accountAttValues?: AccountAttributeValueCreateNestedManyWithoutInstanceInput
    dimensionValueAttributeValues?: DimensionValueAttributeValueCreateNestedManyWithoutInstanceInput
    modelData?: ModelDataCreateNestedManyWithoutInstanceInput
    modelDataCalculations?: ModelDataCalculationsCreateNestedManyWithoutInstanceInput
    modelAccounts?: ModelAccountStructureCreateNestedManyWithoutInstanceInput
    tableData?: TableDataCreateNestedManyWithoutInstanceInput
  }

  export type InstanceUncheckedCreateWithoutTablesInput = {
    id?: string
    code: string
    name: string
    clientId: string
    description?: string | null
    status?: $Enums.instanceStatus
    userIds?: InstanceCreateuserIdsInput | string[]
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    levels?: LevelUncheckedCreateNestedManyWithoutInstanceInput
    versions?: VersionUncheckedCreateNestedManyWithoutInstanceInput
    currencies?: CurrencyUncheckedCreateNestedManyWithoutInstanceInput
    accounts?: AccountUncheckedCreateNestedManyWithoutInstanceInput
    models?: ModelUncheckedCreateNestedManyWithoutInstanceInput
    dimensions?: DimensionUncheckedCreateNestedManyWithoutInstanceInput
    dimensionValues?: DimensionValueUncheckedCreateNestedManyWithoutInstanceInput
    levelAttributes?: LevelAttributeUncheckedCreateNestedManyWithoutInstanceInput
    dimensionValueAttributes?: DimensionValueAttributeUncheckedCreateNestedManyWithoutInstanceInput
    accountAttributes?: AccountAttributeUncheckedCreateNestedManyWithoutInstanceInput
    levelAttValues?: LevelAttributeValueUncheckedCreateNestedManyWithoutInstanceInput
    accountAttValues?: AccountAttributeValueUncheckedCreateNestedManyWithoutInstanceInput
    dimensionValueAttributeValues?: DimensionValueAttributeValueUncheckedCreateNestedManyWithoutInstanceInput
    modelData?: ModelDataUncheckedCreateNestedManyWithoutInstanceInput
    modelDataCalculations?: ModelDataCalculationsUncheckedCreateNestedManyWithoutInstanceInput
    modelAccounts?: ModelAccountStructureUncheckedCreateNestedManyWithoutInstanceInput
    tableData?: TableDataUncheckedCreateNestedManyWithoutInstanceInput
  }

  export type InstanceCreateOrConnectWithoutTablesInput = {
    where: InstanceWhereUniqueInput
    create: XOR<InstanceCreateWithoutTablesInput, InstanceUncheckedCreateWithoutTablesInput>
  }

  export type TableDataCreateWithoutTableInput = {
    id?: string
    clientId: string
    rowKey: string
    versionId: string
    levelId: string
    data: InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    instance: InstanceCreateNestedOneWithoutTableDataInput
  }

  export type TableDataUncheckedCreateWithoutTableInput = {
    id?: string
    clientId: string
    instanceId: string
    rowKey: string
    versionId: string
    levelId: string
    data: InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type TableDataCreateOrConnectWithoutTableInput = {
    where: TableDataWhereUniqueInput
    create: XOR<TableDataCreateWithoutTableInput, TableDataUncheckedCreateWithoutTableInput>
  }

  export type TableDataCreateManyTableInputEnvelope = {
    data: TableDataCreateManyTableInput | TableDataCreateManyTableInput[]
  }

  export type TableColumnDefinitionUpdateManyInput = {
    where: TableColumnDefinitionWhereInput
    data: TableColumnDefinitionUpdateInput
  }

  export type TableColumnDefinitionDeleteManyInput = {
    where: TableColumnDefinitionWhereInput
  }

  export type InstanceUpsertWithoutTablesInput = {
    update: XOR<InstanceUpdateWithoutTablesInput, InstanceUncheckedUpdateWithoutTablesInput>
    create: XOR<InstanceCreateWithoutTablesInput, InstanceUncheckedCreateWithoutTablesInput>
    where?: InstanceWhereInput
  }

  export type InstanceUpdateToOneWithWhereWithoutTablesInput = {
    where?: InstanceWhereInput
    data: XOR<InstanceUpdateWithoutTablesInput, InstanceUncheckedUpdateWithoutTablesInput>
  }

  export type InstanceUpdateWithoutTablesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnuminstanceStatusFieldUpdateOperationsInput | $Enums.instanceStatus
    userIds?: InstanceUpdateuserIdsInput | string[]
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    client?: ClientUpdateOneRequiredWithoutInstancesNestedInput
    levels?: LevelUpdateManyWithoutInstanceNestedInput
    versions?: VersionUpdateManyWithoutInstanceNestedInput
    currencies?: CurrencyUpdateManyWithoutInstanceNestedInput
    accounts?: AccountUpdateManyWithoutInstanceNestedInput
    models?: ModelUpdateManyWithoutInstanceNestedInput
    dimensions?: DimensionUpdateManyWithoutInstanceNestedInput
    dimensionValues?: DimensionValueUpdateManyWithoutInstanceNestedInput
    levelAttributes?: LevelAttributeUpdateManyWithoutInstanceNestedInput
    dimensionValueAttributes?: DimensionValueAttributeUpdateManyWithoutInstanceNestedInput
    accountAttributes?: AccountAttributeUpdateManyWithoutInstanceNestedInput
    levelAttValues?: LevelAttributeValueUpdateManyWithoutInstanceNestedInput
    accountAttValues?: AccountAttributeValueUpdateManyWithoutInstanceNestedInput
    dimensionValueAttributeValues?: DimensionValueAttributeValueUpdateManyWithoutInstanceNestedInput
    modelData?: ModelDataUpdateManyWithoutInstanceNestedInput
    modelDataCalculations?: ModelDataCalculationsUpdateManyWithoutInstanceNestedInput
    modelAccounts?: ModelAccountStructureUpdateManyWithoutInstanceNestedInput
    tableData?: TableDataUpdateManyWithoutInstanceNestedInput
  }

  export type InstanceUncheckedUpdateWithoutTablesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnuminstanceStatusFieldUpdateOperationsInput | $Enums.instanceStatus
    userIds?: InstanceUpdateuserIdsInput | string[]
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    levels?: LevelUncheckedUpdateManyWithoutInstanceNestedInput
    versions?: VersionUncheckedUpdateManyWithoutInstanceNestedInput
    currencies?: CurrencyUncheckedUpdateManyWithoutInstanceNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutInstanceNestedInput
    models?: ModelUncheckedUpdateManyWithoutInstanceNestedInput
    dimensions?: DimensionUncheckedUpdateManyWithoutInstanceNestedInput
    dimensionValues?: DimensionValueUncheckedUpdateManyWithoutInstanceNestedInput
    levelAttributes?: LevelAttributeUncheckedUpdateManyWithoutInstanceNestedInput
    dimensionValueAttributes?: DimensionValueAttributeUncheckedUpdateManyWithoutInstanceNestedInput
    accountAttributes?: AccountAttributeUncheckedUpdateManyWithoutInstanceNestedInput
    levelAttValues?: LevelAttributeValueUncheckedUpdateManyWithoutInstanceNestedInput
    accountAttValues?: AccountAttributeValueUncheckedUpdateManyWithoutInstanceNestedInput
    dimensionValueAttributeValues?: DimensionValueAttributeValueUncheckedUpdateManyWithoutInstanceNestedInput
    modelData?: ModelDataUncheckedUpdateManyWithoutInstanceNestedInput
    modelDataCalculations?: ModelDataCalculationsUncheckedUpdateManyWithoutInstanceNestedInput
    modelAccounts?: ModelAccountStructureUncheckedUpdateManyWithoutInstanceNestedInput
    tableData?: TableDataUncheckedUpdateManyWithoutInstanceNestedInput
  }

  export type TableDataUpsertWithWhereUniqueWithoutTableInput = {
    where: TableDataWhereUniqueInput
    update: XOR<TableDataUpdateWithoutTableInput, TableDataUncheckedUpdateWithoutTableInput>
    create: XOR<TableDataCreateWithoutTableInput, TableDataUncheckedCreateWithoutTableInput>
  }

  export type TableDataUpdateWithWhereUniqueWithoutTableInput = {
    where: TableDataWhereUniqueInput
    data: XOR<TableDataUpdateWithoutTableInput, TableDataUncheckedUpdateWithoutTableInput>
  }

  export type TableDataUpdateManyWithWhereWithoutTableInput = {
    where: TableDataScalarWhereInput
    data: XOR<TableDataUpdateManyMutationInput, TableDataUncheckedUpdateManyWithoutTableInput>
  }

  export type TableCreateWithoutTableDataInput = {
    id?: string
    clientId: string
    name: string
    code: string
    description?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    status: $Enums.ModelStatus
    columnDefinitions?: XOR<TableColumnDefinitionListCreateEnvelopeInput, TableColumnDefinitionCreateInput> | TableColumnDefinitionCreateInput[]
    instance: InstanceCreateNestedOneWithoutTablesInput
  }

  export type TableUncheckedCreateWithoutTableDataInput = {
    id?: string
    clientId: string
    instanceId: string
    name: string
    code: string
    description?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    status: $Enums.ModelStatus
    columnDefinitions?: XOR<TableColumnDefinitionListCreateEnvelopeInput, TableColumnDefinitionCreateInput> | TableColumnDefinitionCreateInput[]
  }

  export type TableCreateOrConnectWithoutTableDataInput = {
    where: TableWhereUniqueInput
    create: XOR<TableCreateWithoutTableDataInput, TableUncheckedCreateWithoutTableDataInput>
  }

  export type InstanceCreateWithoutTableDataInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    status?: $Enums.instanceStatus
    userIds?: InstanceCreateuserIdsInput | string[]
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    client: ClientCreateNestedOneWithoutInstancesInput
    levels?: LevelCreateNestedManyWithoutInstanceInput
    versions?: VersionCreateNestedManyWithoutInstanceInput
    currencies?: CurrencyCreateNestedManyWithoutInstanceInput
    accounts?: AccountCreateNestedManyWithoutInstanceInput
    models?: ModelCreateNestedManyWithoutInstanceInput
    dimensions?: DimensionCreateNestedManyWithoutInstanceInput
    dimensionValues?: DimensionValueCreateNestedManyWithoutInstanceInput
    levelAttributes?: LevelAttributeCreateNestedManyWithoutInstanceInput
    dimensionValueAttributes?: DimensionValueAttributeCreateNestedManyWithoutInstanceInput
    accountAttributes?: AccountAttributeCreateNestedManyWithoutInstanceInput
    levelAttValues?: LevelAttributeValueCreateNestedManyWithoutInstanceInput
    accountAttValues?: AccountAttributeValueCreateNestedManyWithoutInstanceInput
    dimensionValueAttributeValues?: DimensionValueAttributeValueCreateNestedManyWithoutInstanceInput
    modelData?: ModelDataCreateNestedManyWithoutInstanceInput
    modelDataCalculations?: ModelDataCalculationsCreateNestedManyWithoutInstanceInput
    modelAccounts?: ModelAccountStructureCreateNestedManyWithoutInstanceInput
    tables?: TableCreateNestedManyWithoutInstanceInput
  }

  export type InstanceUncheckedCreateWithoutTableDataInput = {
    id?: string
    code: string
    name: string
    clientId: string
    description?: string | null
    status?: $Enums.instanceStatus
    userIds?: InstanceCreateuserIdsInput | string[]
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    levels?: LevelUncheckedCreateNestedManyWithoutInstanceInput
    versions?: VersionUncheckedCreateNestedManyWithoutInstanceInput
    currencies?: CurrencyUncheckedCreateNestedManyWithoutInstanceInput
    accounts?: AccountUncheckedCreateNestedManyWithoutInstanceInput
    models?: ModelUncheckedCreateNestedManyWithoutInstanceInput
    dimensions?: DimensionUncheckedCreateNestedManyWithoutInstanceInput
    dimensionValues?: DimensionValueUncheckedCreateNestedManyWithoutInstanceInput
    levelAttributes?: LevelAttributeUncheckedCreateNestedManyWithoutInstanceInput
    dimensionValueAttributes?: DimensionValueAttributeUncheckedCreateNestedManyWithoutInstanceInput
    accountAttributes?: AccountAttributeUncheckedCreateNestedManyWithoutInstanceInput
    levelAttValues?: LevelAttributeValueUncheckedCreateNestedManyWithoutInstanceInput
    accountAttValues?: AccountAttributeValueUncheckedCreateNestedManyWithoutInstanceInput
    dimensionValueAttributeValues?: DimensionValueAttributeValueUncheckedCreateNestedManyWithoutInstanceInput
    modelData?: ModelDataUncheckedCreateNestedManyWithoutInstanceInput
    modelDataCalculations?: ModelDataCalculationsUncheckedCreateNestedManyWithoutInstanceInput
    modelAccounts?: ModelAccountStructureUncheckedCreateNestedManyWithoutInstanceInput
    tables?: TableUncheckedCreateNestedManyWithoutInstanceInput
  }

  export type InstanceCreateOrConnectWithoutTableDataInput = {
    where: InstanceWhereUniqueInput
    create: XOR<InstanceCreateWithoutTableDataInput, InstanceUncheckedCreateWithoutTableDataInput>
  }

  export type TableUpsertWithoutTableDataInput = {
    update: XOR<TableUpdateWithoutTableDataInput, TableUncheckedUpdateWithoutTableDataInput>
    create: XOR<TableCreateWithoutTableDataInput, TableUncheckedCreateWithoutTableDataInput>
    where?: TableWhereInput
  }

  export type TableUpdateToOneWithWhereWithoutTableDataInput = {
    where?: TableWhereInput
    data: XOR<TableUpdateWithoutTableDataInput, TableUncheckedUpdateWithoutTableDataInput>
  }

  export type TableUpdateWithoutTableDataInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumModelStatusFieldUpdateOperationsInput | $Enums.ModelStatus
    columnDefinitions?: XOR<TableColumnDefinitionListUpdateEnvelopeInput, TableColumnDefinitionCreateInput> | TableColumnDefinitionCreateInput[]
    instance?: InstanceUpdateOneRequiredWithoutTablesNestedInput
  }

  export type TableUncheckedUpdateWithoutTableDataInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumModelStatusFieldUpdateOperationsInput | $Enums.ModelStatus
    columnDefinitions?: XOR<TableColumnDefinitionListUpdateEnvelopeInput, TableColumnDefinitionCreateInput> | TableColumnDefinitionCreateInput[]
  }

  export type InstanceUpsertWithoutTableDataInput = {
    update: XOR<InstanceUpdateWithoutTableDataInput, InstanceUncheckedUpdateWithoutTableDataInput>
    create: XOR<InstanceCreateWithoutTableDataInput, InstanceUncheckedCreateWithoutTableDataInput>
    where?: InstanceWhereInput
  }

  export type InstanceUpdateToOneWithWhereWithoutTableDataInput = {
    where?: InstanceWhereInput
    data: XOR<InstanceUpdateWithoutTableDataInput, InstanceUncheckedUpdateWithoutTableDataInput>
  }

  export type InstanceUpdateWithoutTableDataInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnuminstanceStatusFieldUpdateOperationsInput | $Enums.instanceStatus
    userIds?: InstanceUpdateuserIdsInput | string[]
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    client?: ClientUpdateOneRequiredWithoutInstancesNestedInput
    levels?: LevelUpdateManyWithoutInstanceNestedInput
    versions?: VersionUpdateManyWithoutInstanceNestedInput
    currencies?: CurrencyUpdateManyWithoutInstanceNestedInput
    accounts?: AccountUpdateManyWithoutInstanceNestedInput
    models?: ModelUpdateManyWithoutInstanceNestedInput
    dimensions?: DimensionUpdateManyWithoutInstanceNestedInput
    dimensionValues?: DimensionValueUpdateManyWithoutInstanceNestedInput
    levelAttributes?: LevelAttributeUpdateManyWithoutInstanceNestedInput
    dimensionValueAttributes?: DimensionValueAttributeUpdateManyWithoutInstanceNestedInput
    accountAttributes?: AccountAttributeUpdateManyWithoutInstanceNestedInput
    levelAttValues?: LevelAttributeValueUpdateManyWithoutInstanceNestedInput
    accountAttValues?: AccountAttributeValueUpdateManyWithoutInstanceNestedInput
    dimensionValueAttributeValues?: DimensionValueAttributeValueUpdateManyWithoutInstanceNestedInput
    modelData?: ModelDataUpdateManyWithoutInstanceNestedInput
    modelDataCalculations?: ModelDataCalculationsUpdateManyWithoutInstanceNestedInput
    modelAccounts?: ModelAccountStructureUpdateManyWithoutInstanceNestedInput
    tables?: TableUpdateManyWithoutInstanceNestedInput
  }

  export type InstanceUncheckedUpdateWithoutTableDataInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnuminstanceStatusFieldUpdateOperationsInput | $Enums.instanceStatus
    userIds?: InstanceUpdateuserIdsInput | string[]
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    levels?: LevelUncheckedUpdateManyWithoutInstanceNestedInput
    versions?: VersionUncheckedUpdateManyWithoutInstanceNestedInput
    currencies?: CurrencyUncheckedUpdateManyWithoutInstanceNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutInstanceNestedInput
    models?: ModelUncheckedUpdateManyWithoutInstanceNestedInput
    dimensions?: DimensionUncheckedUpdateManyWithoutInstanceNestedInput
    dimensionValues?: DimensionValueUncheckedUpdateManyWithoutInstanceNestedInput
    levelAttributes?: LevelAttributeUncheckedUpdateManyWithoutInstanceNestedInput
    dimensionValueAttributes?: DimensionValueAttributeUncheckedUpdateManyWithoutInstanceNestedInput
    accountAttributes?: AccountAttributeUncheckedUpdateManyWithoutInstanceNestedInput
    levelAttValues?: LevelAttributeValueUncheckedUpdateManyWithoutInstanceNestedInput
    accountAttValues?: AccountAttributeValueUncheckedUpdateManyWithoutInstanceNestedInput
    dimensionValueAttributeValues?: DimensionValueAttributeValueUncheckedUpdateManyWithoutInstanceNestedInput
    modelData?: ModelDataUncheckedUpdateManyWithoutInstanceNestedInput
    modelDataCalculations?: ModelDataCalculationsUncheckedUpdateManyWithoutInstanceNestedInput
    modelAccounts?: ModelAccountStructureUncheckedUpdateManyWithoutInstanceNestedInput
    tables?: TableUncheckedUpdateManyWithoutInstanceNestedInput
  }

  export type DataSourceCredentialCreateWithoutDatasourcesInput = {
    id?: string
    clientId: string
    instanceId: string
    name: string
    code: string
    description?: string | null
    type: $Enums.DatasourceCredentialAuthType
    credentialId?: string | null
    credentialKey?: string | null
    credentialSecret?: string | null
    credentialToken?: string | null
    credentialTokenSecret?: string | null
    credentialHostname?: string | null
    credentialUsername?: string | null
    fingerprint?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type DataSourceCredentialUncheckedCreateWithoutDatasourcesInput = {
    id?: string
    clientId: string
    instanceId: string
    name: string
    code: string
    description?: string | null
    type: $Enums.DatasourceCredentialAuthType
    credentialId?: string | null
    credentialKey?: string | null
    credentialSecret?: string | null
    credentialToken?: string | null
    credentialTokenSecret?: string | null
    credentialHostname?: string | null
    credentialUsername?: string | null
    fingerprint?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type DataSourceCredentialCreateOrConnectWithoutDatasourcesInput = {
    where: DataSourceCredentialWhereUniqueInput
    create: XOR<DataSourceCredentialCreateWithoutDatasourcesInput, DataSourceCredentialUncheckedCreateWithoutDatasourcesInput>
  }

  export type DataSourceCredentialUpsertWithoutDatasourcesInput = {
    update: XOR<DataSourceCredentialUpdateWithoutDatasourcesInput, DataSourceCredentialUncheckedUpdateWithoutDatasourcesInput>
    create: XOR<DataSourceCredentialCreateWithoutDatasourcesInput, DataSourceCredentialUncheckedCreateWithoutDatasourcesInput>
    where?: DataSourceCredentialWhereInput
  }

  export type DataSourceCredentialUpdateToOneWithWhereWithoutDatasourcesInput = {
    where?: DataSourceCredentialWhereInput
    data: XOR<DataSourceCredentialUpdateWithoutDatasourcesInput, DataSourceCredentialUncheckedUpdateWithoutDatasourcesInput>
  }

  export type DataSourceCredentialUpdateWithoutDatasourcesInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumDatasourceCredentialAuthTypeFieldUpdateOperationsInput | $Enums.DatasourceCredentialAuthType
    credentialId?: NullableStringFieldUpdateOperationsInput | string | null
    credentialKey?: NullableStringFieldUpdateOperationsInput | string | null
    credentialSecret?: NullableStringFieldUpdateOperationsInput | string | null
    credentialToken?: NullableStringFieldUpdateOperationsInput | string | null
    credentialTokenSecret?: NullableStringFieldUpdateOperationsInput | string | null
    credentialHostname?: NullableStringFieldUpdateOperationsInput | string | null
    credentialUsername?: NullableStringFieldUpdateOperationsInput | string | null
    fingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DataSourceCredentialUncheckedUpdateWithoutDatasourcesInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumDatasourceCredentialAuthTypeFieldUpdateOperationsInput | $Enums.DatasourceCredentialAuthType
    credentialId?: NullableStringFieldUpdateOperationsInput | string | null
    credentialKey?: NullableStringFieldUpdateOperationsInput | string | null
    credentialSecret?: NullableStringFieldUpdateOperationsInput | string | null
    credentialToken?: NullableStringFieldUpdateOperationsInput | string | null
    credentialTokenSecret?: NullableStringFieldUpdateOperationsInput | string | null
    credentialHostname?: NullableStringFieldUpdateOperationsInput | string | null
    credentialUsername?: NullableStringFieldUpdateOperationsInput | string | null
    fingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DataSourceCreateWithoutCredentialInput = {
    id?: string
    clientId: string
    instanceId: string
    name: string
    code: string
    description?: string | null
    type: $Enums.DataSourceType
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type DataSourceUncheckedCreateWithoutCredentialInput = {
    id?: string
    clientId: string
    instanceId: string
    name: string
    code: string
    description?: string | null
    type: $Enums.DataSourceType
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type DataSourceCreateOrConnectWithoutCredentialInput = {
    where: DataSourceWhereUniqueInput
    create: XOR<DataSourceCreateWithoutCredentialInput, DataSourceUncheckedCreateWithoutCredentialInput>
  }

  export type DataSourceCreateManyCredentialInputEnvelope = {
    data: DataSourceCreateManyCredentialInput | DataSourceCreateManyCredentialInput[]
  }

  export type DataSourceUpsertWithWhereUniqueWithoutCredentialInput = {
    where: DataSourceWhereUniqueInput
    update: XOR<DataSourceUpdateWithoutCredentialInput, DataSourceUncheckedUpdateWithoutCredentialInput>
    create: XOR<DataSourceCreateWithoutCredentialInput, DataSourceUncheckedCreateWithoutCredentialInput>
  }

  export type DataSourceUpdateWithWhereUniqueWithoutCredentialInput = {
    where: DataSourceWhereUniqueInput
    data: XOR<DataSourceUpdateWithoutCredentialInput, DataSourceUncheckedUpdateWithoutCredentialInput>
  }

  export type DataSourceUpdateManyWithWhereWithoutCredentialInput = {
    where: DataSourceScalarWhereInput
    data: XOR<DataSourceUpdateManyMutationInput, DataSourceUncheckedUpdateManyWithoutCredentialInput>
  }

  export type DataSourceScalarWhereInput = {
    AND?: DataSourceScalarWhereInput | DataSourceScalarWhereInput[]
    OR?: DataSourceScalarWhereInput[]
    NOT?: DataSourceScalarWhereInput | DataSourceScalarWhereInput[]
    id?: StringFilter<"DataSource"> | string
    clientId?: StringFilter<"DataSource"> | string
    instanceId?: StringFilter<"DataSource"> | string
    name?: StringFilter<"DataSource"> | string
    code?: StringFilter<"DataSource"> | string
    credentialId?: StringNullableFilter<"DataSource"> | string | null
    description?: StringNullableFilter<"DataSource"> | string | null
    type?: EnumDataSourceTypeFilter<"DataSource"> | $Enums.DataSourceType
    createdAt?: DateTimeNullableFilter<"DataSource"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"DataSource"> | Date | string | null
  }

  export type EnumTableColumnTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TableColumnType | EnumTableColumnTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TableColumnType[] | ListEnumTableColumnTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TableColumnType[] | ListEnumTableColumnTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTableColumnTypeFilter<$PrismaModel> | $Enums.TableColumnType
  }

  export type ClientCreateManyCountryInput = {
    id?: string
    name: string
    code: string
    status?: $Enums.clientStatus
    address?: XOR<addressTypeNullableCreateEnvelopeInput, addressTypeCreateInput> | null
    contactId?: string | null
    lastLogin?: Date | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type UserCreateManyCountryInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    authProviderId: string
    role?: $Enums.userRole
    permissions?: UserCreatepermissionsInput | string[]
    clientId: string
    defaultInstance: string
    selectedInstance?: string | null
    lastLogin?: Date | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ClientUpdateWithoutCountryInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumclientStatusFieldUpdateOperationsInput | $Enums.clientStatus
    address?: XOR<addressTypeNullableUpdateEnvelopeInput, addressTypeCreateInput> | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: UserUpdateManyWithoutClientNestedInput
    instances?: InstanceUpdateManyWithoutClientNestedInput
    Permission?: PermissionUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutCountryInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumclientStatusFieldUpdateOperationsInput | $Enums.clientStatus
    address?: XOR<addressTypeNullableUpdateEnvelopeInput, addressTypeCreateInput> | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: UserUncheckedUpdateManyWithoutClientNestedInput
    instances?: InstanceUncheckedUpdateManyWithoutClientNestedInput
    Permission?: PermissionUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateManyWithoutCountryInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumclientStatusFieldUpdateOperationsInput | $Enums.clientStatus
    address?: XOR<addressTypeNullableUpdateEnvelopeInput, addressTypeCreateInput> | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUpdateWithoutCountryInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    authProviderId?: StringFieldUpdateOperationsInput | string
    role?: EnumuserRoleFieldUpdateOperationsInput | $Enums.userRole
    permissions?: UserUpdatepermissionsInput | string[]
    defaultInstance?: StringFieldUpdateOperationsInput | string
    selectedInstance?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    client?: ClientUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutCountryInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    authProviderId?: StringFieldUpdateOperationsInput | string
    role?: EnumuserRoleFieldUpdateOperationsInput | $Enums.userRole
    permissions?: UserUpdatepermissionsInput | string[]
    clientId?: StringFieldUpdateOperationsInput | string
    defaultInstance?: StringFieldUpdateOperationsInput | string
    selectedInstance?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUncheckedUpdateManyWithoutCountryInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    authProviderId?: StringFieldUpdateOperationsInput | string
    role?: EnumuserRoleFieldUpdateOperationsInput | $Enums.userRole
    permissions?: UserUpdatepermissionsInput | string[]
    clientId?: StringFieldUpdateOperationsInput | string
    defaultInstance?: StringFieldUpdateOperationsInput | string
    selectedInstance?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserCreateManyClientInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    authProviderId: string
    role?: $Enums.userRole
    countryId?: string | null
    permissions?: UserCreatepermissionsInput | string[]
    defaultInstance: string
    selectedInstance?: string | null
    lastLogin?: Date | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type InstanceCreateManyClientInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    status?: $Enums.instanceStatus
    userIds?: InstanceCreateuserIdsInput | string[]
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type PermissionCreateManyClientInput = {
    id?: string
    name: string
    code: string
    actions?: PermissionCreateactionsInput | string[]
    subjects?: PermissionCreatesubjectsInput | string[]
    description?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type addressTypeUpdateInput = {
    address1?: NullableStringFieldUpdateOperationsInput | string | null
    address2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUpdateWithoutClientInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    authProviderId?: StringFieldUpdateOperationsInput | string
    role?: EnumuserRoleFieldUpdateOperationsInput | $Enums.userRole
    permissions?: UserUpdatepermissionsInput | string[]
    defaultInstance?: StringFieldUpdateOperationsInput | string
    selectedInstance?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: CountryUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutClientInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    authProviderId?: StringFieldUpdateOperationsInput | string
    role?: EnumuserRoleFieldUpdateOperationsInput | $Enums.userRole
    countryId?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: UserUpdatepermissionsInput | string[]
    defaultInstance?: StringFieldUpdateOperationsInput | string
    selectedInstance?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUncheckedUpdateManyWithoutClientInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    authProviderId?: StringFieldUpdateOperationsInput | string
    role?: EnumuserRoleFieldUpdateOperationsInput | $Enums.userRole
    countryId?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: UserUpdatepermissionsInput | string[]
    defaultInstance?: StringFieldUpdateOperationsInput | string
    selectedInstance?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InstanceUpdateWithoutClientInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnuminstanceStatusFieldUpdateOperationsInput | $Enums.instanceStatus
    userIds?: InstanceUpdateuserIdsInput | string[]
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    levels?: LevelUpdateManyWithoutInstanceNestedInput
    versions?: VersionUpdateManyWithoutInstanceNestedInput
    currencies?: CurrencyUpdateManyWithoutInstanceNestedInput
    accounts?: AccountUpdateManyWithoutInstanceNestedInput
    models?: ModelUpdateManyWithoutInstanceNestedInput
    dimensions?: DimensionUpdateManyWithoutInstanceNestedInput
    dimensionValues?: DimensionValueUpdateManyWithoutInstanceNestedInput
    levelAttributes?: LevelAttributeUpdateManyWithoutInstanceNestedInput
    dimensionValueAttributes?: DimensionValueAttributeUpdateManyWithoutInstanceNestedInput
    accountAttributes?: AccountAttributeUpdateManyWithoutInstanceNestedInput
    levelAttValues?: LevelAttributeValueUpdateManyWithoutInstanceNestedInput
    accountAttValues?: AccountAttributeValueUpdateManyWithoutInstanceNestedInput
    dimensionValueAttributeValues?: DimensionValueAttributeValueUpdateManyWithoutInstanceNestedInput
    modelData?: ModelDataUpdateManyWithoutInstanceNestedInput
    modelDataCalculations?: ModelDataCalculationsUpdateManyWithoutInstanceNestedInput
    modelAccounts?: ModelAccountStructureUpdateManyWithoutInstanceNestedInput
    tables?: TableUpdateManyWithoutInstanceNestedInput
    tableData?: TableDataUpdateManyWithoutInstanceNestedInput
  }

  export type InstanceUncheckedUpdateWithoutClientInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnuminstanceStatusFieldUpdateOperationsInput | $Enums.instanceStatus
    userIds?: InstanceUpdateuserIdsInput | string[]
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    levels?: LevelUncheckedUpdateManyWithoutInstanceNestedInput
    versions?: VersionUncheckedUpdateManyWithoutInstanceNestedInput
    currencies?: CurrencyUncheckedUpdateManyWithoutInstanceNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutInstanceNestedInput
    models?: ModelUncheckedUpdateManyWithoutInstanceNestedInput
    dimensions?: DimensionUncheckedUpdateManyWithoutInstanceNestedInput
    dimensionValues?: DimensionValueUncheckedUpdateManyWithoutInstanceNestedInput
    levelAttributes?: LevelAttributeUncheckedUpdateManyWithoutInstanceNestedInput
    dimensionValueAttributes?: DimensionValueAttributeUncheckedUpdateManyWithoutInstanceNestedInput
    accountAttributes?: AccountAttributeUncheckedUpdateManyWithoutInstanceNestedInput
    levelAttValues?: LevelAttributeValueUncheckedUpdateManyWithoutInstanceNestedInput
    accountAttValues?: AccountAttributeValueUncheckedUpdateManyWithoutInstanceNestedInput
    dimensionValueAttributeValues?: DimensionValueAttributeValueUncheckedUpdateManyWithoutInstanceNestedInput
    modelData?: ModelDataUncheckedUpdateManyWithoutInstanceNestedInput
    modelDataCalculations?: ModelDataCalculationsUncheckedUpdateManyWithoutInstanceNestedInput
    modelAccounts?: ModelAccountStructureUncheckedUpdateManyWithoutInstanceNestedInput
    tables?: TableUncheckedUpdateManyWithoutInstanceNestedInput
    tableData?: TableDataUncheckedUpdateManyWithoutInstanceNestedInput
  }

  export type InstanceUncheckedUpdateManyWithoutClientInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnuminstanceStatusFieldUpdateOperationsInput | $Enums.instanceStatus
    userIds?: InstanceUpdateuserIdsInput | string[]
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PermissionUpdateWithoutClientInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    actions?: PermissionUpdateactionsInput | string[]
    subjects?: PermissionUpdatesubjectsInput | string[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PermissionUncheckedUpdateWithoutClientInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    actions?: PermissionUpdateactionsInput | string[]
    subjects?: PermissionUpdatesubjectsInput | string[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PermissionUncheckedUpdateManyWithoutClientInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    actions?: PermissionUpdateactionsInput | string[]
    subjects?: PermissionUpdatesubjectsInput | string[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LevelCreateManyInstanceInput = {
    id?: string
    code: string
    name: string
    isRoot?: boolean
    description?: string | null
    parentId?: string | null
    clientId: string
    currencyId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type VersionCreateManyInstanceInput = {
    id?: string
    code: string
    name: string
    begin: Date | string
    end: Date | string
    startOfPlan: Date | string
    description?: string | null
    isDefault?: boolean
    isActuals?: boolean
    status?: $Enums.versionStatus
    clientId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type CurrencyCreateManyInstanceInput = {
    id?: string
    name: string
    code: string
    currencyIsoCodeId: string
    assignedLevels: number
    isDefault?: $Enums.YesNo
    clientId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type AccountCreateManyInstanceInput = {
    id?: string
    code: string
    name: string
    isRoot?: boolean
    isModelRoot?: boolean
    accountType: $Enums.AccountType
    accountTypeTag: $Enums.AccountTypeTag
    group?: $Enums.YesNo
    plannedBy?: $Enums.ActPlanBy | null
    actualsBy?: $Enums.ActActualsBy | null
    displayAs?: $Enums.ActDisplayAs
    containsSalaryInfo?: $Enums.YesNo
    description?: string | null
    clientId: string
    parentId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ModelCreateManyInstanceInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    dimensionality?: ModelCreatedimensionalityInput | string[]
    status?: $Enums.ModelStatus
    isDefault?: boolean
    clientId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    rootAccountId: string
  }

  export type DimensionCreateManyInstanceInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    dimensionValueDefault?: string | null
    clientId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type DimensionValueCreateManyInstanceInput = {
    id?: string
    code: string
    name: string
    parentId?: string | null
    clientId: string
    dimensionId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type LevelAttributeCreateManyInstanceInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    clientId: string
    attributeValueDefault?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type DimensionValueAttributeCreateManyInstanceInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    clientId: string
    updatedAt?: Date | string | null
    createdAt?: Date | string | null
  }

  export type AccountAttributeCreateManyInstanceInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    attributeValueDefault?: string | null
    clientId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type LevelAttributeValueCreateManyInstanceInput = {
    id?: string
    code: string
    name: string
    attributeId: string
    parentId?: string | null
    clientId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type AccountAttributeValueCreateManyInstanceInput = {
    id?: string
    code: string
    name: string
    attributeId: string
    parentId?: string | null
    clientId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type DimensionValueAttributeValueCreateManyInstanceInput = {
    id?: string
    code: string
    name: string
    attributeId: string
    clientId: string
    parentId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ModelDataCreateManyInstanceInput = {
    id?: string
    clientId: string
    modelId: string
    versionId: string
    levelId: string
    accountId: string
    dimensionality?: XOR<ModelDataDimensionalityListCreateEnvelopeInput, ModelDataDimensionalityCreateInput> | ModelDataDimensionalityCreateInput[]
    timespan: InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ModelDataCalculationsCreateManyInstanceInput = {
    id?: string
    clientId: string
    modelId: string
    versionId: string
    levelId: string
    accountId: string
    modelAccountId: string
    calculations: InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ModelAccountStructureCreateManyInstanceInput = {
    id?: string
    isRoot?: boolean
    clientId: string
    parentId?: string | null
    modelId: string
    accountId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type TableCreateManyInstanceInput = {
    id?: string
    clientId: string
    name: string
    code: string
    description?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    status: $Enums.ModelStatus
    columnDefinitions?: XOR<TableColumnDefinitionListCreateEnvelopeInput, TableColumnDefinitionCreateInput> | TableColumnDefinitionCreateInput[]
  }

  export type TableDataCreateManyInstanceInput = {
    id?: string
    clientId: string
    tableId: string
    rowKey: string
    versionId: string
    levelId: string
    data: InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type LevelUpdateWithoutInstanceInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isRoot?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    AttributeAndValues?: LevelAttributeAndValueUpdateManyWithoutLevelNestedInput
    parent?: LevelUpdateOneWithoutChildLevelsNestedInput
    currency?: CurrencyUpdateOneRequiredWithoutLevelsNestedInput
    childLevels?: LevelUpdateManyWithoutParentNestedInput
    modelData?: ModelDataUpdateManyWithoutLevelNestedInput
    modeldataCalculations?: ModelDataCalculationsUpdateManyWithoutLevelNestedInput
  }

  export type LevelUncheckedUpdateWithoutInstanceInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isRoot?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    currencyId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    AttributeAndValues?: LevelAttributeAndValueUncheckedUpdateManyWithoutLevelNestedInput
    childLevels?: LevelUncheckedUpdateManyWithoutParentNestedInput
    modelData?: ModelDataUncheckedUpdateManyWithoutLevelNestedInput
    modeldataCalculations?: ModelDataCalculationsUncheckedUpdateManyWithoutLevelNestedInput
  }

  export type LevelUncheckedUpdateManyWithoutInstanceInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isRoot?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    currencyId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VersionUpdateWithoutInstanceInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    begin?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    startOfPlan?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isActuals?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumversionStatusFieldUpdateOperationsInput | $Enums.versionStatus
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modelData?: ModelDataUpdateManyWithoutVersionNestedInput
    modelDataCalculations?: ModelDataCalculationsUpdateManyWithoutVersionNestedInput
  }

  export type VersionUncheckedUpdateWithoutInstanceInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    begin?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    startOfPlan?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isActuals?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumversionStatusFieldUpdateOperationsInput | $Enums.versionStatus
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modelData?: ModelDataUncheckedUpdateManyWithoutVersionNestedInput
    modelDataCalculations?: ModelDataCalculationsUncheckedUpdateManyWithoutVersionNestedInput
  }

  export type VersionUncheckedUpdateManyWithoutInstanceInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    begin?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    startOfPlan?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isActuals?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumversionStatusFieldUpdateOperationsInput | $Enums.versionStatus
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CurrencyUpdateWithoutInstanceInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    assignedLevels?: IntFieldUpdateOperationsInput | number
    isDefault?: EnumYesNoFieldUpdateOperationsInput | $Enums.YesNo
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currencyIsoCode?: CurrencyIsoCodeUpdateOneRequiredWithoutCurrenciesNestedInput
    levels?: LevelUpdateManyWithoutCurrencyNestedInput
    defaults?: ConfigUpdateManyWithoutDefaultCurrencyNestedInput
  }

  export type CurrencyUncheckedUpdateWithoutInstanceInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    currencyIsoCodeId?: StringFieldUpdateOperationsInput | string
    assignedLevels?: IntFieldUpdateOperationsInput | number
    isDefault?: EnumYesNoFieldUpdateOperationsInput | $Enums.YesNo
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    levels?: LevelUncheckedUpdateManyWithoutCurrencyNestedInput
    defaults?: ConfigUncheckedUpdateManyWithoutDefaultCurrencyNestedInput
  }

  export type CurrencyUncheckedUpdateManyWithoutInstanceInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    currencyIsoCodeId?: StringFieldUpdateOperationsInput | string
    assignedLevels?: IntFieldUpdateOperationsInput | number
    isDefault?: EnumYesNoFieldUpdateOperationsInput | $Enums.YesNo
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AccountUpdateWithoutInstanceInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isRoot?: BoolFieldUpdateOperationsInput | boolean
    isModelRoot?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    accountTypeTag?: EnumAccountTypeTagFieldUpdateOperationsInput | $Enums.AccountTypeTag
    group?: EnumYesNoFieldUpdateOperationsInput | $Enums.YesNo
    plannedBy?: NullableEnumActPlanByFieldUpdateOperationsInput | $Enums.ActPlanBy | null
    actualsBy?: NullableEnumActActualsByFieldUpdateOperationsInput | $Enums.ActActualsBy | null
    displayAs?: EnumActDisplayAsFieldUpdateOperationsInput | $Enums.ActDisplayAs
    containsSalaryInfo?: EnumYesNoFieldUpdateOperationsInput | $Enums.YesNo
    description?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parent?: AccountUpdateOneWithoutChildAccountsNestedInput
    childAccounts?: AccountUpdateManyWithoutParentNestedInput
    AttributeAndValues?: AccountAttributeAndValueUpdateManyWithoutAccountNestedInput
    modelAccounts?: ModelAccountStructureUpdateManyWithoutAccountNestedInput
    modelData?: ModelDataUpdateManyWithoutAccountNestedInput
    modeldataCalculations?: ModelDataCalculationsUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutInstanceInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isRoot?: BoolFieldUpdateOperationsInput | boolean
    isModelRoot?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    accountTypeTag?: EnumAccountTypeTagFieldUpdateOperationsInput | $Enums.AccountTypeTag
    group?: EnumYesNoFieldUpdateOperationsInput | $Enums.YesNo
    plannedBy?: NullableEnumActPlanByFieldUpdateOperationsInput | $Enums.ActPlanBy | null
    actualsBy?: NullableEnumActActualsByFieldUpdateOperationsInput | $Enums.ActActualsBy | null
    displayAs?: EnumActDisplayAsFieldUpdateOperationsInput | $Enums.ActDisplayAs
    containsSalaryInfo?: EnumYesNoFieldUpdateOperationsInput | $Enums.YesNo
    description?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    childAccounts?: AccountUncheckedUpdateManyWithoutParentNestedInput
    AttributeAndValues?: AccountAttributeAndValueUncheckedUpdateManyWithoutAccountNestedInput
    modelAccounts?: ModelAccountStructureUncheckedUpdateManyWithoutAccountNestedInput
    modelData?: ModelDataUncheckedUpdateManyWithoutAccountNestedInput
    modeldataCalculations?: ModelDataCalculationsUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateManyWithoutInstanceInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isRoot?: BoolFieldUpdateOperationsInput | boolean
    isModelRoot?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    accountTypeTag?: EnumAccountTypeTagFieldUpdateOperationsInput | $Enums.AccountTypeTag
    group?: EnumYesNoFieldUpdateOperationsInput | $Enums.YesNo
    plannedBy?: NullableEnumActPlanByFieldUpdateOperationsInput | $Enums.ActPlanBy | null
    actualsBy?: NullableEnumActActualsByFieldUpdateOperationsInput | $Enums.ActActualsBy | null
    displayAs?: EnumActDisplayAsFieldUpdateOperationsInput | $Enums.ActDisplayAs
    containsSalaryInfo?: EnumYesNoFieldUpdateOperationsInput | $Enums.YesNo
    description?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ModelUpdateWithoutInstanceInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dimensionality?: ModelUpdatedimensionalityInput | string[]
    status?: EnumModelStatusFieldUpdateOperationsInput | $Enums.ModelStatus
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rootAccountId?: StringFieldUpdateOperationsInput | string
    modelData?: ModelDataUpdateManyWithoutModelNestedInput
    modelAccounts?: ModelAccountStructureUpdateManyWithoutModelNestedInput
    modelDataCalculations?: ModelDataCalculationsUpdateManyWithoutModelNestedInput
  }

  export type ModelUncheckedUpdateWithoutInstanceInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dimensionality?: ModelUpdatedimensionalityInput | string[]
    status?: EnumModelStatusFieldUpdateOperationsInput | $Enums.ModelStatus
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rootAccountId?: StringFieldUpdateOperationsInput | string
    modelData?: ModelDataUncheckedUpdateManyWithoutModelNestedInput
    modelAccounts?: ModelAccountStructureUncheckedUpdateManyWithoutModelNestedInput
    modelDataCalculations?: ModelDataCalculationsUncheckedUpdateManyWithoutModelNestedInput
  }

  export type ModelUncheckedUpdateManyWithoutInstanceInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dimensionality?: ModelUpdatedimensionalityInput | string[]
    status?: EnumModelStatusFieldUpdateOperationsInput | $Enums.ModelStatus
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rootAccountId?: StringFieldUpdateOperationsInput | string
  }

  export type DimensionUpdateWithoutInstanceInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dimensionValueDefault?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dimensionValues?: DimensionValueUpdateManyWithoutDimensionNestedInput
  }

  export type DimensionUncheckedUpdateWithoutInstanceInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dimensionValueDefault?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dimensionValues?: DimensionValueUncheckedUpdateManyWithoutDimensionNestedInput
  }

  export type DimensionUncheckedUpdateManyWithoutInstanceInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dimensionValueDefault?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DimensionValueUpdateWithoutInstanceInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parent?: DimensionValueUpdateOneWithoutChildDimensionValuesNestedInput
    childDimensionValues?: DimensionValueUpdateManyWithoutParentNestedInput
    AttributeAndValues?: DimensionValueAttributeAndValueUpdateManyWithoutDimensionValueNestedInput
    dimension?: DimensionUpdateOneRequiredWithoutDimensionValuesNestedInput
  }

  export type DimensionValueUncheckedUpdateWithoutInstanceInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    dimensionId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    childDimensionValues?: DimensionValueUncheckedUpdateManyWithoutParentNestedInput
    AttributeAndValues?: DimensionValueAttributeAndValueUncheckedUpdateManyWithoutDimensionValueNestedInput
  }

  export type DimensionValueUncheckedUpdateManyWithoutInstanceInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    dimensionId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LevelAttributeUpdateWithoutInstanceInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    attributeValueDefault?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    levelAttributeValues?: LevelAttributeValueUpdateManyWithoutLevelAttributeNestedInput
    levelAttributeAndValues?: LevelAttributeAndValueUpdateManyWithoutAttributeNestedInput
  }

  export type LevelAttributeUncheckedUpdateWithoutInstanceInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    attributeValueDefault?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    levelAttributeValues?: LevelAttributeValueUncheckedUpdateManyWithoutLevelAttributeNestedInput
    levelAttributeAndValues?: LevelAttributeAndValueUncheckedUpdateManyWithoutAttributeNestedInput
  }

  export type LevelAttributeUncheckedUpdateManyWithoutInstanceInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    attributeValueDefault?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DimensionValueAttributeUpdateWithoutInstanceInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    AttributeValues?: DimensionValueAttributeValueUpdateManyWithoutDimensionValueAttributeNestedInput
    AttributeAndValues?: DimensionValueAttributeAndValueUpdateManyWithoutAttributeNestedInput
  }

  export type DimensionValueAttributeUncheckedUpdateWithoutInstanceInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    AttributeValues?: DimensionValueAttributeValueUncheckedUpdateManyWithoutDimensionValueAttributeNestedInput
    AttributeAndValues?: DimensionValueAttributeAndValueUncheckedUpdateManyWithoutAttributeNestedInput
  }

  export type DimensionValueAttributeUncheckedUpdateManyWithoutInstanceInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AccountAttributeUpdateWithoutInstanceInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    attributeValueDefault?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountAttributeValues?: AccountAttributeValueUpdateManyWithoutAccountAttributeNestedInput
    AttributeAndValues?: AccountAttributeAndValueUpdateManyWithoutAttributeNestedInput
  }

  export type AccountAttributeUncheckedUpdateWithoutInstanceInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    attributeValueDefault?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountAttributeValues?: AccountAttributeValueUncheckedUpdateManyWithoutAccountAttributeNestedInput
    AttributeAndValues?: AccountAttributeAndValueUncheckedUpdateManyWithoutAttributeNestedInput
  }

  export type AccountAttributeUncheckedUpdateManyWithoutInstanceInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    attributeValueDefault?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LevelAttributeValueUpdateWithoutInstanceInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parent?: LevelAttributeValueUpdateOneWithoutChildAttributeValuesNestedInput
    childAttributeValues?: LevelAttributeValueUpdateManyWithoutParentNestedInput
    levelAttribute?: LevelAttributeUpdateOneRequiredWithoutLevelAttributeValuesNestedInput
    levelAttributeAndValues?: LevelAttributeAndValueUpdateManyWithoutAttributeValueNestedInput
  }

  export type LevelAttributeValueUncheckedUpdateWithoutInstanceInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    attributeId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    childAttributeValues?: LevelAttributeValueUncheckedUpdateManyWithoutParentNestedInput
    levelAttributeAndValues?: LevelAttributeAndValueUncheckedUpdateManyWithoutAttributeValueNestedInput
  }

  export type LevelAttributeValueUncheckedUpdateManyWithoutInstanceInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    attributeId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AccountAttributeValueUpdateWithoutInstanceInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parent?: AccountAttributeValueUpdateOneWithoutChildAttributeValuesNestedInput
    childAttributeValues?: AccountAttributeValueUpdateManyWithoutParentNestedInput
    accountAttribute?: AccountAttributeUpdateOneRequiredWithoutAccountAttributeValuesNestedInput
    AttributeAndValues?: AccountAttributeAndValueUpdateManyWithoutAttributeValueNestedInput
  }

  export type AccountAttributeValueUncheckedUpdateWithoutInstanceInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    attributeId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    childAttributeValues?: AccountAttributeValueUncheckedUpdateManyWithoutParentNestedInput
    AttributeAndValues?: AccountAttributeAndValueUncheckedUpdateManyWithoutAttributeValueNestedInput
  }

  export type AccountAttributeValueUncheckedUpdateManyWithoutInstanceInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    attributeId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DimensionValueAttributeValueUpdateWithoutInstanceInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parent?: DimensionValueAttributeValueUpdateOneWithoutChildAttributeValuesNestedInput
    childAttributeValues?: DimensionValueAttributeValueUpdateManyWithoutParentNestedInput
    dimensionValueAttribute?: DimensionValueAttributeUpdateOneRequiredWithoutAttributeValuesNestedInput
    dimensionAttributeAndValues?: DimensionValueAttributeAndValueUpdateManyWithoutAttributeValueNestedInput
  }

  export type DimensionValueAttributeValueUncheckedUpdateWithoutInstanceInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    attributeId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    childAttributeValues?: DimensionValueAttributeValueUncheckedUpdateManyWithoutParentNestedInput
    dimensionAttributeAndValues?: DimensionValueAttributeAndValueUncheckedUpdateManyWithoutAttributeValueNestedInput
  }

  export type DimensionValueAttributeValueUncheckedUpdateManyWithoutInstanceInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    attributeId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ModelDataUpdateWithoutInstanceInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    dimensionality?: XOR<ModelDataDimensionalityListUpdateEnvelopeInput, ModelDataDimensionalityCreateInput> | ModelDataDimensionalityCreateInput[]
    timespan?: InputJsonValue | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    model?: ModelUpdateOneRequiredWithoutModelDataNestedInput
    level?: LevelUpdateOneRequiredWithoutModelDataNestedInput
    account?: AccountUpdateOneRequiredWithoutModelDataNestedInput
    version?: VersionUpdateOneRequiredWithoutModelDataNestedInput
  }

  export type ModelDataUncheckedUpdateWithoutInstanceInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    modelId?: StringFieldUpdateOperationsInput | string
    versionId?: StringFieldUpdateOperationsInput | string
    levelId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    dimensionality?: XOR<ModelDataDimensionalityListUpdateEnvelopeInput, ModelDataDimensionalityCreateInput> | ModelDataDimensionalityCreateInput[]
    timespan?: InputJsonValue | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ModelDataUncheckedUpdateManyWithoutInstanceInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    modelId?: StringFieldUpdateOperationsInput | string
    versionId?: StringFieldUpdateOperationsInput | string
    levelId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    dimensionality?: XOR<ModelDataDimensionalityListUpdateEnvelopeInput, ModelDataDimensionalityCreateInput> | ModelDataDimensionalityCreateInput[]
    timespan?: InputJsonValue | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ModelDataCalculationsUpdateWithoutInstanceInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    calculations?: InputJsonValue | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    model?: ModelUpdateOneRequiredWithoutModelDataCalculationsNestedInput
    level?: LevelUpdateOneRequiredWithoutModeldataCalculationsNestedInput
    account?: AccountUpdateOneRequiredWithoutModeldataCalculationsNestedInput
    version?: VersionUpdateOneRequiredWithoutModelDataCalculationsNestedInput
    modelAccount?: ModelAccountStructureUpdateOneRequiredWithoutModeldataCalculationsNestedInput
  }

  export type ModelDataCalculationsUncheckedUpdateWithoutInstanceInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    modelId?: StringFieldUpdateOperationsInput | string
    versionId?: StringFieldUpdateOperationsInput | string
    levelId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    modelAccountId?: StringFieldUpdateOperationsInput | string
    calculations?: InputJsonValue | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ModelDataCalculationsUncheckedUpdateManyWithoutInstanceInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    modelId?: StringFieldUpdateOperationsInput | string
    versionId?: StringFieldUpdateOperationsInput | string
    levelId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    modelAccountId?: StringFieldUpdateOperationsInput | string
    calculations?: InputJsonValue | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ModelAccountStructureUpdateWithoutInstanceInput = {
    isRoot?: BoolFieldUpdateOperationsInput | boolean
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    model?: ModelUpdateOneRequiredWithoutModelAccountsNestedInput
    account?: AccountUpdateOneRequiredWithoutModelAccountsNestedInput
    modeldataCalculations?: ModelDataCalculationsUpdateManyWithoutModelAccountNestedInput
    parentAccount?: ModelAccountStructureUpdateOneWithoutChildAccountsNestedInput
    childAccounts?: ModelAccountStructureUpdateManyWithoutParentAccountNestedInput
  }

  export type ModelAccountStructureUncheckedUpdateWithoutInstanceInput = {
    isRoot?: BoolFieldUpdateOperationsInput | boolean
    clientId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    modelId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modeldataCalculations?: ModelDataCalculationsUncheckedUpdateManyWithoutModelAccountNestedInput
    childAccounts?: ModelAccountStructureUncheckedUpdateManyWithoutParentAccountNestedInput
  }

  export type ModelAccountStructureUncheckedUpdateManyWithoutInstanceInput = {
    isRoot?: BoolFieldUpdateOperationsInput | boolean
    clientId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    modelId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TableUpdateWithoutInstanceInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumModelStatusFieldUpdateOperationsInput | $Enums.ModelStatus
    columnDefinitions?: XOR<TableColumnDefinitionListUpdateEnvelopeInput, TableColumnDefinitionCreateInput> | TableColumnDefinitionCreateInput[]
    tableData?: TableDataUpdateManyWithoutTableNestedInput
  }

  export type TableUncheckedUpdateWithoutInstanceInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumModelStatusFieldUpdateOperationsInput | $Enums.ModelStatus
    columnDefinitions?: XOR<TableColumnDefinitionListUpdateEnvelopeInput, TableColumnDefinitionCreateInput> | TableColumnDefinitionCreateInput[]
    tableData?: TableDataUncheckedUpdateManyWithoutTableNestedInput
  }

  export type TableUncheckedUpdateManyWithoutInstanceInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumModelStatusFieldUpdateOperationsInput | $Enums.ModelStatus
    columnDefinitions?: XOR<TableColumnDefinitionListUpdateEnvelopeInput, TableColumnDefinitionCreateInput> | TableColumnDefinitionCreateInput[]
  }

  export type TableDataUpdateWithoutInstanceInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    rowKey?: StringFieldUpdateOperationsInput | string
    versionId?: StringFieldUpdateOperationsInput | string
    levelId?: StringFieldUpdateOperationsInput | string
    data?: InputJsonValue | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    table?: TableUpdateOneRequiredWithoutTableDataNestedInput
  }

  export type TableDataUncheckedUpdateWithoutInstanceInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    tableId?: StringFieldUpdateOperationsInput | string
    rowKey?: StringFieldUpdateOperationsInput | string
    versionId?: StringFieldUpdateOperationsInput | string
    levelId?: StringFieldUpdateOperationsInput | string
    data?: InputJsonValue | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TableDataUncheckedUpdateManyWithoutInstanceInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    tableId?: StringFieldUpdateOperationsInput | string
    rowKey?: StringFieldUpdateOperationsInput | string
    versionId?: StringFieldUpdateOperationsInput | string
    levelId?: StringFieldUpdateOperationsInput | string
    data?: InputJsonValue | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ModelDataCreateManyVersionInput = {
    id?: string
    clientId: string
    instanceId: string
    modelId: string
    levelId: string
    accountId: string
    dimensionality?: XOR<ModelDataDimensionalityListCreateEnvelopeInput, ModelDataDimensionalityCreateInput> | ModelDataDimensionalityCreateInput[]
    timespan: InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ModelDataCalculationsCreateManyVersionInput = {
    id?: string
    clientId: string
    instanceId: string
    modelId: string
    levelId: string
    accountId: string
    modelAccountId: string
    calculations: InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ModelDataUpdateWithoutVersionInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    dimensionality?: XOR<ModelDataDimensionalityListUpdateEnvelopeInput, ModelDataDimensionalityCreateInput> | ModelDataDimensionalityCreateInput[]
    timespan?: InputJsonValue | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    model?: ModelUpdateOneRequiredWithoutModelDataNestedInput
    level?: LevelUpdateOneRequiredWithoutModelDataNestedInput
    account?: AccountUpdateOneRequiredWithoutModelDataNestedInput
    instance?: InstanceUpdateOneRequiredWithoutModelDataNestedInput
  }

  export type ModelDataUncheckedUpdateWithoutVersionInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    modelId?: StringFieldUpdateOperationsInput | string
    levelId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    dimensionality?: XOR<ModelDataDimensionalityListUpdateEnvelopeInput, ModelDataDimensionalityCreateInput> | ModelDataDimensionalityCreateInput[]
    timespan?: InputJsonValue | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ModelDataUncheckedUpdateManyWithoutVersionInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    modelId?: StringFieldUpdateOperationsInput | string
    levelId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    dimensionality?: XOR<ModelDataDimensionalityListUpdateEnvelopeInput, ModelDataDimensionalityCreateInput> | ModelDataDimensionalityCreateInput[]
    timespan?: InputJsonValue | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ModelDataCalculationsUpdateWithoutVersionInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    calculations?: InputJsonValue | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    model?: ModelUpdateOneRequiredWithoutModelDataCalculationsNestedInput
    level?: LevelUpdateOneRequiredWithoutModeldataCalculationsNestedInput
    account?: AccountUpdateOneRequiredWithoutModeldataCalculationsNestedInput
    instance?: InstanceUpdateOneRequiredWithoutModelDataCalculationsNestedInput
    modelAccount?: ModelAccountStructureUpdateOneRequiredWithoutModeldataCalculationsNestedInput
  }

  export type ModelDataCalculationsUncheckedUpdateWithoutVersionInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    modelId?: StringFieldUpdateOperationsInput | string
    levelId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    modelAccountId?: StringFieldUpdateOperationsInput | string
    calculations?: InputJsonValue | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ModelDataCalculationsUncheckedUpdateManyWithoutVersionInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    modelId?: StringFieldUpdateOperationsInput | string
    levelId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    modelAccountId?: StringFieldUpdateOperationsInput | string
    calculations?: InputJsonValue | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CurrencyCreateManyCurrencyIsoCodeInput = {
    id?: string
    name: string
    code: string
    assignedLevels: number
    isDefault?: $Enums.YesNo
    clientId: string
    instanceId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ConfigCreateManyDefaultIsoCurrencyInput = {
    id?: string
    defaultCurrencyId: string
    defaultTopLevelName: string
    defaultTopLevelDescription: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type CurrencyUpdateWithoutCurrencyIsoCodeInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    assignedLevels?: IntFieldUpdateOperationsInput | number
    isDefault?: EnumYesNoFieldUpdateOperationsInput | $Enums.YesNo
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instance?: InstanceUpdateOneRequiredWithoutCurrenciesNestedInput
    levels?: LevelUpdateManyWithoutCurrencyNestedInput
    defaults?: ConfigUpdateManyWithoutDefaultCurrencyNestedInput
  }

  export type CurrencyUncheckedUpdateWithoutCurrencyIsoCodeInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    assignedLevels?: IntFieldUpdateOperationsInput | number
    isDefault?: EnumYesNoFieldUpdateOperationsInput | $Enums.YesNo
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    levels?: LevelUncheckedUpdateManyWithoutCurrencyNestedInput
    defaults?: ConfigUncheckedUpdateManyWithoutDefaultCurrencyNestedInput
  }

  export type CurrencyUncheckedUpdateManyWithoutCurrencyIsoCodeInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    assignedLevels?: IntFieldUpdateOperationsInput | number
    isDefault?: EnumYesNoFieldUpdateOperationsInput | $Enums.YesNo
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ConfigUpdateWithoutDefaultIsoCurrencyInput = {
    defaultTopLevelName?: StringFieldUpdateOperationsInput | string
    defaultTopLevelDescription?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    defaultCurrency?: CurrencyUpdateOneRequiredWithoutDefaultsNestedInput
  }

  export type ConfigUncheckedUpdateWithoutDefaultIsoCurrencyInput = {
    defaultCurrencyId?: StringFieldUpdateOperationsInput | string
    defaultTopLevelName?: StringFieldUpdateOperationsInput | string
    defaultTopLevelDescription?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ConfigUncheckedUpdateManyWithoutDefaultIsoCurrencyInput = {
    defaultCurrencyId?: StringFieldUpdateOperationsInput | string
    defaultTopLevelName?: StringFieldUpdateOperationsInput | string
    defaultTopLevelDescription?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LevelCreateManyCurrencyInput = {
    id?: string
    code: string
    name: string
    isRoot?: boolean
    description?: string | null
    parentId?: string | null
    clientId: string
    instanceId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ConfigCreateManyDefaultCurrencyInput = {
    id?: string
    defaultIsoCurrencyId: string
    defaultTopLevelName: string
    defaultTopLevelDescription: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type LevelUpdateWithoutCurrencyInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isRoot?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    AttributeAndValues?: LevelAttributeAndValueUpdateManyWithoutLevelNestedInput
    parent?: LevelUpdateOneWithoutChildLevelsNestedInput
    instance?: InstanceUpdateOneRequiredWithoutLevelsNestedInput
    childLevels?: LevelUpdateManyWithoutParentNestedInput
    modelData?: ModelDataUpdateManyWithoutLevelNestedInput
    modeldataCalculations?: ModelDataCalculationsUpdateManyWithoutLevelNestedInput
  }

  export type LevelUncheckedUpdateWithoutCurrencyInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isRoot?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    AttributeAndValues?: LevelAttributeAndValueUncheckedUpdateManyWithoutLevelNestedInput
    childLevels?: LevelUncheckedUpdateManyWithoutParentNestedInput
    modelData?: ModelDataUncheckedUpdateManyWithoutLevelNestedInput
    modeldataCalculations?: ModelDataCalculationsUncheckedUpdateManyWithoutLevelNestedInput
  }

  export type LevelUncheckedUpdateManyWithoutCurrencyInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isRoot?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ConfigUpdateWithoutDefaultCurrencyInput = {
    defaultTopLevelName?: StringFieldUpdateOperationsInput | string
    defaultTopLevelDescription?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    defaultIsoCurrency?: CurrencyIsoCodeUpdateOneRequiredWithoutConfigNestedInput
  }

  export type ConfigUncheckedUpdateWithoutDefaultCurrencyInput = {
    defaultIsoCurrencyId?: StringFieldUpdateOperationsInput | string
    defaultTopLevelName?: StringFieldUpdateOperationsInput | string
    defaultTopLevelDescription?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ConfigUncheckedUpdateManyWithoutDefaultCurrencyInput = {
    defaultIsoCurrencyId?: StringFieldUpdateOperationsInput | string
    defaultTopLevelName?: StringFieldUpdateOperationsInput | string
    defaultTopLevelDescription?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LevelAttributeAndValueCreateManyLevelInput = {
    id?: string
    clientId: string
    instanceId: string
    attributeId: string
    attributeValueId: string
    levelCode: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type LevelCreateManyParentInput = {
    id?: string
    code: string
    name: string
    isRoot?: boolean
    description?: string | null
    clientId: string
    instanceId: string
    currencyId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ModelDataCreateManyLevelInput = {
    id?: string
    clientId: string
    instanceId: string
    modelId: string
    versionId: string
    accountId: string
    dimensionality?: XOR<ModelDataDimensionalityListCreateEnvelopeInput, ModelDataDimensionalityCreateInput> | ModelDataDimensionalityCreateInput[]
    timespan: InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ModelDataCalculationsCreateManyLevelInput = {
    id?: string
    clientId: string
    instanceId: string
    modelId: string
    versionId: string
    accountId: string
    modelAccountId: string
    calculations: InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type LevelAttributeAndValueUpdateWithoutLevelInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    levelCode?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attribute?: LevelAttributeUpdateOneWithoutLevelAttributeAndValuesNestedInput
    attributeValue?: LevelAttributeValueUpdateOneWithoutLevelAttributeAndValuesNestedInput
  }

  export type LevelAttributeAndValueUncheckedUpdateWithoutLevelInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    attributeId?: StringFieldUpdateOperationsInput | string
    attributeValueId?: StringFieldUpdateOperationsInput | string
    levelCode?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LevelAttributeAndValueUncheckedUpdateManyWithoutLevelInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    attributeId?: StringFieldUpdateOperationsInput | string
    attributeValueId?: StringFieldUpdateOperationsInput | string
    levelCode?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LevelUpdateWithoutParentInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isRoot?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    AttributeAndValues?: LevelAttributeAndValueUpdateManyWithoutLevelNestedInput
    instance?: InstanceUpdateOneRequiredWithoutLevelsNestedInput
    currency?: CurrencyUpdateOneRequiredWithoutLevelsNestedInput
    childLevels?: LevelUpdateManyWithoutParentNestedInput
    modelData?: ModelDataUpdateManyWithoutLevelNestedInput
    modeldataCalculations?: ModelDataCalculationsUpdateManyWithoutLevelNestedInput
  }

  export type LevelUncheckedUpdateWithoutParentInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isRoot?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    currencyId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    AttributeAndValues?: LevelAttributeAndValueUncheckedUpdateManyWithoutLevelNestedInput
    childLevels?: LevelUncheckedUpdateManyWithoutParentNestedInput
    modelData?: ModelDataUncheckedUpdateManyWithoutLevelNestedInput
    modeldataCalculations?: ModelDataCalculationsUncheckedUpdateManyWithoutLevelNestedInput
  }

  export type LevelUncheckedUpdateManyWithoutParentInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isRoot?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    currencyId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ModelDataUpdateWithoutLevelInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    dimensionality?: XOR<ModelDataDimensionalityListUpdateEnvelopeInput, ModelDataDimensionalityCreateInput> | ModelDataDimensionalityCreateInput[]
    timespan?: InputJsonValue | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    model?: ModelUpdateOneRequiredWithoutModelDataNestedInput
    account?: AccountUpdateOneRequiredWithoutModelDataNestedInput
    version?: VersionUpdateOneRequiredWithoutModelDataNestedInput
    instance?: InstanceUpdateOneRequiredWithoutModelDataNestedInput
  }

  export type ModelDataUncheckedUpdateWithoutLevelInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    modelId?: StringFieldUpdateOperationsInput | string
    versionId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    dimensionality?: XOR<ModelDataDimensionalityListUpdateEnvelopeInput, ModelDataDimensionalityCreateInput> | ModelDataDimensionalityCreateInput[]
    timespan?: InputJsonValue | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ModelDataUncheckedUpdateManyWithoutLevelInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    modelId?: StringFieldUpdateOperationsInput | string
    versionId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    dimensionality?: XOR<ModelDataDimensionalityListUpdateEnvelopeInput, ModelDataDimensionalityCreateInput> | ModelDataDimensionalityCreateInput[]
    timespan?: InputJsonValue | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ModelDataCalculationsUpdateWithoutLevelInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    calculations?: InputJsonValue | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    model?: ModelUpdateOneRequiredWithoutModelDataCalculationsNestedInput
    account?: AccountUpdateOneRequiredWithoutModeldataCalculationsNestedInput
    version?: VersionUpdateOneRequiredWithoutModelDataCalculationsNestedInput
    instance?: InstanceUpdateOneRequiredWithoutModelDataCalculationsNestedInput
    modelAccount?: ModelAccountStructureUpdateOneRequiredWithoutModeldataCalculationsNestedInput
  }

  export type ModelDataCalculationsUncheckedUpdateWithoutLevelInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    modelId?: StringFieldUpdateOperationsInput | string
    versionId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    modelAccountId?: StringFieldUpdateOperationsInput | string
    calculations?: InputJsonValue | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ModelDataCalculationsUncheckedUpdateManyWithoutLevelInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    modelId?: StringFieldUpdateOperationsInput | string
    versionId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    modelAccountId?: StringFieldUpdateOperationsInput | string
    calculations?: InputJsonValue | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LevelAttributeValueCreateManyParentInput = {
    id?: string
    code: string
    name: string
    attributeId: string
    clientId: string
    instanceId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type LevelAttributeAndValueCreateManyAttributeValueInput = {
    id?: string
    levelId: string
    clientId: string
    instanceId: string
    attributeId: string
    levelCode: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type LevelAttributeValueUpdateWithoutParentInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    childAttributeValues?: LevelAttributeValueUpdateManyWithoutParentNestedInput
    instance?: InstanceUpdateOneRequiredWithoutLevelAttValuesNestedInput
    levelAttribute?: LevelAttributeUpdateOneRequiredWithoutLevelAttributeValuesNestedInput
    levelAttributeAndValues?: LevelAttributeAndValueUpdateManyWithoutAttributeValueNestedInput
  }

  export type LevelAttributeValueUncheckedUpdateWithoutParentInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    attributeId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    childAttributeValues?: LevelAttributeValueUncheckedUpdateManyWithoutParentNestedInput
    levelAttributeAndValues?: LevelAttributeAndValueUncheckedUpdateManyWithoutAttributeValueNestedInput
  }

  export type LevelAttributeValueUncheckedUpdateManyWithoutParentInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    attributeId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LevelAttributeAndValueUpdateWithoutAttributeValueInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    levelCode?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    level?: LevelUpdateOneWithoutAttributeAndValuesNestedInput
    attribute?: LevelAttributeUpdateOneWithoutLevelAttributeAndValuesNestedInput
  }

  export type LevelAttributeAndValueUncheckedUpdateWithoutAttributeValueInput = {
    levelId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    attributeId?: StringFieldUpdateOperationsInput | string
    levelCode?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LevelAttributeAndValueUncheckedUpdateManyWithoutAttributeValueInput = {
    levelId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    attributeId?: StringFieldUpdateOperationsInput | string
    levelCode?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LevelAttributeValueCreateManyLevelAttributeInput = {
    id?: string
    code: string
    name: string
    parentId?: string | null
    clientId: string
    instanceId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type LevelAttributeAndValueCreateManyAttributeInput = {
    id?: string
    levelId: string
    clientId: string
    instanceId: string
    attributeValueId: string
    levelCode: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type LevelAttributeValueUpdateWithoutLevelAttributeInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parent?: LevelAttributeValueUpdateOneWithoutChildAttributeValuesNestedInput
    childAttributeValues?: LevelAttributeValueUpdateManyWithoutParentNestedInput
    instance?: InstanceUpdateOneRequiredWithoutLevelAttValuesNestedInput
    levelAttributeAndValues?: LevelAttributeAndValueUpdateManyWithoutAttributeValueNestedInput
  }

  export type LevelAttributeValueUncheckedUpdateWithoutLevelAttributeInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    childAttributeValues?: LevelAttributeValueUncheckedUpdateManyWithoutParentNestedInput
    levelAttributeAndValues?: LevelAttributeAndValueUncheckedUpdateManyWithoutAttributeValueNestedInput
  }

  export type LevelAttributeValueUncheckedUpdateManyWithoutLevelAttributeInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LevelAttributeAndValueUpdateWithoutAttributeInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    levelCode?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    level?: LevelUpdateOneWithoutAttributeAndValuesNestedInput
    attributeValue?: LevelAttributeValueUpdateOneWithoutLevelAttributeAndValuesNestedInput
  }

  export type LevelAttributeAndValueUncheckedUpdateWithoutAttributeInput = {
    levelId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    attributeValueId?: StringFieldUpdateOperationsInput | string
    levelCode?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LevelAttributeAndValueUncheckedUpdateManyWithoutAttributeInput = {
    levelId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    attributeValueId?: StringFieldUpdateOperationsInput | string
    levelCode?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AccountAttributeValueCreateManyAccountAttributeInput = {
    id?: string
    code: string
    name: string
    parentId?: string | null
    clientId: string
    instanceId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type AccountAttributeAndValueCreateManyAttributeInput = {
    id?: string
    accountId: string
    clientId: string
    instanceId: string
    attributeValueId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type AccountAttributeValueUpdateWithoutAccountAttributeInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parent?: AccountAttributeValueUpdateOneWithoutChildAttributeValuesNestedInput
    childAttributeValues?: AccountAttributeValueUpdateManyWithoutParentNestedInput
    instance?: InstanceUpdateOneRequiredWithoutAccountAttValuesNestedInput
    AttributeAndValues?: AccountAttributeAndValueUpdateManyWithoutAttributeValueNestedInput
  }

  export type AccountAttributeValueUncheckedUpdateWithoutAccountAttributeInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    childAttributeValues?: AccountAttributeValueUncheckedUpdateManyWithoutParentNestedInput
    AttributeAndValues?: AccountAttributeAndValueUncheckedUpdateManyWithoutAttributeValueNestedInput
  }

  export type AccountAttributeValueUncheckedUpdateManyWithoutAccountAttributeInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AccountAttributeAndValueUpdateWithoutAttributeInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account?: AccountUpdateOneWithoutAttributeAndValuesNestedInput
    attributeValue?: AccountAttributeValueUpdateOneWithoutAttributeAndValuesNestedInput
  }

  export type AccountAttributeAndValueUncheckedUpdateWithoutAttributeInput = {
    accountId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    attributeValueId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AccountAttributeAndValueUncheckedUpdateManyWithoutAttributeInput = {
    accountId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    attributeValueId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AccountAttributeValueCreateManyParentInput = {
    id?: string
    code: string
    name: string
    attributeId: string
    clientId: string
    instanceId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type AccountAttributeAndValueCreateManyAttributeValueInput = {
    id?: string
    accountId: string
    clientId: string
    instanceId: string
    attributeId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type AccountAttributeValueUpdateWithoutParentInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    childAttributeValues?: AccountAttributeValueUpdateManyWithoutParentNestedInput
    accountAttribute?: AccountAttributeUpdateOneRequiredWithoutAccountAttributeValuesNestedInput
    instance?: InstanceUpdateOneRequiredWithoutAccountAttValuesNestedInput
    AttributeAndValues?: AccountAttributeAndValueUpdateManyWithoutAttributeValueNestedInput
  }

  export type AccountAttributeValueUncheckedUpdateWithoutParentInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    attributeId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    childAttributeValues?: AccountAttributeValueUncheckedUpdateManyWithoutParentNestedInput
    AttributeAndValues?: AccountAttributeAndValueUncheckedUpdateManyWithoutAttributeValueNestedInput
  }

  export type AccountAttributeValueUncheckedUpdateManyWithoutParentInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    attributeId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AccountAttributeAndValueUpdateWithoutAttributeValueInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account?: AccountUpdateOneWithoutAttributeAndValuesNestedInput
    attribute?: AccountAttributeUpdateOneWithoutAttributeAndValuesNestedInput
  }

  export type AccountAttributeAndValueUncheckedUpdateWithoutAttributeValueInput = {
    accountId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    attributeId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AccountAttributeAndValueUncheckedUpdateManyWithoutAttributeValueInput = {
    accountId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    attributeId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AccountCreateManyParentInput = {
    id?: string
    code: string
    name: string
    isRoot?: boolean
    isModelRoot?: boolean
    accountType: $Enums.AccountType
    accountTypeTag: $Enums.AccountTypeTag
    group?: $Enums.YesNo
    plannedBy?: $Enums.ActPlanBy | null
    actualsBy?: $Enums.ActActualsBy | null
    displayAs?: $Enums.ActDisplayAs
    containsSalaryInfo?: $Enums.YesNo
    description?: string | null
    instanceId: string
    clientId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type AccountAttributeAndValueCreateManyAccountInput = {
    id?: string
    clientId: string
    instanceId: string
    attributeId: string
    attributeValueId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ModelAccountStructureCreateManyAccountInput = {
    id?: string
    instanceId: string
    isRoot?: boolean
    clientId: string
    parentId?: string | null
    modelId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ModelDataCreateManyAccountInput = {
    id?: string
    clientId: string
    instanceId: string
    modelId: string
    versionId: string
    levelId: string
    dimensionality?: XOR<ModelDataDimensionalityListCreateEnvelopeInput, ModelDataDimensionalityCreateInput> | ModelDataDimensionalityCreateInput[]
    timespan: InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ModelDataCalculationsCreateManyAccountInput = {
    id?: string
    clientId: string
    instanceId: string
    modelId: string
    versionId: string
    levelId: string
    modelAccountId: string
    calculations: InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type AccountUpdateWithoutParentInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isRoot?: BoolFieldUpdateOperationsInput | boolean
    isModelRoot?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    accountTypeTag?: EnumAccountTypeTagFieldUpdateOperationsInput | $Enums.AccountTypeTag
    group?: EnumYesNoFieldUpdateOperationsInput | $Enums.YesNo
    plannedBy?: NullableEnumActPlanByFieldUpdateOperationsInput | $Enums.ActPlanBy | null
    actualsBy?: NullableEnumActActualsByFieldUpdateOperationsInput | $Enums.ActActualsBy | null
    displayAs?: EnumActDisplayAsFieldUpdateOperationsInput | $Enums.ActDisplayAs
    containsSalaryInfo?: EnumYesNoFieldUpdateOperationsInput | $Enums.YesNo
    description?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instance?: InstanceUpdateOneRequiredWithoutAccountsNestedInput
    childAccounts?: AccountUpdateManyWithoutParentNestedInput
    AttributeAndValues?: AccountAttributeAndValueUpdateManyWithoutAccountNestedInput
    modelAccounts?: ModelAccountStructureUpdateManyWithoutAccountNestedInput
    modelData?: ModelDataUpdateManyWithoutAccountNestedInput
    modeldataCalculations?: ModelDataCalculationsUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutParentInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isRoot?: BoolFieldUpdateOperationsInput | boolean
    isModelRoot?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    accountTypeTag?: EnumAccountTypeTagFieldUpdateOperationsInput | $Enums.AccountTypeTag
    group?: EnumYesNoFieldUpdateOperationsInput | $Enums.YesNo
    plannedBy?: NullableEnumActPlanByFieldUpdateOperationsInput | $Enums.ActPlanBy | null
    actualsBy?: NullableEnumActActualsByFieldUpdateOperationsInput | $Enums.ActActualsBy | null
    displayAs?: EnumActDisplayAsFieldUpdateOperationsInput | $Enums.ActDisplayAs
    containsSalaryInfo?: EnumYesNoFieldUpdateOperationsInput | $Enums.YesNo
    description?: NullableStringFieldUpdateOperationsInput | string | null
    instanceId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    childAccounts?: AccountUncheckedUpdateManyWithoutParentNestedInput
    AttributeAndValues?: AccountAttributeAndValueUncheckedUpdateManyWithoutAccountNestedInput
    modelAccounts?: ModelAccountStructureUncheckedUpdateManyWithoutAccountNestedInput
    modelData?: ModelDataUncheckedUpdateManyWithoutAccountNestedInput
    modeldataCalculations?: ModelDataCalculationsUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateManyWithoutParentInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isRoot?: BoolFieldUpdateOperationsInput | boolean
    isModelRoot?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    accountTypeTag?: EnumAccountTypeTagFieldUpdateOperationsInput | $Enums.AccountTypeTag
    group?: EnumYesNoFieldUpdateOperationsInput | $Enums.YesNo
    plannedBy?: NullableEnumActPlanByFieldUpdateOperationsInput | $Enums.ActPlanBy | null
    actualsBy?: NullableEnumActActualsByFieldUpdateOperationsInput | $Enums.ActActualsBy | null
    displayAs?: EnumActDisplayAsFieldUpdateOperationsInput | $Enums.ActDisplayAs
    containsSalaryInfo?: EnumYesNoFieldUpdateOperationsInput | $Enums.YesNo
    description?: NullableStringFieldUpdateOperationsInput | string | null
    instanceId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AccountAttributeAndValueUpdateWithoutAccountInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attribute?: AccountAttributeUpdateOneWithoutAttributeAndValuesNestedInput
    attributeValue?: AccountAttributeValueUpdateOneWithoutAttributeAndValuesNestedInput
  }

  export type AccountAttributeAndValueUncheckedUpdateWithoutAccountInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    attributeId?: StringFieldUpdateOperationsInput | string
    attributeValueId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AccountAttributeAndValueUncheckedUpdateManyWithoutAccountInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    attributeId?: StringFieldUpdateOperationsInput | string
    attributeValueId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ModelAccountStructureUpdateWithoutAccountInput = {
    isRoot?: BoolFieldUpdateOperationsInput | boolean
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instance?: InstanceUpdateOneRequiredWithoutModelAccountsNestedInput
    model?: ModelUpdateOneRequiredWithoutModelAccountsNestedInput
    modeldataCalculations?: ModelDataCalculationsUpdateManyWithoutModelAccountNestedInput
    parentAccount?: ModelAccountStructureUpdateOneWithoutChildAccountsNestedInput
    childAccounts?: ModelAccountStructureUpdateManyWithoutParentAccountNestedInput
  }

  export type ModelAccountStructureUncheckedUpdateWithoutAccountInput = {
    instanceId?: StringFieldUpdateOperationsInput | string
    isRoot?: BoolFieldUpdateOperationsInput | boolean
    clientId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    modelId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modeldataCalculations?: ModelDataCalculationsUncheckedUpdateManyWithoutModelAccountNestedInput
    childAccounts?: ModelAccountStructureUncheckedUpdateManyWithoutParentAccountNestedInput
  }

  export type ModelAccountStructureUncheckedUpdateManyWithoutAccountInput = {
    instanceId?: StringFieldUpdateOperationsInput | string
    isRoot?: BoolFieldUpdateOperationsInput | boolean
    clientId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    modelId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ModelDataUpdateWithoutAccountInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    dimensionality?: XOR<ModelDataDimensionalityListUpdateEnvelopeInput, ModelDataDimensionalityCreateInput> | ModelDataDimensionalityCreateInput[]
    timespan?: InputJsonValue | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    model?: ModelUpdateOneRequiredWithoutModelDataNestedInput
    level?: LevelUpdateOneRequiredWithoutModelDataNestedInput
    version?: VersionUpdateOneRequiredWithoutModelDataNestedInput
    instance?: InstanceUpdateOneRequiredWithoutModelDataNestedInput
  }

  export type ModelDataUncheckedUpdateWithoutAccountInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    modelId?: StringFieldUpdateOperationsInput | string
    versionId?: StringFieldUpdateOperationsInput | string
    levelId?: StringFieldUpdateOperationsInput | string
    dimensionality?: XOR<ModelDataDimensionalityListUpdateEnvelopeInput, ModelDataDimensionalityCreateInput> | ModelDataDimensionalityCreateInput[]
    timespan?: InputJsonValue | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ModelDataUncheckedUpdateManyWithoutAccountInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    modelId?: StringFieldUpdateOperationsInput | string
    versionId?: StringFieldUpdateOperationsInput | string
    levelId?: StringFieldUpdateOperationsInput | string
    dimensionality?: XOR<ModelDataDimensionalityListUpdateEnvelopeInput, ModelDataDimensionalityCreateInput> | ModelDataDimensionalityCreateInput[]
    timespan?: InputJsonValue | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ModelDataCalculationsUpdateWithoutAccountInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    calculations?: InputJsonValue | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    model?: ModelUpdateOneRequiredWithoutModelDataCalculationsNestedInput
    level?: LevelUpdateOneRequiredWithoutModeldataCalculationsNestedInput
    version?: VersionUpdateOneRequiredWithoutModelDataCalculationsNestedInput
    instance?: InstanceUpdateOneRequiredWithoutModelDataCalculationsNestedInput
    modelAccount?: ModelAccountStructureUpdateOneRequiredWithoutModeldataCalculationsNestedInput
  }

  export type ModelDataCalculationsUncheckedUpdateWithoutAccountInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    modelId?: StringFieldUpdateOperationsInput | string
    versionId?: StringFieldUpdateOperationsInput | string
    levelId?: StringFieldUpdateOperationsInput | string
    modelAccountId?: StringFieldUpdateOperationsInput | string
    calculations?: InputJsonValue | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ModelDataCalculationsUncheckedUpdateManyWithoutAccountInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    modelId?: StringFieldUpdateOperationsInput | string
    versionId?: StringFieldUpdateOperationsInput | string
    levelId?: StringFieldUpdateOperationsInput | string
    modelAccountId?: StringFieldUpdateOperationsInput | string
    calculations?: InputJsonValue | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DimensionValueCreateManyDimensionInput = {
    id?: string
    code: string
    name: string
    parentId?: string | null
    clientId: string
    instanceId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type DimensionValueUpdateWithoutDimensionInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parent?: DimensionValueUpdateOneWithoutChildDimensionValuesNestedInput
    childDimensionValues?: DimensionValueUpdateManyWithoutParentNestedInput
    AttributeAndValues?: DimensionValueAttributeAndValueUpdateManyWithoutDimensionValueNestedInput
    instance?: InstanceUpdateOneRequiredWithoutDimensionValuesNestedInput
  }

  export type DimensionValueUncheckedUpdateWithoutDimensionInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    childDimensionValues?: DimensionValueUncheckedUpdateManyWithoutParentNestedInput
    AttributeAndValues?: DimensionValueAttributeAndValueUncheckedUpdateManyWithoutDimensionValueNestedInput
  }

  export type DimensionValueUncheckedUpdateManyWithoutDimensionInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DimensionValueCreateManyParentInput = {
    id?: string
    code: string
    name: string
    clientId: string
    instanceId: string
    dimensionId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type DimensionValueAttributeAndValueCreateManyDimensionValueInput = {
    id?: string
    clientId: string
    instanceId: string
    attributeId: string
    attributeValueId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type DimensionValueUpdateWithoutParentInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    childDimensionValues?: DimensionValueUpdateManyWithoutParentNestedInput
    AttributeAndValues?: DimensionValueAttributeAndValueUpdateManyWithoutDimensionValueNestedInput
    instance?: InstanceUpdateOneRequiredWithoutDimensionValuesNestedInput
    dimension?: DimensionUpdateOneRequiredWithoutDimensionValuesNestedInput
  }

  export type DimensionValueUncheckedUpdateWithoutParentInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    dimensionId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    childDimensionValues?: DimensionValueUncheckedUpdateManyWithoutParentNestedInput
    AttributeAndValues?: DimensionValueAttributeAndValueUncheckedUpdateManyWithoutDimensionValueNestedInput
  }

  export type DimensionValueUncheckedUpdateManyWithoutParentInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    dimensionId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DimensionValueAttributeAndValueUpdateWithoutDimensionValueInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attribute?: DimensionValueAttributeUpdateOneWithoutAttributeAndValuesNestedInput
    attributeValue?: DimensionValueAttributeValueUpdateOneWithoutDimensionAttributeAndValuesNestedInput
  }

  export type DimensionValueAttributeAndValueUncheckedUpdateWithoutDimensionValueInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    attributeId?: StringFieldUpdateOperationsInput | string
    attributeValueId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DimensionValueAttributeAndValueUncheckedUpdateManyWithoutDimensionValueInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    attributeId?: StringFieldUpdateOperationsInput | string
    attributeValueId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DimensionValueAttributeValueCreateManyDimensionValueAttributeInput = {
    id?: string
    code: string
    name: string
    clientId: string
    parentId?: string | null
    instanceId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type DimensionValueAttributeAndValueCreateManyAttributeInput = {
    id?: string
    clientId: string
    instanceId: string
    attributeValueId: string
    dimensionValueId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type DimensionValueAttributeValueUpdateWithoutDimensionValueAttributeInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instance?: InstanceUpdateOneRequiredWithoutDimensionValueAttributeValuesNestedInput
    parent?: DimensionValueAttributeValueUpdateOneWithoutChildAttributeValuesNestedInput
    childAttributeValues?: DimensionValueAttributeValueUpdateManyWithoutParentNestedInput
    dimensionAttributeAndValues?: DimensionValueAttributeAndValueUpdateManyWithoutAttributeValueNestedInput
  }

  export type DimensionValueAttributeValueUncheckedUpdateWithoutDimensionValueAttributeInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    instanceId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    childAttributeValues?: DimensionValueAttributeValueUncheckedUpdateManyWithoutParentNestedInput
    dimensionAttributeAndValues?: DimensionValueAttributeAndValueUncheckedUpdateManyWithoutAttributeValueNestedInput
  }

  export type DimensionValueAttributeValueUncheckedUpdateManyWithoutDimensionValueAttributeInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    instanceId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DimensionValueAttributeAndValueUpdateWithoutAttributeInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dimensionValue?: DimensionValueUpdateOneWithoutAttributeAndValuesNestedInput
    attributeValue?: DimensionValueAttributeValueUpdateOneWithoutDimensionAttributeAndValuesNestedInput
  }

  export type DimensionValueAttributeAndValueUncheckedUpdateWithoutAttributeInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    attributeValueId?: StringFieldUpdateOperationsInput | string
    dimensionValueId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DimensionValueAttributeAndValueUncheckedUpdateManyWithoutAttributeInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    attributeValueId?: StringFieldUpdateOperationsInput | string
    dimensionValueId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DimensionValueAttributeValueCreateManyParentInput = {
    id?: string
    code: string
    name: string
    attributeId: string
    clientId: string
    instanceId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type DimensionValueAttributeAndValueCreateManyAttributeValueInput = {
    id?: string
    clientId: string
    instanceId: string
    attributeId: string
    dimensionValueId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type DimensionValueAttributeValueUpdateWithoutParentInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instance?: InstanceUpdateOneRequiredWithoutDimensionValueAttributeValuesNestedInput
    childAttributeValues?: DimensionValueAttributeValueUpdateManyWithoutParentNestedInput
    dimensionValueAttribute?: DimensionValueAttributeUpdateOneRequiredWithoutAttributeValuesNestedInput
    dimensionAttributeAndValues?: DimensionValueAttributeAndValueUpdateManyWithoutAttributeValueNestedInput
  }

  export type DimensionValueAttributeValueUncheckedUpdateWithoutParentInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    attributeId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    childAttributeValues?: DimensionValueAttributeValueUncheckedUpdateManyWithoutParentNestedInput
    dimensionAttributeAndValues?: DimensionValueAttributeAndValueUncheckedUpdateManyWithoutAttributeValueNestedInput
  }

  export type DimensionValueAttributeValueUncheckedUpdateManyWithoutParentInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    attributeId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DimensionValueAttributeAndValueUpdateWithoutAttributeValueInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dimensionValue?: DimensionValueUpdateOneWithoutAttributeAndValuesNestedInput
    attribute?: DimensionValueAttributeUpdateOneWithoutAttributeAndValuesNestedInput
  }

  export type DimensionValueAttributeAndValueUncheckedUpdateWithoutAttributeValueInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    attributeId?: StringFieldUpdateOperationsInput | string
    dimensionValueId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DimensionValueAttributeAndValueUncheckedUpdateManyWithoutAttributeValueInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    attributeId?: StringFieldUpdateOperationsInput | string
    dimensionValueId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ModelDataCreateManyModelInput = {
    id?: string
    clientId: string
    instanceId: string
    versionId: string
    levelId: string
    accountId: string
    dimensionality?: XOR<ModelDataDimensionalityListCreateEnvelopeInput, ModelDataDimensionalityCreateInput> | ModelDataDimensionalityCreateInput[]
    timespan: InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ModelAccountStructureCreateManyModelInput = {
    id?: string
    instanceId: string
    isRoot?: boolean
    clientId: string
    parentId?: string | null
    accountId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ModelDataCalculationsCreateManyModelInput = {
    id?: string
    clientId: string
    instanceId: string
    versionId: string
    levelId: string
    accountId: string
    modelAccountId: string
    calculations: InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ModelDataUpdateWithoutModelInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    dimensionality?: XOR<ModelDataDimensionalityListUpdateEnvelopeInput, ModelDataDimensionalityCreateInput> | ModelDataDimensionalityCreateInput[]
    timespan?: InputJsonValue | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    level?: LevelUpdateOneRequiredWithoutModelDataNestedInput
    account?: AccountUpdateOneRequiredWithoutModelDataNestedInput
    version?: VersionUpdateOneRequiredWithoutModelDataNestedInput
    instance?: InstanceUpdateOneRequiredWithoutModelDataNestedInput
  }

  export type ModelDataUncheckedUpdateWithoutModelInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    versionId?: StringFieldUpdateOperationsInput | string
    levelId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    dimensionality?: XOR<ModelDataDimensionalityListUpdateEnvelopeInput, ModelDataDimensionalityCreateInput> | ModelDataDimensionalityCreateInput[]
    timespan?: InputJsonValue | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ModelDataUncheckedUpdateManyWithoutModelInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    versionId?: StringFieldUpdateOperationsInput | string
    levelId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    dimensionality?: XOR<ModelDataDimensionalityListUpdateEnvelopeInput, ModelDataDimensionalityCreateInput> | ModelDataDimensionalityCreateInput[]
    timespan?: InputJsonValue | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ModelAccountStructureUpdateWithoutModelInput = {
    isRoot?: BoolFieldUpdateOperationsInput | boolean
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instance?: InstanceUpdateOneRequiredWithoutModelAccountsNestedInput
    account?: AccountUpdateOneRequiredWithoutModelAccountsNestedInput
    modeldataCalculations?: ModelDataCalculationsUpdateManyWithoutModelAccountNestedInput
    parentAccount?: ModelAccountStructureUpdateOneWithoutChildAccountsNestedInput
    childAccounts?: ModelAccountStructureUpdateManyWithoutParentAccountNestedInput
  }

  export type ModelAccountStructureUncheckedUpdateWithoutModelInput = {
    instanceId?: StringFieldUpdateOperationsInput | string
    isRoot?: BoolFieldUpdateOperationsInput | boolean
    clientId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modeldataCalculations?: ModelDataCalculationsUncheckedUpdateManyWithoutModelAccountNestedInput
    childAccounts?: ModelAccountStructureUncheckedUpdateManyWithoutParentAccountNestedInput
  }

  export type ModelAccountStructureUncheckedUpdateManyWithoutModelInput = {
    instanceId?: StringFieldUpdateOperationsInput | string
    isRoot?: BoolFieldUpdateOperationsInput | boolean
    clientId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ModelDataCalculationsUpdateWithoutModelInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    calculations?: InputJsonValue | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    level?: LevelUpdateOneRequiredWithoutModeldataCalculationsNestedInput
    account?: AccountUpdateOneRequiredWithoutModeldataCalculationsNestedInput
    version?: VersionUpdateOneRequiredWithoutModelDataCalculationsNestedInput
    instance?: InstanceUpdateOneRequiredWithoutModelDataCalculationsNestedInput
    modelAccount?: ModelAccountStructureUpdateOneRequiredWithoutModeldataCalculationsNestedInput
  }

  export type ModelDataCalculationsUncheckedUpdateWithoutModelInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    versionId?: StringFieldUpdateOperationsInput | string
    levelId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    modelAccountId?: StringFieldUpdateOperationsInput | string
    calculations?: InputJsonValue | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ModelDataCalculationsUncheckedUpdateManyWithoutModelInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    versionId?: StringFieldUpdateOperationsInput | string
    levelId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    modelAccountId?: StringFieldUpdateOperationsInput | string
    calculations?: InputJsonValue | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ModelDataCalculationsCreateManyModelAccountInput = {
    id?: string
    clientId: string
    instanceId: string
    modelId: string
    versionId: string
    levelId: string
    accountId: string
    calculations: InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ModelAccountStructureCreateManyParentAccountInput = {
    id?: string
    instanceId: string
    isRoot?: boolean
    clientId: string
    modelId: string
    accountId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ModelDataCalculationsUpdateWithoutModelAccountInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    calculations?: InputJsonValue | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    model?: ModelUpdateOneRequiredWithoutModelDataCalculationsNestedInput
    level?: LevelUpdateOneRequiredWithoutModeldataCalculationsNestedInput
    account?: AccountUpdateOneRequiredWithoutModeldataCalculationsNestedInput
    version?: VersionUpdateOneRequiredWithoutModelDataCalculationsNestedInput
    instance?: InstanceUpdateOneRequiredWithoutModelDataCalculationsNestedInput
  }

  export type ModelDataCalculationsUncheckedUpdateWithoutModelAccountInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    modelId?: StringFieldUpdateOperationsInput | string
    versionId?: StringFieldUpdateOperationsInput | string
    levelId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    calculations?: InputJsonValue | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ModelDataCalculationsUncheckedUpdateManyWithoutModelAccountInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    modelId?: StringFieldUpdateOperationsInput | string
    versionId?: StringFieldUpdateOperationsInput | string
    levelId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    calculations?: InputJsonValue | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ModelAccountStructureUpdateWithoutParentAccountInput = {
    isRoot?: BoolFieldUpdateOperationsInput | boolean
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instance?: InstanceUpdateOneRequiredWithoutModelAccountsNestedInput
    model?: ModelUpdateOneRequiredWithoutModelAccountsNestedInput
    account?: AccountUpdateOneRequiredWithoutModelAccountsNestedInput
    modeldataCalculations?: ModelDataCalculationsUpdateManyWithoutModelAccountNestedInput
    childAccounts?: ModelAccountStructureUpdateManyWithoutParentAccountNestedInput
  }

  export type ModelAccountStructureUncheckedUpdateWithoutParentAccountInput = {
    instanceId?: StringFieldUpdateOperationsInput | string
    isRoot?: BoolFieldUpdateOperationsInput | boolean
    clientId?: StringFieldUpdateOperationsInput | string
    modelId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modeldataCalculations?: ModelDataCalculationsUncheckedUpdateManyWithoutModelAccountNestedInput
    childAccounts?: ModelAccountStructureUncheckedUpdateManyWithoutParentAccountNestedInput
  }

  export type ModelAccountStructureUncheckedUpdateManyWithoutParentAccountInput = {
    instanceId?: StringFieldUpdateOperationsInput | string
    isRoot?: BoolFieldUpdateOperationsInput | boolean
    clientId?: StringFieldUpdateOperationsInput | string
    modelId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ModelDataDimensionalityUpdateInput = {
    dimensionId?: StringFieldUpdateOperationsInput | string
    dimensionValueId?: StringFieldUpdateOperationsInput | string
  }

  export type TableDataCreateManyTableInput = {
    id?: string
    clientId: string
    instanceId: string
    rowKey: string
    versionId: string
    levelId: string
    data: InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type TableColumnDefinitionUpdateInput = {
    tableId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumTableColumnTypeFieldUpdateOperationsInput | $Enums.TableColumnType
    dimensionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TableDataUpdateWithoutTableInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    rowKey?: StringFieldUpdateOperationsInput | string
    versionId?: StringFieldUpdateOperationsInput | string
    levelId?: StringFieldUpdateOperationsInput | string
    data?: InputJsonValue | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instance?: InstanceUpdateOneRequiredWithoutTableDataNestedInput
  }

  export type TableDataUncheckedUpdateWithoutTableInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    rowKey?: StringFieldUpdateOperationsInput | string
    versionId?: StringFieldUpdateOperationsInput | string
    levelId?: StringFieldUpdateOperationsInput | string
    data?: InputJsonValue | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TableDataUncheckedUpdateManyWithoutTableInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    rowKey?: StringFieldUpdateOperationsInput | string
    versionId?: StringFieldUpdateOperationsInput | string
    levelId?: StringFieldUpdateOperationsInput | string
    data?: InputJsonValue | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DataSourceCreateManyCredentialInput = {
    id?: string
    clientId: string
    instanceId: string
    name: string
    code: string
    description?: string | null
    type: $Enums.DataSourceType
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type DataSourceUpdateWithoutCredentialInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumDataSourceTypeFieldUpdateOperationsInput | $Enums.DataSourceType
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DataSourceUncheckedUpdateWithoutCredentialInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumDataSourceTypeFieldUpdateOperationsInput | $Enums.DataSourceType
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DataSourceUncheckedUpdateManyWithoutCredentialInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumDataSourceTypeFieldUpdateOperationsInput | $Enums.DataSourceType
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NestedEnumTableColumnTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TableColumnType | EnumTableColumnTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TableColumnType[] | ListEnumTableColumnTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TableColumnType[] | ListEnumTableColumnTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTableColumnTypeFilter<$PrismaModel> | $Enums.TableColumnType
  }

  export type EnumTableColumnTypeFieldUpdateOperationsInput = {
    set?: $Enums.TableColumnType
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}